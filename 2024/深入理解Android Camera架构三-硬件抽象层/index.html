<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Android Camera,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="一、概述始于谷歌的Treble开源项目，基于接口与实现的分离的设计原则，谷歌加入了Camera Provider这一抽象层，该层作为一个独立进程存在于整个系统中，并且通过HIDL这一自定义语言成功地将Camera Hal Module从Camera Service中解耦出来，承担起了对Camera HAL的封装工作，纵观整个Android系统，对于Camera Provider而言，对上是通过HI">
<meta name="keywords" content="Android Camera">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Android Camera架构三-硬件抽象层">
<meta property="og:url" content="http://zproo.github.io/2024/深入理解Android Camera架构三-硬件抽象层/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="一、概述始于谷歌的Treble开源项目，基于接口与实现的分离的设计原则，谷歌加入了Camera Provider这一抽象层，该层作为一个独立进程存在于整个系统中，并且通过HIDL这一自定义语言成功地将Camera Hal Module从Camera Service中解耦出来，承担起了对Camera HAL的封装工作，纵观整个Android系统，对于Camera Provider而言，对上是通过HI">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构三-硬件抽象层/cameraprovider.png">
<meta property="og:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构三-硬件抽象层/cameraproviderhidl.png">
<meta property="og:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构三-硬件抽象层/processprovider.png">
<meta property="og:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构三-硬件抽象层/cameraproviderstart.png">
<meta property="og:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构三-硬件抽象层/vb2/commit/b/深入理解Android%20Camera架构三-硬件抽象层/cameraproviderflow.png">
<meta property="og:updated_time" content="2024-10-26T03:03:07.558Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Android Camera架构三-硬件抽象层">
<meta name="twitter:description" content="一、概述始于谷歌的Treble开源项目，基于接口与实现的分离的设计原则，谷歌加入了Camera Provider这一抽象层，该层作为一个独立进程存在于整个系统中，并且通过HIDL这一自定义语言成功地将Camera Hal Module从Camera Service中解耦出来，承担起了对Camera HAL的封装工作，纵观整个Android系统，对于Camera Provider而言，对上是通过HI">
<meta name="twitter:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构三-硬件抽象层/cameraprovider.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2024/深入理解Android Camera架构三-硬件抽象层/">

  <title> 深入理解Android Camera架构三-硬件抽象层 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/Android-Camera/" rel="tag" title="Android Camera">Android Camera</a>
      
      </div>
      <h1>深入理解Android Camera架构三-硬件抽象层</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2024-03-20T21:18:23+08:00" content="2024-03-20" title="2024-03-20 21:18:23">
          2024-03-20
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解Android Camera架构三-硬件抽象层
              
            
          </h1>
        

        <div class="post-meta">
		  

          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2024-03-20T21:18:23+08:00" content="2024-03-20">
              2024-03-20
            </time>
          </span>

          

          <!--  -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>始于谷歌的Treble开源项目，基于接口与实现的分离的设计原则，谷歌加入了Camera Provider这一抽象层，该层作为一个独立进程存在于整个系统中，并且通过HIDL这一自定义语言成功地将Camera Hal Module从Camera Service中解耦出来，承担起了对Camera HAL的封装工作，纵观整个Android系统，对于Camera Provider而言，对上是通过HIDL接口负责与Camera Service的跨进程通信，对下通过标准的HAL3接口下发针对Camera的实际操作，这俨然是一个中央枢纽般的调配中心的角色，而事实上正是如此，由此看来，对Camera Provider的梳理变得尤为重要，接下来就以我个人理解出发来简单介绍下Camera Provider。</p>
<p>Camera Provider通过提供标准的HIDL接口给Camera Service进行调用，保持与Service的正常通信，其中谷歌将HIDL接口的定义直接暴露给平台厂商进行自定义实现，其中为了极大地减轻并降低开发者的工作量和开发难度，谷歌很好地封装了其跨进程实现细节，同样地，Camera Provider通过标准的HAL3接口，向下控制着具体的Camera HAL Module，而这个接口依然交由平台厂商负责去实现，而进程内部则通过简单的函数调用，将HIDL接口与HAL3接口完美的衔接起来，由此构成了Provider整体架构。</p>
<p><img src="/2024/深入理解Android Camera架构三-硬件抽象层/cameraprovider.png" style="zoom:50%;"></p>
<p>由图中可以看出Camera Provider进程由两部分组成，一是运行在系统中的主程序通过提供了标准的HIDL接口保持了与Camera Service的跨进程通讯，二是为了进一步扩展其功能，通过dlopen方式加载了一系列So库，而其中就包括了实现了Camera HAL3接口的So库，而HAL3接口主要定义了主要用于实现图像控制的功能，其实现主要交由平台厂商或者开发者来完成，所以Camera HAL3 So库的实现各式各样，在高通平台上，这里的实现是我们后面重点需要分析的CamX-CHI框架。在开始梳理CamX-CHI之前，不防先从上到下，以接口为主线简单梳理下Camera Provider的各个部分。</p>
<h2 id="二、Camera-HIDL接口"><a href="#二、Camera-HIDL接口" class="headerlink" title="二、Camera HIDL接口"></a>二、Camera HIDL接口</h2><p>首先需要明确一个概念，就是HIDL是一种自定义语言，其核心是接口的定义，而谷歌为了使开发者将注意力落在接口的定义上而不是机制的实现上，主动封装了HIDL机制的实现细节，开发者只需要通过*.hal文件定义接口，填充接口内部实际的实现即可，接下来来看下具体定义的几个主要接口：（hardware\interfaces\camera\provider）</p>
<p><img src="/2024/深入理解Android Camera架构三-硬件抽象层/cameraproviderhidl.png" style="zoom: 80%;"></p>
<p>因为HIDL机制本身是跨进程通讯的，所以Camera Service本身通过HIDL接口获取的对象都会有Bn端和Bp端，分别代表了Binder两端，接下来为了方便理解，我们都省略掉Bn/Bp说法,直接用具体接口类代表，忽略跨进程两端的区别。</p>
<h3 id="2-1-ICameraProvider-hal"><a href="#2-1-ICameraProvider-hal" class="headerlink" title="2.1 ICameraProvider.hal"></a>2.1 ICameraProvider.hal</h3><p>ICameraProvider.hal源码如下：</p>
<p>[-&gt;hardware\interfaces\camera\provider\2.4\ICameraProvider.hal]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">package android.hardware.camera.provider@2.4;</span><br><span class="line"></span><br><span class="line">import ICameraProviderCallback;</span><br><span class="line">import android.hardware.camera.common@1.0::types;</span><br><span class="line">import android.hardware.camera.device@1.0::ICameraDevice;</span><br><span class="line">import android.hardware.camera.device@3.2::ICameraDevice;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Camera provider HAL, which enumerates the available individual camera devices</span><br><span class="line"> * known to the provider, and provides updates about changes to device status,</span><br><span class="line"> * such as connection, disconnection, or torch mode enable/disable.</span><br><span class="line"> *</span><br><span class="line"> * The provider is responsible for generating a list of camera device service</span><br><span class="line"> * names that can then be opened via the hardware service manager.</span><br><span class="line"> *</span><br><span class="line"> * Multiple camera provider HALs may be present in a single system.</span><br><span class="line"> * For discovery, the service names, and process names, must be of the form</span><br><span class="line"> * &quot;android.hardware.camera.provider@&lt;major&gt;.&lt;minor&gt;/&lt;type&gt;/&lt;instance&gt;&quot;</span><br><span class="line"> * where</span><br><span class="line"> *   - &lt;major&gt;/&lt;minor&gt; is the provider HAL HIDL version,</span><br><span class="line"> *   - &lt;type&gt; is the type of devices this provider knows about, such as</span><br><span class="line"> *     &quot;internal&quot;, &quot;legacy&quot;, &quot;external&quot;, &quot;remote&quot; etc. The camera framework</span><br><span class="line"> *     must not differentiate or chage its behavior based on the specific type.</span><br><span class="line"> *   - &lt;instance&gt; is a non-negative integer starting from 0 to disambiguate</span><br><span class="line"> *     between multiple HALs of the same type.</span><br><span class="line"> *</span><br><span class="line"> * The &quot;legacy&quot; type is only used for passthrough legacy HAL mode, and must</span><br><span class="line"> * not be used by a standalone binderized HAL.</span><br><span class="line"> *</span><br><span class="line"> * The device instance names enumerated by the provider in getCameraIdList() or</span><br><span class="line"> * ICameraProviderCallback::cameraDeviceStatusChange() must be of the form</span><br><span class="line"> * &quot;device@&lt;major&gt;.&lt;minor&gt;/&lt;type&gt;/&lt;id&gt;&quot; where</span><br><span class="line"> * &lt;major&gt;/&lt;minor&gt; is the HIDL version of the interface. &lt;id&gt; is either a small</span><br><span class="line"> * incrementing integer for &quot;internal&quot; device types, with 0 being the main</span><br><span class="line"> * back-facing camera and 1 being the main front-facing camera, if they exist.</span><br><span class="line"> * Or, for external devices, a unique serial number (if possible) that can be</span><br><span class="line"> * used to identify the device reliably when it is disconnected and reconnected.</span><br><span class="line"> *</span><br><span class="line"> * Multiple providers must not enumerate the same device ID.</span><br><span class="line"> */</span><br><span class="line">interface ICameraProvider &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * setCallback:</span><br><span class="line">     *</span><br><span class="line">     * Provide a callback interface to the HAL provider to inform framework of</span><br><span class="line">     * asynchronous camera events. The framework must call this function once</span><br><span class="line">     * during camera service startup, before any other calls to the provider</span><br><span class="line">     * (note that in case the camera service restarts, this method must be</span><br><span class="line">     * invoked again during its startup).</span><br><span class="line">     *</span><br><span class="line">     * @param callback</span><br><span class="line">     *     A non-null callback interface to invoke when camera events occur.</span><br><span class="line">     * @return status</span><br><span class="line">     *     Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On success</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         An unexpected internal error occurred while setting the callbacks</span><br><span class="line">     *     ILLEGAL_ARGUMENT:</span><br><span class="line">     *         The callback argument is invalid (for example, null).</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    setCallback(ICameraProviderCallback callback) generates (Status status);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * getVendorTags:</span><br><span class="line">     *</span><br><span class="line">     * Retrieve all vendor tags supported by devices discoverable through this</span><br><span class="line">     * provider. The tags are grouped into sections.</span><br><span class="line">     *</span><br><span class="line">     * @return status</span><br><span class="line">     *     Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On success</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         An unexpected internal error occurred while setting the callbacks</span><br><span class="line">     * @return sections</span><br><span class="line">     *     The supported vendor tag sections; empty if there are no supported</span><br><span class="line">     *     vendor tags, or status is not OK.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    getVendorTags() generates (Status status, vec&lt;VendorTagSection&gt; sections);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * getCameraIdList:</span><br><span class="line">     *</span><br><span class="line">     * Returns the list of internal camera device interfaces known to this</span><br><span class="line">     * camera provider. These devices can then be accessed via the hardware</span><br><span class="line">     * service manager.</span><br><span class="line">     *</span><br><span class="line">     * External camera devices (camera facing EXTERNAL) must be reported through</span><br><span class="line">     * the device status change callback, not in this list. Only devices with</span><br><span class="line">     * facing BACK or FRONT must be listed here.</span><br><span class="line">     *</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On a succesful generation of camera ID list</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         A camera ID list cannot be created. This may be due to</span><br><span class="line">     *         a failure to initialize the camera subsystem, for example.</span><br><span class="line">     * @return cameraDeviceServiceNames The vector of internal camera device</span><br><span class="line">     *     names known to this provider.</span><br><span class="line">     */</span><br><span class="line">    getCameraIdList()</span><br><span class="line">            generates (Status status, vec&lt;string&gt; cameraDeviceNames);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * isSetTorchModeSupported:</span><br><span class="line">     *</span><br><span class="line">     * Returns if the camera devices known to this camera provider support</span><br><span class="line">     * setTorchMode API or not. If the provider does not support setTorchMode</span><br><span class="line">     * API, calling to setTorchMode will return METHOD_NOT_SUPPORTED.</span><br><span class="line">     *</span><br><span class="line">     * Note that not every camera device has a flash unit, so even this API</span><br><span class="line">     * returns true, setTorchMode call might still fail due to the camera device</span><br><span class="line">     * does not have a flash unit. In such case, the returned status will be</span><br><span class="line">     * OPERATION_NOT_SUPPORTED.</span><br><span class="line">     *</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On a succesful call</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         Torch API support cannot be queried. This may be due to</span><br><span class="line">     *         a failure to initialize the camera subsystem, for example.</span><br><span class="line">     * @return support Whether the camera devices known to this provider</span><br><span class="line">     *     supports setTorchMode API or not. Devices launched with SDK</span><br><span class="line">     *     level 29 or higher must return true.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    isSetTorchModeSupported() generates (Status status, bool support);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * getCameraDeviceInterface_VN_x:</span><br><span class="line">     *</span><br><span class="line">     * Return a android.hardware.camera.device@N.x/ICameraDevice interface for</span><br><span class="line">     * the requested device name. This does not power on the camera device, but</span><br><span class="line">     * simply acquires the interface for querying the device static information,</span><br><span class="line">     * or to additionally open the device for active use.</span><br><span class="line">     *</span><br><span class="line">     * A separate method is required for each major revision of the camera device</span><br><span class="line">     * HAL interface, since they are not compatible with each other.</span><br><span class="line">     *</span><br><span class="line">     * Valid device names for this provider can be obtained via either</span><br><span class="line">     * getCameraIdList(), or via availability callbacks from</span><br><span class="line">     * ICameraProviderCallback::cameraDeviceStatusChange().</span><br><span class="line">     *</span><br><span class="line">     * The returned interface must be of the highest defined minor version for</span><br><span class="line">     * the major version; it&apos;s the responsibility of the HAL client to ensure</span><br><span class="line">     * they do not use methods/etc that are not valid for the actual minor</span><br><span class="line">     * version of the device.</span><br><span class="line">     *</span><br><span class="line">     * @param cameraDeviceName the name of the device to get an interface to.</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On a succesful generation of camera ID list</span><br><span class="line">     *     ILLEGAL_ARGUMENT:</span><br><span class="line">     *         This device name is unknown, or has been disconnected</span><br><span class="line">     *     OPERATION_NOT_SUPPORTED:</span><br><span class="line">     *         The specified device does not support this major version of the</span><br><span class="line">     *         HAL interface.</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         A camera interface cannot be returned due to an unexpected</span><br><span class="line">     *         internal error.</span><br><span class="line">     * @return device The inteface to this camera device, or null in case of</span><br><span class="line">     *     error.</span><br><span class="line">     */</span><br><span class="line">    getCameraDeviceInterface_V1_x(string cameraDeviceName) generates</span><br><span class="line">            (Status status,</span><br><span class="line">             android.hardware.camera.device@1.0::ICameraDevice device);</span><br><span class="line">    getCameraDeviceInterface_V3_x(string cameraDeviceName) generates</span><br><span class="line">            (Status status,</span><br><span class="line">             android.hardware.camera.device@3.2::ICameraDevice device);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraProvider接口类，由CameraProvider继承并实现，在Camera Provider启动的时候被实例化，主要接口如下：</p>
<ul>
<li>getCameraDeviceInterface_V3_x: 该方法主要用于Camera Service获取ICameraDevice，通过该对象可以控制Camera 设备的诸如配置数据流、下发request等具体行为。</li>
<li>setCallback： 将Camera Service 实现的ICameraProviderCallback传入Camera Provider，一旦Provider有事件产生时便可以通过该对象通知Camera Service。</li>
</ul>
<h3 id="2-2-ICameraProviderCallback-hal"><a href="#2-2-ICameraProviderCallback-hal" class="headerlink" title="2.2 ICameraProviderCallback.hal"></a>2.2 ICameraProviderCallback.hal</h3><p>ICameraProviderCallback.hal源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package android.hardware.camera.provider@2.4;</span><br><span class="line"></span><br><span class="line">import android.hardware.camera.common@1.0::types;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Callback functions for a camera provider HAL to use to inform the camera</span><br><span class="line"> * service of changes to the camera subsystem.</span><br><span class="line"> */</span><br><span class="line">interface ICameraProviderCallback &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * cameraDeviceStatusChange:</span><br><span class="line">     *</span><br><span class="line">     * Callback to the camera service to indicate that the state of a specific</span><br><span class="line">     * camera device has changed.</span><br><span class="line">     *</span><br><span class="line">     * On camera service startup, when ICameraProvider::setCallback is invoked,</span><br><span class="line">     * the camera service must assume that all internal camera devices are in</span><br><span class="line">     * the CAMERA_DEVICE_STATUS_PRESENT state.</span><br><span class="line">     *</span><br><span class="line">     * The provider must call this method to inform the camera service of any</span><br><span class="line">     * initially NOT_PRESENT devices, and of any external camera devices that</span><br><span class="line">     * are already present, as soon as the callbacks are available through</span><br><span class="line">     * setCallback.</span><br><span class="line">     *</span><br><span class="line">     * @param cameraDeviceServiceName The name of the camera device that has a</span><br><span class="line">     *     new status.</span><br><span class="line">     * @param newStatus The new status that device is in.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    cameraDeviceStatusChange(string cameraDeviceName,</span><br><span class="line">            CameraDeviceStatus newStatus);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * torchModeStatusChange:</span><br><span class="line">     *</span><br><span class="line">     * Callback to the camera service to indicate that the state of the torch</span><br><span class="line">     * mode of the flash unit associated with a specific camera device has</span><br><span class="line">     * changed. At provider registration time, the camera service must assume</span><br><span class="line">     * the torch modes are in the TORCH_MODE_STATUS_AVAILABLE_OFF state if</span><br><span class="line">     * android.flash.info.available is reported as true via the</span><br><span class="line">     * ICameraDevice::getCameraCharacteristics call.</span><br><span class="line">     *</span><br><span class="line">     * @param cameraDeviceServiceName The name of the camera device that has a</span><br><span class="line">     *     new status.</span><br><span class="line">     * @param newStatus The new status that device is in.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    torchModeStatusChange(string cameraDeviceName,</span><br><span class="line">            TorchModeStatus newStatus);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraProviderCallback回调接口类，该接口由Camera Service 中的CameraProviderManager::ProviderInfo继承并实现，在Camera Service 启动的时候被实例化，通过调用ICameraProvider::setCallback接口注册到Camera Provider中，其主要接口如下：</p>
<ul>
<li>cameraDeviceStatusChange： 将Camera 设备状态上传至Camera Service，状态由CameraDeviceStatus定义</li>
</ul>
<h3 id="2-3-ICameraDevice-ha"><a href="#2-3-ICameraDevice-ha" class="headerlink" title="2.3 ICameraDevice.ha"></a>2.3 ICameraDevice.ha</h3><p>ICameraDevice.hal源码如下：</p>
<p>[-&gt;hardware\interfaces\camera\device\3.2\ICameraDevice.hal]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">package android.hardware.camera.device@3.2;</span><br><span class="line"></span><br><span class="line">import android.hardware.camera.common@1.0::types;</span><br><span class="line">import ICameraDeviceSession;</span><br><span class="line">import ICameraDeviceCallback;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Camera device HAL, first modern version</span><br><span class="line"> *</span><br><span class="line"> * Supports the android.hardware.Camera API, and the android.hardware.camera2</span><br><span class="line"> * API at LIMITED or better hardware level.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">interface ICameraDevice &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get camera device resource cost information.</span><br><span class="line">     *</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On success</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         An unexpected internal camera HAL error occurred, and the</span><br><span class="line">     *         resource cost is not available.</span><br><span class="line">     *     CAMERA_DISCONNECTED:</span><br><span class="line">     *         An external camera device has been disconnected, and is no longer</span><br><span class="line">     *         available. This camera device interface is now stale, and a new</span><br><span class="line">     *         instance must be acquired if the device is reconnected. All</span><br><span class="line">     *         subsequent calls on this interface must return</span><br><span class="line">     *         CAMERA_DISCONNECTED.</span><br><span class="line">     * @return resourceCost</span><br><span class="line">     *     The resources required to open this camera device, or unspecified</span><br><span class="line">     *     values if status is not OK.</span><br><span class="line">     */</span><br><span class="line">    getResourceCost() generates (Status status, CameraResourceCost resourceCost);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * getCameraCharacteristics:</span><br><span class="line">     *</span><br><span class="line">     * Return the static camera information for this camera device. This</span><br><span class="line">     * information may not change between consecutive calls.</span><br><span class="line">     *</span><br><span class="line">     * When an external camera is disconnected, its camera id becomes</span><br><span class="line">     * invalid. Calling this method with this invalid camera id must result in</span><br><span class="line">     * ILLEGAL_ARGUMENT; this may happen even before the device status callback</span><br><span class="line">     * is invoked by the HAL.</span><br><span class="line">     *</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On a successful open of the camera device.</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         The camera device cannot be opened due to an internal</span><br><span class="line">     *         error.</span><br><span class="line">     *     CAMERA_DISCONNECTED:</span><br><span class="line">     *         An external camera device has been disconnected, and is no longer</span><br><span class="line">     *         available. This camera device interface is now stale, and a new</span><br><span class="line">     *         instance must be acquired if the device is reconnected. All</span><br><span class="line">     *         subsequent calls on this interface must return</span><br><span class="line">     *         CAMERA_DISCONNECTED.</span><br><span class="line">     *</span><br><span class="line">     * @return cameraCharacteristics</span><br><span class="line">     *     The static metadata for this camera device, or an empty metadata</span><br><span class="line">     *     structure if status is not OK.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    getCameraCharacteristics() generates</span><br><span class="line">            (Status status, CameraMetadata cameraCharacteristics);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * setTorchMode:</span><br><span class="line">     *</span><br><span class="line">     * Turn on or off the torch mode of the flash unit associated with this</span><br><span class="line">     * camera device. If the operation is successful, HAL must notify the</span><br><span class="line">     * framework torch state by invoking</span><br><span class="line">     * ICameraProviderCallback::torchModeStatusChange() with the new state.</span><br><span class="line">     *</span><br><span class="line">     * An active camera session has a higher priority accessing the flash</span><br><span class="line">     * unit. When there are any resource conflicts, such as when open() is</span><br><span class="line">     * called to fully activate a camera device, the provider must notify the</span><br><span class="line">     * framework through ICameraProviderCallback::torchModeStatusChange() that</span><br><span class="line">     * the torch mode has been turned off and the torch mode state has become</span><br><span class="line">     * TORCH_MODE_STATUS_NOT_AVAILABLE. When resources to turn on torch mode</span><br><span class="line">     * become available again, the provider must notify the framework through</span><br><span class="line">     * ICameraProviderCallback::torchModeStatusChange() that the torch mode</span><br><span class="line">     * state has become TORCH_MODE_STATUS_AVAILABLE_OFF for set_torch_mode() to</span><br><span class="line">     * be called.</span><br><span class="line">     *</span><br><span class="line">     * When the client calls setTorchMode() to turn on the torch mode of a flash</span><br><span class="line">     * unit, if the HAL cannot keep multiple torch modes on simultaneously, the</span><br><span class="line">     * HAL must turn off the torch mode(s) that were turned on by previous</span><br><span class="line">     * setTorchMode() calls and notify the framework that the torch mode state</span><br><span class="line">     * of those flash unit(s) has become TORCH_MODE_STATUS_AVAILABLE_OFF.</span><br><span class="line">     *</span><br><span class="line">     * @param torchMode The new mode to set the device flash unit to.</span><br><span class="line">     *</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On a successful change to the torch state</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         The flash unit cannot be operated due to an unexpected internal</span><br><span class="line">     *         error.</span><br><span class="line">     *     ILLEGAL_ARGUMENT:</span><br><span class="line">     *         The camera ID is unknown.</span><br><span class="line">     *     CAMERA_IN_USE:</span><br><span class="line">     *         This camera device has been opened, so the torch cannot be</span><br><span class="line">     *         controlled until it is closed.</span><br><span class="line">     *     MAX_CAMERAS_IN_USE:</span><br><span class="line">     *         Due to other camera devices being open, or due to other</span><br><span class="line">     *         resource constraints, the torch cannot be controlled currently.</span><br><span class="line">     *     METHOD_NOT_SUPPORTED:</span><br><span class="line">     *         This provider does not support direct operation of flashlight</span><br><span class="line">     *         torch mode. The framework must open the camera device and turn</span><br><span class="line">     *         the torch on through the device interface.</span><br><span class="line">     *     OPERATION_NOT_SUPPORTED:</span><br><span class="line">     *         This camera device does not have a flash unit. This can</span><br><span class="line">     *         be returned if and only if android.flash.info.available is</span><br><span class="line">     *         false.</span><br><span class="line">     *     CAMERA_DISCONNECTED:</span><br><span class="line">     *         An external camera device has been disconnected, and is no longer</span><br><span class="line">     *         available. This camera device interface is now stale, and a new</span><br><span class="line">     *         instance must be acquired if the device is reconnected. All</span><br><span class="line">     *         subsequent calls on this interface must return</span><br><span class="line">     *         CAMERA_DISCONNECTED.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    setTorchMode(TorchMode mode) generates (Status status);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * open:</span><br><span class="line">     *</span><br><span class="line">     * Power on and initialize this camera device for active use, returning a</span><br><span class="line">     * session handle for active operations.</span><br><span class="line">     *</span><br><span class="line">     * @param callback Interface to invoke by the HAL for device asynchronous</span><br><span class="line">     *     events. For HALs newer than version 3.2, HAL must use castFrom</span><br><span class="line">     *     method to check the exact version of callback sent by camera service.</span><br><span class="line">     *</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On a successful open of the camera device.</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         The camera device cannot be opened due to an internal</span><br><span class="line">     *         error.</span><br><span class="line">     *     ILLEGAL_ARGUMENT:</span><br><span class="line">     *         The callbacks handle is invalid (for example, it is null).</span><br><span class="line">     *     CAMERA_IN_USE:</span><br><span class="line">     *         This camera device is already open.</span><br><span class="line">     *     MAX_CAMERAS_IN_USE:</span><br><span class="line">     *         The maximal number of camera devices that can be</span><br><span class="line">     *         opened concurrently were opened already.</span><br><span class="line">     *     CAMERA_DISCONNECTED:</span><br><span class="line">     *         This external camera device has been disconnected, and is no</span><br><span class="line">     *         longer available. This interface is now stale, and a new instance</span><br><span class="line">     *         must be acquired if the device is reconnected. All subsequent</span><br><span class="line">     *         calls on this interface must return CAMERA_DISCONNECTED.</span><br><span class="line">     * @return session The interface to the newly-opened camera session,</span><br><span class="line">     *     or null if status is not OK.</span><br><span class="line">     */</span><br><span class="line">    open(ICameraDeviceCallback callback) generates</span><br><span class="line">            (Status status, ICameraDeviceSession session);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * dumpState:</span><br><span class="line">     *</span><br><span class="line">     * Print out debugging state for the camera device. This may be called by</span><br><span class="line">     * the framework when the camera service is asked for a debug dump, which</span><br><span class="line">     * happens when using the dumpsys tool, or when capturing a bugreport.</span><br><span class="line">     *</span><br><span class="line">     * The passed-in file descriptor can be used to write debugging text using</span><br><span class="line">     * dprintf() or write(). The text must be in ASCII encoding only.</span><br><span class="line">     *</span><br><span class="line">     * In case this camera device has been disconnected, the dump must not fail,</span><br><span class="line">     * but may simply print out &apos;Device disconnected&apos; or equivalent.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This must be a non-blocking call. The HAL should return from this call</span><br><span class="line">     * in 1ms, must return from this call in 10ms. This call must avoid</span><br><span class="line">     * deadlocks, as it may be called at any point during camera operation.</span><br><span class="line">     * Any synchronization primitives used (such as mutex locks or semaphores)</span><br><span class="line">     * must be acquired with a timeout.</span><br><span class="line">     */</span><br><span class="line">    dumpState(handle fd);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraDevice接口类，由CameraDevice::TrampolineDeviceInterface_3_2实现，其主要接口如下:</p>
<ul>
<li>open： 用于创建一个Camera设备，并且将Camera Service中继承ICameraDeviceCallback并实现了相应接口的Camera3Device作为参数传入Provider中，供Provider上传事件或者图像数据。</li>
<li>getCameraCharacteristics：用于获取Camera设备的属性。</li>
</ul>
<h3 id="2-4-ICameraDeviceCallback-hal"><a href="#2-4-ICameraDeviceCallback-hal" class="headerlink" title="2.4 ICameraDeviceCallback.hal"></a>2.4 ICameraDeviceCallback.hal</h3><p>ICameraDeviceCallback.hal源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">package android.hardware.camera.device@3.2;</span><br><span class="line"></span><br><span class="line">import android.hardware.camera.common@1.0::types;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * Callback methods for the HAL to call into the framework.</span><br><span class="line"> *</span><br><span class="line"> * These methods are used to return metadata and image buffers for a completed</span><br><span class="line"> * or failed captures, and to notify the framework of asynchronous events such</span><br><span class="line"> * as errors.</span><br><span class="line"> *</span><br><span class="line"> * The framework must not call back into the HAL from within these callbacks,</span><br><span class="line"> * and these calls must not block for extended periods.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">interface ICameraDeviceCallback &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * processCaptureResult:</span><br><span class="line">     *</span><br><span class="line">     * Send results from one or more completed or partially completed captures</span><br><span class="line">     * to the framework.</span><br><span class="line">     * processCaptureResult() may be invoked multiple times by the HAL in</span><br><span class="line">     * response to a single capture request. This allows, for example, the</span><br><span class="line">     * metadata and low-resolution buffers to be returned in one call, and</span><br><span class="line">     * post-processed JPEG buffers in a later call, once it is available. Each</span><br><span class="line">     * call must include the frame number of the request it is returning</span><br><span class="line">     * metadata or buffers for. Only one call to processCaptureResult</span><br><span class="line">     * may be made at a time by the HAL although the calls may come from</span><br><span class="line">     * different threads in the HAL.</span><br><span class="line">     *</span><br><span class="line">     * A component (buffer or metadata) of the complete result may only be</span><br><span class="line">     * included in one process_capture_result call. A buffer for each stream,</span><br><span class="line">     * and the result metadata, must be returned by the HAL for each request in</span><br><span class="line">     * one of the processCaptureResult calls, even in case of errors producing</span><br><span class="line">     * some of the output. A call to processCaptureResult() with neither</span><br><span class="line">     * output buffers or result metadata is not allowed.</span><br><span class="line">     *</span><br><span class="line">     * The order of returning metadata and buffers for a single result does not</span><br><span class="line">     * matter, but buffers for a given stream must be returned in FIFO order. So</span><br><span class="line">     * the buffer for request 5 for stream A must always be returned before the</span><br><span class="line">     * buffer for request 6 for stream A. This also applies to the result</span><br><span class="line">     * metadata; the metadata for request 5 must be returned before the metadata</span><br><span class="line">     * for request 6.</span><br><span class="line">     *</span><br><span class="line">     * However, different streams are independent of each other, so it is</span><br><span class="line">     * acceptable and expected that the buffer for request 5 for stream A may be</span><br><span class="line">     * returned after the buffer for request 6 for stream B is. And it is</span><br><span class="line">     * acceptable that the result metadata for request 6 for stream B is</span><br><span class="line">     * returned before the buffer for request 5 for stream A is. If multiple</span><br><span class="line">     * capture results are included in a single call, camera framework must</span><br><span class="line">     * process results sequentially from lower index to higher index, as if</span><br><span class="line">     * these results were sent to camera framework one by one, from lower index</span><br><span class="line">     * to higher index.</span><br><span class="line">     *</span><br><span class="line">     * The HAL retains ownership of result structure, which only needs to be</span><br><span class="line">     * valid to access during this call.</span><br><span class="line">     *</span><br><span class="line">     * The output buffers do not need to be filled yet; the framework must wait</span><br><span class="line">     * on the stream buffer release sync fence before reading the buffer</span><br><span class="line">     * data. Therefore, this method should be called by the HAL as soon as</span><br><span class="line">     * possible, even if some or all of the output buffers are still in</span><br><span class="line">     * being filled. The HAL must include valid release sync fences into each</span><br><span class="line">     * output_buffers stream buffer entry, or -1 if that stream buffer is</span><br><span class="line">     * already filled.</span><br><span class="line">     *</span><br><span class="line">     * If the result buffer cannot be constructed for a request, the HAL must</span><br><span class="line">     * return an empty metadata buffer, but still provide the output buffers and</span><br><span class="line">     * their sync fences. In addition, notify() must be called with an</span><br><span class="line">     * ERROR_RESULT message.</span><br><span class="line">     *</span><br><span class="line">     * If an output buffer cannot be filled, its status field must be set to</span><br><span class="line">     * STATUS_ERROR. In addition, notify() must be called with a ERROR_BUFFER</span><br><span class="line">     * message.</span><br><span class="line">     *</span><br><span class="line">     * If the entire capture has failed, then this method still needs to be</span><br><span class="line">     * called to return the output buffers to the framework. All the buffer</span><br><span class="line">     * statuses must be STATUS_ERROR, and the result metadata must be an</span><br><span class="line">     * empty buffer. In addition, notify() must be called with a ERROR_REQUEST</span><br><span class="line">     * message. In this case, individual ERROR_RESULT/ERROR_BUFFER messages</span><br><span class="line">     * must not be sent.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This is a non-blocking call. The framework must handle each CaptureResult</span><br><span class="line">     * within 5ms.</span><br><span class="line">     *</span><br><span class="line">     * The pipeline latency (see S7 for definition) should be less than or equal to</span><br><span class="line">     * 4 frame intervals, and must be less than or equal to 8 frame intervals.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    processCaptureResult(vec&lt;CaptureResult&gt; results);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * notify:</span><br><span class="line">     *</span><br><span class="line">     * Asynchronous notification callback from the HAL, fired for various</span><br><span class="line">     * reasons. Only for information independent of frame capture, or that</span><br><span class="line">     * require specific timing. Multiple messages may be sent in one call; a</span><br><span class="line">     * message with a higher index must be considered to have occurred after a</span><br><span class="line">     * message with a lower index.</span><br><span class="line">     *</span><br><span class="line">     * Multiple threads may call notify() simultaneously.</span><br><span class="line">     *</span><br><span class="line">     * Buffers delivered to the framework must not be dispatched to the</span><br><span class="line">     * application layer until a start of exposure timestamp (or input image&apos;s</span><br><span class="line">     * start of exposure timestamp for a reprocess request) has been received</span><br><span class="line">     * via a SHUTTER notify() call. It is highly recommended to dispatch this</span><br><span class="line">     * call as early as possible.</span><br><span class="line">     *</span><br><span class="line">     * The SHUTTER notify calls for requests with android.control.enableZsl</span><br><span class="line">     * set to TRUE and ANDROID_CONTROL_CAPTURE_INTENT == STILL_CAPTURE may be</span><br><span class="line">     * out-of-order compared to SHUTTER notify for other kinds of requests</span><br><span class="line">     * (including regular, reprocess, or zero-shutter-lag requests with</span><br><span class="line">     * different capture intents).</span><br><span class="line">     *</span><br><span class="line">     * As a result, the capture results of zero-shutter-lag requests with</span><br><span class="line">     * ANDROID_CONTROL_CAPTURE_INTENT == STILL_CAPTURE may be out-of-order</span><br><span class="line">     * compared to capture results for other kinds of requests.</span><br><span class="line">     *</span><br><span class="line">     * Different SHUTTER notify calls for zero-shutter-lag requests with</span><br><span class="line">     * ANDROID_CONTROL_CAPTURE_INTENT == STILL_CAPTURE must be in order between</span><br><span class="line">     * them, as is for other kinds of requests. SHUTTER notify calls for</span><br><span class="line">     * zero-shutter-lag requests with non STILL_CAPTURE intent must be in order</span><br><span class="line">     * with SHUTTER notify calls for regular requests.</span><br><span class="line">     * ------------------------------------------------------------------------</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This is a non-blocking call. The framework must handle each message in 5ms.</span><br><span class="line">     */</span><br><span class="line">    notify(vec&lt;NotifyMsg&gt; msgs);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraDeviceCallback接口类，由Camera Service中的Camera3Device继承并实现，通过调用ICameraDevice::open方法注册到Provider中，其主要接口如下：</p>
<ul>
<li>processCaptureResult_3_4: 一旦有图像数据产生会通过调用该方法将数据以及meta data上传至Camera Service。</li>
<li>notify: 通过该方法上传事件至Camera Service中，比如shutter事件等。</li>
</ul>
<h3 id="2-5-ICameraDeviceSession-hal"><a href="#2-5-ICameraDeviceSession-hal" class="headerlink" title="2.5 ICameraDeviceSession.hal"></a>2.5 ICameraDeviceSession.hal</h3><p>ICameraDeviceSession.hal源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line">package android.hardware.camera.device@3.2;</span><br><span class="line"></span><br><span class="line">import android.hardware.camera.common@1.0::types;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Camera device active session interface.</span><br><span class="line"> *</span><br><span class="line"> * Obtained via ICameraDevice::open(), this interface contains the methods to</span><br><span class="line"> * configure and request captures from an active camera device.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">interface ICameraDeviceSession &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * constructDefaultRequestSettings:</span><br><span class="line">     *</span><br><span class="line">     * Create capture settings for standard camera use cases.</span><br><span class="line">     *</span><br><span class="line">     * The device must return a settings buffer that is configured to meet the</span><br><span class="line">     * requested use case, which must be one of the CAMERA3_TEMPLATE_*</span><br><span class="line">     * enums. All request control fields must be included.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This must be a non-blocking call. The HAL should return from this call</span><br><span class="line">     * in 1ms, and must return from this call in 5ms.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On a successful construction of default settings.</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         An unexpected internal error occurred, and the default settings</span><br><span class="line">     *         are not available.</span><br><span class="line">     *     ILLEGAL_ARGUMENT:</span><br><span class="line">     *         The camera HAL does not support the input template type</span><br><span class="line">     *     CAMERA_DISCONNECTED:</span><br><span class="line">     *         An external camera device has been disconnected, and is no longer</span><br><span class="line">     *         available. This camera device interface is now stale, and a new</span><br><span class="line">     *         instance must be acquired if the device is reconnected. All</span><br><span class="line">     *         subsequent calls on this interface must return</span><br><span class="line">     *         CAMERA_DISCONNECTED.</span><br><span class="line">     * @return template The default capture request settings for the requested</span><br><span class="line">     *     use case, or an empty metadata structure if status is not OK.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    constructDefaultRequestSettings(RequestTemplate type) generates</span><br><span class="line">            (Status status, CameraMetadata requestTemplate);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * configureStreams:</span><br><span class="line">     *</span><br><span class="line">     * Reset the HAL camera device processing pipeline and set up new input and</span><br><span class="line">     * output streams. This call replaces any existing stream configuration with</span><br><span class="line">     * the streams defined in the streamList. This method must be called at</span><br><span class="line">     * least once before a request is submitted with processCaptureRequest().</span><br><span class="line">     *</span><br><span class="line">     * The streamList must contain at least one output-capable stream, and may</span><br><span class="line">     * not contain more than one input-capable stream.</span><br><span class="line">     *</span><br><span class="line">     * The streamList may contain streams that are also in the currently-active</span><br><span class="line">     * set of streams (from the previous call to configureStreams()). These</span><br><span class="line">     * streams must already have valid values for usage, maxBuffers, and the</span><br><span class="line">     * private pointer.</span><br><span class="line">     *</span><br><span class="line">     * If the HAL needs to change the stream configuration for an existing</span><br><span class="line">     * stream due to the new configuration, it may rewrite the values of usage</span><br><span class="line">     * and/or maxBuffers during the configure call.</span><br><span class="line">     *</span><br><span class="line">     * The framework must detect such a change, and may then reallocate the</span><br><span class="line">     * stream buffers before using buffers from that stream in a request.</span><br><span class="line">     *</span><br><span class="line">     * If a currently-active stream is not included in streamList, the HAL may</span><br><span class="line">     * safely remove any references to that stream. It must not be reused in a</span><br><span class="line">     * later configureStreams() call by the framework, and all the gralloc</span><br><span class="line">     * buffers for it must be freed after the configureStreams() call returns.</span><br><span class="line">     *</span><br><span class="line">     * If the stream is new, the client must set the consumer usage flags in</span><br><span class="line">     * requestedConfiguration. Upon return, the HAL device must set producerUsage,</span><br><span class="line">     * maxBuffers, and other fields in the configureStreams() return values. These</span><br><span class="line">     * fields are then used by the framework and the platform gralloc module to</span><br><span class="line">     * allocate the gralloc buffers for each stream.</span><br><span class="line">     *</span><br><span class="line">     * Newly allocated buffers may be included in a capture request at any time</span><br><span class="line">     * by the framework. Once a gralloc buffer is returned to the framework</span><br><span class="line">     * with processCaptureResult (and its respective releaseFence has been</span><br><span class="line">     * signaled) the framework may free or reuse it at any time.</span><br><span class="line">     *</span><br><span class="line">     * ------------------------------------------------------------------------</span><br><span class="line">     *</span><br><span class="line">     * Preconditions:</span><br><span class="line">     *</span><br><span class="line">     * The framework must only call this method when no captures are being</span><br><span class="line">     * processed. That is, all results have been returned to the framework, and</span><br><span class="line">     * all in-flight input and output buffers have been returned and their</span><br><span class="line">     * release sync fences have been signaled by the HAL. The framework must not</span><br><span class="line">     * submit new requests for capture while the configureStreams() call is</span><br><span class="line">     * underway.</span><br><span class="line">     *</span><br><span class="line">     * Postconditions:</span><br><span class="line">     *</span><br><span class="line">     * The HAL device must configure itself to provide maximum possible output</span><br><span class="line">     * frame rate given the sizes and formats of the output streams, as</span><br><span class="line">     * documented in the camera device&apos;s static metadata.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This call is expected to be heavyweight and possibly take several hundred</span><br><span class="line">     * milliseconds to complete, since it may require resetting and</span><br><span class="line">     * reconfiguring the image sensor and the camera processing pipeline.</span><br><span class="line">     * Nevertheless, the HAL device should attempt to minimize the</span><br><span class="line">     * reconfiguration delay to minimize the user-visible pauses during</span><br><span class="line">     * application operational mode changes (such as switching from still</span><br><span class="line">     * capture to video recording).</span><br><span class="line">     *</span><br><span class="line">     * The HAL should return from this call in 500ms, and must return from this</span><br><span class="line">     * call in 1000ms.</span><br><span class="line">     *</span><br><span class="line">     * @return Status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *          On successful stream configuration.</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         If there has been a fatal error and the device is no longer</span><br><span class="line">     *         operational. Only close() can be called successfully by the</span><br><span class="line">     *         framework after this error is returned.</span><br><span class="line">     *     ILLEGAL_ARGUMENT:</span><br><span class="line">     *         If the requested stream configuration is invalid. Some examples</span><br><span class="line">     *         of invalid stream configurations include:</span><br><span class="line">     *           - Including more than 1 INPUT stream</span><br><span class="line">     *           - Not including any OUTPUT streams</span><br><span class="line">     *           - Including streams with unsupported formats, or an unsupported</span><br><span class="line">     *             size for that format.</span><br><span class="line">     *           - Including too many output streams of a certain format.</span><br><span class="line">     *           - Unsupported rotation configuration</span><br><span class="line">     *           - Stream sizes/formats don&apos;t satisfy the</span><br><span class="line">     *             StreamConfigurationMode requirements for non-NORMAL mode, or</span><br><span class="line">     *             the requested operation_mode is not supported by the HAL.</span><br><span class="line">     *           - Unsupported usage flag</span><br><span class="line">     *         The camera service cannot filter out all possible illegal stream</span><br><span class="line">     *         configurations, since some devices may support more simultaneous</span><br><span class="line">     *         streams or larger stream resolutions than the minimum required</span><br><span class="line">     *         for a given camera device hardware level. The HAL must return an</span><br><span class="line">     *         ILLEGAL_ARGUMENT for any unsupported stream set, and then be</span><br><span class="line">     *         ready to accept a future valid stream configuration in a later</span><br><span class="line">     *         configureStreams call.</span><br><span class="line">     * @return finalConfiguration The stream parameters desired by the HAL for</span><br><span class="line">     *     each stream, including maximum buffers, the usage flags, and the</span><br><span class="line">     *     override format.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    configureStreams(StreamConfiguration requestedConfiguration)</span><br><span class="line">            generates (Status status,</span><br><span class="line">                    HalStreamConfiguration halConfiguration);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * processCaptureRequest:</span><br><span class="line">     *</span><br><span class="line">     * Send a list of capture requests to the HAL. The HAL must not return from</span><br><span class="line">     * this call until it is ready to accept the next set of requests to</span><br><span class="line">     * process. Only one call to processCaptureRequest() must be made at a time</span><br><span class="line">     * by the framework, and the calls must all be from the same thread. The</span><br><span class="line">     * next call to processCaptureRequest() must be made as soon as a new</span><br><span class="line">     * request and its associated buffers are available. In a normal preview</span><br><span class="line">     * scenario, this means the function is generally called again by the</span><br><span class="line">     * framework almost instantly. If more than one request is provided by the</span><br><span class="line">     * client, the HAL must process the requests in order of lowest index to</span><br><span class="line">     * highest index.</span><br><span class="line">     *</span><br><span class="line">     * The cachesToRemove argument contains a list of buffer caches (see</span><br><span class="line">     * StreamBuffer document for more information on buffer cache) to be removed</span><br><span class="line">     * by camera HAL. Camera HAL must remove these cache entries whether or not</span><br><span class="line">     * this method returns OK.</span><br><span class="line">     *</span><br><span class="line">     * The actual request processing is asynchronous, with the results of</span><br><span class="line">     * capture being returned by the HAL through the processCaptureResult()</span><br><span class="line">     * call. This call requires the result metadata to be available, but output</span><br><span class="line">     * buffers may simply provide sync fences to wait on. Multiple requests are</span><br><span class="line">     * expected to be in flight at once, to maintain full output frame rate.</span><br><span class="line">     *</span><br><span class="line">     * The framework retains ownership of the request structure. It is only</span><br><span class="line">     * guaranteed to be valid during this call. The HAL device must make copies</span><br><span class="line">     * of the information it needs to retain for the capture processing. The HAL</span><br><span class="line">     * is responsible for waiting on and closing the buffers&apos; fences and</span><br><span class="line">     * returning the buffer handles to the framework.</span><br><span class="line">     *</span><br><span class="line">     * The HAL must write the file descriptor for the input buffer&apos;s release</span><br><span class="line">     * sync fence into input_buffer-&gt;release_fence, if input_buffer is not</span><br><span class="line">     * valid. If the HAL returns -1 for the input buffer release sync fence, the</span><br><span class="line">     * framework is free to immediately reuse the input buffer. Otherwise, the</span><br><span class="line">     * framework must wait on the sync fence before refilling and reusing the</span><br><span class="line">     * input buffer.</span><br><span class="line">     *</span><br><span class="line">     * The input/output buffers provided by the framework in each request</span><br><span class="line">     * may be brand new (having never before seen by the HAL).</span><br><span class="line">     *</span><br><span class="line">     * ------------------------------------------------------------------------</span><br><span class="line">     * Performance considerations:</span><br><span class="line">     *</span><br><span class="line">     * Handling a new buffer should be extremely lightweight and there must be</span><br><span class="line">     * no frame rate degradation or frame jitter introduced.</span><br><span class="line">     *</span><br><span class="line">     * This call must return fast enough to ensure that the requested frame</span><br><span class="line">     * rate can be sustained, especially for streaming cases (post-processing</span><br><span class="line">     * quality settings set to FAST). The HAL should return this call in 1</span><br><span class="line">     * frame interval, and must return from this call in 4 frame intervals.</span><br><span class="line">     *</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On a successful start to processing the capture request</span><br><span class="line">     *     ILLEGAL_ARGUMENT:</span><br><span class="line">     *         If the input is malformed (the settings are empty when not</span><br><span class="line">     *         allowed, there are 0 output buffers, etc) and capture processing</span><br><span class="line">     *         cannot start. Failures during request processing must be</span><br><span class="line">     *         handled by calling ICameraDeviceCallback::notify(). In case of</span><br><span class="line">     *         this error, the framework retains responsibility for the</span><br><span class="line">     *         stream buffers&apos; fences and the buffer handles; the HAL must not</span><br><span class="line">     *         close the fences or return these buffers with</span><br><span class="line">     *         ICameraDeviceCallback::processCaptureResult().</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         If the camera device has encountered a serious error. After this</span><br><span class="line">     *         error is returned, only the close() method can be successfully</span><br><span class="line">     *         called by the framework.</span><br><span class="line">     * @return numRequestProcessed Number of requests successfully processed by</span><br><span class="line">     *     camera HAL. When status is OK, this must be equal to the size of</span><br><span class="line">     *     requests. When the call fails, this number is the number of requests</span><br><span class="line">     *     that HAL processed successfully before HAL runs into an error.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    processCaptureRequest(vec&lt;CaptureRequest&gt; requests,</span><br><span class="line">            vec&lt;BufferCache&gt; cachesToRemove)</span><br><span class="line">            generates (Status status, uint32_t numRequestProcessed);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * getCaptureRequestMetadataQueue:</span><br><span class="line">     *</span><br><span class="line">     * Retrieves the queue used along with processCaptureRequest. If</span><br><span class="line">     * client decides to use fast message queue to pass request metadata,</span><br><span class="line">     * it must:</span><br><span class="line">     * - Call getCaptureRequestMetadataQueue to retrieve the fast message queue;</span><br><span class="line">     * - In each of the requests sent in processCaptureRequest, set</span><br><span class="line">     *   fmqSettingsSize field of CaptureRequest to be the size to read from the</span><br><span class="line">     *   fast message queue; leave settings field of CaptureRequest empty.</span><br><span class="line">     *</span><br><span class="line">     * @return queue the queue that client writes request metadata to.</span><br><span class="line">     */</span><br><span class="line">    getCaptureRequestMetadataQueue() generates (fmq_sync&lt;uint8_t&gt; queue);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * getCaptureResultMetadataQueue:</span><br><span class="line">     *</span><br><span class="line">     * Retrieves the queue used along with</span><br><span class="line">     * ICameraDeviceCallback.processCaptureResult.</span><br><span class="line">     *</span><br><span class="line">     * Clients to ICameraDeviceSession must:</span><br><span class="line">     * - Call getCaptureRequestMetadataQueue to retrieve the fast message queue;</span><br><span class="line">     * - In implementation of ICameraDeviceCallback, test whether</span><br><span class="line">     *   .fmqResultSize field is zero.</span><br><span class="line">     *     - If .fmqResultSize != 0, read result metadata from the fast message</span><br><span class="line">     *       queue;</span><br><span class="line">     *     - otherwise, read result metadata in CaptureResult.result.</span><br><span class="line">     *</span><br><span class="line">     * @return queue the queue that implementation writes result metadata to.</span><br><span class="line">     */</span><br><span class="line">    getCaptureResultMetadataQueue() generates (fmq_sync&lt;uint8_t&gt; queue);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * flush:</span><br><span class="line">     *</span><br><span class="line">     * Flush all currently in-process captures and all buffers in the pipeline</span><br><span class="line">     * on the given device. Generally, this method is used to dump all state as</span><br><span class="line">     * quickly as possible in order to prepare for a configure_streams() call.</span><br><span class="line">     *</span><br><span class="line">     * No buffers are required to be successfully returned, so every buffer</span><br><span class="line">     * held at the time of flush() (whether successfully filled or not) may be</span><br><span class="line">     * returned with CAMERA3_BUFFER_STATUS_ERROR. Note the HAL is still allowed</span><br><span class="line">     * to return valid (CAMERA3_BUFFER_STATUS_OK) buffers during this call,</span><br><span class="line">     * provided they are successfully filled.</span><br><span class="line">     *</span><br><span class="line">     * All requests currently in the HAL are expected to be returned as soon as</span><br><span class="line">     * possible. Not-in-process requests must return errors immediately. Any</span><br><span class="line">     * interruptible hardware blocks must be stopped, and any uninterruptible</span><br><span class="line">     * blocks must be waited on.</span><br><span class="line">     *</span><br><span class="line">     * flush() may be called concurrently to processCaptureRequest(), with the</span><br><span class="line">     * expectation that processCaptureRequest returns quickly and the</span><br><span class="line">     * request submitted in that processCaptureRequest call is treated like</span><br><span class="line">     * all other in-flight requests. Due to concurrency issues, it is possible</span><br><span class="line">     * that from the HAL&apos;s point of view, a processCaptureRequest() call may</span><br><span class="line">     * be started after flush has been invoked but has not returned yet. If such</span><br><span class="line">     * a call happens before flush() returns, the HAL must treat the new</span><br><span class="line">     * capture request like other in-flight pending requests (see #4 below).</span><br><span class="line">     *</span><br><span class="line">     * More specifically, the HAL must follow below requirements for various</span><br><span class="line">     * cases:</span><br><span class="line">     *</span><br><span class="line">     * 1. For captures that are too late for the HAL to cancel/stop, and must be</span><br><span class="line">     *    completed normally by the HAL; i.e. the HAL can send shutter/notify</span><br><span class="line">     *    and processCaptureResult and buffers as normal.</span><br><span class="line">     *</span><br><span class="line">     * 2. For pending requests that have not done any processing, the HAL must</span><br><span class="line">     *    call notify CAMERA3_MSG_ERROR_REQUEST, and return all the output</span><br><span class="line">     *    buffers with processCaptureResult in the error state</span><br><span class="line">     *    (CAMERA3_BUFFER_STATUS_ERROR). The HAL must not place the release</span><br><span class="line">     *    fence into an error state, instead, the release fences must be set to</span><br><span class="line">     *    the acquire fences passed by the framework, or -1 if they have been</span><br><span class="line">     *    waited on by the HAL already. This is also the path to follow for any</span><br><span class="line">     *    captures for which the HAL already called notify() with</span><br><span class="line">     *    CAMERA3_MSG_SHUTTER but won&apos;t be producing any metadata/valid buffers</span><br><span class="line">     *    for. After CAMERA3_MSG_ERROR_REQUEST, for a given frame, only</span><br><span class="line">     *    processCaptureResults with buffers in CAMERA3_BUFFER_STATUS_ERROR</span><br><span class="line">     *    are allowed. No further notifys or processCaptureResult with</span><br><span class="line">     *    non-empty metadata is allowed.</span><br><span class="line">     *</span><br><span class="line">     * 3. For partially completed pending requests that do not have all the</span><br><span class="line">     *    output buffers or perhaps missing metadata, the HAL must follow</span><br><span class="line">     *    below:</span><br><span class="line">     *</span><br><span class="line">     *    3.1. Call notify with CAMERA3_MSG_ERROR_RESULT if some of the expected</span><br><span class="line">     *         result metadata (i.e. one or more partial metadata) won&apos;t be</span><br><span class="line">     *         available for the capture.</span><br><span class="line">     *</span><br><span class="line">     *    3.2. Call notify with CAMERA3_MSG_ERROR_BUFFER for every buffer that</span><br><span class="line">     *         won&apos;t be produced for the capture.</span><br><span class="line">     *</span><br><span class="line">     *    3.3. Call notify with CAMERA3_MSG_SHUTTER with the capture timestamp</span><br><span class="line">     *         before any buffers/metadata are returned with</span><br><span class="line">     *         processCaptureResult.</span><br><span class="line">     *</span><br><span class="line">     *    3.4. For captures that will produce some results, the HAL must not</span><br><span class="line">     *         call CAMERA3_MSG_ERROR_REQUEST, since that indicates complete</span><br><span class="line">     *         failure.</span><br><span class="line">     *</span><br><span class="line">     *    3.5. Valid buffers/metadata must be passed to the framework as</span><br><span class="line">     *         normal.</span><br><span class="line">     *</span><br><span class="line">     *    3.6. Failed buffers must be returned to the framework as described</span><br><span class="line">     *         for case 2. But failed buffers do not have to follow the strict</span><br><span class="line">     *         ordering valid buffers do, and may be out-of-order with respect</span><br><span class="line">     *         to valid buffers. For example, if buffers A, B, C, D, E are sent,</span><br><span class="line">     *         D and E are failed, then A, E, B, D, C is an acceptable return</span><br><span class="line">     *         order.</span><br><span class="line">     *</span><br><span class="line">     *    3.7. For fully-missing metadata, calling CAMERA3_MSG_ERROR_RESULT is</span><br><span class="line">     *         sufficient, no need to call processCaptureResult with empty</span><br><span class="line">     *         metadata or equivalent.</span><br><span class="line">     *</span><br><span class="line">     * 4. If a flush() is invoked while a processCaptureRequest() invocation</span><br><span class="line">     *    is active, that process call must return as soon as possible. In</span><br><span class="line">     *    addition, if a processCaptureRequest() call is made after flush()</span><br><span class="line">     *    has been invoked but before flush() has returned, the capture request</span><br><span class="line">     *    provided by the late processCaptureRequest call must be treated</span><br><span class="line">     *    like a pending request in case #2 above.</span><br><span class="line">     *</span><br><span class="line">     * flush() must only return when there are no more outstanding buffers or</span><br><span class="line">     * requests left in the HAL. The framework may call configure_streams (as</span><br><span class="line">     * the HAL state is now quiesced) or may issue new requests.</span><br><span class="line">     *</span><br><span class="line">     * Note that it&apos;s sufficient to only support fully-succeeded and</span><br><span class="line">     * fully-failed result cases. However, it is highly desirable to support</span><br><span class="line">     * the partial failure cases as well, as it could help improve the flush</span><br><span class="line">     * call overall performance.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * The HAL should return from this call in 100ms, and must return from this</span><br><span class="line">     * call in 1000ms. And this call must not be blocked longer than pipeline</span><br><span class="line">     * latency (see S7 for definition).</span><br><span class="line">     *</span><br><span class="line">     * @return status Status code for the operation, one of:</span><br><span class="line">     *     OK:</span><br><span class="line">     *         On a successful flush of the camera HAL.</span><br><span class="line">     *     INTERNAL_ERROR:</span><br><span class="line">     *         If the camera device has encountered a serious error. After this</span><br><span class="line">     *         error is returned, only the close() method can be successfully</span><br><span class="line">     *         called by the framework.</span><br><span class="line">     */</span><br><span class="line">    flush() generates (Status status);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * close:</span><br><span class="line">     *</span><br><span class="line">     * Shut down the camera device.</span><br><span class="line">     *</span><br><span class="line">     * After this call, all calls to this session instance must return</span><br><span class="line">     * INTERNAL_ERROR.</span><br><span class="line">     *</span><br><span class="line">     * This method must always succeed, even if the device has encountered a</span><br><span class="line">     * serious error.</span><br><span class="line">     */</span><br><span class="line">    close();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraDeviceSession接口类，由CameraDeviceSession::TrampolineSessionInterface_3_2继承并实现，其主要接口如下：</p>
<ul>
<li>constructDefaultRequestSettings：用于创建默认的Request配置项。</li>
<li>configureStreams_3_5：用于配置数据流，其中包括了output buffer/Surface/图像格式大小等属性。</li>
<li>processCaptureRequest_3_4：下发request到Provider中，一个request对应着一次图像需求。</li>
<li>close: 关闭当前会话。</li>
</ul>
<h2 id="三-、Camera-Provider-主程序"><a href="#三-、Camera-Provider-主程序" class="headerlink" title="三 、Camera Provider 主程序"></a>三 、Camera Provider 主程序</h2><p>打开camera时，可以看到cameraprovider进程，下面看下具体cameprovider如何启动的，以及整个进程如何运转。</p>
<p><img src="/2024/深入理解Android Camera架构三-硬件抽象层/processprovider.png" alt=""></p>
<p>下图是整个cameraprovider进程启动流程图，将会根据这个流程图进行分析</p>
<p><img src="/2024/深入理解Android Camera架构三-硬件抽象层/cameraproviderstart.png" style="zoom:80%;"></p>
<h3 id="3-1-android-hardware-camera-provider-2-4-service-64-rc"><a href="#3-1-android-hardware-camera-provider-2-4-service-64-rc" class="headerlink" title="3.1 android.hardware.camera.provider@2.4-service_64.rc"></a>3.1 <a href="mailto:android.hardware.camera.provider@2.4-servic" target="_blank" rel="noopener">android.hardware.camera.provider@2.4-servic</a>e_64.rc</h3><p>在系统初始化的时候，系统会去运行<a href="mailto:android.hardware.camera.provider@2.4-servic" target="_blank" rel="noopener">android.hardware.camera.provider@2.4-servic</a>e_64程序启动Provider进程</p>
<p>[-&gt;hardware\interfaces\camera\provider\2.4\default\<a href="mailto:android.hardware.camera.provider@2.4-servic" target="_blank" rel="noopener">android.hardware.camera.provider@2.4-servic</a>e_64.rc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service vendor.camera-provider-2-4 /vendor/bin/hw/android.hardware.camera.provider@2.4-service_64</span><br><span class="line">    interface android.hardware.camera.provider@2.4::ICameraProvider legacy/0</span><br><span class="line">    class hal</span><br><span class="line">    user cameraserver</span><br><span class="line">    group audio camera input drmrpc</span><br><span class="line">    ioprio rt 4</span><br><span class="line">    capabilities SYS_NICE</span><br><span class="line">    writepid /dev/cpuset/camera-daemon/tasks /dev/stune/foreground/tasks</span><br></pre></td></tr></table></figure>
<h3 id="3-2-service-cpp"><a href="#3-2-service-cpp" class="headerlink" title="3.2 service.cpp"></a>3.2 service.cpp</h3><p>下面先简单介绍下hidl服务启动的两个方式</p>
<p>直通式 HAL(passthrough)模式：编译成so库，供System分区的进程和应用直接加载调用，两者在同一个进程中；</p>
<p>绑定式HAL(Binderized )模式：直接编译成一个daemon可运行的服务，然后System分区的进程通过HwBinder的IPC通信方式来调用，两者在二个独立的进程中。</p>
<p>绑定式可以用两种方式来绑定服务，第一种通过defaultPassthroughServiceImplementation 的调用来注册服务，另外一种是直接调用RegisterAsService来注册服务。</p>
<p>CameraProvider是通过defaultPassthroughServiceImplementation 的调用来注册服务</p>
<p>[-&gt;hardware\interfaces\camera\provider\2.4\default\service.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#ifdef LAZY_SERVICE</span><br><span class="line">#define LOG_TAG &quot;android.hardware.camera.provider@2.4-service-lazy&quot;</span><br><span class="line">#else</span><br><span class="line">#define LOG_TAG &quot;android.hardware.camera.provider@2.4-service&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;android/hardware/camera/provider/2.4/ICameraProvider.h&gt;</span><br><span class="line">#include &lt;binder/ProcessState.h&gt;</span><br><span class="line">#include &lt;hidl/LegacySupport.h&gt;</span><br><span class="line"></span><br><span class="line">using android::status_t;</span><br><span class="line">using android::hardware::defaultLazyPassthroughServiceImplementation;</span><br><span class="line">using android::hardware::defaultPassthroughServiceImplementation;</span><br><span class="line">using android::hardware::camera::provider::V2_4::ICameraProvider;</span><br><span class="line"></span><br><span class="line">#ifdef LAZY_SERVICE</span><br><span class="line">const bool kLazyService = true;</span><br><span class="line">#else</span><br><span class="line">const bool kLazyService = false;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(&quot;CameraProvider@2.4 legacy service is starting.&quot;);</span><br><span class="line">    // The camera HAL may communicate to other vendor components via</span><br><span class="line">    // /dev/vndbinder</span><br><span class="line">    android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);</span><br><span class="line">    status_t status;</span><br><span class="line">    if (kLazyService) &#123;</span><br><span class="line">        status = defaultLazyPassthroughServiceImplementation&lt;ICameraProvider&gt;(&quot;legacy/0&quot;,</span><br><span class="line">                                                                              /*maxThreads*/ 6);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        status = defaultPassthroughServiceImplementation&lt;ICameraProvider&gt;(&quot;legacy/0&quot;,</span><br><span class="line">                                                                          /*maxThreads*/ 6);</span><br><span class="line">    &#125;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在manifest中注册的provider，选择的是hwbinder，可知注册的方式是绑定式HAL(Binderized )模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;hal format=&quot;hidl&quot;&gt;</span><br><span class="line">       &lt;name&gt;android.hardware.camera.provider&lt;/name&gt;</span><br><span class="line">       &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">       &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">           &lt;name&gt;ICameraProvider&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;legacy/0&lt;/instance&gt;</span><br><span class="line">           &lt;instance&gt;external/0&lt;/instance&gt;</span><br><span class="line">      &lt;/interface&gt;</span><br><span class="line"> &lt;/hal&gt;</span><br></pre></td></tr></table></figure>
<p>[-&gt;system/libhidl/transport/include/hidl/LegacySupport.h]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Creates default passthrough service implementation. This method never returns.</span><br><span class="line">   *</span><br><span class="line">   * Return value is exit status.</span><br><span class="line">   */</span><br><span class="line">  template &lt;class Interface&gt;</span><br><span class="line">  __attribute__((warn_unused_result)) status_t defaultPassthroughServiceImplementation(</span><br><span class="line">      const std::string&amp; name, size_t maxThreads = 1) &#123;</span><br><span class="line">      configureRpcThreadpool(maxThreads, true);</span><br><span class="line">     status_t result = registerPassthroughServiceImplementation&lt;Interface&gt;(name);</span><br><span class="line">  </span><br><span class="line">      if (result != OK) &#123;</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      joinRpcThreadpool();</span><br><span class="line">      return UNKNOWN_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">   * Registers passthrough service implementation.</span><br><span class="line">   */</span><br><span class="line">  template &lt;class Interface&gt;</span><br><span class="line">  __attribute__((warn_unused_result)) status_t registerPassthroughServiceImplementation(</span><br><span class="line">      const std::string&amp; name = &quot;default&quot;) &#123;</span><br><span class="line">      return details::registerPassthroughServiceImplementation&lt;Interface&gt;(</span><br><span class="line">         [](const sp&lt;Interface&gt;&amp; service, const std::string&amp; name) &#123;</span><br><span class="line">              return service-&gt;registerAsService(name);</span><br><span class="line">          &#125;,</span><br><span class="line">         name);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">template &lt;class Interface, typename Func&gt;</span><br><span class="line">__attribute__((warn_unused_result)) status_t registerPassthroughServiceImplementation(</span><br><span class="line">    Func registerServiceCb, const std::string&amp; name = &quot;default&quot;) &#123;</span><br><span class="line">    sp&lt;Interface&gt; service = Interface::getService(name, true /* getStub */);</span><br><span class="line"></span><br><span class="line">    if (service == nullptr) &#123;</span><br><span class="line">        ALOGE(&quot;Could not get passthrough implementation for %s/%s.&quot;,</span><br><span class="line">            Interface::descriptor, name.c_str());</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_FATAL_IF(service-&gt;isRemote(), &quot;Implementation of %s/%s is remote!&quot;,</span><br><span class="line">            Interface::descriptor, name.c_str());</span><br><span class="line"></span><br><span class="line">    status_t status = registerServiceCb(service, name);</span><br><span class="line"></span><br><span class="line">    if (status == OK) &#123;</span><br><span class="line">        ALOGI(&quot;Registration complete for %s/%s.&quot;,</span><br><span class="line">            Interface::descriptor, name.c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGE(&quot;Could not register service %s/%s (%d).&quot;,</span><br><span class="line">            Interface::descriptor, name.c_str(), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  // namespace details</span><br><span class="line"></span><br><span class="line">// 文件路径out\soong\.intermediates\hardware\interfaces\camera\provider\2.4\android.hardware.camera.provider@2.4_genc++\gen\android\hardware\camera\provider\2.4\CameraProviderAll.cpp</span><br><span class="line"></span><br><span class="line">::android::sp&lt;ICameraProvider&gt; ICameraProvider::getService(const std::string &amp;serviceName, const bool getStub) &#123;</span><br><span class="line">    return ::android::hardware::details::getServiceInternal&lt;BpHwCameraProvider&gt;(serviceName, true, getStub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//system/libhidl/transport/include/hidl/HidlTransportSupport.h</span><br><span class="line">sp&lt;IType&gt; getServiceInternal(const std::string&amp; instance, bool retry, bool getStub) &#123;</span><br><span class="line">     using ::android::hidl::base::V1_0::IBase;</span><br><span class="line">  </span><br><span class="line">      sp&lt;IBase&gt; base = getRawServiceInternal(IType::descriptor, instance, retry, getStub);</span><br><span class="line">  </span><br><span class="line">      if (base == nullptr) &#123;</span><br><span class="line">         return nullptr;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      if (base-&gt;isRemote()) &#123;</span><br><span class="line">         // getRawServiceInternal guarantees we get the proper class</span><br><span class="line">         return sp&lt;IType&gt;(new BpType(getOrCreateCachedBinder(base.get())));</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    return IType::castFrom(base);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;  // namespace details</span><br><span class="line"> </span><br><span class="line"> &#125;  /</span><br><span class="line"></span><br><span class="line">//system\libhidl\transport\ServiceManagement.cpp</span><br><span class="line">sp&lt;::android::hidl::base::V1_0::IBase&gt; getRawServiceInternal(const std::string&amp; descriptor,</span><br><span class="line">                                                             const std::string&amp; instance,</span><br><span class="line">                                                             bool retry, bool getStub) &#123;</span><br><span class="line">    using Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport;</span><br><span class="line">    using ::android::hidl::manager::V1_0::IServiceManager;</span><br><span class="line">    sp&lt;Waiter&gt; waiter;</span><br><span class="line"></span><br><span class="line">    sp&lt;IServiceManager1_1&gt; sm;</span><br><span class="line">    Transport transport = Transport::EMPTY;</span><br><span class="line">    if (kIsRecovery) &#123;</span><br><span class="line">        transport = Transport::PASSTHROUGH;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sm = defaultServiceManager1_1();</span><br><span class="line">        if (sm == nullptr) &#123;</span><br><span class="line">            ALOGE(&quot;getService: defaultServiceManager() is null&quot;);</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Return&lt;Transport&gt; transportRet = sm-&gt;getTransport(descriptor, instance);</span><br><span class="line"></span><br><span class="line">        if (!transportRet.isOk()) &#123;</span><br><span class="line">            ALOGE(&quot;getService: defaultServiceManager()-&gt;getTransport returns %s&quot;,</span><br><span class="line">                  transportRet.description().c_str());</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        transport = transportRet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const bool vintfHwbinder = (transport == Transport::HWBINDER);</span><br><span class="line">    const bool vintfPassthru = (transport == Transport::PASSTHROUGH);</span><br><span class="line"></span><br><span class="line">#ifdef ENFORCE_VINTF_MANIFEST</span><br><span class="line"></span><br><span class="line">#ifdef LIBHIDL_TARGET_DEBUGGABLE</span><br><span class="line">    const char* env = std::getenv(&quot;TREBLE_TESTING_OVERRIDE&quot;);</span><br><span class="line">    const bool trebleTestingOverride = env &amp;&amp; !strcmp(env, &quot;true&quot;);</span><br><span class="line">    const bool vintfLegacy = (transport == Transport::EMPTY) &amp;&amp; trebleTestingOverride;</span><br><span class="line">#else   // ENFORCE_VINTF_MANIFEST but not LIBHIDL_TARGET_DEBUGGABLE</span><br><span class="line">    const bool trebleTestingOverride = false;</span><br><span class="line">    const bool vintfLegacy = false;</span><br><span class="line">#endif  // LIBHIDL_TARGET_DEBUGGABLE</span><br><span class="line"></span><br><span class="line">#else   // not ENFORCE_VINTF_MANIFEST</span><br><span class="line">    const char* env = std::getenv(&quot;TREBLE_TESTING_OVERRIDE&quot;);</span><br><span class="line">    const bool trebleTestingOverride = env &amp;&amp; !strcmp(env, &quot;true&quot;);</span><br><span class="line">    const bool vintfLegacy = (transport == Transport::EMPTY);</span><br><span class="line">#endif  // ENFORCE_VINTF_MANIFEST</span><br><span class="line"></span><br><span class="line">    for (int tries = 0; !getStub &amp;&amp; (vintfHwbinder || vintfLegacy); tries++) &#123;</span><br><span class="line">        if (waiter == nullptr &amp;&amp; tries &gt; 0) &#123;</span><br><span class="line">            waiter = new Waiter(descriptor, instance, sm);</span><br><span class="line">        &#125;</span><br><span class="line">        if (waiter != nullptr) &#123;</span><br><span class="line">            waiter-&gt;reset();  // don&apos;t reorder this -- see comments on reset()</span><br><span class="line">        &#125;</span><br><span class="line">        Return&lt;sp&lt;IBase&gt;&gt; ret = sm-&gt;get(descriptor, instance);</span><br><span class="line">        if (!ret.isOk()) &#123;</span><br><span class="line">            ALOGE(&quot;getService: defaultServiceManager()-&gt;get returns %s for %s/%s.&quot;,</span><br><span class="line">                  ret.description().c_str(), descriptor.c_str(), instance.c_str());</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;IBase&gt; base = ret;</span><br><span class="line">        if (base != nullptr) &#123;</span><br><span class="line">            Return&lt;bool&gt; canCastRet =</span><br><span class="line">                details::canCastInterface(base.get(), descriptor.c_str(), true /* emitError */);</span><br><span class="line"></span><br><span class="line">            if (canCastRet.isOk() &amp;&amp; canCastRet) &#123;</span><br><span class="line">                if (waiter != nullptr) &#123;</span><br><span class="line">                    waiter-&gt;done();</span><br><span class="line">                &#125;</span><br><span class="line">                return base; // still needs to be wrapped by Bp class.</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!handleCastError(canCastRet, descriptor, instance)) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // In case of legacy or we were not asked to retry, don&apos;t.</span><br><span class="line">        if (vintfLegacy || !retry) break;</span><br><span class="line"></span><br><span class="line">        if (waiter != nullptr) &#123;</span><br><span class="line">            ALOGI(&quot;getService: Trying again for %s/%s...&quot;, descriptor.c_str(), instance.c_str());</span><br><span class="line">            waiter-&gt;wait(true /* timeout */);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (waiter != nullptr) &#123;</span><br><span class="line">        waiter-&gt;done();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        const sp&lt;IServiceManager&gt; pm = getPassthroughServiceManager();</span><br><span class="line">        if (pm != nullptr) &#123;</span><br><span class="line">            sp&lt;IBase&gt; base = pm-&gt;get(descriptor, instance).withDefault(nullptr);</span><br><span class="line">            if (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                base = wrapPassthrough(base);</span><br><span class="line">            &#125;</span><br><span class="line">            return base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IServiceManager1_0&gt; getPassthroughServiceManager() &#123;</span><br><span class="line">    return getPassthroughServiceManager1_1();</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;IServiceManager1_1&gt; getPassthroughServiceManager1_1() &#123;</span><br><span class="line">    static sp&lt;PassthroughServiceManager&gt; manager(new PassthroughServiceManager());</span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">truct PassthroughServiceManager : IServiceManager1_1 &#123;</span><br><span class="line">    static void openLibs(</span><br><span class="line">        const std::string&amp; fqName,</span><br><span class="line">        const std::function&lt;bool /* continue */ (void* /* handle */, const std::string&amp; /* lib */,</span><br><span class="line">                                                 const std::string&amp; /* sym */)&gt;&amp; eachLib) &#123;</span><br><span class="line">        //fqName looks like android.hardware.foo@1.0::IFoo</span><br><span class="line">        size_t idx = fqName.find(&quot;::&quot;);</span><br><span class="line"></span><br><span class="line">        if (idx == std::string::npos ||</span><br><span class="line">                idx + strlen(&quot;::&quot;) + 1 &gt;= fqName.size()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;Invalid interface name passthrough lookup: &quot; &lt;&lt; fqName;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string packageAndVersion = fqName.substr(0, idx);</span><br><span class="line">        std::string ifaceName = fqName.substr(idx + strlen(&quot;::&quot;));</span><br><span class="line"></span><br><span class="line">        const std::string prefix = packageAndVersion + &quot;-impl&quot;;</span><br><span class="line">        // sym为 HIDL_FETCH_ICameraProvider</span><br><span class="line">        const std::string sym = &quot;HIDL_FETCH_&quot; + ifaceName;</span><br><span class="line"></span><br><span class="line">        constexpr int dlMode = RTLD_LAZY;</span><br><span class="line">        void* handle = nullptr;</span><br><span class="line"></span><br><span class="line">        dlerror(); // clear</span><br><span class="line"></span><br><span class="line">        static std::string halLibPathVndkSp = android::base::StringPrintf(</span><br><span class="line">            HAL_LIBRARY_PATH_VNDK_SP_FOR_VERSION, details::getVndkVersionStr().c_str());</span><br><span class="line">        std::vector&lt;std::string&gt; paths = &#123;</span><br><span class="line">            HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR, halLibPathVndkSp,</span><br><span class="line">#ifndef __ANDROID_VNDK__</span><br><span class="line">            HAL_LIBRARY_PATH_SYSTEM,</span><br><span class="line">#endif</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">#ifdef LIBHIDL_TARGET_DEBUGGABLE</span><br><span class="line">        const char* env = std::getenv(&quot;TREBLE_TESTING_OVERRIDE&quot;);</span><br><span class="line">        const bool trebleTestingOverride = env &amp;&amp; !strcmp(env, &quot;true&quot;);</span><br><span class="line">        if (trebleTestingOverride) &#123;</span><br><span class="line">            // Load HAL implementations that are statically linked</span><br><span class="line">            handle = dlopen(nullptr, dlMode);</span><br><span class="line">            if (handle == nullptr) &#123;</span><br><span class="line">                const char* error = dlerror();</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;Failed to dlopen self: &quot;</span><br><span class="line">                           &lt;&lt; (error == nullptr ? &quot;unknown error&quot; : error);</span><br><span class="line">            &#125; else if (!eachLib(handle, &quot;SELF&quot;, sym)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            const char* vtsRootPath = std::getenv(&quot;VTS_ROOT_PATH&quot;);</span><br><span class="line">            if (vtsRootPath &amp;&amp; strlen(vtsRootPath) &gt; 0) &#123;</span><br><span class="line">                const std::string halLibraryPathVtsOverride =</span><br><span class="line">                    std::string(vtsRootPath) + HAL_LIBRARY_PATH_SYSTEM;</span><br><span class="line">                paths.insert(paths.begin(), halLibraryPathVtsOverride);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        for (const std::string&amp; path : paths) &#123;</span><br><span class="line">            std::vector&lt;std::string&gt; libs = findFiles(path, prefix, &quot;.so&quot;);</span><br><span class="line"></span><br><span class="line">            for (const std::string &amp;lib : libs) &#123;</span><br><span class="line">                const std::string fullPath = path + lib;</span><br><span class="line"></span><br><span class="line">                if (kIsRecovery || path == HAL_LIBRARY_PATH_SYSTEM) &#123;</span><br><span class="line">                    handle = dlopen(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">#if !defined(__ANDROID_RECOVERY__)</span><br><span class="line">                    handle = android_load_sphal_library(fullPath.c_str(), dlMode);</span><br><span class="line">#endif</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (handle == nullptr) &#123;</span><br><span class="line">                    const char* error = dlerror();</span><br><span class="line">                    LOG(ERROR) &lt;&lt; &quot;Failed to dlopen &quot; &lt;&lt; lib &lt;&lt; &quot;: &quot;</span><br><span class="line">                               &lt;&lt; (error == nullptr ? &quot;unknown error&quot; : error);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!eachLib(handle, lib, sym)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Return&lt;sp&lt;IBase&gt;&gt; get(const hidl_string&amp; fqName,</span><br><span class="line">                          const hidl_string&amp; name) override &#123;</span><br><span class="line">        sp&lt;IBase&gt; ret = nullptr;</span><br><span class="line"></span><br><span class="line">        openLibs(fqName, [&amp;](void* handle, const std::string &amp;lib, const std::string &amp;sym) &#123;</span><br><span class="line">            IBase* (*generator)(const char* name);</span><br><span class="line">             // 通过dlsym在android.hardware.camera.provider@2.4-impl.so中找到HIDL_FETCH_ICameraProvider的地址</span><br><span class="line">            *(void **)(&amp;generator) = dlsym(handle, sym.c_str());</span><br><span class="line">            if(!generator) &#123;</span><br><span class="line">                const char* error = dlerror();</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;Passthrough lookup opened &quot; &lt;&lt; lib</span><br><span class="line">                           &lt;&lt; &quot; but could not find symbol &quot; &lt;&lt; sym &lt;&lt; &quot;: &quot;</span><br><span class="line">                           &lt;&lt; (error == nullptr ? &quot;unknown error&quot; : error);</span><br><span class="line">                dlclose(handle);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // 执行HIDL_FETCH_ICameraProvider函数，参数为legacy/0</span><br><span class="line">            ret = (*generator)(name.c_str());</span><br><span class="line"></span><br><span class="line">            if (ret == nullptr) &#123;</span><br><span class="line">                dlclose(handle);</span><br><span class="line">                return true; // this module doesn&apos;t provide this instance name</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Actual fqname might be a subclass.</span><br><span class="line">            // This assumption is tested in vts_treble_vintf_test</span><br><span class="line">            using ::android::hardware::details::getDescriptor;</span><br><span class="line">            std::string actualFqName = getDescriptor(ret.get());</span><br><span class="line">            CHECK(actualFqName.size() &gt; 0);</span><br><span class="line">            registerReference(actualFqName, name);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-CameraProvider-2-4-cpp"><a href="#3-3-CameraProvider-2-4-cpp" class="headerlink" title="3.3 CameraProvider_2_4.cpp"></a>3.3 CameraProvider_2_4.cpp</h3><p>上面最后调用到HIDL_FETCH_ICameraProvider，通过这个方法实例化LegacyCameraProviderImpl_2_4</p>
<p>[-&gt;hardware\interfaces\camera\provider\2.4\default\CameraProvider_2_4.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;CameraProvider_2_4.h&quot;</span><br><span class="line">#include &quot;LegacyCameraProviderImpl_2_4.h&quot;</span><br><span class="line">#include &quot;ExternalCameraProviderImpl_2_4.h&quot;</span><br><span class="line"></span><br><span class="line">const char *kLegacyProviderName = &quot;legacy/0&quot;;</span><br><span class="line">const char *kExternalProviderName = &quot;external/0&quot;;</span><br><span class="line"></span><br><span class="line">namespace android &#123;</span><br><span class="line">namespace hardware &#123;</span><br><span class="line">namespace camera &#123;</span><br><span class="line">namespace provider &#123;</span><br><span class="line">namespace V2_4 &#123;</span><br><span class="line">namespace implementation &#123;</span><br><span class="line"></span><br><span class="line">using android::hardware::camera::provider::V2_4::ICameraProvider;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; ICameraProvider* HIDL_FETCH_ICameraProvider(const char* name);</span><br><span class="line"></span><br><span class="line">template&lt;typename IMPL&gt;</span><br><span class="line">CameraProvider&lt;IMPL&gt;* getProviderImpl() &#123;</span><br><span class="line">    CameraProvider&lt;IMPL&gt; *provider = new CameraProvider&lt;IMPL&gt;();</span><br><span class="line">    if (provider == nullptr) &#123;</span><br><span class="line">        ALOGE(&quot;%s: cannot allocate camera provider!&quot;, __FUNCTION__);</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    if (provider-&gt;isInitFailed()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: camera provider init failed!&quot;, __FUNCTION__);</span><br><span class="line">        delete provider;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    return provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ICameraProvider* HIDL_FETCH_ICameraProvider(const char* name) &#123;</span><br><span class="line">    using namespace android::hardware::camera::provider::V2_4::implementation;</span><br><span class="line">    ICameraProvider* provider = nullptr;</span><br><span class="line">    if (strcmp(name, kLegacyProviderName) == 0) &#123;</span><br><span class="line">        provider = getProviderImpl&lt;LegacyCameraProviderImpl_2_4&gt;();</span><br><span class="line">    &#125; else if (strcmp(name, kExternalProviderName) == 0) &#123;</span><br><span class="line">        provider = getProviderImpl&lt;ExternalCameraProviderImpl_2_4&gt;();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGE(&quot;%s: unknown instance name: %s&quot;, __FUNCTION__, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace implementation</span><br><span class="line">&#125;  // namespace V2_4</span><br><span class="line">&#125;  // namespace provider</span><br><span class="line">&#125;  // namespace camera</span><br><span class="line">&#125;  // namespace hardware</span><br><span class="line">&#125;  // namespace android</span><br></pre></td></tr></table></figure>
<h3 id="3-4-LegacyCameraProviderImpl-2-4初始化"><a href="#3-4-LegacyCameraProviderImpl-2-4初始化" class="headerlink" title="3.4 LegacyCameraProviderImpl_2_4初始化"></a>3.4 LegacyCameraProviderImpl_2_4初始化</h3><p>其构造函数中通过hw_get_module标准方法获取HAL的camera_module_t结构体,并将其存入CameraModule对象中，之后通过调用该camera_modult_t结构体的init方法初始化HAL Module，紧接着调用其get_number_of_camera方法获取当前HAL支持的Camera数量，最后通过调用其set_callbacks方法将LegcyCameraProviderImpl_2_4（LegcyCameraProviderImpl_2_4继承了camera_modult_callback_t）作为参数传入CamX-CHI中，接受来自CamX-CHI中的数据以及事件，当这一系列动作完成了之后，Camera Provider进程便一直便存在于系统中，监听着来自Camera Service的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">LegacyCameraProviderImpl_2_4::LegacyCameraProviderImpl_2_4() :</span><br><span class="line">        camera_module_callbacks_t(&#123;sCameraDeviceStatusChange,</span><br><span class="line">                                   sTorchModeStatusChange&#125;) &#123;</span><br><span class="line">    mInitFailed = initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool LegacyCameraProviderImpl_2_4::initialize() &#123;</span><br><span class="line">    camera_module_t *rawModule;</span><br><span class="line">    int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">            (const hw_module_t **)&amp;rawModule);</span><br><span class="line">    if (err &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;Could not load camera HAL module: %d (%s)&quot;, err, strerror(-err));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mModule = new CameraModule(rawModule);</span><br><span class="line">    err = mModule-&gt;init();</span><br><span class="line">    if (err != OK) &#123;</span><br><span class="line">        ALOGE(&quot;Could not initialize camera HAL module: %d (%s)&quot;, err, strerror(-err));</span><br><span class="line">        mModule.clear();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(&quot;Loaded \&quot;%s\&quot; camera module&quot;, mModule-&gt;getModuleName());</span><br><span class="line"></span><br><span class="line">    // Setup vendor tags here so HAL can setup vendor keys in camera characteristics</span><br><span class="line">    VendorTagDescriptor::clearGlobalVendorTagDescriptor();</span><br><span class="line">    if (!setUpVendorTags()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Vendor tag setup failed, will not be available.&quot;, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Setup callback now because we are going to try openLegacy next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mPreferredHal3MinorVersion =</span><br><span class="line">        property_get_int32(&quot;ro.vendor.camera.wrapper.hal3TrebleMinorVersion&quot;, 3);</span><br><span class="line">    ALOGV(&quot;Preferred HAL 3 minor version is %d&quot;, mPreferredHal3MinorVersion);</span><br><span class="line">    switch(mPreferredHal3MinorVersion) &#123;</span><br><span class="line">        case 2:</span><br><span class="line">        case 3:</span><br><span class="line">            // OK</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            ALOGW(&quot;Unknown minor camera device HAL version %d in property &quot;</span><br><span class="line">                    &quot;&apos;camera.wrapper.hal3TrebleMinorVersion&apos;, defaulting to 3&quot;,</span><br><span class="line">                    mPreferredHal3MinorVersion);</span><br><span class="line">            mPreferredHal3MinorVersion = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras();</span><br><span class="line">    for (int i = 0; i &lt; mNumberOfLegacyCameras; i++) &#123;</span><br><span class="line">        uint32_t device_version;</span><br><span class="line">        auto rc = mModule-&gt;getCameraDeviceVersion(i, &amp;device_version);</span><br><span class="line">        if (rc != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Camera device version query failed!&quot;, __func__);</span><br><span class="line">            mModule.clear();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (checkCameraVersion(i, device_version) != OK) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Camera version check failed!&quot;, __func__);</span><br><span class="line">            mModule.clear();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char cameraId[kMaxCameraIdLen];</span><br><span class="line">        snprintf(cameraId, sizeof(cameraId), &quot;%d&quot;, i);</span><br><span class="line">        std::string cameraIdStr(cameraId);</span><br><span class="line">        mCameraStatusMap[cameraIdStr] = CAMERA_DEVICE_STATUS_PRESENT;</span><br><span class="line">        addDeviceNames(i);</span><br><span class="line">    &#125;</span><br><span class="line">    err = mModule-&gt;setCallbacks(this);</span><br><span class="line">    if (err != OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGE(&quot;Could not set camera module callback: %d (%s)&quot;, err, strerror(-err));</span><br><span class="line">        mModule.clear();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; // mInitFailed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-获取CameraDevice"><a href="#3-5-获取CameraDevice" class="headerlink" title="3.5 获取CameraDevice"></a>3.5 获取CameraDevice</h3><p>在深入理解Android Camera架构二中3.1.7.2获取ICameraDevice的接口</p>
<h4 id="3-5-1-getCameraDeviceInterface-V3-x"><a href="#3-5-1-getCameraDeviceInterface-V3-x" class="headerlink" title="3.5.1 getCameraDeviceInterface_V3_x"></a>3.5.1 getCameraDeviceInterface_V3_x</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> const sp&lt;provider::V2_4::ICameraProvider&gt; interface = startProviderInterface();</span><br><span class="line">   if (interface == nullptr) &#123;</span><br><span class="line">       return nullptr;</span><br><span class="line">   &#125;</span><br><span class="line">//获取Provider端的ICameraDevice代理</span><br><span class="line">   ret = interface-&gt;getCameraDeviceInterface_V3_x(name, [&amp;status, &amp;cameraInterface](</span><br><span class="line">       Status s, sp&lt;device::V3_2::ICameraDevice&gt; interface) &#123;</span><br><span class="line">               status = s;</span><br><span class="line">               cameraInterface = interface;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-new-CameraDevice"><a href="#3-5-2-new-CameraDevice" class="headerlink" title="3.5.2 new CameraDevice"></a>3.5.2 new CameraDevice</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">Return&lt;void&gt; LegacyCameraProviderImpl_2_4::getCameraDeviceInterface_V3_x(</span><br><span class="line">        const hidl_string&amp; cameraDeviceName,</span><br><span class="line">        ICameraProvider::getCameraDeviceInterface_V3_x_cb _hidl_cb)  &#123;</span><br><span class="line">    std::string cameraId, deviceVersion;</span><br><span class="line">    bool match = matchDeviceName(cameraDeviceName, &amp;deviceVersion, &amp;cameraId);</span><br><span class="line">    if (!match) &#123;</span><br><span class="line">        _hidl_cb(Status::ILLEGAL_ARGUMENT, nullptr);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string deviceName(cameraDeviceName.c_str());</span><br><span class="line">    ssize_t index = mCameraDeviceNames.indexOf(std::make_pair(cameraId, deviceName));</span><br><span class="line">    if (index == NAME_NOT_FOUND) &#123; // Either an illegal name or a device version mismatch</span><br><span class="line">        Status status = Status::OK;</span><br><span class="line">        ssize_t idx = mCameraIds.indexOf(cameraId);</span><br><span class="line">        if (idx == NAME_NOT_FOUND) &#123;</span><br><span class="line">            ALOGE(&quot;%s: cannot find camera %s!&quot;, __FUNCTION__, cameraId.c_str());</span><br><span class="line">            status = Status::ILLEGAL_ARGUMENT;</span><br><span class="line">        &#125; else &#123; // invalid version</span><br><span class="line">            ALOGE(&quot;%s: camera device %s does not support version %s!&quot;,</span><br><span class="line">                    __FUNCTION__, cameraId.c_str(), deviceVersion.c_str());</span><br><span class="line">            status = Status::OPERATION_NOT_SUPPORTED;</span><br><span class="line">        &#125;</span><br><span class="line">        _hidl_cb(status, nullptr);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mCameraStatusMap.count(cameraId) == 0 ||</span><br><span class="line">            mCameraStatusMap[cameraId] != CAMERA_DEVICE_STATUS_PRESENT) &#123;</span><br><span class="line">        _hidl_cb(Status::ILLEGAL_ARGUMENT, nullptr);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;android::hardware::camera::device::V3_2::implementation::CameraDevice&gt; deviceImpl;</span><br><span class="line"></span><br><span class="line">    // ICameraDevice 3.4 or upper</span><br><span class="line">    if (deviceVersion &gt;= kHAL3_4) &#123;</span><br><span class="line">        ALOGV(&quot;Constructing v3.4+ camera device&quot;);</span><br><span class="line">        if (deviceVersion == kHAL3_4) &#123;</span><br><span class="line">            deviceImpl = new android::hardware::camera::device::V3_4::implementation::CameraDevice(</span><br><span class="line">                    mModule, cameraId, mCameraDeviceNames);</span><br><span class="line">        &#125; else if (deviceVersion == kHAL3_5) &#123;</span><br><span class="line">            deviceImpl = new android::hardware::camera::device::V3_5::implementation::CameraDevice(</span><br><span class="line">                    mModule, cameraId, mCameraDeviceNames);</span><br><span class="line">        &#125;</span><br><span class="line">        if (deviceImpl == nullptr || deviceImpl-&gt;isInitFailed()) &#123;</span><br><span class="line">            ALOGE(&quot;%s: camera device %s init failed!&quot;, __FUNCTION__, cameraId.c_str());</span><br><span class="line">            _hidl_cb(Status::INTERNAL_ERROR, nullptr);</span><br><span class="line">            return Void();</span><br><span class="line">        &#125;</span><br><span class="line">        IF_ALOGV() &#123;</span><br><span class="line">            deviceImpl-&gt;getInterface()-&gt;interfaceChain([](</span><br><span class="line">                ::android::hardware::hidl_vec&lt;::android::hardware::hidl_string&gt; interfaceChain) &#123;</span><br><span class="line">                    ALOGV(&quot;Device interface chain:&quot;);</span><br><span class="line">                    for (auto iface : interfaceChain) &#123;</span><br><span class="line">                        ALOGV(&quot;  %s&quot;, iface.c_str());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        _hidl_cb (Status::OK, deviceImpl-&gt;getInterface());</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ICameraDevice 3.2 and 3.3</span><br><span class="line">    // Since some Treble HAL revisions can map to the same legacy HAL version(s), we default</span><br><span class="line">    // to the newest possible Treble HAL revision, but allow for override if needed via</span><br><span class="line">    // system property.</span><br><span class="line">    switch (mPreferredHal3MinorVersion) &#123;</span><br><span class="line">        case 2: &#123; // Map legacy camera device v3 HAL to Treble camera device HAL v3.2</span><br><span class="line">            ALOGV(&quot;Constructing v3.2 camera device&quot;);</span><br><span class="line">            deviceImpl = new android::hardware::camera::device::V3_2::implementation::CameraDevice(</span><br><span class="line">                    mModule, cameraId, mCameraDeviceNames);</span><br><span class="line">            if (deviceImpl == nullptr || deviceImpl-&gt;isInitFailed()) &#123;</span><br><span class="line">                ALOGE(&quot;%s: camera device %s init failed!&quot;, __FUNCTION__, cameraId.c_str());</span><br><span class="line">                _hidl_cb(Status::INTERNAL_ERROR, nullptr);</span><br><span class="line">                return Void();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 3: &#123; // Map legacy camera device v3 HAL to Treble camera device HAL v3.3</span><br><span class="line">            ALOGV(&quot;Constructing v3.3 camera device&quot;);</span><br><span class="line">            deviceImpl = new android::hardware::camera::device::V3_3::implementation::CameraDevice(</span><br><span class="line">                    mModule, cameraId, mCameraDeviceNames);</span><br><span class="line">            if (deviceImpl == nullptr || deviceImpl-&gt;isInitFailed()) &#123;</span><br><span class="line">                ALOGE(&quot;%s: camera device %s init failed!&quot;, __FUNCTION__, cameraId.c_str());</span><br><span class="line">                _hidl_cb(Status::INTERNAL_ERROR, nullptr);</span><br><span class="line">                return Void();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            ALOGE(&quot;%s: Unknown HAL minor version %d!&quot;, __FUNCTION__, mPreferredHal3MinorVersion);</span><br><span class="line">            _hidl_cb(Status::INTERNAL_ERROR, nullptr);</span><br><span class="line">            return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_cb (Status::OK, deviceImpl-&gt;getInterface());</span><br><span class="line">    return Void();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-3-deviceImpl-gt-getInterface"><a href="#3-5-3-deviceImpl-gt-getInterface" class="headerlink" title="3.5.3 deviceImpl-&gt;getInterface"></a>3.5.3 deviceImpl-&gt;getInterface</h4><p>[-&gt;hardware\interfaces\camera\device\3.2]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CameraDevice::CameraDevice(</span><br><span class="line">    sp&lt;CameraModule&gt; module, const std::string&amp; cameraId,</span><br><span class="line">    const SortedVector&lt;std::pair&lt;std::string, std::string&gt;&gt;&amp; cameraDeviceNames) :</span><br><span class="line">        mModule(module),</span><br><span class="line">        mCameraId(cameraId),</span><br><span class="line">        mDisconnected(false),</span><br><span class="line">        mCameraDeviceNames(cameraDeviceNames) &#123;</span><br><span class="line">    mCameraIdInt = atoi(mCameraId.c_str());</span><br><span class="line">    // Should not reach here as provider also validate ID</span><br><span class="line">    if (mCameraIdInt &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Invalid camera id: %s&quot;, __FUNCTION__, mCameraId.c_str());</span><br><span class="line">        mInitFail = true;</span><br><span class="line">    &#125; else if (mCameraIdInt &gt;= mModule-&gt;getNumberOfCameras()) &#123;</span><br><span class="line">        ALOGI(&quot;%s: Adding a new camera id: %s&quot;, __FUNCTION__, mCameraId.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDeviceVersion = mModule-&gt;getDeviceVersion(mCameraIdInt);</span><br><span class="line">    if (mDeviceVersion &lt; CAMERA_DEVICE_API_VERSION_3_2) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Camera id %s does not support HAL3.2+&quot;,</span><br><span class="line">                __FUNCTION__, mCameraId.c_str());</span><br><span class="line">        mInitFail = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual sp&lt;ICameraDevice&gt; getInterface() &#123;</span><br><span class="line">        return new TrampolineDeviceInterface_3_2(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">struct TrampolineDeviceInterface_3_2 : public ICameraDevice &#123;</span><br><span class="line">        TrampolineDeviceInterface_3_2(sp&lt;CameraDevice&gt; parent) :</span><br><span class="line">            mParent(parent) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        virtual Return&lt;void&gt; getResourceCost(V3_2::ICameraDevice::getResourceCost_cb _hidl_cb)</span><br><span class="line">                override &#123;</span><br><span class="line">            return mParent-&gt;getResourceCost(_hidl_cb);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-open"><a href="#3-6-open" class="headerlink" title="3.6 open"></a>3.6 open</h3><p>在深入理解Android Camera架构二中3.2.2.4中调用provider的open方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto interface = deviceInfo3-&gt;startDeviceInterface&lt;</span><br><span class="line">            CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT&gt;();</span><br><span class="line">    if (interface == nullptr) &#123;</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = interface-&gt;open(callback, [&amp;status, &amp;session]</span><br><span class="line">            (Status s, const sp&lt;device::V3_2::ICameraDeviceSession&gt;&amp; cameraSession) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                if (status == Status::OK) &#123;</span><br><span class="line">                    *session = cameraSession;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="3-6-1-CameraDevice-open"><a href="#3-6-1-CameraDevice-open" class="headerlink" title="3.6.1 CameraDevice::open"></a>3.6.1 CameraDevice::open</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Return&lt;void&gt; CameraDevice::open(const sp&lt;ICameraDeviceCallback&gt;&amp; callback,</span><br><span class="line">        ICameraDevice::open_cb _hidl_cb)  &#123;</span><br><span class="line">    Status status = initStatus();</span><br><span class="line">    sp&lt;CameraDeviceSession&gt; session = nullptr;</span><br><span class="line"></span><br><span class="line">    if (callback == nullptr) &#123;</span><br><span class="line">        ALOGE(&quot;%s: cannot open camera %s. callback is null!&quot;,</span><br><span class="line">                __FUNCTION__, mCameraId.c_str());</span><br><span class="line">        _hidl_cb(Status::ILLEGAL_ARGUMENT, nullptr);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (status != Status::OK) &#123;</span><br><span class="line">        // Provider will never pass initFailed device to client, so</span><br><span class="line">        // this must be a disconnected camera</span><br><span class="line">        ALOGE(&quot;%s: cannot open camera %s. camera is disconnected!&quot;,</span><br><span class="line">                __FUNCTION__, mCameraId.c_str());</span><br><span class="line">        _hidl_cb(Status::CAMERA_DISCONNECTED, nullptr);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        ALOGV(&quot;%s: Initializing device for camera %d&quot;, __FUNCTION__, mCameraIdInt);</span><br><span class="line">        session = mSession.promote();</span><br><span class="line">        if (session != nullptr &amp;&amp; !session-&gt;isClosed()) &#123;</span><br><span class="line">            ALOGE(&quot;%s: cannot open an already opened camera!&quot;, __FUNCTION__);</span><br><span class="line">            mLock.unlock();</span><br><span class="line">            _hidl_cb(Status::CAMERA_IN_USE, nullptr);</span><br><span class="line">            return Void();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** Open HAL device */</span><br><span class="line">        status_t res;</span><br><span class="line">        camera3_device_t *device;</span><br><span class="line"></span><br><span class="line">        ATRACE_BEGIN(&quot;camera3-&gt;open&quot;);</span><br><span class="line">        res = mModule-&gt;open(mCameraId.c_str(),</span><br><span class="line">                reinterpret_cast&lt;hw_device_t**&gt;(&amp;device));</span><br><span class="line">        ATRACE_END();</span><br><span class="line"></span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            ALOGE(&quot;%s: cannot open camera %s!&quot;, __FUNCTION__, mCameraId.c_str());</span><br><span class="line">            mLock.unlock();</span><br><span class="line">            _hidl_cb(getHidlStatus(res), nullptr);</span><br><span class="line">            return Void();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** Cross-check device version */</span><br><span class="line">        if (device-&gt;common.version &lt; CAMERA_DEVICE_API_VERSION_3_2) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Could not open camera: &quot;</span><br><span class="line">                    &quot;Camera device should be at least %x, reports %x instead&quot;,</span><br><span class="line">                    __FUNCTION__,</span><br><span class="line">                    CAMERA_DEVICE_API_VERSION_3_2,</span><br><span class="line">                    device-&gt;common.version);</span><br><span class="line">            device-&gt;common.close(&amp;device-&gt;common);</span><br><span class="line">            mLock.unlock();</span><br><span class="line">            _hidl_cb(Status::ILLEGAL_ARGUMENT, nullptr);</span><br><span class="line">            return Void();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        struct camera_info info;</span><br><span class="line">        res = mModule-&gt;getCameraInfo(mCameraIdInt, &amp;info);</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Could not open camera: getCameraInfo failed&quot;, __FUNCTION__);</span><br><span class="line">            device-&gt;common.close(&amp;device-&gt;common);</span><br><span class="line">            mLock.unlock();</span><br><span class="line">            _hidl_cb(Status::ILLEGAL_ARGUMENT, nullptr);</span><br><span class="line">            return Void();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session = createSession(</span><br><span class="line">                device, info.static_camera_characteristics, callback);</span><br><span class="line">        if (session == nullptr) &#123;</span><br><span class="line">            ALOGE(&quot;%s: camera device session allocation failed&quot;, __FUNCTION__);</span><br><span class="line">            mLock.unlock();</span><br><span class="line">            _hidl_cb(Status::INTERNAL_ERROR, nullptr);</span><br><span class="line">            return Void();</span><br><span class="line">        &#125;</span><br><span class="line">        if (session-&gt;isInitFailed()) &#123;</span><br><span class="line">            ALOGE(&quot;%s: camera device session init failed&quot;, __FUNCTION__);</span><br><span class="line">            session = nullptr;</span><br><span class="line">            mLock.unlock();</span><br><span class="line">            _hidl_cb(Status::INTERNAL_ERROR, nullptr);</span><br><span class="line">            return Void();</span><br><span class="line">        &#125;</span><br><span class="line">        mSession = session;</span><br><span class="line"></span><br><span class="line">        IF_ALOGV() &#123;</span><br><span class="line">            session-&gt;getInterface()-&gt;interfaceChain([](</span><br><span class="line">                ::android::hardware::hidl_vec&lt;::android::hardware::hidl_string&gt; interfaceChain) &#123;</span><br><span class="line">                    ALOGV(&quot;Session interface chain:&quot;);</span><br><span class="line">                    for (const auto&amp; iface : interfaceChain) &#123;</span><br><span class="line">                        ALOGV(&quot;  %s&quot;, iface.c_str());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    _hidl_cb(status, session-&gt;getInterface());</span><br><span class="line">    return Void();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-2-createSession"><a href="#3-6-2-createSession" class="headerlink" title="3.6.2 createSession"></a>3.6.2 createSession</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;CameraDeviceSession&gt; CameraDevice::createSession(camera3_device_t* device,</span><br><span class="line">        const camera_metadata_t* deviceInfo,</span><br><span class="line">        const sp&lt;ICameraDeviceCallback&gt;&amp; callback) &#123;</span><br><span class="line">    return new CameraDeviceSession(device, deviceInfo, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-3-new-CameraDeviceSession"><a href="#3-6-3-new-CameraDeviceSession" class="headerlink" title="3.6.3 new CameraDeviceSession"></a>3.6.3 new CameraDeviceSession</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">struct CameraDeviceSession : public virtual RefBase, protected camera3_callback_ops  &#123;</span><br><span class="line"></span><br><span class="line">    CameraDeviceSession(camera3_device_t*,</span><br><span class="line">                        const camera_metadata_t* deviceInfo,</span><br><span class="line">                        const sp&lt;ICameraDeviceCallback&gt;&amp;);</span><br><span class="line">    virtual ~CameraDeviceSession();</span><br><span class="line">    // Call by CameraDevice to dump active device states</span><br><span class="line">    void dumpState(const native_handle_t* fd);</span><br><span class="line">    // Caller must use this method to check if CameraDeviceSession ctor failed</span><br><span class="line">    bool isInitFailed() &#123; return mInitFail; &#125;</span><br><span class="line">    // Used by CameraDevice to signal external camera disconnected</span><br><span class="line">    void disconnect();</span><br><span class="line">    bool isClosed();</span><br><span class="line"></span><br><span class="line">    // Retrieve the HIDL interface, split into its own class to avoid inheritance issues when</span><br><span class="line">    // dealing with minor version revs and simultaneous implementation and interface inheritance</span><br><span class="line">    virtual sp&lt;ICameraDeviceSession&gt; getInterface() &#123;</span><br><span class="line">        return new TrampolineSessionInterface_3_2(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CameraDeviceSession::CameraDeviceSession(</span><br><span class="line">    camera3_device_t* device,</span><br><span class="line">    const camera_metadata_t* deviceInfo,</span><br><span class="line">    const sp&lt;ICameraDeviceCallback&gt;&amp; callback) :</span><br><span class="line">        camera3_callback_ops(&#123;&amp;sProcessCaptureResult, &amp;sNotify, nullptr, nullptr&#125;),</span><br><span class="line">        mDevice(device),</span><br><span class="line">        mDeviceVersion(device-&gt;common.version),</span><br><span class="line">        mFreeBufEarly(shouldFreeBufEarly()),</span><br><span class="line">        mIsAELockAvailable(false),</span><br><span class="line">        mDerivePostRawSensKey(false),</span><br><span class="line">        mNumPartialResults(1),</span><br><span class="line">        mResultBatcher(callback) &#123;</span><br><span class="line">    mDeviceInfo = deviceInfo;</span><br><span class="line">    camera_metadata_entry partialResultsCount =</span><br><span class="line">            mDeviceInfo.find(ANDROID_REQUEST_PARTIAL_RESULT_COUNT);</span><br><span class="line">    if (partialResultsCount.count &gt; 0) &#123;</span><br><span class="line">        mNumPartialResults = partialResultsCount.data.i32[0];</span><br><span class="line">    &#125;</span><br><span class="line">    mResultBatcher.setNumPartialResults(mNumPartialResults);</span><br><span class="line"></span><br><span class="line">    camera_metadata_entry aeLockAvailableEntry = mDeviceInfo.find(</span><br><span class="line">            ANDROID_CONTROL_AE_LOCK_AVAILABLE);</span><br><span class="line">    if (aeLockAvailableEntry.count &gt; 0) &#123;</span><br><span class="line">        mIsAELockAvailable = (aeLockAvailableEntry.data.u8[0] ==</span><br><span class="line">                ANDROID_CONTROL_AE_LOCK_AVAILABLE_TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Determine whether we need to derive sensitivity boost values for older devices.</span><br><span class="line">    // If post-RAW sensitivity boost range is listed, so should post-raw sensitivity control</span><br><span class="line">    // be listed (as the default value 100)</span><br><span class="line">    if (mDeviceInfo.exists(ANDROID_CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE)) &#123;</span><br><span class="line">        mDerivePostRawSensKey = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInitFail = initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-4-CameraDeviceSession-initialize"><a href="#3-6-4-CameraDeviceSession-initialize" class="headerlink" title="3.6.4 CameraDeviceSession::initialize"></a>3.6.4 CameraDeviceSession::initialize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">bool CameraDeviceSession::initialize() &#123;</span><br><span class="line">    /** Initialize device with callback functions */</span><br><span class="line">    ATRACE_BEGIN(&quot;camera3-&gt;initialize&quot;);</span><br><span class="line">    status_t res = mDevice-&gt;ops-&gt;initialize(mDevice, this);</span><br><span class="line">    ATRACE_END();</span><br><span class="line"></span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to initialize HAL device: %s (%d)&quot;,</span><br><span class="line">                __FUNCTION__, strerror(-res), res);</span><br><span class="line">        mDevice-&gt;common.close(&amp;mDevice-&gt;common);</span><br><span class="line">        mClosed = true;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // &quot;ro.camera&quot; properties are no longer supported on vendor side.</span><br><span class="line">    //  Support a fall back for the fmq size override that uses &quot;ro.vendor.camera&quot;</span><br><span class="line">    //  properties.</span><br><span class="line">    int32_t reqFMQSize = property_get_int32(&quot;ro.vendor.camera.req.fmq.size&quot;, /*default*/-1);</span><br><span class="line">    if (reqFMQSize &lt; 0) &#123;</span><br><span class="line">        reqFMQSize = property_get_int32(&quot;ro.camera.req.fmq.size&quot;, /*default*/-1);</span><br><span class="line">        if (reqFMQSize &lt; 0) &#123;</span><br><span class="line">            reqFMQSize = CAMERA_REQUEST_METADATA_QUEUE_SIZE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGV(&quot;%s: request FMQ size overridden to %d&quot;, __FUNCTION__, reqFMQSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGV(&quot;%s: request FMQ size overridden to %d via fallback property&quot;, __FUNCTION__,</span><br><span class="line">                reqFMQSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRequestMetadataQueue = std::make_unique&lt;RequestMetadataQueue&gt;(</span><br><span class="line">            static_cast&lt;size_t&gt;(reqFMQSize),</span><br><span class="line">            false /* non blocking */);</span><br><span class="line">    if (!mRequestMetadataQueue-&gt;isValid()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: invalid request fmq&quot;, __FUNCTION__);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // &quot;ro.camera&quot; properties are no longer supported on vendor side.</span><br><span class="line">    //  Support a fall back for the fmq size override that uses &quot;ro.vendor.camera&quot;</span><br><span class="line">    //  properties.</span><br><span class="line">    int32_t resFMQSize = property_get_int32(&quot;ro.vendor.camera.res.fmq.size&quot;, /*default*/-1);</span><br><span class="line">    if (resFMQSize &lt; 0) &#123;</span><br><span class="line">        resFMQSize = property_get_int32(&quot;ro.camera.res.fmq.size&quot;, /*default*/-1);</span><br><span class="line">        if (resFMQSize &lt; 0) &#123;</span><br><span class="line">            resFMQSize = CAMERA_RESULT_METADATA_QUEUE_SIZE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGV(&quot;%s: result FMQ size overridden to %d&quot;, __FUNCTION__, resFMQSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGV(&quot;%s: result FMQ size overridden to %d via fallback property&quot;, __FUNCTION__,</span><br><span class="line">                resFMQSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mResultMetadataQueue = std::make_shared&lt;RequestMetadataQueue&gt;(</span><br><span class="line">            static_cast&lt;size_t&gt;(resFMQSize),</span><br><span class="line">            false /* non blocking */);</span><br><span class="line">    if (!mResultMetadataQueue-&gt;isValid()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: invalid result fmq&quot;, __FUNCTION__);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    mResultBatcher.setResultMetadataQueue(mResultMetadataQueue);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-configureStreams"><a href="#3-7-configureStreams" class="headerlink" title="3.7 configureStreams"></a>3.7 configureStreams</h3><p>Camera3Device通过接口最终调用CameraDeviceSession中的configureStreams方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtual Return&lt;void&gt; configureStreams(</span><br><span class="line">               const V3_2::StreamConfiguration&amp; requestedConfiguration,</span><br><span class="line">               V3_2::ICameraDeviceSession::configureStreams_cb _hidl_cb) override &#123;</span><br><span class="line">           return mParent-&gt;configureStreams(requestedConfiguration, _hidl_cb);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-7-1-TrampolineSessionInterface-3-2-configureStreams"><a href="#3-7-1-TrampolineSessionInterface-3-2-configureStreams" class="headerlink" title="3.7.1 TrampolineSessionInterface_3_2::configureStreams"></a>3.7.1 TrampolineSessionInterface_3_2::configureStreams</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> struct TrampolineSessionInterface_3_2 : public ICameraDeviceSession &#123;</span><br><span class="line">        TrampolineSessionInterface_3_2(sp&lt;CameraDeviceSession&gt; parent) :</span><br><span class="line">                mParent(parent) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        virtual Return&lt;void&gt; constructDefaultRequestSettings(</span><br><span class="line">                V3_2::RequestTemplate type,</span><br><span class="line">                V3_2::ICameraDeviceSession::constructDefaultRequestSettings_cb _hidl_cb) override &#123;</span><br><span class="line">            return mParent-&gt;constructDefaultRequestSettings(type, _hidl_cb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtual Return&lt;void&gt; configureStreams(</span><br><span class="line">                const V3_2::StreamConfiguration&amp; requestedConfiguration,</span><br><span class="line">                V3_2::ICameraDeviceSession::configureStreams_cb _hidl_cb) override &#123;</span><br><span class="line">            return mParent-&gt;configureStreams(requestedConfiguration, _hidl_cb);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-7-2-CameraDeviceSession-configureStreams"><a href="#3-7-2-CameraDeviceSession-configureStreams" class="headerlink" title="3.7.2 CameraDeviceSession::configureStreams"></a>3.7.2 CameraDeviceSession::configureStreams</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Return&lt;void&gt; CameraDeviceSession::configureStreams(</span><br><span class="line">        const StreamConfiguration&amp; requestedConfiguration,</span><br><span class="line">        ICameraDeviceSession::configureStreams_cb _hidl_cb)  &#123;</span><br><span class="line">    Status status = initStatus();</span><br><span class="line">    HalStreamConfiguration outStreams;</span><br><span class="line"></span><br><span class="line">    // hold the inflight lock for entire configureStreams scope since there must not be any</span><br><span class="line">    // inflight request/results during stream configuration.</span><br><span class="line">    Mutex::Autolock _l(mInflightLock);</span><br><span class="line">    if (!mInflightBuffers.empty()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: trying to configureStreams while there are still %zu inflight buffers!&quot;,</span><br><span class="line">                __FUNCTION__, mInflightBuffers.size());</span><br><span class="line">        _hidl_cb(Status::INTERNAL_ERROR, outStreams);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!mInflightAETriggerOverrides.empty()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: trying to configureStreams while there are still %zu inflight&quot;</span><br><span class="line">                &quot; trigger overrides!&quot;, __FUNCTION__,</span><br><span class="line">                mInflightAETriggerOverrides.size());</span><br><span class="line">        _hidl_cb(Status::INTERNAL_ERROR, outStreams);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!mInflightRawBoostPresent.empty()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: trying to configureStreams while there are still %zu inflight&quot;</span><br><span class="line">                &quot; boost overrides!&quot;, __FUNCTION__,</span><br><span class="line">                mInflightRawBoostPresent.size());</span><br><span class="line">        _hidl_cb(Status::INTERNAL_ERROR, outStreams);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (status != Status::OK) &#123;</span><br><span class="line">        _hidl_cb(status, outStreams);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    camera3_stream_configuration_t stream_list&#123;&#125;;</span><br><span class="line">    hidl_vec&lt;camera3_stream_t*&gt; streams;</span><br><span class="line">    if (!preProcessConfigurationLocked(requestedConfiguration, &amp;stream_list, &amp;streams)) &#123;</span><br><span class="line">        _hidl_cb(Status::INTERNAL_ERROR, outStreams);</span><br><span class="line">        return Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ATRACE_BEGIN(&quot;camera3-&gt;configure_streams&quot;);</span><br><span class="line">    status_t ret = mDevice-&gt;ops-&gt;configure_streams(mDevice, &amp;stream_list);</span><br><span class="line">    ATRACE_END();</span><br><span class="line"></span><br><span class="line">    // In case Hal returns error most likely it was not able to release</span><br><span class="line">    // the corresponding resources of the deleted streams.</span><br><span class="line">    if (ret == OK) &#123;</span><br><span class="line">        postProcessConfigurationLocked(requestedConfiguration);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        postProcessConfigurationFailureLocked(requestedConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ret == -EINVAL) &#123;</span><br><span class="line">        status = Status::ILLEGAL_ARGUMENT;</span><br><span class="line">    &#125; else if (ret != OK) &#123;</span><br><span class="line">        status = Status::INTERNAL_ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        convertToHidl(stream_list, &amp;outStreams);</span><br><span class="line">        mFirstRequest = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_cb(status, outStreams);</span><br><span class="line">    return Void();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他processCaptureRequest流程和上面一样</p>
<h3 id="3-8-总结"><a href="#3-8-总结" class="headerlink" title="3.8 总结"></a>3.8 总结</h3><p>在系统初始化的时候，系统会去运行<a href="mailto:android.hardware.camera.provider@2.4-servic" target="_blank" rel="noopener">android.hardware.camera.provider@2.4-servic</a>e_64程序启动Provider进程，并加入HW Service Manager中接受统一管理，在该过程中实例化了一个LegacyCameraProviderImpl_2_4对象，并在其构造函数中通过hw_get_module标准方法获取HAL的camera_module_t结构体,并将其存入CameraModule对象中，之后通过调用该camera_modult_t结构体的init方法初始化HAL Module，紧接着调用其get_number_of_camera方法获取当前HAL支持的Camera数量，最后通过调用其set_callbacks方法将LegcyCameraProviderImpl_2_4（LegcyCameraProviderImpl_2_4继承了camera_modult_callback_t）作为参数传入CamX-CHI中，接受来自CamX-CHI中的数据以及事件，当这一系列动作完成了之后，Camera Provider进程便一直便存在于系统中，监听着来自Camera Service的调用。</p>
<p><img src="/2024/深入理解Android Camera架构三-硬件抽象层/vb2\commit\b\深入理解Android Camera架构三-硬件抽象层\cameraproviderflow.png"></p>
<p>接下来以上图为例简单介绍下Provider中几个重要流程：</p>
<ul>
<li>Camera Service通过调用ICameraProvider的getCameraDeviceInterface_v3_x接口获取ICameraDevice，在此过程中，Provider会去实例化一个CameraDevice对象，并且将之前存有camera_modult_t结构体的CameraModule对象传入CameraDevice中，这样就可以在CameraDevice内部通过CameraModule访问到camera_module_t的相关资源，然后将CameraDevice内部类TrampolineDeviceInterface_3_2（该类继承并实现了ICameraDevice接口）返回给Camera Service。</li>
<li>Camera Service通过之前获取的ICameraDevice，调用其open方法来打开Camera设备，接着在Provider中会去调用CameraDevice对象的open方法，在该方法内部会去调用camera_module_t结构体的open方法，从而获取到HAL部分的camera3_device_t结构体，紧接着Provider会实例化一个CameraDeviceSession对象，并且将刚才获取到的camera3_device_t结构体以参数的方式传入CameraDeviceSession中，在CameraDeviceSession的构造方法中又会调用CameraDeviceSession的initialize方法，在该方法内部又会去调用camera3_device_t结构体的ops内的initialize方法开始HAL部分的初始化工作，最后CameraDeviceSession对象被作为camera3_callback_ops的实现传入HAL，接收来自HAL的数据或者具体事件，当一切动作都完成后，Provider会将CameraDeviceSession::TrampolineSessionInterface_3_2（该类继承并实现了ICameraDeviceSession接口）对象通过HIDL回调的方法返回给Camera Service中。</li>
<li>Camera Service通过调用ICameraDevcieSession的configureStreams_3_5接口进行数据流的配置，在Provider中，最终会通过调用之前获取的camera3_device_t结构体内ops的configure_streams方法下发到HAL中进行处理。</li>
<li>Camera Service通过调用ICameraDevcieSession的processCaptureRequest_3_4接口下发request请求到Provider中，在Provider中，最终依然会通过调用获取的camera3_device_t结构体内ops中的process_capture_request方法将此次请求下发到HAL中进行处理。</li>
</ul>
<p>从整个流程不难看出，这几个接口最终对应的是HAL3的接口，并且Provider并没有经过太多复杂的额外的处理。</p>
<h2 id="四、Camera-HAL3接口"><a href="#四、Camera-HAL3接口" class="headerlink" title="四、Camera HAL3接口"></a>四、Camera HAL3接口</h2><p>HAL硬件抽象层(Hardware Abstraction Layer)，是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层， 每一个平台厂商可以将不开源的代码封装在这一层，仅仅提供二进制文件。</p>
<p>该层定义了自己的一套通用标准接口，平台厂商务必按照以下规则定义自己的Module:</p>
<p>每一个硬件模块都通过hw_module_t来描述，具有固定的名字HMI</p>
<p>每一个硬件模块都必须实现hw_module_t里面的open方法，用于打开硬件设备，并返回对应的操作接口集合</p>
<p>硬件的操作接口集合使用hw_device_t 来描述，并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合</p>
<p>其中代表硬件模块的是hw_module_t，对应的设备是通过hw_device_t来描述，这两者的定义如下：</p>
<p>[-&gt;hardware\libhardware\include\hardware\hardware.h]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright (C) 2008 The Android Open Source Project</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef ANDROID_INCLUDE_HARDWARE_HARDWARE_H</span><br><span class="line">#define ANDROID_INCLUDE_HARDWARE_HARDWARE_H</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;sys/cdefs.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;cutils/native_handle.h&gt;</span><br><span class="line">#include &lt;system/graphics.h&gt;</span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Value for the hw_module_t.tag field</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define MAKE_TAG_CONSTANT(A,B,C,D) (((A) &lt;&lt; 24) | ((B) &lt;&lt; 16) | ((C) &lt;&lt; 8) | (D))</span><br><span class="line"></span><br><span class="line">#define HARDWARE_MODULE_TAG MAKE_TAG_CONSTANT(&apos;H&apos;, &apos;W&apos;, &apos;M&apos;, &apos;T&apos;)</span><br><span class="line">#define HARDWARE_DEVICE_TAG MAKE_TAG_CONSTANT(&apos;H&apos;, &apos;W&apos;, &apos;D&apos;, &apos;T&apos;)</span><br><span class="line"></span><br><span class="line">#define HARDWARE_MAKE_API_VERSION(maj,min) \</span><br><span class="line">            ((((maj) &amp; 0xff) &lt;&lt; 8) | ((min) &amp; 0xff))</span><br><span class="line"></span><br><span class="line">#define HARDWARE_MAKE_API_VERSION_2(maj,min,hdr) \</span><br><span class="line">            ((((maj) &amp; 0xff) &lt;&lt; 24) | (((min) &amp; 0xff) &lt;&lt; 16) | ((hdr) &amp; 0xffff))</span><br><span class="line">#define HARDWARE_API_VERSION_2_MAJ_MIN_MASK 0xffff0000</span><br><span class="line">#define HARDWARE_API_VERSION_2_HEADER_MASK  0x0000ffff</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The current HAL API version.</span><br><span class="line"> *</span><br><span class="line"> * All module implementations must set the hw_module_t.hal_api_version field</span><br><span class="line"> * to this value when declaring the module with HAL_MODULE_INFO_SYM.</span><br><span class="line"> *</span><br><span class="line"> * Note that previous implementations have always set this field to 0.</span><br><span class="line"> * Therefore, libhardware HAL API will always consider versions 0.0 and 1.0</span><br><span class="line"> * to be 100% binary compatible.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">#define HARDWARE_HAL_API_VERSION HARDWARE_MAKE_API_VERSION(1, 0)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Helper macros for module implementors.</span><br><span class="line"> *</span><br><span class="line"> * The derived modules should provide convenience macros for supported</span><br><span class="line"> * versions so that implementations can explicitly specify module/device</span><br><span class="line"> * versions at definition time.</span><br><span class="line"> *</span><br><span class="line"> * Use this macro to set the hw_module_t.module_api_version field.</span><br><span class="line"> */</span><br><span class="line">#define HARDWARE_MODULE_API_VERSION(maj,min) HARDWARE_MAKE_API_VERSION(maj,min)</span><br><span class="line">#define HARDWARE_MODULE_API_VERSION_2(maj,min,hdr) HARDWARE_MAKE_API_VERSION_2(maj,min,hdr)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Use this macro to set the hw_device_t.version field</span><br><span class="line"> */</span><br><span class="line">#define HARDWARE_DEVICE_API_VERSION(maj,min) HARDWARE_MAKE_API_VERSION(maj,min)</span><br><span class="line">#define HARDWARE_DEVICE_API_VERSION_2(maj,min,hdr) HARDWARE_MAKE_API_VERSION_2(maj,min,hdr)</span><br><span class="line"></span><br><span class="line">struct hw_module_t;</span><br><span class="line">struct hw_module_methods_t;</span><br><span class="line">struct hw_device_t;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM</span><br><span class="line"> * and the fields of this data structure must begin with hw_module_t</span><br><span class="line"> * followed by module specific information.</span><br><span class="line"> */</span><br><span class="line">typedef struct hw_module_t &#123;</span><br><span class="line">    /** tag must be initialized to HARDWARE_MODULE_TAG */</span><br><span class="line">    uint32_t tag;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The API version of the implemented module. The module owner is</span><br><span class="line">     * responsible for updating the version when a module interface has</span><br><span class="line">     * changed.</span><br><span class="line">     *</span><br><span class="line">     * The derived modules such as gralloc and audio own and manage this field.</span><br><span class="line">     * The module user must interpret the version field to decide whether or</span><br><span class="line">     * not to inter-operate with the supplied module implementation.</span><br><span class="line">     * For example, SurfaceFlinger is responsible for making sure that</span><br><span class="line">     * it knows how to manage different versions of the gralloc-module API,</span><br><span class="line">     * and AudioFlinger must know how to do the same for audio-module API.</span><br><span class="line">     *</span><br><span class="line">     * The module API version should include a major and a minor component.</span><br><span class="line">     * For example, version 1.0 could be represented as 0x0100. This format</span><br><span class="line">     * implies that versions 0x0100-0x01ff are all API-compatible.</span><br><span class="line">     *</span><br><span class="line">     * In the future, libhardware will expose a hw_get_module_version()</span><br><span class="line">     * (or equivalent) function that will take minimum/maximum supported</span><br><span class="line">     * versions as arguments and would be able to reject modules with</span><br><span class="line">     * versions outside of the supplied range.</span><br><span class="line">     */</span><br><span class="line">    uint16_t module_api_version;</span><br><span class="line">#define version_major module_api_version</span><br><span class="line">    /**</span><br><span class="line">     * version_major/version_minor defines are supplied here for temporary</span><br><span class="line">     * source code compatibility. They will be removed in the next version.</span><br><span class="line">     * ALL clients must convert to the new version format.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The API version of the HAL module interface. This is meant to</span><br><span class="line">     * version the hw_module_t, hw_module_methods_t, and hw_device_t</span><br><span class="line">     * structures and definitions.</span><br><span class="line">     *</span><br><span class="line">     * The HAL interface owns this field. Module users/implementations</span><br><span class="line">     * must NOT rely on this value for version information.</span><br><span class="line">     *</span><br><span class="line">     * Presently, 0 is the only valid value.</span><br><span class="line">     */</span><br><span class="line">    uint16_t hal_api_version;</span><br><span class="line">#define version_minor hal_api_version</span><br><span class="line"></span><br><span class="line">    /** Identifier of module */</span><br><span class="line">    const char *id;</span><br><span class="line"></span><br><span class="line">    /** Name of this module */</span><br><span class="line">    const char *name;</span><br><span class="line"></span><br><span class="line">    /** Author/owner/implementor of the module */</span><br><span class="line">    const char *author;</span><br><span class="line"></span><br><span class="line">    /** Modules methods */</span><br><span class="line">    struct hw_module_methods_t* methods;</span><br><span class="line"></span><br><span class="line">    /** module&apos;s dso */</span><br><span class="line">    void* dso;</span><br><span class="line"></span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint64_t reserved[32-7];</span><br><span class="line">#else</span><br><span class="line">    /** padding to 128 bytes, reserved for future use */</span><br><span class="line">    uint32_t reserved[32-7];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; hw_module_t;</span><br><span class="line"></span><br><span class="line">typedef struct hw_module_methods_t &#123;</span><br><span class="line">    /** Open a specific device */</span><br><span class="line">    int (*open)(const struct hw_module_t* module, const char* id,</span><br><span class="line">            struct hw_device_t** device);</span><br><span class="line"></span><br><span class="line">&#125; hw_module_methods_t;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Every device data structure must begin with hw_device_t</span><br><span class="line"> * followed by module specific public methods and attributes.</span><br><span class="line"> */</span><br><span class="line">typedef struct hw_device_t &#123;</span><br><span class="line">    /** tag must be initialized to HARDWARE_DEVICE_TAG */</span><br><span class="line">    uint32_t tag;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Version of the module-specific device API. This value is used by</span><br><span class="line">     * the derived-module user to manage different device implementations.</span><br><span class="line">     *</span><br><span class="line">     * The module user is responsible for checking the module_api_version</span><br><span class="line">     * and device version fields to ensure that the user is capable of</span><br><span class="line">     * communicating with the specific module implementation.</span><br><span class="line">     *</span><br><span class="line">     * One module can support multiple devices with different versions. This</span><br><span class="line">     * can be useful when a device interface changes in an incompatible way</span><br><span class="line">     * but it is still necessary to support older implementations at the same</span><br><span class="line">     * time. One such example is the Camera 2.0 API.</span><br><span class="line">     *</span><br><span class="line">     * This field is interpreted by the module user and is ignored by the</span><br><span class="line">     * HAL interface itself.</span><br><span class="line">     */</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    /** reference to the module this device belongs to */</span><br><span class="line">    struct hw_module_t* module;</span><br><span class="line"></span><br><span class="line">    /** padding reserved for future use */</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint64_t reserved[12];</span><br><span class="line">#else</span><br><span class="line">    uint32_t reserved[12];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /** Close this device */</span><br><span class="line">    int (*close)(struct hw_device_t* device);</span><br><span class="line"></span><br><span class="line">&#125; hw_device_t;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">#define TO_HW_DEVICE_T_OPEN(x) reinterpret_cast&lt;struct hw_device_t**&gt;(x)</span><br><span class="line">#else</span><br><span class="line">#define TO_HW_DEVICE_T_OPEN(x) (struct hw_device_t**)(x)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Name of the hal_module_info</span><br><span class="line"> */</span><br><span class="line">#define HAL_MODULE_INFO_SYM         HMI</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Name of the hal_module_info as a string</span><br><span class="line"> */</span><br><span class="line">#define HAL_MODULE_INFO_SYM_AS_STR  &quot;HMI&quot;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get the module info associated with a module by id.</span><br><span class="line"> *</span><br><span class="line"> * @return: 0 == success, &lt;0 == error and *module == NULL</span><br><span class="line"> */</span><br><span class="line">int hw_get_module(const char *id, const struct hw_module_t **module);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get the module info associated with a module instance by class &apos;class_id&apos;</span><br><span class="line"> * and instance &apos;inst&apos;.</span><br><span class="line"> *</span><br><span class="line"> * Some modules types necessitate multiple instances. For example audio supports</span><br><span class="line"> * multiple concurrent interfaces and thus &apos;audio&apos; is the module class</span><br><span class="line"> * and &apos;primary&apos; or &apos;a2dp&apos; are module interfaces. This implies that the files</span><br><span class="line"> * providing these modules would be named audio.primary.&lt;variant&gt;.so and</span><br><span class="line"> * audio.a2dp.&lt;variant&gt;.so</span><br><span class="line"> *</span><br><span class="line"> * @return: 0 == success, &lt;0 == error and *module == NULL</span><br><span class="line"> */</span><br><span class="line">int hw_get_module_by_class(const char *class_id, const char *inst,</span><br><span class="line">                           const struct hw_module_t **module);</span><br><span class="line"></span><br><span class="line">__END_DECLS</span><br><span class="line"></span><br><span class="line">#endif  /* ANDROID_INCLUDE_HARDWARE_HARDWARE_H */</span><br></pre></td></tr></table></figure>
<p>从上面的定义可以看出，主要是通过hw_module_t 代表了模块，通过其open方法用来打开一个设备，而该设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外，并无其它方法，由此可见谷歌定义的HAL接口，并不能满足绝大部分HAL模块的需要，所以谷歌想出了一个比较好的解决方式，那便是将这两个基本结构嵌入到更大的结构体内部，同时在更大的结构内部定义了各自模块特有的方法，用于实现模块的功能，这样，一来对上保持了HAL的统一规范，二来也扩展了模块的功能。</p>
<p>基于上面的方式，谷歌便针对Camera 提出了HAL3接口，其中主要包括了用于代表一系列操作主体的结构体以及具体操作函数，接下来我们分别进行详细介绍：</p>
<p>HAL3中主要定义了camera_module_t/camera3_device_t/camera3_stream_configuration/camera3_stream以及camera3_stream_buffer几个主要结构体。</p>
<h3 id="4-1-camera-module-t"><a href="#4-1-camera-module-t" class="headerlink" title="4.1 camera_module_t"></a>4.1 camera_module_t</h3><p>[-&gt;/hardware/libhardware/include/hardware/camera_common.h]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br></pre></td><td class="code"><pre><span class="line">typedef struct camera_module &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Common methods of the camera module.  This *must* be the first member of</span><br><span class="line">     * camera_module as users of this structure will cast a hw_module_t to</span><br><span class="line">     * camera_module pointer in contexts where it&apos;s known the hw_module_t</span><br><span class="line">     * references a camera_module.</span><br><span class="line">     *</span><br><span class="line">     * The return values for common.methods-&gt;open for camera_module are:</span><br><span class="line">     *</span><br><span class="line">     * 0:           On a successful open of the camera device.</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV:     The camera device cannot be opened due to an internal</span><br><span class="line">     *              error.</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span><br><span class="line">     *              and/or the module is invalid.</span><br><span class="line">     *</span><br><span class="line">     * -EBUSY:      The camera device was already opened for this camera id</span><br><span class="line">     *              (by using this method or open_legacy),</span><br><span class="line">     *              regardless of the device HAL version it was opened as.</span><br><span class="line">     *</span><br><span class="line">     * -EUSERS:     The maximal number of camera devices that can be</span><br><span class="line">     *              opened concurrently were opened already, either by</span><br><span class="line">     *              this method or the open_legacy method.</span><br><span class="line">     *</span><br><span class="line">     * All other return values from common.methods-&gt;open will be treated as</span><br><span class="line">     * -ENODEV.</span><br><span class="line">     */</span><br><span class="line">    hw_module_t common;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get_number_of_cameras:</span><br><span class="line">     *</span><br><span class="line">     * Returns the number of camera devices accessible through the camera</span><br><span class="line">     * module.  The camera devices are numbered 0 through N-1, where N is the</span><br><span class="line">     * value returned by this call. The name of the camera device for open() is</span><br><span class="line">     * simply the number converted to a string. That is, &quot;0&quot; for camera ID 0,</span><br><span class="line">     * &quot;1&quot; for camera ID 1.</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_2_3 or lower:</span><br><span class="line">     *</span><br><span class="line">     *   The value here must be static, and cannot change after the first call</span><br><span class="line">     *   to this method.</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_2_4 or higher:</span><br><span class="line">     *</span><br><span class="line">     *   The value here must be static, and must count only built-in cameras,</span><br><span class="line">     *   which have CAMERA_FACING_BACK or CAMERA_FACING_FRONT camera facing values</span><br><span class="line">     *   (camera_info.facing). The HAL must not include the external cameras</span><br><span class="line">     *   (camera_info.facing == CAMERA_FACING_EXTERNAL) into the return value</span><br><span class="line">     *   of this call. Frameworks will use camera_device_status_change callback</span><br><span class="line">     *   to manage number of external cameras.</span><br><span class="line">     */</span><br><span class="line">    int (*get_number_of_cameras)(void);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get_camera_info:</span><br><span class="line">     *</span><br><span class="line">     * Return the static camera information for a given camera device. This</span><br><span class="line">     * information may not change for a camera device.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     * 0:           On a successful operation</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV:     The information cannot be provided due to an internal</span><br><span class="line">     *              error.</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span><br><span class="line">     *              and/or the module is invalid.</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_2_4 or higher:</span><br><span class="line">     *</span><br><span class="line">     *   When a camera is disconnected, its camera id becomes invalid. Calling this</span><br><span class="line">     *   this method with this invalid camera id will get -EINVAL and NULL camera</span><br><span class="line">     *   static metadata (camera_info.static_camera_characteristics).</span><br><span class="line">     */</span><br><span class="line">    int (*get_camera_info)(int camera_id, struct camera_info *info);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set_callbacks:</span><br><span class="line">     *</span><br><span class="line">     * Provide callback function pointers to the HAL module to inform framework</span><br><span class="line">     * of asynchronous camera module events. The framework will call this</span><br><span class="line">     * function once after initial camera HAL module load, after the</span><br><span class="line">     * get_number_of_cameras() method is called for the first time, and before</span><br><span class="line">     * any other calls to the module.</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     *  CAMERA_MODULE_API_VERSION_1_0, CAMERA_MODULE_API_VERSION_2_0:</span><br><span class="line">     *</span><br><span class="line">     *    Not provided by HAL module. Framework may not call this function.</span><br><span class="line">     *</span><br><span class="line">     *  CAMERA_MODULE_API_VERSION_2_1:</span><br><span class="line">     *</span><br><span class="line">     *    Valid to be called by the framework.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     * 0:           On a successful operation</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV:     The operation cannot be completed due to an internal</span><br><span class="line">     *              error.</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL:     The input arguments are invalid, i.e. the callbacks are</span><br><span class="line">     *              null</span><br><span class="line">     */</span><br><span class="line">    int (*set_callbacks)(const camera_module_callbacks_t *callbacks);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get_vendor_tag_ops:</span><br><span class="line">     *</span><br><span class="line">     * Get methods to query for vendor extension metadata tag information. The</span><br><span class="line">     * HAL should fill in all the vendor tag operation methods, or leave ops</span><br><span class="line">     * unchanged if no vendor tags are defined.</span><br><span class="line">     *</span><br><span class="line">     * The vendor_tag_ops structure used here is defined in:</span><br><span class="line">     * system/media/camera/include/system/vendor_tags.h</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     *  CAMERA_MODULE_API_VERSION_1_x/2_0/2_1:</span><br><span class="line">     *    Not provided by HAL module. Framework may not call this function.</span><br><span class="line">     *</span><br><span class="line">     *  CAMERA_MODULE_API_VERSION_2_2:</span><br><span class="line">     *    Valid to be called by the framework.</span><br><span class="line">     */</span><br><span class="line">    void (*get_vendor_tag_ops)(vendor_tag_ops_t* ops);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * open_legacy:</span><br><span class="line">     *</span><br><span class="line">     * Open a specific legacy camera HAL device if multiple device HAL API</span><br><span class="line">     * versions are supported by this camera HAL module. For example, if the</span><br><span class="line">     * camera module supports both CAMERA_DEVICE_API_VERSION_1_0 and</span><br><span class="line">     * CAMERA_DEVICE_API_VERSION_3_2 device API for the same camera id,</span><br><span class="line">     * framework can call this function to open the camera device as</span><br><span class="line">     * CAMERA_DEVICE_API_VERSION_1_0 device.</span><br><span class="line">     *</span><br><span class="line">     * This is an optional method. A Camera HAL module does not need to support</span><br><span class="line">     * more than one device HAL version per device, and such modules may return</span><br><span class="line">     * -ENOSYS for all calls to this method. For all older HAL device API</span><br><span class="line">     * versions that are not supported, it may return -EOPNOTSUPP. When above</span><br><span class="line">     * cases occur, The normal open() method (common.methods-&gt;open) will be</span><br><span class="line">     * used by the framework instead.</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     *  CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2:</span><br><span class="line">     *    Not provided by HAL module. Framework will not call this function.</span><br><span class="line">     *</span><br><span class="line">     *  CAMERA_MODULE_API_VERSION_2_3:</span><br><span class="line">     *    Valid to be called by the framework.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     * 0:           On a successful open of the camera device.</span><br><span class="line">     *</span><br><span class="line">     * -ENOSYS      This method is not supported.</span><br><span class="line">     *</span><br><span class="line">     * -EOPNOTSUPP: The requested HAL version is not supported by this method.</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span><br><span class="line">     *              and/or the module is invalid.</span><br><span class="line">     *</span><br><span class="line">     * -EBUSY:      The camera device was already opened for this camera id</span><br><span class="line">     *              (by using this method or common.methods-&gt;open method),</span><br><span class="line">     *              regardless of the device HAL version it was opened as.</span><br><span class="line">     *</span><br><span class="line">     * -EUSERS:     The maximal number of camera devices that can be</span><br><span class="line">     *              opened concurrently were opened already, either by</span><br><span class="line">     *              this method or common.methods-&gt;open method.</span><br><span class="line">     */</span><br><span class="line">    int (*open_legacy)(const struct hw_module_t* module, const char* id,</span><br><span class="line">            uint32_t halVersion, struct hw_device_t** device);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set_torch_mode:</span><br><span class="line">     *</span><br><span class="line">     * Turn on or off the torch mode of the flash unit associated with a given</span><br><span class="line">     * camera ID. If the operation is successful, HAL must notify the framework</span><br><span class="line">     * torch state by invoking</span><br><span class="line">     * camera_module_callbacks.torch_mode_status_change() with the new state.</span><br><span class="line">     *</span><br><span class="line">     * The camera device has a higher priority accessing the flash unit. When</span><br><span class="line">     * there are any resource conflicts, such as open() is called to open a</span><br><span class="line">     * camera device, HAL module must notify the framework through</span><br><span class="line">     * camera_module_callbacks.torch_mode_status_change() that the</span><br><span class="line">     * torch mode has been turned off and the torch mode state has become</span><br><span class="line">     * TORCH_MODE_STATUS_NOT_AVAILABLE. When resources to turn on torch mode</span><br><span class="line">     * become available again, HAL module must notify the framework through</span><br><span class="line">     * camera_module_callbacks.torch_mode_status_change() that the torch mode</span><br><span class="line">     * state has become TORCH_MODE_STATUS_AVAILABLE_OFF for set_torch_mode() to</span><br><span class="line">     * be called.</span><br><span class="line">     *</span><br><span class="line">     * When the framework calls set_torch_mode() to turn on the torch mode of a</span><br><span class="line">     * flash unit, if HAL cannot keep multiple torch modes on simultaneously,</span><br><span class="line">     * HAL should turn off the torch mode that was turned on by</span><br><span class="line">     * a previous set_torch_mode() call and notify the framework that the torch</span><br><span class="line">     * mode state of that flash unit has become TORCH_MODE_STATUS_AVAILABLE_OFF.</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3:</span><br><span class="line">     *   Not provided by HAL module. Framework will not call this function.</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_2_4:</span><br><span class="line">     *   Valid to be called by the framework.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     * 0:           On a successful operation.</span><br><span class="line">     *</span><br><span class="line">     * -ENOSYS:     The camera device does not support this operation. It is</span><br><span class="line">     *              returned if and only if android.flash.info.available is</span><br><span class="line">     *              false.</span><br><span class="line">     *</span><br><span class="line">     * -EBUSY:      The camera device is already in use.</span><br><span class="line">     *</span><br><span class="line">     * -EUSERS:     The resources needed to turn on the torch mode are not</span><br><span class="line">     *              available, typically because other camera devices are</span><br><span class="line">     *              holding the resources to make using the flash unit not</span><br><span class="line">     *              possible.</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL:     camera_id is invalid.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    int (*set_torch_mode)(const char* camera_id, bool enabled);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * init:</span><br><span class="line">     *</span><br><span class="line">     * This method is called by the camera service before any other methods</span><br><span class="line">     * are invoked, right after the camera HAL library has been successfully</span><br><span class="line">     * loaded. It may be left as NULL by the HAL module, if no initialization</span><br><span class="line">     * in needed.</span><br><span class="line">     *</span><br><span class="line">     * It can be used by HAL implementations to perform initialization and</span><br><span class="line">     * other one-time operations.</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3:</span><br><span class="line">     *   Not provided by HAL module. Framework will not call this function.</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_2_4:</span><br><span class="line">     *   If not NULL, will always be called by the framework once after the HAL</span><br><span class="line">     *   module is loaded, before any other HAL module method is called.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     * 0:           On a successful operation.</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV:     Initialization cannot be completed due to an internal</span><br><span class="line">     *              error. The HAL must be assumed to be in a nonfunctional</span><br><span class="line">     *              state.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    int (*init)();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get_physical_camera_info:</span><br><span class="line">     *</span><br><span class="line">     * Return the static metadata for a physical camera as a part of a logical</span><br><span class="line">     * camera device. This function is only called for those physical camera</span><br><span class="line">     * ID(s) that are not exposed independently. In other words, camera_id will</span><br><span class="line">     * be greater or equal to the return value of get_number_of_cameras().</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     * 0:           On a successful operation</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV:     The information cannot be provided due to an internal</span><br><span class="line">     *              error.</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span><br><span class="line">     *              and/or the module is invalid.</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3/2_4:</span><br><span class="line">     *   Not provided by HAL module. Framework will not call this function.</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_2_5 or higher:</span><br><span class="line">     *   If any of the camera devices accessible through this camera module is</span><br><span class="line">     *   a logical multi-camera, and at least one of the physical cameras isn&apos;t</span><br><span class="line">     *   a stand-alone camera device, this function will be called by the camera</span><br><span class="line">     *   framework. Calling this function with invalid physical_camera_id will</span><br><span class="line">     *   get -EINVAL, and NULL static_metadata.</span><br><span class="line">     */</span><br><span class="line">    int (*get_physical_camera_info)(int physical_camera_id,</span><br><span class="line">            camera_metadata_t **static_metadata);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * is_stream_combination_supported:</span><br><span class="line">     *</span><br><span class="line">     * Check for device support of specific camera stream combination.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     * 0:           In case the stream combination is supported.</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL:     In case the stream combination is not supported.</span><br><span class="line">     *</span><br><span class="line">     * -ENOSYS:     In case stream combination query is not supported.</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3/2_4:</span><br><span class="line">     *   Not provided by HAL module. Framework will not call this function.</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_2_5 or higher:</span><br><span class="line">     *   Valid to be called by the framework.</span><br><span class="line">     */</span><br><span class="line">    int (*is_stream_combination_supported)(int camera_id,</span><br><span class="line">            const camera_stream_combination_t *streams);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * notify_device_state_change:</span><br><span class="line">     *</span><br><span class="line">     * Notify the camera module that the state of the overall device has</span><br><span class="line">     * changed in some way that the HAL may want to know about.</span><br><span class="line">     *</span><br><span class="line">     * For example, a physical shutter may have been uncovered or covered,</span><br><span class="line">     * or a camera may have been covered or uncovered by an add-on keyboard</span><br><span class="line">     * or other accessory.</span><br><span class="line">     *</span><br><span class="line">     * The state is a bitfield of potential states, and some physical configurations</span><br><span class="line">     * could plausibly correspond to multiple different combinations of state bits.</span><br><span class="line">     * The HAL must ignore any state bits it is not actively using to determine</span><br><span class="line">     * the appropriate camera configuration.</span><br><span class="line">     *</span><br><span class="line">     * For example, on some devices the FOLDED state could mean that</span><br><span class="line">     * backward-facing cameras are covered by the fold, so FOLDED by itself implies</span><br><span class="line">     * BACK_COVERED. But other devices may support folding but not cover any cameras</span><br><span class="line">     * when folded, so for those FOLDED would not imply any of the other flags.</span><br><span class="line">     * Since these relationships are very device-specific, it is difficult to specify</span><br><span class="line">     * a comprehensive policy.  But as a recommendation, it is suggested that if a flag</span><br><span class="line">     * necessarily implies other flags are set as well, then those flags should be set.</span><br><span class="line">     * So even though FOLDED would be enough to infer BACK_COVERED on some devices, the</span><br><span class="line">     * BACK_COVERED flag should also be set for clarity.</span><br><span class="line">     *</span><br><span class="line">     * This method may be invoked by the HAL client at any time. It must not</span><br><span class="line">     * cause any active camera device sessions to be closed, but may dynamically</span><br><span class="line">     * change which physical camera a logical multi-camera is using for its</span><br><span class="line">     * active and future output.</span><br><span class="line">     *</span><br><span class="line">     * The method must be invoked by the HAL client at least once before the</span><br><span class="line">     * client calls ICameraDevice::open on any camera device interfaces listed</span><br><span class="line">     * by this provider, to establish the initial device state.</span><br><span class="line">     *</span><br><span class="line">     * Note that the deviceState is 64-bit bitmask, with system defined states in</span><br><span class="line">     * lower 32-bit and vendor defined states in upper 32-bit.</span><br><span class="line">     */</span><br><span class="line">    void (*notify_device_state_change)(uint64_t deviceState);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get_camera_device_version:</span><br><span class="line">     *</span><br><span class="line">     * Return the device version for a given camera device. This value may not change for a camera</span><br><span class="line">     * device. The version returned here must be the same as the one from get_camera_info.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     * 0:           On a successful operation</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV:     The information cannot be provided due to an internal</span><br><span class="line">     *              error.</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span><br><span class="line">     *              and/or the module is invalid.</span><br><span class="line">     *</span><br><span class="line">     * Version information (based on camera_module_t.common.module_api_version):</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_MODULE_API_VERSION_2_5 or higher:</span><br><span class="line">     *</span><br><span class="line">     *   When a camera is disconnected, its camera id becomes invalid. Calling this</span><br><span class="line">     *   this method with this invalid camera id will get -EINVAL and NULL camera</span><br><span class="line">     *   static metadata (camera_info.static_camera_characteristics).</span><br><span class="line">     */</span><br><span class="line">    int (*get_camera_device_version)(int camera_id, uint32_t *version);</span><br><span class="line"></span><br><span class="line">    /* reserved for future use */</span><br><span class="line">    void* reserved[1];</span><br><span class="line">&#125; camera_module_t;</span><br></pre></td></tr></table></figure>
<p>camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法</p>
<h3 id="4-2-camera3-device-t"><a href="#4-2-camera3-device-t" class="headerlink" title="4.2 camera3_device_t"></a>4.2 camera3_device_t</h3><p>[-&gt;hardware/libhardware/include/hardware/camera3.h]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct camera3_device &#123;</span><br><span class="line">    /**</span><br><span class="line">     * common.version must equal CAMERA_DEVICE_API_VERSION_3_0 to identify this</span><br><span class="line">     * device as implementing version 3.0 of the camera device HAL.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * Camera open (common.module-&gt;common.methods-&gt;open) should return in 200ms, and must return</span><br><span class="line">     * in 500ms.</span><br><span class="line">     * Camera close (common.close) should return in 200ms, and must return in 500ms.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    hw_device_t common;</span><br><span class="line">    camera3_device_ops_t *ops;</span><br><span class="line">    void *priv;</span><br><span class="line">&#125; camera3_device_t;</span><br></pre></td></tr></table></figure>
<p>camera3_device_t包含了hw_device_t，主要用来表示Camera设备，其中定义了camera3_device_ops操作方法集合，用来实现正常获取图像数据以及控制Camera的功能。</p>
<h3 id="4-3-camera3-device-ops"><a href="#4-3-camera3-device-ops" class="headerlink" title="4.3 camera3_device_ops"></a>4.3 camera3_device_ops</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br></pre></td><td class="code"><pre><span class="line">typedef struct camera3_device_ops &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * initialize:</span><br><span class="line">     *</span><br><span class="line">     * One-time initialization to pass framework callback function pointers to</span><br><span class="line">     * the HAL. Will be called once after a successful open() call, before any</span><br><span class="line">     * other functions are called on the camera3_device_ops structure.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This should be a non-blocking call. The HAL should return from this call</span><br><span class="line">     * in 5ms, and must return from this call in 10ms.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     *  0:     On successful initialization</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV: If initialization fails. Only close() can be called successfully</span><br><span class="line">     *          by the framework after this.</span><br><span class="line">     */</span><br><span class="line">    int (*initialize)(const struct camera3_device *,</span><br><span class="line">            const camera3_callback_ops_t *callback_ops);</span><br><span class="line"></span><br><span class="line">    /**********************************************************************</span><br><span class="line">     * Stream management</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * configure_streams:</span><br><span class="line">     *</span><br><span class="line">     * CAMERA_DEVICE_API_VERSION_3_0 only:</span><br><span class="line">     *</span><br><span class="line">     * Reset the HAL camera device processing pipeline and set up new input and</span><br><span class="line">     * output streams. This call replaces any existing stream configuration with</span><br><span class="line">     * the streams defined in the stream_list. This method will be called at</span><br><span class="line">     * least once after initialize() before a request is submitted with</span><br><span class="line">     * process_capture_request().</span><br><span class="line">     *</span><br><span class="line">     * The stream_list must contain at least one output-capable stream, and may</span><br><span class="line">     * not contain more than one input-capable stream.</span><br><span class="line">     *</span><br><span class="line">     * The stream_list may contain streams that are also in the currently-active</span><br><span class="line">     * set of streams (from the previous call to configure_stream()). These</span><br><span class="line">     * streams will already have valid values for usage, max_buffers, and the</span><br><span class="line">     * private pointer.</span><br><span class="line">     *</span><br><span class="line">     * If such a stream has already had its buffers registered,</span><br><span class="line">     * register_stream_buffers() will not be called again for the stream, and</span><br><span class="line">     * buffers from the stream can be immediately included in input requests.</span><br><span class="line">     *</span><br><span class="line">     * If the HAL needs to change the stream configuration for an existing</span><br><span class="line">     * stream due to the new configuration, it may rewrite the values of usage</span><br><span class="line">     * and/or max_buffers during the configure call.</span><br><span class="line">     *</span><br><span class="line">     * The framework will detect such a change, and will then reallocate the</span><br><span class="line">     * stream buffers, and call register_stream_buffers() again before using</span><br><span class="line">     * buffers from that stream in a request.</span><br><span class="line">     *</span><br><span class="line">     * If a currently-active stream is not included in stream_list, the HAL may</span><br><span class="line">     * safely remove any references to that stream. It will not be reused in a</span><br><span class="line">     * later configure() call by the framework, and all the gralloc buffers for</span><br><span class="line">     * it will be freed after the configure_streams() call returns.</span><br><span class="line">     *</span><br><span class="line">     * The stream_list structure is owned by the framework, and may not be</span><br><span class="line">     * accessed once this call completes. The address of an individual</span><br><span class="line">     * camera3_stream_t structure will remain valid for access by the HAL until</span><br><span class="line">     * the end of the first configure_stream() call which no longer includes</span><br><span class="line">     * that camera3_stream_t in the stream_list argument. The HAL may not change</span><br><span class="line">     * values in the stream structure outside of the private pointer, except for</span><br><span class="line">     * the usage and max_buffers members during the configure_streams() call</span><br><span class="line">     * itself.</span><br><span class="line">     *</span><br><span class="line">     * If the stream is new, the usage, max_buffer, and private pointer fields</span><br><span class="line">     * of the stream structure will all be set to 0. The HAL device must set</span><br><span class="line">     * these fields before the configure_streams() call returns. These fields</span><br><span class="line">     * are then used by the framework and the platform gralloc module to</span><br><span class="line">     * allocate the gralloc buffers for each stream.</span><br><span class="line">     *</span><br><span class="line">     * Before such a new stream can have its buffers included in a capture</span><br><span class="line">     * request, the framework will call register_stream_buffers() with that</span><br><span class="line">     * stream. However, the framework is not required to register buffers for</span><br><span class="line">     * _all_ streams before submitting a request. This allows for quick startup</span><br><span class="line">     * of (for example) a preview stream, with allocation for other streams</span><br><span class="line">     * happening later or concurrently.</span><br><span class="line">     *</span><br><span class="line">     * ------------------------------------------------------------------------</span><br><span class="line">     * CAMERA_DEVICE_API_VERSION_3_1 only:</span><br><span class="line">     *</span><br><span class="line">     * Reset the HAL camera device processing pipeline and set up new input and</span><br><span class="line">     * output streams. This call replaces any existing stream configuration with</span><br><span class="line">     * the streams defined in the stream_list. This method will be called at</span><br><span class="line">     * least once after initialize() before a request is submitted with</span><br><span class="line">     * process_capture_request().</span><br><span class="line">     *</span><br><span class="line">     * The stream_list must contain at least one output-capable stream, and may</span><br><span class="line">     * not contain more than one input-capable stream.</span><br><span class="line">     *</span><br><span class="line">     * The stream_list may contain streams that are also in the currently-active</span><br><span class="line">     * set of streams (from the previous call to configure_stream()). These</span><br><span class="line">     * streams will already have valid values for usage, max_buffers, and the</span><br><span class="line">     * private pointer.</span><br><span class="line">     *</span><br><span class="line">     * If such a stream has already had its buffers registered,</span><br><span class="line">     * register_stream_buffers() will not be called again for the stream, and</span><br><span class="line">     * buffers from the stream can be immediately included in input requests.</span><br><span class="line">     *</span><br><span class="line">     * If the HAL needs to change the stream configuration for an existing</span><br><span class="line">     * stream due to the new configuration, it may rewrite the values of usage</span><br><span class="line">     * and/or max_buffers during the configure call.</span><br><span class="line">     *</span><br><span class="line">     * The framework will detect such a change, and will then reallocate the</span><br><span class="line">     * stream buffers, and call register_stream_buffers() again before using</span><br><span class="line">     * buffers from that stream in a request.</span><br><span class="line">     *</span><br><span class="line">     * If a currently-active stream is not included in stream_list, the HAL may</span><br><span class="line">     * safely remove any references to that stream. It will not be reused in a</span><br><span class="line">     * later configure() call by the framework, and all the gralloc buffers for</span><br><span class="line">     * it will be freed after the configure_streams() call returns.</span><br><span class="line">     *</span><br><span class="line">     * The stream_list structure is owned by the framework, and may not be</span><br><span class="line">     * accessed once this call completes. The address of an individual</span><br><span class="line">     * camera3_stream_t structure will remain valid for access by the HAL until</span><br><span class="line">     * the end of the first configure_stream() call which no longer includes</span><br><span class="line">     * that camera3_stream_t in the stream_list argument. The HAL may not change</span><br><span class="line">     * values in the stream structure outside of the private pointer, except for</span><br><span class="line">     * the usage and max_buffers members during the configure_streams() call</span><br><span class="line">     * itself.</span><br><span class="line">     *</span><br><span class="line">     * If the stream is new, max_buffer, and private pointer fields of the</span><br><span class="line">     * stream structure will all be set to 0. The usage will be set to the</span><br><span class="line">     * consumer usage flags. The HAL device must set these fields before the</span><br><span class="line">     * configure_streams() call returns. These fields are then used by the</span><br><span class="line">     * framework and the platform gralloc module to allocate the gralloc</span><br><span class="line">     * buffers for each stream.</span><br><span class="line">     *</span><br><span class="line">     * Before such a new stream can have its buffers included in a capture</span><br><span class="line">     * request, the framework will call register_stream_buffers() with that</span><br><span class="line">     * stream. However, the framework is not required to register buffers for</span><br><span class="line">     * _all_ streams before submitting a request. This allows for quick startup</span><br><span class="line">     * of (for example) a preview stream, with allocation for other streams</span><br><span class="line">     * happening later or concurrently.</span><br><span class="line">     *</span><br><span class="line">     * ------------------------------------------------------------------------</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">     *</span><br><span class="line">     * Reset the HAL camera device processing pipeline and set up new input and</span><br><span class="line">     * output streams. This call replaces any existing stream configuration with</span><br><span class="line">     * the streams defined in the stream_list. This method will be called at</span><br><span class="line">     * least once after initialize() before a request is submitted with</span><br><span class="line">     * process_capture_request().</span><br><span class="line">     *</span><br><span class="line">     * The stream_list must contain at least one output-capable stream, and may</span><br><span class="line">     * not contain more than one input-capable stream.</span><br><span class="line">     *</span><br><span class="line">     * The stream_list may contain streams that are also in the currently-active</span><br><span class="line">     * set of streams (from the previous call to configure_stream()). These</span><br><span class="line">     * streams will already have valid values for usage, max_buffers, and the</span><br><span class="line">     * private pointer.</span><br><span class="line">     *</span><br><span class="line">     * If the HAL needs to change the stream configuration for an existing</span><br><span class="line">     * stream due to the new configuration, it may rewrite the values of usage</span><br><span class="line">     * and/or max_buffers during the configure call.</span><br><span class="line">     *</span><br><span class="line">     * The framework will detect such a change, and may then reallocate the</span><br><span class="line">     * stream buffers before using buffers from that stream in a request.</span><br><span class="line">     *</span><br><span class="line">     * If a currently-active stream is not included in stream_list, the HAL may</span><br><span class="line">     * safely remove any references to that stream. It will not be reused in a</span><br><span class="line">     * later configure() call by the framework, and all the gralloc buffers for</span><br><span class="line">     * it will be freed after the configure_streams() call returns.</span><br><span class="line">     *</span><br><span class="line">     * The stream_list structure is owned by the framework, and may not be</span><br><span class="line">     * accessed once this call completes. The address of an individual</span><br><span class="line">     * camera3_stream_t structure will remain valid for access by the HAL until</span><br><span class="line">     * the end of the first configure_stream() call which no longer includes</span><br><span class="line">     * that camera3_stream_t in the stream_list argument. The HAL may not change</span><br><span class="line">     * values in the stream structure outside of the private pointer, except for</span><br><span class="line">     * the usage and max_buffers members during the configure_streams() call</span><br><span class="line">     * itself.</span><br><span class="line">     *</span><br><span class="line">     * If the stream is new, max_buffer, and private pointer fields of the</span><br><span class="line">     * stream structure will all be set to 0. The usage will be set to the</span><br><span class="line">     * consumer usage flags. The HAL device must set these fields before the</span><br><span class="line">     * configure_streams() call returns. These fields are then used by the</span><br><span class="line">     * framework and the platform gralloc module to allocate the gralloc</span><br><span class="line">     * buffers for each stream.</span><br><span class="line">     *</span><br><span class="line">     * Newly allocated buffers may be included in a capture request at any time</span><br><span class="line">     * by the framework. Once a gralloc buffer is returned to the framework</span><br><span class="line">     * with process_capture_result (and its respective release_fence has been</span><br><span class="line">     * signaled) the framework may free or reuse it at any time.</span><br><span class="line">     *</span><br><span class="line">     * ------------------------------------------------------------------------</span><br><span class="line">     *</span><br><span class="line">     * Preconditions:</span><br><span class="line">     *</span><br><span class="line">     * The framework will only call this method when no captures are being</span><br><span class="line">     * processed. That is, all results have been returned to the framework, and</span><br><span class="line">     * all in-flight input and output buffers have been returned and their</span><br><span class="line">     * release sync fences have been signaled by the HAL. The framework will not</span><br><span class="line">     * submit new requests for capture while the configure_streams() call is</span><br><span class="line">     * underway.</span><br><span class="line">     *</span><br><span class="line">     * Postconditions:</span><br><span class="line">     *</span><br><span class="line">     * The HAL device must configure itself to provide maximum possible output</span><br><span class="line">     * frame rate given the sizes and formats of the output streams, as</span><br><span class="line">     * documented in the camera device&apos;s static metadata.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This call is expected to be heavyweight and possibly take several hundred</span><br><span class="line">     * milliseconds to complete, since it may require resetting and</span><br><span class="line">     * reconfiguring the image sensor and the camera processing pipeline.</span><br><span class="line">     * Nevertheless, the HAL device should attempt to minimize the</span><br><span class="line">     * reconfiguration delay to minimize the user-visible pauses during</span><br><span class="line">     * application operational mode changes (such as switching from still</span><br><span class="line">     * capture to video recording).</span><br><span class="line">     *</span><br><span class="line">     * The HAL should return from this call in 500ms, and must return from this</span><br><span class="line">     * call in 1000ms.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     *  0:      On successful stream configuration</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL: If the requested stream configuration is invalid. Some examples</span><br><span class="line">     *          of invalid stream configurations include:</span><br><span class="line">     *</span><br><span class="line">     *          - Including more than 1 input-capable stream (INPUT or</span><br><span class="line">     *            BIDIRECTIONAL)</span><br><span class="line">     *</span><br><span class="line">     *          - Not including any output-capable streams (OUTPUT or</span><br><span class="line">     *            BIDIRECTIONAL)</span><br><span class="line">     *</span><br><span class="line">     *          - Including streams with unsupported formats, or an unsupported</span><br><span class="line">     *            size for that format.</span><br><span class="line">     *</span><br><span class="line">     *          - Including too many output streams of a certain format.</span><br><span class="line">     *</span><br><span class="line">     *          - Unsupported rotation configuration (only applies to</span><br><span class="line">     *            devices with version &gt;= CAMERA_DEVICE_API_VERSION_3_3)</span><br><span class="line">     *</span><br><span class="line">     *          - Stream sizes/formats don&apos;t satisfy the</span><br><span class="line">     *            camera3_stream_configuration_t-&gt;operation_mode requirements for non-NORMAL mode,</span><br><span class="line">     *            or the requested operation_mode is not supported by the HAL.</span><br><span class="line">     *            (only applies to devices with version &gt;= CAMERA_DEVICE_API_VERSION_3_3)</span><br><span class="line">     *</span><br><span class="line">     *          Note that the framework submitting an invalid stream</span><br><span class="line">     *          configuration is not normal operation, since stream</span><br><span class="line">     *          configurations are checked before configure. An invalid</span><br><span class="line">     *          configuration means that a bug exists in the framework code, or</span><br><span class="line">     *          there is a mismatch between the HAL&apos;s static metadata and the</span><br><span class="line">     *          requirements on streams.</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV: If there has been a fatal error and the device is no longer</span><br><span class="line">     *          operational. Only close() can be called successfully by the</span><br><span class="line">     *          framework after this error is returned.</span><br><span class="line">     */</span><br><span class="line">    int (*configure_streams)(const struct camera3_device *,</span><br><span class="line">            camera3_stream_configuration_t *stream_list);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * register_stream_buffers:</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">     *</span><br><span class="line">     * DEPRECATED. This will not be called and must be set to NULL.</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">     *</span><br><span class="line">     * Register buffers for a given stream with the HAL device. This method is</span><br><span class="line">     * called by the framework after a new stream is defined by</span><br><span class="line">     * configure_streams, and before buffers from that stream are included in a</span><br><span class="line">     * capture request. If the same stream is listed in a subsequent</span><br><span class="line">     * configure_streams() call, register_stream_buffers will _not_ be called</span><br><span class="line">     * again for that stream.</span><br><span class="line">     *</span><br><span class="line">     * The framework does not need to register buffers for all configured</span><br><span class="line">     * streams before it submits the first capture request. This allows quick</span><br><span class="line">     * startup for preview (or similar use cases) while other streams are still</span><br><span class="line">     * being allocated.</span><br><span class="line">     *</span><br><span class="line">     * This method is intended to allow the HAL device to map or otherwise</span><br><span class="line">     * prepare the buffers for later use. The buffers passed in will already be</span><br><span class="line">     * locked for use. At the end of the call, all the buffers must be ready to</span><br><span class="line">     * be returned to the stream.  The buffer_set argument is only valid for the</span><br><span class="line">     * duration of this call.</span><br><span class="line">     *</span><br><span class="line">     * If the stream format was set to HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED,</span><br><span class="line">     * the camera HAL should inspect the passed-in buffers here to determine any</span><br><span class="line">     * platform-private pixel format information.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This should be a non-blocking call. The HAL should return from this call</span><br><span class="line">     * in 1ms, and must return from this call in 5ms.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     *  0:      On successful registration of the new stream buffers</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL: If the stream_buffer_set does not refer to a valid active</span><br><span class="line">     *          stream, or if the buffers array is invalid.</span><br><span class="line">     *</span><br><span class="line">     * -ENOMEM: If there was a failure in registering the buffers. The framework</span><br><span class="line">     *          must consider all the stream buffers to be unregistered, and can</span><br><span class="line">     *          try to register again later.</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV: If there is a fatal error, and the device is no longer</span><br><span class="line">     *          operational. Only close() can be called successfully by the</span><br><span class="line">     *          framework after this error is returned.</span><br><span class="line">     */</span><br><span class="line">    int (*register_stream_buffers)(const struct camera3_device *,</span><br><span class="line">            const camera3_stream_buffer_set_t *buffer_set);</span><br><span class="line"></span><br><span class="line">    /**********************************************************************</span><br><span class="line">     * Request creation and submission</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * construct_default_request_settings:</span><br><span class="line">     *</span><br><span class="line">     * Create capture settings for standard camera use cases.</span><br><span class="line">     *</span><br><span class="line">     * The device must return a settings buffer that is configured to meet the</span><br><span class="line">     * requested use case, which must be one of the CAMERA3_TEMPLATE_*</span><br><span class="line">     * enums. All request control fields must be included.</span><br><span class="line">     *</span><br><span class="line">     * The HAL retains ownership of this structure, but the pointer to the</span><br><span class="line">     * structure must be valid until the device is closed. The framework and the</span><br><span class="line">     * HAL may not modify the buffer once it is returned by this call. The same</span><br><span class="line">     * buffer may be returned for subsequent calls for the same template, or for</span><br><span class="line">     * other templates.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This should be a non-blocking call. The HAL should return from this call</span><br><span class="line">     * in 1ms, and must return from this call in 5ms.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     *   Valid metadata: On successful creation of a default settings</span><br><span class="line">     *                   buffer.</span><br><span class="line">     *</span><br><span class="line">     *   NULL:           In case of a fatal error. After this is returned, only</span><br><span class="line">     *                   the close() method can be called successfully by the</span><br><span class="line">     *                   framework.</span><br><span class="line">     */</span><br><span class="line">    const camera_metadata_t* (*construct_default_request_settings)(</span><br><span class="line">            const struct camera3_device *,</span><br><span class="line">            int type);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * process_capture_request:</span><br><span class="line">     *</span><br><span class="line">     * Send a new capture request to the HAL. The HAL should not return from</span><br><span class="line">     * this call until it is ready to accept the next request to process. Only</span><br><span class="line">     * one call to process_capture_request() will be made at a time by the</span><br><span class="line">     * framework, and the calls will all be from the same thread. The next call</span><br><span class="line">     * to process_capture_request() will be made as soon as a new request and</span><br><span class="line">     * its associated buffers are available. In a normal preview scenario, this</span><br><span class="line">     * means the function will be called again by the framework almost</span><br><span class="line">     * instantly.</span><br><span class="line">     *</span><br><span class="line">     * The actual request processing is asynchronous, with the results of</span><br><span class="line">     * capture being returned by the HAL through the process_capture_result()</span><br><span class="line">     * call. This call requires the result metadata to be available, but output</span><br><span class="line">     * buffers may simply provide sync fences to wait on. Multiple requests are</span><br><span class="line">     * expected to be in flight at once, to maintain full output frame rate.</span><br><span class="line">     *</span><br><span class="line">     * The framework retains ownership of the request structure. It is only</span><br><span class="line">     * guaranteed to be valid during this call. The HAL device must make copies</span><br><span class="line">     * of the information it needs to retain for the capture processing. The HAL</span><br><span class="line">     * is responsible for waiting on and closing the buffers&apos; fences and</span><br><span class="line">     * returning the buffer handles to the framework.</span><br><span class="line">     *</span><br><span class="line">     * The HAL must write the file descriptor for the input buffer&apos;s release</span><br><span class="line">     * sync fence into input_buffer-&gt;release_fence, if input_buffer is not</span><br><span class="line">     * NULL. If the HAL returns -1 for the input buffer release sync fence, the</span><br><span class="line">     * framework is free to immediately reuse the input buffer. Otherwise, the</span><br><span class="line">     * framework will wait on the sync fence before refilling and reusing the</span><br><span class="line">     * input buffer.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">     *</span><br><span class="line">     * The input/output buffers provided by the framework in each request</span><br><span class="line">     * may be brand new (having never before seen by the HAL).</span><br><span class="line">     *</span><br><span class="line">     * ------------------------------------------------------------------------</span><br><span class="line">     * Performance considerations:</span><br><span class="line">     *</span><br><span class="line">     * Handling a new buffer should be extremely lightweight and there should be</span><br><span class="line">     * no frame rate degradation or frame jitter introduced.</span><br><span class="line">     *</span><br><span class="line">     * This call must return fast enough to ensure that the requested frame</span><br><span class="line">     * rate can be sustained, especially for streaming cases (post-processing</span><br><span class="line">     * quality settings set to FAST). The HAL should return this call in 1</span><br><span class="line">     * frame interval, and must return from this call in 4 frame intervals.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     *  0:      On a successful start to processing the capture request</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL: If the input is malformed (the settings are NULL when not</span><br><span class="line">     *          allowed, invalid physical camera settings,</span><br><span class="line">     *          there are 0 output buffers, etc) and capture processing</span><br><span class="line">     *          cannot start. Failures during request processing should be</span><br><span class="line">     *          handled by calling camera3_callback_ops_t.notify(). In case of</span><br><span class="line">     *          this error, the framework will retain responsibility for the</span><br><span class="line">     *          stream buffers&apos; fences and the buffer handles; the HAL should</span><br><span class="line">     *          not close the fences or return these buffers with</span><br><span class="line">     *          process_capture_result.</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV: If the camera device has encountered a serious error. After this</span><br><span class="line">     *          error is returned, only the close() method can be successfully</span><br><span class="line">     *          called by the framework.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    int (*process_capture_request)(const struct camera3_device *,</span><br><span class="line">            camera3_capture_request_t *request);</span><br><span class="line"></span><br><span class="line">    /**********************************************************************</span><br><span class="line">     * Miscellaneous methods</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get_metadata_vendor_tag_ops:</span><br><span class="line">     *</span><br><span class="line">     * Get methods to query for vendor extension metadata tag information. The</span><br><span class="line">     * HAL should fill in all the vendor tag operation methods, or leave ops</span><br><span class="line">     * unchanged if no vendor tags are defined.</span><br><span class="line">     *</span><br><span class="line">     * The definition of vendor_tag_query_ops_t can be found in</span><br><span class="line">     * system/media/camera/include/system/camera_metadata.h.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">     *    DEPRECATED. This function has been deprecated and should be set to</span><br><span class="line">     *    NULL by the HAL.  Please implement get_vendor_tag_ops in camera_common.h</span><br><span class="line">     *    instead.</span><br><span class="line">     */</span><br><span class="line">    void (*get_metadata_vendor_tag_ops)(const struct camera3_device*,</span><br><span class="line">            vendor_tag_query_ops_t* ops);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * dump:</span><br><span class="line">     *</span><br><span class="line">     * Print out debugging state for the camera device. This will be called by</span><br><span class="line">     * the framework when the camera service is asked for a debug dump, which</span><br><span class="line">     * happens when using the dumpsys tool, or when capturing a bugreport.</span><br><span class="line">     *</span><br><span class="line">     * The passed-in file descriptor can be used to write debugging text using</span><br><span class="line">     * dprintf() or write(). The text should be in ASCII encoding only.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This must be a non-blocking call. The HAL should return from this call</span><br><span class="line">     * in 1ms, must return from this call in 10ms. This call must avoid</span><br><span class="line">     * deadlocks, as it may be called at any point during camera operation.</span><br><span class="line">     * Any synchronization primitives used (such as mutex locks or semaphores)</span><br><span class="line">     * should be acquired with a timeout.</span><br><span class="line">     */</span><br><span class="line">    void (*dump)(const struct camera3_device *, int fd);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * flush:</span><br><span class="line">     *</span><br><span class="line">     * Flush all currently in-process captures and all buffers in the pipeline</span><br><span class="line">     * on the given device. The framework will use this to dump all state as</span><br><span class="line">     * quickly as possible in order to prepare for a configure_streams() call.</span><br><span class="line">     *</span><br><span class="line">     * No buffers are required to be successfully returned, so every buffer</span><br><span class="line">     * held at the time of flush() (whether successfully filled or not) may be</span><br><span class="line">     * returned with CAMERA3_BUFFER_STATUS_ERROR. Note the HAL is still allowed</span><br><span class="line">     * to return valid (CAMERA3_BUFFER_STATUS_OK) buffers during this call,</span><br><span class="line">     * provided they are successfully filled.</span><br><span class="line">     *</span><br><span class="line">     * All requests currently in the HAL are expected to be returned as soon as</span><br><span class="line">     * possible.  Not-in-process requests should return errors immediately. Any</span><br><span class="line">     * interruptible hardware blocks should be stopped, and any uninterruptible</span><br><span class="line">     * blocks should be waited on.</span><br><span class="line">     *</span><br><span class="line">     * flush() may be called concurrently to process_capture_request(), with the expectation that</span><br><span class="line">     * process_capture_request will return quickly and the request submitted in that</span><br><span class="line">     * process_capture_request call is treated like all other in-flight requests.  Due to</span><br><span class="line">     * concurrency issues, it is possible that from the HAL&apos;s point of view, a</span><br><span class="line">     * process_capture_request() call may be started after flush has been invoked but has not</span><br><span class="line">     * returned yet. If such a call happens before flush() returns, the HAL should treat the new</span><br><span class="line">     * capture request like other in-flight pending requests (see #4 below).</span><br><span class="line">     *</span><br><span class="line">     * More specifically, the HAL must follow below requirements for various cases:</span><br><span class="line">     *</span><br><span class="line">     * 1. For captures that are too late for the HAL to cancel/stop, and will be</span><br><span class="line">     *    completed normally by the HAL; i.e. the HAL can send shutter/notify and</span><br><span class="line">     *    process_capture_result and buffers as normal.</span><br><span class="line">     *</span><br><span class="line">     * 2. For pending requests that have not done any processing, the HAL must call notify</span><br><span class="line">     *    CAMERA3_MSG_ERROR_REQUEST, and return all the output buffers with</span><br><span class="line">     *    process_capture_result in the error state (CAMERA3_BUFFER_STATUS_ERROR).</span><br><span class="line">     *    The HAL must not place the release fence into an error state, instead,</span><br><span class="line">     *    the release fences must be set to the acquire fences passed by the framework,</span><br><span class="line">     *    or -1 if they have been waited on by the HAL already. This is also the path</span><br><span class="line">     *    to follow for any captures for which the HAL already called notify() with</span><br><span class="line">     *    CAMERA3_MSG_SHUTTER but won&apos;t be producing any metadata/valid buffers for.</span><br><span class="line">     *    After CAMERA3_MSG_ERROR_REQUEST, for a given frame, only process_capture_results with</span><br><span class="line">     *    buffers in CAMERA3_BUFFER_STATUS_ERROR are allowed. No further notifys or</span><br><span class="line">     *    process_capture_result with non-null metadata is allowed.</span><br><span class="line">     *</span><br><span class="line">     * 3. For partially completed pending requests that will not have all the output</span><br><span class="line">     *    buffers or perhaps missing metadata, the HAL should follow below:</span><br><span class="line">     *</span><br><span class="line">     *    3.1. Call notify with CAMERA3_MSG_ERROR_RESULT if some of the expected result</span><br><span class="line">     *    metadata (i.e. one or more partial metadata) won&apos;t be available for the capture.</span><br><span class="line">     *</span><br><span class="line">     *    3.2. Call notify with CAMERA3_MSG_ERROR_BUFFER for every buffer that won&apos;t</span><br><span class="line">     *         be produced for the capture.</span><br><span class="line">     *</span><br><span class="line">     *    3.3  Call notify with CAMERA3_MSG_SHUTTER with the capture timestamp before</span><br><span class="line">     *         any buffers/metadata are returned with process_capture_result.</span><br><span class="line">     *</span><br><span class="line">     *    3.4 For captures that will produce some results, the HAL must not call</span><br><span class="line">     *        CAMERA3_MSG_ERROR_REQUEST, since that indicates complete failure.</span><br><span class="line">     *</span><br><span class="line">     *    3.5. Valid buffers/metadata should be passed to the framework as normal.</span><br><span class="line">     *</span><br><span class="line">     *    3.6. Failed buffers should be returned to the framework as described for case 2.</span><br><span class="line">     *         But failed buffers do not have to follow the strict ordering valid buffers do,</span><br><span class="line">     *         and may be out-of-order with respect to valid buffers. For example, if buffers</span><br><span class="line">     *         A, B, C, D, E are sent, D and E are failed, then A, E, B, D, C is an acceptable</span><br><span class="line">     *         return order.</span><br><span class="line">     *</span><br><span class="line">     *    3.7. For fully-missing metadata, calling CAMERA3_MSG_ERROR_RESULT is sufficient, no</span><br><span class="line">     *         need to call process_capture_result with NULL metadata or equivalent.</span><br><span class="line">     *</span><br><span class="line">     * 4. If a flush() is invoked while a process_capture_request() invocation is active, that</span><br><span class="line">     *    process call should return as soon as possible. In addition, if a process_capture_request()</span><br><span class="line">     *    call is made after flush() has been invoked but before flush() has returned, the</span><br><span class="line">     *    capture request provided by the late process_capture_request call should be treated like</span><br><span class="line">     *    a pending request in case #2 above.</span><br><span class="line">     *</span><br><span class="line">     * flush() should only return when there are no more outstanding buffers or</span><br><span class="line">     * requests left in the HAL. The framework may call configure_streams (as</span><br><span class="line">     * the HAL state is now quiesced) or may issue new requests.</span><br><span class="line">     *</span><br><span class="line">     * Note that it&apos;s sufficient to only support fully-succeeded and fully-failed result cases.</span><br><span class="line">     * However, it is highly desirable to support the partial failure cases as well, as it</span><br><span class="line">     * could help improve the flush call overall performance.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * The HAL should return from this call in 100ms, and must return from this</span><br><span class="line">     * call in 1000ms. And this call must not be blocked longer than pipeline</span><br><span class="line">     * latency (see S7 for definition).</span><br><span class="line">     *</span><br><span class="line">     * Version information:</span><br><span class="line">     *</span><br><span class="line">     *   only available if device version &gt;= CAMERA_DEVICE_API_VERSION_3_1.</span><br><span class="line">     *</span><br><span class="line">     * Return values:</span><br><span class="line">     *</span><br><span class="line">     *  0:      On a successful flush of the camera HAL.</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL: If the input is malformed (the device is not valid).</span><br><span class="line">     *</span><br><span class="line">     * -ENODEV: If the camera device has encountered a serious error. After this</span><br><span class="line">     *          error is returned, only the close() method can be successfully</span><br><span class="line">     *          called by the framework.</span><br><span class="line">     */</span><br><span class="line">    int (*flush)(const struct camera3_device *);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * signal_stream_flush:</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span><br><span class="line">     *</span><br><span class="line">     *    Not defined and must be NULL</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span><br><span class="line">     *</span><br><span class="line">     * Signaling HAL camera service is about to perform configure_streams() call</span><br><span class="line">     * and HAL must return all buffers of designated streams. HAL must finish</span><br><span class="line">     * inflight requests normally and return all buffers belonging to the</span><br><span class="line">     * designated streams through process_capture_result() or</span><br><span class="line">     * return_stream_buffers() API in a timely manner, or camera service will run</span><br><span class="line">     * into a fatal error.</span><br><span class="line">     *</span><br><span class="line">     * Note that this call serves as an optional hint and camera service may</span><br><span class="line">     * skip calling this if all buffers are already returned.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    void (*signal_stream_flush)(const struct camera3_device*,</span><br><span class="line">            uint32_t num_streams,</span><br><span class="line">            const camera3_stream_t* const* streams);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * is_reconfiguration_required:</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span><br><span class="line">     *</span><br><span class="line">     *    Not defined and must be NULL</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span><br><span class="line">     *</span><br><span class="line">     * Check whether complete stream reconfiguration is required for possible new session</span><br><span class="line">     * parameter values.</span><br><span class="line">     *</span><br><span class="line">     * This method must be called by the camera framework in case the client changes</span><br><span class="line">     * the value of any advertised session parameters. Depending on the specific values</span><br><span class="line">     * the HAL can decide whether a complete stream reconfiguration is required. In case</span><br><span class="line">     * the HAL returns -ENVAL, the camera framework must skip the internal reconfiguration.</span><br><span class="line">     * In case Hal returns 0, the framework must reconfigure the streams and pass the</span><br><span class="line">     * new session parameter values accordingly.</span><br><span class="line">     * This call may be done by the framework some time before the request with new parameters</span><br><span class="line">     * is submitted to the HAL, and the request may be cancelled before it ever gets submitted.</span><br><span class="line">     * Therefore, the HAL must not use this query as an indication to change its behavior in any</span><br><span class="line">     * way.</span><br><span class="line">     * ------------------------------------------------------------------------</span><br><span class="line">     *</span><br><span class="line">     * Preconditions:</span><br><span class="line">     *</span><br><span class="line">     * The framework can call this method at any time after active</span><br><span class="line">     * session configuration. There must be no impact on the performance of</span><br><span class="line">     * pending camera requests in any way. In particular there must not be</span><br><span class="line">     * any glitches or delays during normal camera streaming.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     * HW and SW camera settings must not be changed and there must not be</span><br><span class="line">     * a user-visible impact on camera performance.</span><br><span class="line">     *</span><br><span class="line">     * @param oldSessionParams The currently applied session parameters.</span><br><span class="line">     * @param newSessionParams The new session parameters set by client.</span><br><span class="line">     *</span><br><span class="line">     * @return Status Status code for the operation, one of:</span><br><span class="line">     * 0:                    In case the stream reconfiguration is required</span><br><span class="line">     *</span><br><span class="line">     * -EINVAL:              In case the stream reconfiguration is not required.</span><br><span class="line">     *</span><br><span class="line">     * -ENOSYS:              In case the camera device does not support the</span><br><span class="line">     *                       reconfiguration query.</span><br><span class="line">     */</span><br><span class="line">    int (*is_reconfiguration_required)(const struct camera3_device*,</span><br><span class="line">            const camera_metadata_t* old_session_params,</span><br><span class="line">            const camera_metadata_t* new_session_params);</span><br><span class="line"></span><br><span class="line">    /* reserved for future use */</span><br><span class="line">    void *reserved[6];</span><br><span class="line">&#125; camera3_device_ops_t;</span><br></pre></td></tr></table></figure>
<p>HAL3的核心接口都是在camera3_device_ops中被定义，从代码中可以看见，该结构体定义了一系列的函数指针，用来指向平台厂商实际的实现方法，接下来就其中几个方法简单介绍下：</p>
<p><strong>a) initialize</strong></p>
<p>该方法必须在camera_module_t中的open方法之后，其它camera3_device_ops中方法之前被调用，主要用来将上层实现的回调方法注册到HAL中，并且根据需要在该方法中加入自定义的一些初始化操作，另外，谷歌针对该方法在性能方面也有严格的限制，该方法需要在5ms内返回，最长不能超过10ms。</p>
<p><strong>b) configure_streams</strong></p>
<p>该方法在完成initialize方法之后，在调用process_capture_request方法之前被调用，主要用于重设当前正在运行的Pipeline以及设置新的输入输出流，其中它会将stream_list中的新的数据流替换之前配置的数据流。在调用该方法之前必须确保没有新的request下发并且当前request的动作已经完成，否则会引起无法预测的错误。一旦HAL调用了该方法，则必须在内部配置好满足当前数据流配置的帧率，确保这个流程的运行的顺畅性。</p>
<p>其中包含了两个参数，分别是camera3_device以及stream_list(camera3_stream_configuration_t ),其中第二个参数是上层传入的数据流配置列表，该列表中必须包含至少一个output stream，同时至多包含一个input stream。</p>
<p>另外，谷歌针对该方法有着严格的性能要求，平台厂商在实现该方法的时候，需要在500ms内返回，最长不能超过1000ms。</p>
<p><strong>c) construct_default_request_settings</strong></p>
<p>该方法主要用于构建一系列默认的Camera Usecase的capture 设置项，通过camera_metadata_t来进行描述，其中返回值是一个camera_metadata_t指针，其指向的内存地址是由HAL来进行维护的，同样地，该方法需要在1ms内返回，最长不能超过5ms。</p>
<p><strong>d) process_capture_request</strong></p>
<p>该方法用于下发单次新的capture request到HAL中， 上层必须保证该方法的调用都是在一个线程中完成，而且该方法是异步的，同时其结果并不是通过返回值给到上层，而是通过HAL调用另一个接口process_capture_result()来将结果返回给上层的，在使用的过程中，通过in-flight机制，保证短时间内下发足够多的request，从而满足帧率要求。</p>
<p>该方法的性能依然受到谷歌的严格要求，规定其需要在一帧图像处理完的时长内返回，最长不超过4帧图像处理完成的时长，比如当前预览帧率是30帧，则该方法的操作耗时最长不能超过120ms，否则便会引起明显的帧抖动，从而影响用户体验。</p>
<p><strong>e) dump</strong></p>
<p>该方法用于打印当前Camera设备的状态，一般是由上层通过dumpsys工具输出debug dump信息或者主动抓取bugreport的时候被调用，该方法必须是非阻塞实现，同时需要保证在1ms内返回，最长不能超过10ms。</p>
<p><strong>f) flush</strong></p>
<p>当上层需要执行新的configure_streams的时候，需要调用该方法去尽可能快地清除掉当前已经在处理中的或者即将处理的任务，为配置数据流提供一个相对稳定的环境，其具体工作如下：</p>
<ul>
<li>所有的还在流转的request会尽可能快的返回</li>
<li>并未开始进行流转的request会直接返回，并携带错误信息</li>
<li>任何可以打断的硬件操作会立即被停止</li>
<li>任何无法进行打断的硬件操作会在当前状态下进行休眠</li>
<li>flush会在所有的buffer都得以释放，所有request都成功返回后才真正返回，该方法需要在100ms内返回，最长不能超过1000ms。</li>
</ul>
<p>上面的一系列方法是上层直接对下控制Camera Hal，而一旦Camera Hal产生了数据或者事件的时候，可以通过camera3_callback_ops中定义的回调方法将数据或者事件返回至上层，其结构见下节。</p>
<h3 id="4-4-camera3-callback-ops"><a href="#4-4-camera3-callback-ops" class="headerlink" title="4.4 camera3_callback_ops"></a>4.4 camera3_callback_ops</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">typedef struct camera3_callback_ops &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * process_capture_result:</span><br><span class="line">     *</span><br><span class="line">     * Send results from a completed capture to the framework.</span><br><span class="line">     * process_capture_result() may be invoked multiple times by the HAL in</span><br><span class="line">     * response to a single capture request. This allows, for example, the</span><br><span class="line">     * metadata and low-resolution buffers to be returned in one call, and</span><br><span class="line">     * post-processed JPEG buffers in a later call, once it is available. Each</span><br><span class="line">     * call must include the frame number of the request it is returning</span><br><span class="line">     * metadata or buffers for.</span><br><span class="line">     *</span><br><span class="line">     * A component (buffer or metadata) of the complete result may only be</span><br><span class="line">     * included in one process_capture_result call. A buffer for each stream,</span><br><span class="line">     * and the result metadata, must be returned by the HAL for each request in</span><br><span class="line">     * one of the process_capture_result calls, even in case of errors producing</span><br><span class="line">     * some of the output. A call to process_capture_result() with neither</span><br><span class="line">     * output buffers or result metadata is not allowed.</span><br><span class="line">     *</span><br><span class="line">     * The order of returning metadata and buffers for a single result does not</span><br><span class="line">     * matter, but buffers for a given stream must be returned in FIFO order. So</span><br><span class="line">     * the buffer for request 5 for stream A must always be returned before the</span><br><span class="line">     * buffer for request 6 for stream A. This also applies to the result</span><br><span class="line">     * metadata; the metadata for request 5 must be returned before the metadata</span><br><span class="line">     * for request 6.</span><br><span class="line">     *</span><br><span class="line">     * However, different streams are independent of each other, so it is</span><br><span class="line">     * acceptable and expected that the buffer for request 5 for stream A may be</span><br><span class="line">     * returned after the buffer for request 6 for stream B is. And it is</span><br><span class="line">     * acceptable that the result metadata for request 6 for stream B is</span><br><span class="line">     * returned before the buffer for request 5 for stream A is.</span><br><span class="line">     *</span><br><span class="line">     * The HAL retains ownership of result structure, which only needs to be</span><br><span class="line">     * valid to access during this call. The framework will copy whatever it</span><br><span class="line">     * needs before this call returns.</span><br><span class="line">     *</span><br><span class="line">     * The output buffers do not need to be filled yet; the framework will wait</span><br><span class="line">     * on the stream buffer release sync fence before reading the buffer</span><br><span class="line">     * data. Therefore, this method should be called by the HAL as soon as</span><br><span class="line">     * possible, even if some or all of the output buffers are still in</span><br><span class="line">     * being filled. The HAL must include valid release sync fences into each</span><br><span class="line">     * output_buffers stream buffer entry, or -1 if that stream buffer is</span><br><span class="line">     * already filled.</span><br><span class="line">     *</span><br><span class="line">     * If the result buffer cannot be constructed for a request, the HAL should</span><br><span class="line">     * return an empty metadata buffer, but still provide the output buffers and</span><br><span class="line">     * their sync fences. In addition, notify() must be called with an</span><br><span class="line">     * ERROR_RESULT message.</span><br><span class="line">     *</span><br><span class="line">     * If an output buffer cannot be filled, its status field must be set to</span><br><span class="line">     * STATUS_ERROR. In addition, notify() must be called with a ERROR_BUFFER</span><br><span class="line">     * message.</span><br><span class="line">     *</span><br><span class="line">     * If the entire capture has failed, then this method still needs to be</span><br><span class="line">     * called to return the output buffers to the framework. All the buffer</span><br><span class="line">     * statuses should be STATUS_ERROR, and the result metadata should be an</span><br><span class="line">     * empty buffer. In addition, notify() must be called with a ERROR_REQUEST</span><br><span class="line">     * message. In this case, individual ERROR_RESULT/ERROR_BUFFER messages</span><br><span class="line">     * should not be sent.</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This is a non-blocking call. The framework will return this call in 5ms.</span><br><span class="line">     *</span><br><span class="line">     * The pipeline latency (see S7 for definition) should be less than or equal to</span><br><span class="line">     * 4 frame intervals, and must be less than or equal to 8 frame intervals.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    void (*process_capture_result)(const struct camera3_callback_ops *,</span><br><span class="line">            const camera3_capture_result_t *result);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * notify:</span><br><span class="line">     *</span><br><span class="line">     * Asynchronous notification callback from the HAL, fired for various</span><br><span class="line">     * reasons. Only for information independent of frame capture, or that</span><br><span class="line">     * require specific timing. The ownership of the message structure remains</span><br><span class="line">     * with the HAL, and the msg only needs to be valid for the duration of this</span><br><span class="line">     * call.</span><br><span class="line">     *</span><br><span class="line">     * Multiple threads may call notify() simultaneously.</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">     *</span><br><span class="line">     * The notification for the start of exposure for a given request must be</span><br><span class="line">     * sent by the HAL before the first call to process_capture_result() for</span><br><span class="line">     * that request is made.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">     *</span><br><span class="line">     * Buffers delivered to the framework will not be dispatched to the</span><br><span class="line">     * application layer until a start of exposure timestamp (or input image&apos;s</span><br><span class="line">     * start of exposure timestamp for a reprocess request) has been received</span><br><span class="line">     * via a SHUTTER notify() call. It is highly recommended to dispatch this</span><br><span class="line">     * call as early as possible.</span><br><span class="line">     *</span><br><span class="line">     * ------------------------------------------------------------------------</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     *</span><br><span class="line">     * This is a non-blocking call. The framework will return this call in 5ms.</span><br><span class="line">     */</span><br><span class="line">    void (*notify)(const struct camera3_callback_ops *,</span><br><span class="line">            const camera3_notify_msg_t *msg);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * request_stream_buffers:</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span><br><span class="line">     *</span><br><span class="line">     *    DO NOT USE: not defined and must be NULL.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span><br><span class="line">     *</span><br><span class="line">     * Synchronous callback for HAL to ask for output buffer from camera service.</span><br><span class="line">     *</span><br><span class="line">     * This call may be serialized in camera service so it is strongly</span><br><span class="line">     * recommended to only call this method from one thread.</span><br><span class="line">     *</span><br><span class="line">     * When camera device advertises</span><br><span class="line">     * (android.info.supportedBufferManagementVersion ==</span><br><span class="line">     * ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION_HIDL_DEVICE_3_5), HAL</span><br><span class="line">     * can use this method to request buffers from camera service.</span><br><span class="line">     *</span><br><span class="line">     * Caller is responsible for allocating enough memory for returned_buf_reqs</span><br><span class="line">     * argument (num_buffer_reqs * sizeof(camera3_stream_buffer_ret_t)) bytes</span><br><span class="line">     * and also the memory for the output_buffers field in each</span><br><span class="line">     * camera3_stream_buffer_ret_t</span><br><span class="line">     * (num_buffers_requested * sizeof(camera3_stream_buffer_t)) bytes</span><br><span class="line">     *</span><br><span class="line">     * Performance requirements:</span><br><span class="line">     * This is a blocking call that takes more time with more buffers requested.</span><br><span class="line">     * HAL should not request large amount of buffers on a latency critical code</span><br><span class="line">     * path. It is highly recommended to use a dedicated thread to perform</span><br><span class="line">     * all requestStreamBuffer calls, and adjust the thread priority and/or</span><br><span class="line">     * timing of making the call in order for buffers to arrive before HAL is</span><br><span class="line">     * ready to fill the buffer.</span><br><span class="line">     */</span><br><span class="line">    camera3_buffer_request_status_t (*request_stream_buffers)(</span><br><span class="line">            const struct camera3_callback_ops *,</span><br><span class="line">            uint32_t num_buffer_reqs,</span><br><span class="line">            const camera3_buffer_request_t *buffer_reqs,</span><br><span class="line">            /*out*/uint32_t *num_returned_buf_reqs,</span><br><span class="line">            /*out*/camera3_stream_buffer_ret_t *returned_buf_reqs);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * return_stream_buffers:</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span><br><span class="line">     *</span><br><span class="line">     *    DO NOT USE: not defined and must be NULL.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span><br><span class="line">     *</span><br><span class="line">     * Synchronous callback for HAL to return output buffers to camera service.</span><br><span class="line">     *</span><br><span class="line">     * If this method is called during a configure_streams() call, it will be</span><br><span class="line">     * blocked until camera service finishes the ongoing configure_streams() call.</span><br><span class="line">     */</span><br><span class="line">    void (*return_stream_buffers)(</span><br><span class="line">            const struct camera3_callback_ops *,</span><br><span class="line">            uint32_t num_buffers,</span><br><span class="line">            const camera3_stream_buffer_t* const* buffers);</span><br><span class="line"></span><br><span class="line">&#125; camera3_callback_ops_t;</span><br></pre></td></tr></table></figure>
<p>其中常用的回调方法主要有两个：用于返回数据的process_capture_result以及用于返回事件的notify，接下来分别介绍下：</p>
<p><strong>a) process_capture_result</strong></p>
<p>该方法用于返回HAL部分产生的metadata和image buffers，它与request是多对一的关系，同一个request，可能会对应到多个result，比如可以通过调用一次该方法用于返回metadata以及低分辨率的图像数据，再调用一次该方法用于返回jpeg格式的拍照数据，而这两次调用时对应于同一个process_capture_request动作。</p>
<p>同一个Request的Metadata以及Image Buffers的先后顺序无关紧要，但是同一个数据流的不同Request之间的Result必须严格按照Request的下发先后顺序进行依次返回的，如若不然，会导致图像数据显示出现顺序错乱的情况。</p>
<p>该方法是非阻塞的，而且并且必须要在5ms内返回。</p>
<p><strong>b) notify</strong></p>
<p>该方法用于异步返回HAL事件到上层，必须非阻塞实现，而且要在5ms内返回。</p>
<h3 id="4-5-camera3-stream-configuration"><a href="#4-5-camera3-stream-configuration" class="headerlink" title="4.5 camera3_stream_configuration"></a>4.5 camera3_stream_configuration</h3><p>[-&gt;hardware/libhardware/include/hardware/camera3.h]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * camera3_stream_configuration_t:</span><br><span class="line"> *</span><br><span class="line"> * A structure of stream definitions, used by configure_streams(). This</span><br><span class="line"> * structure defines all the output streams and the reprocessing input</span><br><span class="line"> * stream for the current camera use case.</span><br><span class="line"> */</span><br><span class="line">typedef struct camera3_stream_configuration &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The total number of streams requested by the framework.  This includes</span><br><span class="line">     * both input and output streams. The number of streams will be at least 1,</span><br><span class="line">     * and there will be at least one output-capable stream.</span><br><span class="line">     */</span><br><span class="line">    uint32_t num_streams;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * An array of camera stream pointers, defining the input/output</span><br><span class="line">     * configuration for the camera HAL device.</span><br><span class="line">     *</span><br><span class="line">     * At most one input-capable stream may be defined (INPUT or BIDIRECTIONAL)</span><br><span class="line">     * in a single configuration.</span><br><span class="line">     *</span><br><span class="line">     * At least one output-capable stream must be defined (OUTPUT or</span><br><span class="line">     * BIDIRECTIONAL).</span><br><span class="line">     */</span><br><span class="line">    camera3_stream_t **streams;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_3:</span><br><span class="line">     *</span><br><span class="line">     * The operation mode of streams in this configuration, one of the value</span><br><span class="line">     * defined in camera3_stream_configuration_mode_t.  The HAL can use this</span><br><span class="line">     * mode as an indicator to set the stream property (e.g.,</span><br><span class="line">     * camera3_stream-&gt;max_buffers) appropriately. For example, if the</span><br><span class="line">     * configuration is</span><br><span class="line">     * CAMERA3_STREAM_CONFIGURATION_CONSTRAINED_HIGH_SPEED_MODE, the HAL may</span><br><span class="line">     * want to set aside more buffers for batch mode operation (see</span><br><span class="line">     * android.control.availableHighSpeedVideoConfigurations for batch mode</span><br><span class="line">     * definition).</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    uint32_t operation_mode;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_5:</span><br><span class="line">     *</span><br><span class="line">     * The session metadata buffer contains the initial values of</span><br><span class="line">     * ANDROID_REQUEST_AVAILABLE_SESSION_KEYS. This field is optional</span><br><span class="line">     * and camera clients can choose to ignore it, in which case it will</span><br><span class="line">     * be set to NULL. If parameters are present, then Hal should examine</span><br><span class="line">     * the parameter values and configure its internal camera pipeline</span><br><span class="line">     * accordingly.</span><br><span class="line">     */</span><br><span class="line">    const camera_metadata_t *session_parameters;</span><br><span class="line">&#125; camera3_stream_configuration_t;</span><br></pre></td></tr></table></figure>
<p>该结构体主要用来代表配置的数据流列表，内部装有上层需要进行配置的数据流的指针，内部的定义简单介绍下：</p>
<ul>
<li><p>num_streams: 代表了来自上层的数据流的数量，其中包括了output以及input stream。</p>
</li>
<li><p>streams: 是streams的指针数组，包括了至少一条output stream以及至多一条input stream。</p>
</li>
<li><p>operation_mode: 当前数据流的操作模式，该模式在camera3_stream_configuration_mode_t中被定义，HAL通过这个参数可以针对streams做不同的设置。</p>
</li>
<li><p>session_parameters: 该参数可以作为缺省参数，直接设置为NULL即可，CAMERA_DEVICE_API_VERSION_3_5以上的版本才支持。</p>
</li>
</ul>
<h3 id="4-6-camera3-stream"><a href="#4-6-camera3-stream" class="headerlink" title="4.6 camera3_stream"></a>4.6 camera3_stream</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * camera3_stream_t:</span><br><span class="line"> *</span><br><span class="line"> * A handle to a single camera input or output stream. A stream is defined by</span><br><span class="line"> * the framework by its buffer resolution and format, and additionally by the</span><br><span class="line"> * HAL with the gralloc usage flags and the maximum in-flight buffer count.</span><br><span class="line"> *</span><br><span class="line"> * The stream structures are owned by the framework, but pointers to a</span><br><span class="line"> * camera3_stream passed into the HAL by configure_streams() are valid until the</span><br><span class="line"> * end of the first subsequent configure_streams() call that _does not_ include</span><br><span class="line"> * that camera3_stream as an argument, or until the end of the close() call.</span><br><span class="line"> *</span><br><span class="line"> * All camera3_stream framework-controlled members are immutable once the</span><br><span class="line"> * camera3_stream is passed into configure_streams().  The HAL may only change</span><br><span class="line"> * the HAL-controlled parameters during a configure_streams() call, except for</span><br><span class="line"> * the contents of the private pointer.</span><br><span class="line"> *</span><br><span class="line"> * If a configure_streams() call returns a non-fatal error, all active streams</span><br><span class="line"> * remain valid as if configure_streams() had not been called.</span><br><span class="line"> *</span><br><span class="line"> * The endpoint of the stream is not visible to the camera HAL device.</span><br><span class="line"> * In DEVICE_API_VERSION_3_1, this was changed to share consumer usage flags</span><br><span class="line"> * on streams where the camera is a producer (OUTPUT and BIDIRECTIONAL stream</span><br><span class="line"> * types) see the usage field below.</span><br><span class="line"> */</span><br><span class="line">typedef struct camera3_stream &#123;</span><br><span class="line"></span><br><span class="line">    /*****</span><br><span class="line">     * Set by framework before configure_streams()</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The type of the stream, one of the camera3_stream_type_t values.</span><br><span class="line">     */</span><br><span class="line">    int stream_type;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The width in pixels of the buffers in this stream</span><br><span class="line">     */</span><br><span class="line">    uint32_t width;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The height in pixels of the buffers in this stream</span><br><span class="line">     */</span><br><span class="line">    uint32_t height;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The pixel format for the buffers in this stream. Format is a value from</span><br><span class="line">     * the HAL_PIXEL_FORMAT_* list in system/core/include/system/graphics.h, or</span><br><span class="line">     * from device-specific headers.</span><br><span class="line">     *</span><br><span class="line">     * If HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED is used, then the platform</span><br><span class="line">     * gralloc module will select a format based on the usage flags provided by</span><br><span class="line">     * the camera device and the other endpoint of the stream.</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">     *</span><br><span class="line">     * The camera HAL device must inspect the buffers handed to it in the</span><br><span class="line">     * subsequent register_stream_buffers() call to obtain the</span><br><span class="line">     * implementation-specific format details, if necessary.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">     *</span><br><span class="line">     * register_stream_buffers() won&apos;t be called by the framework, so the HAL</span><br><span class="line">     * should configure the ISP and sensor pipeline based purely on the sizes,</span><br><span class="line">     * usage flags, and formats for the configured streams.</span><br><span class="line">     */</span><br><span class="line">    int format;</span><br><span class="line"></span><br><span class="line">    /*****</span><br><span class="line">     * Set by HAL during configure_streams().</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The gralloc usage flags for this stream, as needed by the HAL. The usage</span><br><span class="line">     * flags are defined in gralloc.h (GRALLOC_USAGE_*), or in device-specific</span><br><span class="line">     * headers.</span><br><span class="line">     *</span><br><span class="line">     * For output streams, these are the HAL&apos;s producer usage flags. For input</span><br><span class="line">     * streams, these are the HAL&apos;s consumer usage flags. The usage flags from</span><br><span class="line">     * the producer and the consumer will be combined together and then passed</span><br><span class="line">     * to the platform gralloc HAL module for allocating the gralloc buffers for</span><br><span class="line">     * each stream.</span><br><span class="line">     *</span><br><span class="line">     * Version information:</span><br><span class="line">     *</span><br><span class="line">     * == CAMERA_DEVICE_API_VERSION_3_0:</span><br><span class="line">     *</span><br><span class="line">     *   No initial value guaranteed when passed via configure_streams().</span><br><span class="line">     *   HAL may not use this field as input, and must write over this field</span><br><span class="line">     *   with its usage flags.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">     *</span><br><span class="line">     *   For stream_type OUTPUT and BIDIRECTIONAL, when passed via</span><br><span class="line">     *   configure_streams(), the initial value of this is the consumer&apos;s</span><br><span class="line">     *   usage flags.  The HAL may use these consumer flags to decide stream</span><br><span class="line">     *   configuration.</span><br><span class="line">     *   For stream_type INPUT, when passed via configure_streams(), the initial</span><br><span class="line">     *   value of this is 0.</span><br><span class="line">     *   For all streams passed via configure_streams(), the HAL must write</span><br><span class="line">     *   over this field with its usage flags.</span><br><span class="line">     *</span><br><span class="line">     *   From Android O, the usage flag for an output stream may be bitwise</span><br><span class="line">     *   combination of usage flags for multiple consumers, for the purpose of</span><br><span class="line">     *   sharing one camera stream between those consumers. The HAL must fail</span><br><span class="line">     *   configure_streams call with -EINVAL if the combined flags cannot be</span><br><span class="line">     *   supported due to imcompatible buffer format, dataSpace, or other hardware</span><br><span class="line">     *   limitations.</span><br><span class="line">     */</span><br><span class="line">    uint32_t usage;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The maximum number of buffers the HAL device may need to have dequeued at</span><br><span class="line">     * the same time. The HAL device may not have more buffers in-flight from</span><br><span class="line">     * this stream than this value.</span><br><span class="line">     */</span><br><span class="line">    uint32_t max_buffers;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A handle to HAL-private information for the stream. Will not be inspected</span><br><span class="line">     * by the framework code.</span><br><span class="line">     */</span><br><span class="line">    void *priv;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A field that describes the contents of the buffer. The format and buffer</span><br><span class="line">     * dimensions define the memory layout and structure of the stream buffers,</span><br><span class="line">     * while dataSpace defines the meaning of the data within the buffer.</span><br><span class="line">     *</span><br><span class="line">     * For most formats, dataSpace defines the color space of the image data.</span><br><span class="line">     * In addition, for some formats, dataSpace indicates whether image- or</span><br><span class="line">     * depth-based data is requested.  See system/core/include/system/graphics.h</span><br><span class="line">     * for details of formats and valid dataSpace values for each format.</span><br><span class="line">     *</span><br><span class="line">     * Version information:</span><br><span class="line">     *</span><br><span class="line">     * &lt; CAMERA_DEVICE_API_VERSION_3_3:</span><br><span class="line">     *</span><br><span class="line">     *   Not defined and should not be accessed. dataSpace should be assumed to</span><br><span class="line">     *   be HAL_DATASPACE_UNKNOWN, and the appropriate color space, etc, should</span><br><span class="line">     *   be determined from the usage flags and the format.</span><br><span class="line">     *</span><br><span class="line">     * = CAMERA_DEVICE_API_VERSION_3_3:</span><br><span class="line">     *</span><br><span class="line">     *   Always set by the camera service. HAL must use this dataSpace to</span><br><span class="line">     *   configure the stream to the correct colorspace, or to select between</span><br><span class="line">     *   color and depth outputs if supported. The dataspace values are the</span><br><span class="line">     *   legacy definitions in graphics.h</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_4:</span><br><span class="line">     *</span><br><span class="line">     *   Always set by the camera service. HAL must use this dataSpace to</span><br><span class="line">     *   configure the stream to the correct colorspace, or to select between</span><br><span class="line">     *   color and depth outputs if supported. The dataspace values are set</span><br><span class="line">     *   using the V0 dataspace definitions in graphics.h</span><br><span class="line">     */</span><br><span class="line">    android_dataspace_t data_space;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The required output rotation of the stream, one of</span><br><span class="line">     * the camera3_stream_rotation_t values. This must be inspected by HAL along</span><br><span class="line">     * with stream width and height. For example, if the rotation is 90 degree</span><br><span class="line">     * and the stream width and height is 720 and 1280 respectively, camera service</span><br><span class="line">     * will supply buffers of size 720x1280, and HAL should capture a 1280x720 image</span><br><span class="line">     * and rotate the image by 90 degree counterclockwise. The rotation field is</span><br><span class="line">     * no-op when the stream type is input. Camera HAL must ignore the rotation</span><br><span class="line">     * field for an input stream.</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">     *</span><br><span class="line">     *    Not defined and must not be accessed. HAL must not apply any rotation</span><br><span class="line">     *    on output images.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_3:</span><br><span class="line">     *</span><br><span class="line">     *    Always set by camera service. HAL must inspect this field during stream</span><br><span class="line">     *    configuration and returns -EINVAL if HAL cannot perform such rotation.</span><br><span class="line">     *    HAL must always support CAMERA3_STREAM_ROTATION_0, so a</span><br><span class="line">     *    configure_streams() call must not fail for unsupported rotation if</span><br><span class="line">     *    rotation field of all streams is CAMERA3_STREAM_ROTATION_0.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    int rotation;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The physical camera id this stream belongs to.</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERISON_3_4:</span><br><span class="line">     *</span><br><span class="line">     *    Not defined and must not be accessed.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERISON_3_5:</span><br><span class="line">     *</span><br><span class="line">     *    Always set by camera service. If the camera device is not a logical</span><br><span class="line">     *    multi camera, or if the camera is a logical multi camera but the stream</span><br><span class="line">     *    is not a physical output stream, this field will point to a 0-length</span><br><span class="line">     *    string.</span><br><span class="line">     *</span><br><span class="line">     *    A logical multi camera is a camera device backed by multiple physical</span><br><span class="line">     *    cameras that are also exposed to the application. And for a logical</span><br><span class="line">     *    multi camera, a physical output stream is an output stream specifically</span><br><span class="line">     *    requested on an underlying physical camera.</span><br><span class="line">     *</span><br><span class="line">     *    For an input stream, this field is guaranteed to be a 0-length string.</span><br><span class="line">     */</span><br><span class="line">    const char* physical_camera_id;</span><br><span class="line"></span><br><span class="line">    /* reserved for future use */</span><br><span class="line">    void *reserved[6];</span><br><span class="line"></span><br><span class="line">&#125; camera3_stream_t;</span><br></pre></td></tr></table></figure>
<p>该结构体主要用来代表具体的数据流实体，在整个的配置过程中，需要在上层进行填充，当下发到HAL中后，HAL会针对其中的各项属性进行配置，这里便简单介绍下其内部的各个元素的意义：</p>
<ul>
<li>stream_type: 表示数据流的类型，类型在camera3_stream_type_t中被定义。</li>
<li>width： 表示当前数据流中的buffer的宽度。</li>
<li>height: 表示当前数据流中buffer的高度。</li>
<li>format: 表示当前数据流中buffer的格式，该格式是在system/core/include/system/graphics.h中被定义。</li>
<li>usage： 表示当前数据流的gralloc用法，其用法定义在gralloc.h中。</li>
<li>max_buffers： 指定了当前数据流中可能支持的最大数据buffer数量。</li>
<li>data_space: 指定了当前数据流buffer中存储的图像数据的颜色空间。</li>
<li>rotation：指定了当前数据流的输出buffer的旋转角度，其角度的定义在camera3_stream_rotation_t中，该参数由Camera Service进行设置，必须在HAL中进行设置，该参数对于input stream并没有效果。</li>
<li>physical_camera_id： 指定了当前数据流从属的物理camera Id。</li>
</ul>
<h3 id="4-7-camera3-stream-buffer"><a href="#4-7-camera3-stream-buffer" class="headerlink" title="4.7 camera3_stream_buffer"></a>4.7 camera3_stream_buffer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * camera3_stream_buffer_t:</span><br><span class="line"> *</span><br><span class="line"> * A single buffer from a camera3 stream. It includes a handle to its parent</span><br><span class="line"> * stream, the handle to the gralloc buffer itself, and sync fences</span><br><span class="line"> *</span><br><span class="line"> * The buffer does not specify whether it is to be used for input or output;</span><br><span class="line"> * that is determined by its parent stream type and how the buffer is passed to</span><br><span class="line"> * the HAL device.</span><br><span class="line"> */</span><br><span class="line">typedef struct camera3_stream_buffer &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The handle of the stream this buffer is associated with</span><br><span class="line">     */</span><br><span class="line">    camera3_stream_t *stream;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The native handle to the buffer</span><br><span class="line">     */</span><br><span class="line">    buffer_handle_t *buffer;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Current state of the buffer, one of the camera3_buffer_status_t</span><br><span class="line">     * values. The framework will not pass buffers to the HAL that are in an</span><br><span class="line">     * error state. In case a buffer could not be filled by the HAL, it must</span><br><span class="line">     * have its status set to CAMERA3_BUFFER_STATUS_ERROR when returned to the</span><br><span class="line">     * framework with process_capture_result().</span><br><span class="line">     */</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The acquire sync fence for this buffer. The HAL must wait on this fence</span><br><span class="line">     * fd before attempting to read from or write to this buffer.</span><br><span class="line">     *</span><br><span class="line">     * The framework may be set to -1 to indicate that no waiting is necessary</span><br><span class="line">     * for this buffer.</span><br><span class="line">     *</span><br><span class="line">     * When the HAL returns an output buffer to the framework with</span><br><span class="line">     * process_capture_result(), the acquire_fence must be set to -1. If the HAL</span><br><span class="line">     * never waits on the acquire_fence due to an error in filling a buffer,</span><br><span class="line">     * when calling process_capture_result() the HAL must set the release_fence</span><br><span class="line">     * of the buffer to be the acquire_fence passed to it by the framework. This</span><br><span class="line">     * will allow the framework to wait on the fence before reusing the buffer.</span><br><span class="line">     *</span><br><span class="line">     * For input buffers, the HAL must not change the acquire_fence field during</span><br><span class="line">     * the process_capture_request() call.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">     *</span><br><span class="line">     * When the HAL returns an input buffer to the framework with</span><br><span class="line">     * process_capture_result(), the acquire_fence must be set to -1. If the HAL</span><br><span class="line">     * never waits on input buffer acquire fence due to an error, the sync</span><br><span class="line">     * fences should be handled similarly to the way they are handled for output</span><br><span class="line">     * buffers.</span><br><span class="line">     */</span><br><span class="line">     int acquire_fence;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The release sync fence for this buffer. The HAL must set this fence when</span><br><span class="line">     * returning buffers to the framework, or write -1 to indicate that no</span><br><span class="line">     * waiting is required for this buffer.</span><br><span class="line">     *</span><br><span class="line">     * For the output buffers, the fences must be set in the output_buffers</span><br><span class="line">     * array passed to process_capture_result().</span><br><span class="line">     *</span><br><span class="line">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">     *</span><br><span class="line">     * For the input buffer, the release fence must be set by the</span><br><span class="line">     * process_capture_request() call.</span><br><span class="line">     *</span><br><span class="line">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">     *</span><br><span class="line">     * For the input buffer, the fences must be set in the input_buffer</span><br><span class="line">     * passed to process_capture_result().</span><br><span class="line">     *</span><br><span class="line">     * After signaling the release_fence for this buffer, the HAL</span><br><span class="line">     * should not make any further attempts to access this buffer as the</span><br><span class="line">     * ownership has been fully transferred back to the framework.</span><br><span class="line">     *</span><br><span class="line">     * If a fence of -1 was specified then the ownership of this buffer</span><br><span class="line">     * is transferred back immediately upon the call of process_capture_result.</span><br><span class="line">     */</span><br><span class="line">    int release_fence;</span><br><span class="line"></span><br><span class="line">&#125; camera3_stream_buffer_t;</span><br></pre></td></tr></table></figure>
<p>该结构体主要用来代表具体的buffer对象，其中重要元素如下：</p>
<ul>
<li>stream: 代表了从属的数据流</li>
<li>buffer：buffer句柄</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>谷歌为了将系统框架和平台厂商的自定义部分相分离，在Android上推出了Treble项目，该项目直接将平台厂商的实现部分放入vendor分区中进行管理，进而与system分区保持隔离，这样便可以在相互独立的空间中进行各自的迭代升级，而互不干扰，而在相机框架体系中，便将Camera HAL Module从Camera Service中解耦出来，放入独立进程Camera Provider中进行管理，而为了更好的进行跨进程访问，谷歌针对Provider提出了HIDL机制用于Camera Servic对于Camera Provier的访问，而HIDL接口的实现是在Camera Provider中实现，针对Camera HAL Module的控制又是通过谷歌制定的Camera HAL3接口来完成，所以由此看来，<strong>Provider的职责也比较简单，通过HIDL机制保持与Camera Service的通信，通过HAL3接口控制着Camera HAL Module。</strong></p>

      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android-Camera/" rel="tag">#Android Camera</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/深入理解Android Camera架构二-服务层/" rel="next" title="深入理解Android Camera架构二-服务层">
                <i class="fa fa-chevron-left"></i> 深入理解Android Camera架构二-服务层
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/深入理解Android Camera架构四-高通CamX-CHI/" rel="prev" title="深入理解Android Camera架构四-高通CamX-CHI">
                深入理解Android Camera架构四-高通CamX-CHI <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">44</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Camera-HIDL接口"><span class="nav-text">二、Camera HIDL接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-ICameraProvider-hal"><span class="nav-text">2.1 ICameraProvider.hal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-ICameraProviderCallback-hal"><span class="nav-text">2.2 ICameraProviderCallback.hal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-ICameraDevice-ha"><span class="nav-text">2.3 ICameraDevice.ha</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-ICameraDeviceCallback-hal"><span class="nav-text">2.4 ICameraDeviceCallback.hal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-ICameraDeviceSession-hal"><span class="nav-text">2.5 ICameraDeviceSession.hal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-、Camera-Provider-主程序"><span class="nav-text">三 、Camera Provider 主程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-android-hardware-camera-provider-2-4-service-64-rc"><span class="nav-text">3.1 android.hardware.camera.provider@2.4-service_64.rc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-service-cpp"><span class="nav-text">3.2 service.cpp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-CameraProvider-2-4-cpp"><span class="nav-text">3.3 CameraProvider_2_4.cpp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-LegacyCameraProviderImpl-2-4初始化"><span class="nav-text">3.4 LegacyCameraProviderImpl_2_4初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-获取CameraDevice"><span class="nav-text">3.5 获取CameraDevice</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-getCameraDeviceInterface-V3-x"><span class="nav-text">3.5.1 getCameraDeviceInterface_V3_x</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-new-CameraDevice"><span class="nav-text">3.5.2 new CameraDevice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-deviceImpl-gt-getInterface"><span class="nav-text">3.5.3 deviceImpl-&gt;getInterface</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-open"><span class="nav-text">3.6 open</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-CameraDevice-open"><span class="nav-text">3.6.1 CameraDevice::open</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-createSession"><span class="nav-text">3.6.2 createSession</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-new-CameraDeviceSession"><span class="nav-text">3.6.3 new CameraDeviceSession</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-4-CameraDeviceSession-initialize"><span class="nav-text">3.6.4 CameraDeviceSession::initialize</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-configureStreams"><span class="nav-text">3.7 configureStreams</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1-TrampolineSessionInterface-3-2-configureStreams"><span class="nav-text">3.7.1 TrampolineSessionInterface_3_2::configureStreams</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-2-CameraDeviceSession-configureStreams"><span class="nav-text">3.7.2 CameraDeviceSession::configureStreams</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-总结"><span class="nav-text">3.8 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Camera-HAL3接口"><span class="nav-text">四、Camera HAL3接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-camera-module-t"><span class="nav-text">4.1 camera_module_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-camera3-device-t"><span class="nav-text">4.2 camera3_device_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-camera3-device-ops"><span class="nav-text">4.3 camera3_device_ops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-camera3-callback-ops"><span class="nav-text">4.4 camera3_callback_ops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-camera3-stream-configuration"><span class="nav-text">4.5 camera3_stream_configuration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-camera3-stream"><span class="nav-text">4.6 camera3_stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-camera3-stream-buffer"><span class="nav-text">4.7 camera3_stream_buffer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、总结"><span class="nav-text">五、总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2024/深入理解Android Camera架构三-硬件抽象层/';
      var disqus_title = "深入理解Android Camera架构三-硬件抽象层";
      var disqus_url = 'http://zproo.github.io/2024/深入理解Android Camera架构三-硬件抽象层/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
