<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Android Camera,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="一、概述Camera Service被设计成一个独立进程，作为一个服务端，处理来自Camera Framework 客户端的跨进程请求，并在内部进行一定的操作，随后作为客户端将请求再一次发送至作为服务端的Camera Provider，整个流程涉及到了两个跨进程操作，前者通过AIDL机制实现，后者通过HIDL机制实现，由于在于Camera Provider通信的过程中，Service是作为客户端存">
<meta name="keywords" content="Android Camera">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Android Camera架构二-服务层">
<meta property="og:url" content="http://zproo.github.io/2024/深入理解Android Camera架构二-服务层/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="一、概述Camera Service被设计成一个独立进程，作为一个服务端，处理来自Camera Framework 客户端的跨进程请求，并在内部进行一定的操作，随后作为客户端将请求再一次发送至作为服务端的Camera Provider，整个流程涉及到了两个跨进程操作，前者通过AIDL机制实现，后者通过HIDL机制实现，由于在于Camera Provider通信的过程中，Service是作为客户端存">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构二-服务层/cameraframworkaidl.png">
<meta property="og:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构二-服务层/cameraaidlinterface.png">
<meta property="og:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构二-服务层/cameraserverstart.png">
<meta property="og:updated_time" content="2024-02-08T08:49:51.792Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Android Camera架构二-服务层">
<meta name="twitter:description" content="一、概述Camera Service被设计成一个独立进程，作为一个服务端，处理来自Camera Framework 客户端的跨进程请求，并在内部进行一定的操作，随后作为客户端将请求再一次发送至作为服务端的Camera Provider，整个流程涉及到了两个跨进程操作，前者通过AIDL机制实现，后者通过HIDL机制实现，由于在于Camera Provider通信的过程中，Service是作为客户端存">
<meta name="twitter:image" content="http://zproo.github.io/2024/深入理解Android%20Camera架构二-服务层/cameraframworkaidl.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2024/深入理解Android Camera架构二-服务层/">

  <title> 深入理解Android Camera架构二-服务层 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/Android-Camera/" rel="tag" title="Android Camera">Android Camera</a>
      
      </div>
      <h1>深入理解Android Camera架构二-服务层</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2024-02-20T21:18:23+08:00" content="2024-02-20" title="2024-02-20 21:18:23">
          2024-02-20
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解Android Camera架构二-服务层
              
            
          </h1>
        

        <div class="post-meta">
		  

          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2024-02-20T21:18:23+08:00" content="2024-02-20">
              2024-02-20
            </time>
          </span>

          

          <!--  -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Camera Service被设计成一个独立进程，作为一个服务端，处理来自Camera Framework 客户端的跨进程请求，并在内部进行一定的操作，随后作为客户端将请求再一次发送至作为服务端的Camera Provider，整个流程涉及到了两个跨进程操作，前者通过AIDL机制实现，后者通过HIDL机制实现，由于在于Camera Provider通信的过程中，Service是作为客户端存在的，所以此处我们重点关注AIDL以及Camera Service 主程序的实现。</p>
<p><img src="/2024/深入理解Android Camera架构二-服务层/cameraframworkaidl.png" style="zoom:50%;"></p>
<h2 id="二、Camera-AIDL-接口"><a href="#二、Camera-AIDL-接口" class="headerlink" title="二、Camera AIDL 接口"></a>二、Camera AIDL 接口</h2><p>在介绍Camera AIDL之前，不妨来简单了解下何为AIDL，谷歌为什么要实现这么一套机制？</p>
<p>在Android系统中，两个进程通常无法相互访问对方的内存，为了解决该问题，谷歌提出了Messager/广播以及后来的Binder，来解决这个问题，但是如果某个进程需要对另一个进程中进行多线程的并发访问，Messager和广播效果往往不是很好，所以Binder会作为主要实现方式，但是Binder的接口使用起来比较复杂，对开发者特别是初学者并不是很友好，所以为了降低跨进程开发门槛，谷歌开创性地提出了AIDL(自定义语言)机制，主动封装了Binder的实现细节，提供给开发者较为简单的使用接口，极大地提升了广大开发者的开发效率。</p>
<p>按照谷歌的针对AIDL机制的要求，需要服务端创建一系列*.aidl文件，并在其中定义需要提供给客户端的公共接口，并且予以实现，接下来我们来看下几个主要的aidl文件。</p>
<p><img src="/2024/深入理解Android Camera架构二-服务层/cameraaidlinterface.png" style="zoom: 67%;"></p>
<h3 id="2-1-ICameraService-aidl"><a href="#2-1-ICameraService-aidl" class="headerlink" title="2.1 ICameraService.aidl"></a>2.1 ICameraService.aidl</h3><p>ICameraService.aidl定义了ICameraService 接口，实现主要通过CameraService类来实现，主要接口如下：</p>
<ul>
<li>getNumberOfCameras： 获取系统中支持的Camera 个数</li>
<li>connectDevice()：打开一个Camera 设备</li>
<li>addListener(): 添加针对Camera 设备以及闪光灯的监听对象</li>
</ul>
<p>[-&gt;frameworks\av\camera\aidl\android\hardware\ICameraService.aidl]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">interface ICameraService</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * All camera service and device Binder calls may return a</span><br><span class="line">     * ServiceSpecificException with the following error codes</span><br><span class="line">     */</span><br><span class="line">    const int ERROR_PERMISSION_DENIED = 1;</span><br><span class="line">    const int ERROR_ALREADY_EXISTS = 2;</span><br><span class="line">    const int ERROR_ILLEGAL_ARGUMENT = 3;</span><br><span class="line">    const int ERROR_DISCONNECTED = 4;</span><br><span class="line">    const int ERROR_TIMED_OUT = 5;</span><br><span class="line">    const int ERROR_DISABLED = 6;</span><br><span class="line">    const int ERROR_CAMERA_IN_USE = 7;</span><br><span class="line">    const int ERROR_MAX_CAMERAS_IN_USE = 8;</span><br><span class="line">    const int ERROR_DEPRECATED_HAL = 9;</span><br><span class="line">    const int ERROR_INVALID_OPERATION = 10;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Types for getNumberOfCameras</span><br><span class="line">     */</span><br><span class="line">    const int CAMERA_TYPE_BACKWARD_COMPATIBLE = 0;</span><br><span class="line">    const int CAMERA_TYPE_ALL = 1;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Return the number of camera devices available in the system</span><br><span class="line">     */</span><br><span class="line">    int getNumberOfCameras(int type);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fetch basic camera information for a camera device</span><br><span class="line">     */</span><br><span class="line">    CameraInfo getCameraInfo(int cameraId);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Default UID/PID values for non-privileged callers of</span><br><span class="line">     * connect(), connectDevice(), and connectLegacy()</span><br><span class="line">     */</span><br><span class="line">    const int USE_CALLING_UID = -1;</span><br><span class="line">    const int USE_CALLING_PID = -1;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Open a camera device through the old camera API</span><br><span class="line">     */</span><br><span class="line">    ICamera connect(ICameraClient client,</span><br><span class="line">            int cameraId,</span><br><span class="line">            String opPackageName,</span><br><span class="line">            int clientUid, int clientPid);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Open a camera device through the new camera API</span><br><span class="line">     * Only supported for device HAL versions &gt;= 3.2</span><br><span class="line">     */</span><br><span class="line">    ICameraDeviceUser connectDevice(ICameraDeviceCallbacks callbacks,</span><br><span class="line">            String cameraId,</span><br><span class="line">            String opPackageName,</span><br><span class="line">            int clientUid);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * halVersion constant for connectLegacy</span><br><span class="line">     */</span><br><span class="line">    const int CAMERA_HAL_API_VERSION_UNSPECIFIED = -1;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Open a camera device in legacy mode, if supported by the camera module HAL.</span><br><span class="line">     */</span><br><span class="line">    ICamera connectLegacy(ICameraClient client,</span><br><span class="line">            int cameraId,</span><br><span class="line">            int halVersion,</span><br><span class="line">            String opPackageName,</span><br><span class="line">            int clientUid);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Add listener for changes to camera device and flashlight state.</span><br><span class="line">     *</span><br><span class="line">     * Also returns the set of currently-known camera IDs and state of each device.</span><br><span class="line">     * Adding a listener will trigger the torch status listener to fire for all</span><br><span class="line">     * devices that have a flash unit.</span><br><span class="line">     */</span><br><span class="line">    CameraStatus[] addListener(ICameraServiceListener listener);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Remove listener for changes to camera device and flashlight state.</span><br><span class="line">     */</span><br><span class="line">    void removeListener(ICameraServiceListener listener);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Read the static camera metadata for a camera device.</span><br><span class="line">     * Only supported for device HAL versions &gt;= 3.2</span><br><span class="line">     */</span><br><span class="line">    CameraMetadataNative getCameraCharacteristics(String cameraId);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Read in the vendor tag descriptors from the camera module HAL.</span><br><span class="line">     * Intended to be used by the native code of CameraMetadataNative to correctly</span><br><span class="line">     * interpret camera metadata with vendor tags.</span><br><span class="line">     */</span><br><span class="line">    VendorTagDescriptor getCameraVendorTagDescriptor();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Retrieve the vendor tag descriptor cache which can have multiple vendor</span><br><span class="line">     * providers.</span><br><span class="line">     * Intended to be used by the native code of CameraMetadataNative to correctly</span><br><span class="line">     * interpret camera metadata with vendor tags.</span><br><span class="line">     */</span><br><span class="line">    VendorTagDescriptorCache getCameraVendorTagCache();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Read the legacy camera1 parameters into a String</span><br><span class="line">     */</span><br><span class="line">    String getLegacyParameters(int cameraId);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * apiVersion constants for supportsCameraApi</span><br><span class="line">     */</span><br><span class="line">    const int API_VERSION_1 = 1;</span><br><span class="line">    const int API_VERSION_2 = 2;</span><br><span class="line"></span><br><span class="line">    // Determines if a particular API version is supported directly for a cameraId.</span><br><span class="line">    boolean supportsCameraApi(String cameraId, int apiVersion);</span><br><span class="line">    // Determines if a cameraId is a hidden physical camera of a logical multi-camera.</span><br><span class="line">    boolean isHiddenPhysicalCamera(String cameraId);</span><br><span class="line"></span><br><span class="line">    void setTorchMode(String cameraId, boolean enabled, IBinder clientBinder);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Notify the camera service of a system event.  Should only be called from system_server.</span><br><span class="line">     *</span><br><span class="line">     * Callers require the android.permission.CAMERA_SEND_SYSTEM_EVENTS permission.</span><br><span class="line">     */</span><br><span class="line">    const int EVENT_NONE = 0;</span><br><span class="line">    const int EVENT_USER_SWITCHED = 1; // The argument is the set of new foreground user IDs.</span><br><span class="line">    oneway void notifySystemEvent(int eventId, in int[] args);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Notify the camera service of a device physical status change. May only be called from</span><br><span class="line">     * a privileged process.</span><br><span class="line">     *</span><br><span class="line">     * newState is a bitfield consisting of DEVICE_STATE_* values combined together. Valid state</span><br><span class="line">     * combinations are device-specific. At device startup, the camera service will assume the device</span><br><span class="line">     * state is NORMAL until otherwise notified.</span><br><span class="line">     *</span><br><span class="line">     * Callers require the android.permission.CAMERA_SEND_SYSTEM_EVENTS permission.</span><br><span class="line">     */</span><br><span class="line">    oneway void notifyDeviceStateChange(long newState);</span><br><span class="line"></span><br><span class="line">    // Bitfield constants for notifyDeviceStateChange</span><br><span class="line">    // All bits &gt;= 32 are for custom vendor states</span><br><span class="line">    // Written as ints since AIDL does not support long constants.</span><br><span class="line">    const int DEVICE_STATE_NORMAL = 0;</span><br><span class="line">    const int DEVICE_STATE_BACK_COVERED = 1;</span><br><span class="line">    const int DEVICE_STATE_FRONT_COVERED = 2;</span><br><span class="line">    const int DEVICE_STATE_FOLDED = 4;</span><br><span class="line">    const int DEVICE_STATE_LAST_FRAMEWORK_BIT = 0x80000000; // 1 &lt;&lt; 31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-ICameraDeviceCallbacks-aidl"><a href="#2-2-ICameraDeviceCallbacks-aidl" class="headerlink" title="2.2 ICameraDeviceCallbacks.aidl"></a>2.2 ICameraDeviceCallbacks.aidl</h3><p>ICameraDeviceCallbacks.aidl文件中定义了ICameraDeviceCallbacks接口，其实现主要由Framework中的CameraDeviceCallbacks类进行实现，主要接口如下：</p>
<ul>
<li>onResultReceived： 一旦Service收到结果数据，便会调用该接口发送至Framework</li>
<li>onCaptureStarted()： 一旦开始进行图像的采集，便调用该接口将部分信息以及时间戳上传至Framework</li>
<li>onDeviceError(): 一旦发生了错误，通过调用该接口通知Framework</li>
</ul>
<p>[-&gt;frameworks\av\camera\aidl\android\hardware\camera2\ICameraDeviceCallbacks.aidl]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">interface ICameraDeviceCallbacks</span><br><span class="line">&#123;</span><br><span class="line">    // Error codes for onDeviceError</span><br><span class="line">    const int ERROR_CAMERA_INVALID_ERROR = -1; // To indicate all invalid error codes</span><br><span class="line">    const int ERROR_CAMERA_DISCONNECTED = 0;</span><br><span class="line">    const int ERROR_CAMERA_DEVICE = 1;</span><br><span class="line">    const int ERROR_CAMERA_SERVICE = 2;</span><br><span class="line">    const int ERROR_CAMERA_REQUEST = 3;</span><br><span class="line">    const int ERROR_CAMERA_RESULT = 4;</span><br><span class="line">    const int ERROR_CAMERA_BUFFER = 5;</span><br><span class="line">    const int ERROR_CAMERA_DISABLED = 6;</span><br><span class="line"></span><br><span class="line">    oneway void onDeviceError(int errorCode, in CaptureResultExtras resultExtras);</span><br><span class="line">    oneway void onDeviceIdle();</span><br><span class="line">    oneway void onCaptureStarted(in CaptureResultExtras resultExtras, long timestamp);</span><br><span class="line">    oneway void onResultReceived(in CameraMetadataNative result,</span><br><span class="line">                                 in CaptureResultExtras resultExtras,</span><br><span class="line">                                 in PhysicalCaptureResultInfo[] physicalCaptureResultInfos);</span><br><span class="line">    oneway void onPrepared(int streamId);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Repeating request encountered an error and was stopped.</span><br><span class="line">     *</span><br><span class="line">     * @param lastFrameNumber Frame number of the last frame of the streaming request.</span><br><span class="line">     * @param repeatingRequestId the ID of the repeating request being stopped</span><br><span class="line">     */</span><br><span class="line">    oneway void onRepeatingRequestError(in long lastFrameNumber,</span><br><span class="line">                                        in int repeatingRequestId);</span><br><span class="line">    oneway void onRequestQueueEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-ICameraDeviceUser-aidl"><a href="#2-3-ICameraDeviceUser-aidl" class="headerlink" title="2.3 ICameraDeviceUser.aidl"></a>2.3 ICameraDeviceUser.aidl</h3><p>ICameraDeviceUser.aidl定义了ICameraDeviceUser接口，由CameraDeviceClient最终实现，主要接口如下：</p>
<ul>
<li>disconnect： 关闭Camera 设备</li>
<li>submitRequestList：发送request</li>
<li>beginConfigure： 开始配置Camera 设备，需要在所有关于数据流的操作之前</li>
<li>endConfigure： 结束关于Camera 设备的配置，该接口需要在所有Request下发之前被调用</li>
<li>createDefaultRequest： 创建一个具有默认配置的Request</li>
</ul>
<p>[-&gt;frameworks\av\camera\aidl\android\hardware\camera2\ICameraDeviceUser.aidl]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">interface ICameraDeviceUser</span><br><span class="line">&#123;</span><br><span class="line">    void disconnect();</span><br><span class="line"></span><br><span class="line">    const int NO_IN_FLIGHT_REPEATING_FRAMES = -1;</span><br><span class="line"></span><br><span class="line">    SubmitInfo submitRequest(in CaptureRequest request, boolean streaming);</span><br><span class="line">    SubmitInfo submitRequestList(in CaptureRequest[] requestList, boolean streaming);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Cancel the repeating request specified by requestId</span><br><span class="line">     * Returns the frame number of the last frame that will be produced from this</span><br><span class="line">     * repeating request, or NO_IN_FLIGHT_REPEATING_FRAMES if no frames were produced</span><br><span class="line">     * by this repeating request.</span><br><span class="line">     *</span><br><span class="line">     * Repeating request may be stopped by camera device due to an error. Canceling a stopped</span><br><span class="line">     * repeating request will trigger ERROR_ILLEGAL_ARGUMENT.</span><br><span class="line">     */</span><br><span class="line">    long cancelRequest(int requestId);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Begin the device configuration.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * beginConfigure must be called before any call to deleteStream, createStream,</span><br><span class="line">     * or endConfigure.  It is not valid to call this when the device is not idle.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     */</span><br><span class="line">    void beginConfigure();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The standard operating mode for a camera device; all API guarantees are in force</span><br><span class="line">     */</span><br><span class="line">    const int NORMAL_MODE = 0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * High-speed recording mode; only two outputs targeting preview and video recording may be</span><br><span class="line">     * used, and requests must be batched.</span><br><span class="line">     */</span><br><span class="line">    const int CONSTRAINED_HIGH_SPEED_MODE = 1;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Start of custom vendor modes</span><br><span class="line">     */</span><br><span class="line">    const int VENDOR_MODE_START = 0x8000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * End the device configuration.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * endConfigure must be called after stream configuration is complete (i.e. after</span><br><span class="line">     * a call to beginConfigure and subsequent createStream/deleteStream calls).  This</span><br><span class="line">     * must be called before any requests can be submitted.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * @param operatingMode The kind of session to create; either NORMAL_MODE or</span><br><span class="line">     *     CONSTRAINED_HIGH_SPEED_MODE. Must be a non-negative value.</span><br><span class="line">     * @param sessionParams Session wide camera parameters</span><br><span class="line">     */</span><br><span class="line">    void endConfigure(int operatingMode, in CameraMetadataNative sessionParams);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * Check whether a particular session configuration has camera device</span><br><span class="line">      * support.</span><br><span class="line">      *</span><br><span class="line">      * @param sessionConfiguration Specific session configuration to be verified.</span><br><span class="line">      * @return true  - in case the stream combination is supported.</span><br><span class="line">      *         false - in case there is no device support.</span><br><span class="line">      */</span><br><span class="line">    boolean isSessionConfigurationSupported(in SessionConfiguration sessionConfiguration);</span><br><span class="line"></span><br><span class="line">    void deleteStream(int streamId);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create an output stream</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Create an output stream based on the given output configuration&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param outputConfiguration size, format, and other parameters for the stream</span><br><span class="line">     * @return new stream ID</span><br><span class="line">     */</span><br><span class="line">    int createStream(in OutputConfiguration outputConfiguration);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create an input stream</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Create an input stream of width, height, and format&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param width Width of the input buffers</span><br><span class="line">     * @param height Height of the input buffers</span><br><span class="line">     * @param format Format of the input buffers. One of HAL_PIXEL_FORMAT_*.</span><br><span class="line">     *</span><br><span class="line">     * @return new stream ID</span><br><span class="line">     */</span><br><span class="line">    int createInputStream(int width, int height, int format);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get the surface of the input stream.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;It&apos;s valid to call this method only after a stream configuration is completed</span><br><span class="line">     * successfully and the stream configuration includes a input stream.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param surface An output argument for the surface of the input stream buffer queue.</span><br><span class="line">     */</span><br><span class="line">    Surface getInputSurface();</span><br><span class="line"></span><br><span class="line">    // Keep in sync with public API in</span><br><span class="line">    // frameworks/base/core/java/android/hardware/camera2/CameraDevice.java</span><br><span class="line">    const int TEMPLATE_PREVIEW = 1;</span><br><span class="line">    const int TEMPLATE_STILL_CAPTURE = 2;</span><br><span class="line">    const int TEMPLATE_RECORD = 3;</span><br><span class="line">    const int TEMPLATE_VIDEO_SNAPSHOT = 4;</span><br><span class="line">    const int TEMPLATE_ZERO_SHUTTER_LAG = 5;</span><br><span class="line">    const int TEMPLATE_MANUAL = 6;</span><br><span class="line"></span><br><span class="line">    CameraMetadataNative createDefaultRequest(int templateId);</span><br><span class="line"></span><br><span class="line">    CameraMetadataNative getCameraInfo();</span><br><span class="line"></span><br><span class="line">    void waitUntilIdle();</span><br><span class="line"></span><br><span class="line">    long flush();</span><br><span class="line"></span><br><span class="line">    void prepare(int streamId);</span><br><span class="line"></span><br><span class="line">    void tearDown(int streamId);</span><br><span class="line"></span><br><span class="line">    void prepare2(int maxCount, int streamId);</span><br><span class="line"></span><br><span class="line">    void updateOutputConfiguration(int streamId, in OutputConfiguration outputConfiguration);</span><br><span class="line"></span><br><span class="line">    void finalizeOutputConfigurations(int streamId, in OutputConfiguration outputConfiguration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-ICameraServiceListener-aidl"><a href="#2-4-ICameraServiceListener-aidl" class="headerlink" title="2.4 ICameraServiceListener.aidl"></a>2.4 ICameraServiceListener.aidl</h3><p>ICameraServiceListener.aidl定义了ICameraServiceListener接口，由Framework中的CameraManagerGlobal类实现，主要接口如下：</p>
<ul>
<li>onStatusChanged： 用于告知当前Camera 设备的状态的变更</li>
<li>onCameraOpened: 用于告知当前Camera打开</li>
<li>onCameraClosed：用于告知当前Camera关闭</li>
</ul>
<p>[-&gt;frameworks\av\camera\aidl\android\hardware\ICameraServiceListener.aidl]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">interface ICameraServiceListener</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Initial status will be transmitted with onStatusChange immediately</span><br><span class="line">     * after this listener is added to the service listener list.</span><br><span class="line">     *</span><br><span class="line">     * Allowed transitions:</span><br><span class="line">     *</span><br><span class="line">     *     (Any)               -&gt; NOT_PRESENT</span><br><span class="line">     *     NOT_PRESENT         -&gt; PRESENT</span><br><span class="line">     *     NOT_PRESENT         -&gt; ENUMERATING</span><br><span class="line">     *     ENUMERATING         -&gt; PRESENT</span><br><span class="line">     *     PRESENT             -&gt; NOT_AVAILABLE</span><br><span class="line">     *     NOT_AVAILABLE       -&gt; PRESENT</span><br><span class="line">     *</span><br><span class="line">     * A state will never immediately transition back to itself.</span><br><span class="line">     *</span><br><span class="line">     * The enums must match the values in</span><br><span class="line">     * include/hardware/camera_common.h when applicable</span><br><span class="line">     */</span><br><span class="line">    // Device physically unplugged</span><br><span class="line">    const int STATUS_NOT_PRESENT      = 0;</span><br><span class="line">    // Device physically has been plugged in and the camera can be used exclusively</span><br><span class="line">    const int STATUS_PRESENT          = 1;</span><br><span class="line">    // Device physically has been plugged in but it will not be connect-able until enumeration is</span><br><span class="line">    // complete</span><br><span class="line">    const int STATUS_ENUMERATING      = 2;</span><br><span class="line">    // Camera is in use by another app and cannot be used exclusively</span><br><span class="line">    const int STATUS_NOT_AVAILABLE    = -2;</span><br><span class="line"></span><br><span class="line">    // Use to initialize variables only</span><br><span class="line">    const int STATUS_UNKNOWN          = -1;</span><br><span class="line"></span><br><span class="line">    oneway void onStatusChanged(int status, String cameraId);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The torch mode status of a camera.</span><br><span class="line">     *</span><br><span class="line">     * Initial status will be transmitted with onTorchStatusChanged immediately</span><br><span class="line">     * after this listener is added to the service listener list.</span><br><span class="line">     *</span><br><span class="line">     * The enums must match the values in</span><br><span class="line">     * include/hardware/camera_common.h</span><br><span class="line">     */</span><br><span class="line">    // The camera&apos;s torch mode has become not available to use via</span><br><span class="line">    // setTorchMode().</span><br><span class="line">    const int TORCH_STATUS_NOT_AVAILABLE = 0;</span><br><span class="line">    // The camera&apos;s torch mode is off and available to be turned on via</span><br><span class="line">    // setTorchMode().</span><br><span class="line">    const int TORCH_STATUS_AVAILABLE_OFF = 1;</span><br><span class="line">    // The camera&apos;s torch mode is on and available to be turned off via</span><br><span class="line">    // setTorchMode().</span><br><span class="line">    const int TORCH_STATUS_AVAILABLE_ON  = 2;</span><br><span class="line"></span><br><span class="line">    // Use to initialize variables only</span><br><span class="line">    const int TORCH_STATUS_UNKNOWN = -1;</span><br><span class="line"></span><br><span class="line">    oneway void onTorchStatusChanged(int status, String cameraId);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Notify registered clients about camera access priority changes.</span><br><span class="line">     * Clients which were previously unable to open a certain camera device</span><br><span class="line">     * can retry after receiving this callback.</span><br><span class="line">     */</span><br><span class="line">    oneway void onCameraAccessPrioritiesChanged();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Notify registered clients about cameras being opened/closed.</span><br><span class="line">     * Only clients with android.permission.CAMERA_OPEN_CLOSE_LISTENER permission</span><br><span class="line">     * will receive such callbacks.</span><br><span class="line">     */</span><br><span class="line">    oneway void onCameraOpened(String cameraId, String clientPackageId);</span><br><span class="line">    oneway void onCameraClosed(String cameraId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、Camera-Service"><a href="#三、Camera-Service" class="headerlink" title="三、Camera Service"></a>三、Camera Service</h2><p>Camera Service 主程序，是随着系统启动而运行，主要目的是向外暴露AIDL接口给Framework进行调用，同时通过调用Camera Provider的HIDL接口，建立与Provider的通信，并且在内部维护从Framework以及Provider获取到的资源，并且按照一定的框架结构保持整个Service在稳定高效的状态下运行，所以接下来我们主要通过初始化过程以及处理来自应用的请求来详细介绍下。</p>
<h3 id="3-1-启动初始化"><a href="#3-1-启动初始化" class="headerlink" title="3.1 启动初始化"></a>3.1 启动初始化</h3><h4 id="3-1-1-cameraserver-rc"><a href="#3-1-1-cameraserver-rc" class="headerlink" title="3.1.1 cameraserver.rc"></a>3.1.1 cameraserver.rc</h4><p>启动依赖cameraserver.rc配置启动</p>
<p>[-&gt;frameworks\av\camera\cameraserver\cameraserver.rc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service cameraserver /system/bin/cameraserver</span><br><span class="line">    class main</span><br><span class="line">    user cameraserver</span><br><span class="line">    group system audio camera input drmrpc sdcard_rw sdcard_r sdcard_all</span><br><span class="line">    ioprio rt 4</span><br><span class="line">    writepid /dev/cpuset/camera-daemon/tasks /dev/stune/foreground/tasks</span><br><span class="line">    rlimit rtprio 10 10</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2-main-cameraserver-cpp"><a href="#3-1-2-main-cameraserver-cpp" class="headerlink" title="3.1.2 main_cameraserver.cpp"></a>3.1.2 main_cameraserver.cpp</h4><p>执行main_cameraserver中的main函数</p>
<p>[-&gt;frameworks\av\camera\cameraserver\main_cameraserver.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc __unused, char** argv __unused)</span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    // Set 5 threads for HIDL calls. Now cameraserver will serve HIDL calls in</span><br><span class="line">    // addition to consuming them from the Camera HAL as well.</span><br><span class="line">    hardware::configureRpcThreadpool(5, /*willjoin*/ false);</span><br><span class="line">   </span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    ALOGI(&quot;ServiceManager: %p&quot;, sm.get());</span><br><span class="line">    //初始化CameraService</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    ALOGI(&quot;ServiceManager: %p done instantiate&quot;, sm.get());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-CameraService-onFirstRef"><a href="#3-1-3-CameraService-onFirstRef" class="headerlink" title="3.1.3 CameraService::onFirstRef"></a>3.1.3 CameraService::onFirstRef</h4><p>执行instantiate后会调用到CameraService的onFirstRef方法</p>
<p>[-&gt;frameworks\av\services\camera\libcameraservice\CameraService.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void CameraService::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(&quot;CameraService process starting&quot;);</span><br><span class="line"></span><br><span class="line">    BnCameraService::onFirstRef();</span><br><span class="line"></span><br><span class="line">    // Update battery life tracking if service is restarting</span><br><span class="line">    BatteryNotifier&amp; notifier(BatteryNotifier::getInstance());</span><br><span class="line">    notifier.noteResetCamera();</span><br><span class="line">    notifier.noteResetFlashlight();</span><br><span class="line"></span><br><span class="line">    status_t res = INVALID_OPERATION;</span><br><span class="line"></span><br><span class="line">    res = enumerateProviders();</span><br><span class="line">    if (res == OK) &#123;</span><br><span class="line">        mInitialized = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mUidPolicy = new UidPolicy(this);</span><br><span class="line">    mUidPolicy-&gt;registerSelf();</span><br><span class="line">    mSensorPrivacyPolicy = new SensorPrivacyPolicy(this);</span><br><span class="line">    mSensorPrivacyPolicy-&gt;registerSelf();</span><br><span class="line">    //初始化 hidl cameraserver</span><br><span class="line">    sp&lt;HidlCameraService&gt; hcs = HidlCameraService::getInstance(this);</span><br><span class="line">    //用于向hwservicemanager注册IBase对象</span><br><span class="line">    if (hcs-&gt;registerAsService() != android::OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Failed to register default android.frameworks.cameraservice.service@1.0&quot;,</span><br><span class="line">              __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // This needs to be last call in this function, so that it&apos;s as close to</span><br><span class="line">    // ServiceManager::addService() as possible.</span><br><span class="line">    CameraService::pingCameraServiceProxy();</span><br><span class="line">    ALOGI(&quot;CameraService pinged cameraservice proxy&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-4-CameraService-enumerateProviders"><a href="#3-1-4-CameraService-enumerateProviders" class="headerlink" title="3.1.4 CameraService::enumerateProviders"></a>3.1.4 CameraService::enumerateProviders</h4><p>实例化CameraProviderManager对象，并进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraService::enumerateProviders() &#123;</span><br><span class="line">    status_t res;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; deviceIds;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock l(mServiceLock);</span><br><span class="line"></span><br><span class="line">        if (nullptr == mCameraProviderManager.get()) &#123;</span><br><span class="line">            mCameraProviderManager = new CameraProviderManager();</span><br><span class="line">            res = mCameraProviderManager-&gt;initialize(this);</span><br><span class="line">            if (res != OK) &#123;</span><br><span class="line">                ALOGE(&quot;%s: Unable to initialize camera provider manager: %s (%d)&quot;,</span><br><span class="line">                        __FUNCTION__, strerror(-res), res);</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // Setup vendor tags before we call get_camera_info the first time</span><br><span class="line">        // because HAL might need to setup static vendor keys in get_camera_info</span><br><span class="line">        // TODO: maybe put this into CameraProviderManager::initialize()?</span><br><span class="line">        mCameraProviderManager-&gt;setUpVendorTags();</span><br><span class="line"></span><br><span class="line">        if (nullptr == mFlashlight.get()) &#123;</span><br><span class="line">            mFlashlight = new CameraFlashlight(mCameraProviderManager, this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = mFlashlight-&gt;findFlashUnits();</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            ALOGE(&quot;Failed to enumerate flash units: %s (%d)&quot;, strerror(-res), res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deviceIds = mCameraProviderManager-&gt;getCameraDeviceIds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (auto&amp; cameraId : deviceIds) &#123;</span><br><span class="line">        String8 id8 = String8(cameraId.c_str());</span><br><span class="line">        if (getCameraState(id8) == nullptr) &#123;</span><br><span class="line">            onDeviceStatusChanged(id8, CameraDeviceStatus::PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-5-mCameraProviderManager-initialize"><a href="#3-1-5-mCameraProviderManager-initialize" class="headerlink" title="3.1.5 mCameraProviderManager::initialize"></a>3.1.5 mCameraProviderManager::initialize</h4><p>[-&gt;frameworks/av/services/camera/libcameraservice/common/CameraProviderManager.cpp]</p>
<p>CameraProviderManager初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraProviderManager::initialize(wp&lt;CameraProviderManager::StatusListener&gt; listener,</span><br><span class="line">        ServiceInteractionProxy* proxy) &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(mInterfaceMutex);</span><br><span class="line">    if (proxy == nullptr) &#123;</span><br><span class="line">        ALOGE(&quot;%s: No valid service interaction proxy provided&quot;, __FUNCTION__);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    mListener = listener;</span><br><span class="line">    mServiceProxy = proxy;</span><br><span class="line">    mDeviceState = static_cast&lt;hardware::hidl_bitfield&lt;provider::V2_5::DeviceState&gt;&gt;(</span><br><span class="line">        provider::V2_5::DeviceState::NORMAL);</span><br><span class="line"></span><br><span class="line">    // Registering will trigger notifications for all already-known providers</span><br><span class="line">    bool success = mServiceProxy-&gt;registerForNotifications(</span><br><span class="line">        /* instance name, empty means no filter */ &quot;&quot;,</span><br><span class="line">        this);</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to register with hardware service manager for notifications &quot;</span><br><span class="line">                &quot;about camera providers&quot;, __FUNCTION__);</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (const auto&amp; instance : mServiceProxy-&gt;listServices()) &#123;</span><br><span class="line">        this-&gt;addProviderLocked(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-6-addProviderLocked"><a href="#3-1-6-addProviderLocked" class="headerlink" title="3.1.6 addProviderLocked"></a>3.1.6 addProviderLocked</h4><p>[-&gt;frameworks/av/services/camera/libcameraservice/common/CameraProviderManager.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraProviderManager::addProviderLocked(const std::string&amp; newProvider) &#123;</span><br><span class="line">    for (const auto&amp; providerInfo : mProviders) &#123;</span><br><span class="line">        if (providerInfo-&gt;mProviderName == newProvider) &#123;</span><br><span class="line">            ALOGW(&quot;%s: Camera provider HAL with name &apos;%s&apos; already registered&quot;, __FUNCTION__,</span><br><span class="line">                    newProvider.c_str());</span><br><span class="line">            return ALREADY_EXISTS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;provider::V2_4::ICameraProvider&gt; interface;</span><br><span class="line">    //获取ICameraProvider代理</span><br><span class="line">    interface = mServiceProxy-&gt;getService(newProvider);</span><br><span class="line"></span><br><span class="line">    if (interface == nullptr) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Camera provider HAL &apos;%s&apos; is not actually available&quot;, __FUNCTION__,</span><br><span class="line">                newProvider.c_str());</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化ProviderInfo</span><br><span class="line">    sp&lt;ProviderInfo&gt; providerInfo = new ProviderInfo(newProvider, this);</span><br><span class="line">    status_t res = providerInfo-&gt;initialize(interface, mDeviceState);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //ProviderInfo添加到容器进行管理</span><br><span class="line">    mProviders.push_back(providerInfo);</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-7-ProviderInfo-initialize"><a href="#3-1-7-ProviderInfo-initialize" class="headerlink" title="3.1.7 ProviderInfo::initialize"></a>3.1.7 ProviderInfo::initialize</h4><p>[-&gt;frameworks/av/services/camera/libcameraservice/common/CameraProviderManager.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraProviderManager::ProviderInfo::initialize(</span><br><span class="line">        sp&lt;provider::V2_4::ICameraProvider&gt;&amp; interface,</span><br><span class="line">        hardware::hidl_bitfield&lt;provider::V2_5::DeviceState&gt; currentDeviceState) &#123;</span><br><span class="line">    status_t res = parseProviderName(mProviderName, &amp;mType, &amp;mId);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Invalid provider name, ignoring&quot;, __FUNCTION__);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(&quot;Connecting to new camera provider: %s, isRemote? %d&quot;,</span><br><span class="line">            mProviderName.c_str(), interface-&gt;isRemote());</span><br><span class="line"></span><br><span class="line">    // Determine minor version</span><br><span class="line">    auto castResult = provider::V2_5::ICameraProvider::castFrom(interface);</span><br><span class="line">    if (castResult.isOk()) &#123;</span><br><span class="line">        mMinorVersion = 5;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mMinorVersion = 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // cameraDeviceStatusChange callbacks may be called (and causing new devices added)</span><br><span class="line">    // before setCallback returns</span><br><span class="line">    hardware::Return&lt;bool&gt; linked = interface-&gt;linkToDeath(this, /*cookie*/ mId);</span><br><span class="line">    if (!linked.isOk()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Transaction error in linking to camera provider &apos;%s&apos; death: %s&quot;,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str(), linked.description().c_str());</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125; else if (!linked) &#123;</span><br><span class="line">        ALOGW(&quot;%s: Unable to link to provider &apos;%s&apos; death notifications&quot;,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    //ICameraProvider代理保存到内部对象中</span><br><span class="line">    if (!kEnableLazyHal) &#123;</span><br><span class="line">        // Save HAL reference indefinitely</span><br><span class="line">        ALOGE(&quot;Saving Interface&quot;);</span><br><span class="line">        mSavedInterface = interface;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mActiveInterface = interface;</span><br><span class="line">    &#125;</span><br><span class="line">    //注册到Camera Provider中，接收来自Provider的事件回调</span><br><span class="line">    hardware::Return&lt;Status&gt; status = interface-&gt;setCallback(this);</span><br><span class="line">    if (!status.isOk()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Transaction error setting up callbacks with camera provider &apos;%s&apos;: %s&quot;,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str(), status.description().c_str());</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (status != Status::OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to register callbacks with camera provider &apos;%s&apos;&quot;,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str());</span><br><span class="line">        return mapToStatusT(status);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGE(&quot;%s: Setting device state for %s: 0x%&quot; PRIx64,</span><br><span class="line">            __FUNCTION__, mProviderName.c_str(), mDeviceState);</span><br><span class="line">    notifyDeviceStateChange(currentDeviceState);</span><br><span class="line"></span><br><span class="line">    res = setUpVendorTags();</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to set up vendor tags from provider &apos;%s&apos;&quot;,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Get initial list of camera devices, if any</span><br><span class="line">    std::vector&lt;std::string&gt; devices;</span><br><span class="line">    hardware::Return&lt;void&gt; ret = interface-&gt;getCameraIdList([&amp;status, this, &amp;devices](</span><br><span class="line">            Status idStatus,</span><br><span class="line">            const hardware::hidl_vec&lt;hardware::hidl_string&gt;&amp; cameraDeviceNames) &#123;</span><br><span class="line">        status = idStatus;</span><br><span class="line">        if (status == Status::OK) &#123;</span><br><span class="line">            for (auto&amp; name : cameraDeviceNames) &#123;</span><br><span class="line">                uint16_t major, minor;</span><br><span class="line">                std::string type, id;</span><br><span class="line">                status_t res = parseDeviceName(name, &amp;major, &amp;minor, &amp;type, &amp;id);</span><br><span class="line">                if (res != OK) &#123;</span><br><span class="line">                    ALOGE(&quot;%s: Error parsing deviceName: %s: %d&quot;, __FUNCTION__, name.c_str(), res);</span><br><span class="line">                    status = Status::INTERNAL_ERROR;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    devices.push_back(name);</span><br><span class="line">                    mProviderPublicCameraIds.push_back(id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; &#125;);</span><br><span class="line">    if (!ret.isOk()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Transaction error in getting camera ID list from provider &apos;%s&apos;: %s&quot;,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str(), linked.description().c_str());</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (status != Status::OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to query for camera devices from provider &apos;%s&apos;&quot;,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str());</span><br><span class="line">        return mapToStatusT(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = interface-&gt;isSetTorchModeSupported(</span><br><span class="line">        [this](auto status, bool supported) &#123;</span><br><span class="line">            if (status == Status::OK) &#123;</span><br><span class="line">                mSetTorchModeSupported = supported;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    if (!ret.isOk()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Transaction error checking torch mode support &apos;%s&apos;: %s&quot;,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str(), ret.description().c_str());</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsRemote = interface-&gt;isRemote();</span><br><span class="line"></span><br><span class="line">    sp&lt;StatusListener&gt; listener = mManager-&gt;getStatusListener();</span><br><span class="line">    for (auto&amp; device : devices) &#123;</span><br><span class="line">        std::string id;</span><br><span class="line">        status_t res = addDevice(device, common::V1_0::CameraDeviceStatus::PRESENT, &amp;id);</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Unable to enumerate camera device &apos;%s&apos;: %s (%d)&quot;,</span><br><span class="line">                    __FUNCTION__, device.c_str(), strerror(-res), res);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	  // Process cached status callbacks</span><br><span class="line">    std::unique_ptr&lt;std::vector&lt;CameraStatusInfoT&gt;&gt; cachedStatus =</span><br><span class="line">            std::make_unique&lt;std::vector&lt;CameraStatusInfoT&gt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mInitLock);</span><br><span class="line">        for (auto&amp; statusInfo : mCachedStatus) &#123;</span><br><span class="line">            std::string id, physicalId;</span><br><span class="line">            status_t res = OK;</span><br><span class="line">            res = cameraDeviceStatusChangeLocked(&amp;id, statusInfo.cameraId, statusInfo.status);</span><br><span class="line">            if (res == OK) &#123;</span><br><span class="line">                cachedStatus-&gt;emplace_back(statusInfo.isPhysicalCameraStatus,</span><br><span class="line">                        id.c_str(), physicalId.c_str(), statusInfo.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mCachedStatus.clear();</span><br><span class="line">        mInitialized = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGI(&quot;Camera provider %s ready with %zu camera devices&quot;,</span><br><span class="line">            mProviderName.c_str(), mDevices.size());</span><br><span class="line"></span><br><span class="line">    //mInitialized = true;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.1.7 addDevice</p>
<p>添加device</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraProviderManager::ProviderInfo::addDevice(const std::string&amp; name,</span><br><span class="line">        CameraDeviceStatus initialStatus, /*out*/ std::string* parsedId) &#123;</span><br><span class="line"></span><br><span class="line">    ALOGE(&quot;Enumerating new camera device: %s&quot;, name.c_str());</span><br><span class="line"></span><br><span class="line">    uint16_t major, minor;</span><br><span class="line">    std::string type, id;</span><br><span class="line"></span><br><span class="line">    status_t res = parseDeviceName(name, &amp;major, &amp;minor, &amp;type, &amp;id);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        ALOGE(&quot;Parse Failed&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    if (type != mType) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Device type %s does not match provider type %s&quot;, __FUNCTION__,</span><br><span class="line">                type.c_str(), mType.c_str());</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mManager-&gt;isValidDeviceLocked(id, major)) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Device %s: ID %s is already in use for device major version %d&quot;, __FUNCTION__,</span><br><span class="line">                name.c_str(), id.c_str(), major);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;DeviceInfo&gt; deviceInfo;</span><br><span class="line">    ALOGE(&quot;major %d&quot;, major);</span><br><span class="line">    switch (major) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            deviceInfo = initializeDeviceInfo&lt;DeviceInfo1&gt;(name, mProviderTagid,</span><br><span class="line">                    id, minor);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            deviceInfo = initializeDeviceInfo&lt;DeviceInfo3&gt;(name, mProviderTagid,</span><br><span class="line">                    id, minor);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            ALOGE(&quot;%s: Device %s: Unknown HIDL device HAL major version %d:&quot;, __FUNCTION__,</span><br><span class="line">                    name.c_str(), major);</span><br><span class="line">            return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (deviceInfo == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">       ALOGE(&quot;devinfo is NULL&quot;);</span><br><span class="line">       return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    deviceInfo-&gt;mStatus = initialStatus;</span><br><span class="line">    bool isAPI1Compatible = deviceInfo-&gt;isAPI1Compatible();</span><br><span class="line">    ALOGE(&quot;Adding the device&quot;);</span><br><span class="line">    //DeviceInfo3存入容器进行统一管理</span><br><span class="line">    mDevices.push_back(std::move(deviceInfo));</span><br><span class="line"></span><br><span class="line">    mUniqueCameraIds.insert(id);</span><br><span class="line">    if (isAPI1Compatible) &#123;</span><br><span class="line">        // addDevice can be called more than once for the same camera id if HAL</span><br><span class="line">        // supports openLegacy.</span><br><span class="line">        if (std::find(mUniqueAPI1CompatibleCameraIds.begin(), mUniqueAPI1CompatibleCameraIds.end(),</span><br><span class="line">                id) == mUniqueAPI1CompatibleCameraIds.end()) &#123;</span><br><span class="line">            mUniqueAPI1CompatibleCameraIds.push_back(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedId != nullptr) &#123;</span><br><span class="line">        *parsedId = id;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-7-1-initializeDeviceInfo"><a href="#3-1-7-1-initializeDeviceInfo" class="headerlink" title="3.1.7.1 initializeDeviceInfo"></a>3.1.7.1 initializeDeviceInfo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class DeviceInfoT&gt;</span><br><span class="line">std::unique_ptr&lt;CameraProviderManager::ProviderInfo::DeviceInfo&gt;</span><br><span class="line">    CameraProviderManager::ProviderInfo::initializeDeviceInfo(</span><br><span class="line">        const std::string &amp;name, const metadata_vendor_id_t tagId,</span><br><span class="line">        const std::string &amp;id, uint16_t minorVersion) &#123;</span><br><span class="line">    Status status;</span><br><span class="line"></span><br><span class="line">    auto cameraInterface =</span><br><span class="line">            startDeviceInterface&lt;typename DeviceInfoT::InterfaceT&gt;(name);</span><br><span class="line">    if (cameraInterface == nullptr) return nullptr;</span><br><span class="line"></span><br><span class="line">    CameraResourceCost resourceCost;</span><br><span class="line">    cameraInterface-&gt;getResourceCost([&amp;status, &amp;resourceCost](</span><br><span class="line">        Status s, CameraResourceCost cost) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                resourceCost = cost;</span><br><span class="line">            &#125;);</span><br><span class="line">    if (status != Status::OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to obtain resource costs for camera device %s: %s&quot;, __FUNCTION__,</span><br><span class="line">                name.c_str(), statusToString(status));</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; conflictName : resourceCost.conflictingDevices) &#123;</span><br><span class="line">        uint16_t major, minor;</span><br><span class="line">        std::string type, id;</span><br><span class="line">        status_t res = parseDeviceName(conflictName, &amp;major, &amp;minor, &amp;type, &amp;id);</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Failed to parse conflicting device %s&quot;, __FUNCTION__, conflictName.c_str());</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        conflictName = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return std::unique_ptr&lt;DeviceInfo&gt;(</span><br><span class="line">        new DeviceInfoT(name, tagId, id, minorVersion, resourceCost, this,</span><br><span class="line">                mProviderPublicCameraIds, cameraInterface));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-7-2-startDeviceInterface"><a href="#3-1-7-2-startDeviceInterface" class="headerlink" title="3.1.7.2 startDeviceInterface"></a>3.1.7.2 startDeviceInterface</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">sp&lt;device::V3_2::ICameraDevice&gt;</span><br><span class="line">CameraProviderManager::ProviderInfo::startDeviceInterface</span><br><span class="line">        &lt;device::V3_2::ICameraDevice&gt;(const std::string &amp;name) &#123;</span><br><span class="line">    Status status;</span><br><span class="line">    sp&lt;device::V3_2::ICameraDevice&gt; cameraInterface;</span><br><span class="line">    hardware::Return&lt;void&gt; ret;</span><br><span class="line">    const sp&lt;provider::V2_4::ICameraProvider&gt; interface = startProviderInterface();</span><br><span class="line">    if (interface == nullptr) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取Provider端的ICameraDevice代理</span><br><span class="line">    ret = interface-&gt;getCameraDeviceInterface_V3_x(name, [&amp;status, &amp;cameraInterface](</span><br><span class="line">        Status s, sp&lt;device::V3_2::ICameraDevice&gt; interface) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                cameraInterface = interface;</span><br><span class="line">            &#125;);</span><br><span class="line">    if (!ret.isOk()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Transaction error trying to obtain interface for camera device %s: %s&quot;,</span><br><span class="line">                __FUNCTION__, name.c_str(), ret.description().c_str());</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    if (status != Status::OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to obtain interface for camera device %s: %s&quot;, __FUNCTION__,</span><br><span class="line">                name.c_str(), statusToString(status));</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    return cameraInterface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-7-3-new-DeviceInfo3"><a href="#3-1-7-3-new-DeviceInfo3" class="headerlink" title="3.1.7.3 new DeviceInfo3"></a>3.1.7.3 new DeviceInfo3</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">CameraProviderManager::ProviderInfo::DeviceInfo3::DeviceInfo3(const std::string&amp; name,</span><br><span class="line">        const metadata_vendor_id_t tagId, const std::string &amp;id,</span><br><span class="line">        uint16_t minorVersion,</span><br><span class="line">        const CameraResourceCost&amp; resourceCost,</span><br><span class="line">        sp&lt;ProviderInfo&gt; parentProvider,</span><br><span class="line">        const std::vector&lt;std::string&gt;&amp; publicCameraIds,</span><br><span class="line">        sp&lt;InterfaceT&gt; interface) :</span><br><span class="line">        DeviceInfo(name, tagId, id, hardware::hidl_version&#123;3, minorVersion&#125;,</span><br><span class="line">                   publicCameraIds, resourceCost, parentProvider) &#123;</span><br><span class="line">    // Get camera characteristics and initialize flash unit availability</span><br><span class="line">    Status status;</span><br><span class="line">    hardware::Return&lt;void&gt; ret;</span><br><span class="line">    ret = interface-&gt;getCameraCharacteristics([&amp;status, this](Status s,</span><br><span class="line">                    device::V3_2::CameraMetadata metadata) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                if (s == Status::OK) &#123;</span><br><span class="line">                    camera_metadata_t *buffer =</span><br><span class="line">                            reinterpret_cast&lt;camera_metadata_t*&gt;(metadata.data());</span><br><span class="line">                    size_t expectedSize = metadata.size();</span><br><span class="line">                    int res = validate_camera_metadata_structure(buffer, &amp;expectedSize);</span><br><span class="line">                    if (res == OK || res == CAMERA_METADATA_VALIDATION_SHIFTED) &#123;</span><br><span class="line">                        set_camera_metadata_vendor_id(buffer, mProviderTagid);</span><br><span class="line">                        mCameraCharacteristics = buffer;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        ALOGE(&quot;%s: Malformed camera metadata received from HAL&quot;, __FUNCTION__);</span><br><span class="line">                        status = Status::INTERNAL_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    if (!ret.isOk()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Transaction error getting camera characteristics for device %s&quot;</span><br><span class="line">                &quot; to check for a flash unit: %s&quot;, __FUNCTION__, id.c_str(),</span><br><span class="line">                ret.description().c_str());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (status != Status::OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to get camera characteristics for device %s: %s (%d)&quot;,</span><br><span class="line">                __FUNCTION__, id.c_str(), CameraProviderManager::statusToString(status), status);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsPublicallyHiddenSecureCamera = isPublicallyHiddenSecureCamera();</span><br><span class="line"></span><br><span class="line">    status_t res = fixupMonochromeTags();</span><br><span class="line">    if (OK != res) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to fix up monochrome tags based for older HAL version: %s (%d)&quot;,</span><br><span class="line">                __FUNCTION__, strerror(-res), res);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    auto stat = addDynamicDepthTags();</span><br><span class="line">    if (OK != stat) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Failed appending dynamic depth tags: %s (%d)&quot;, __FUNCTION__, strerror(-stat),</span><br><span class="line">                stat);</span><br><span class="line">    &#125;</span><br><span class="line">    res = deriveHeicTags();</span><br><span class="line">    if (OK != res) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Unable to derive HEIC tags based on camera and media capabilities: %s (%d)&quot;,</span><br><span class="line">                __FUNCTION__, strerror(-res), res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    camera_metadata_entry flashAvailable =</span><br><span class="line">            mCameraCharacteristics.find(ANDROID_FLASH_INFO_AVAILABLE);</span><br><span class="line">    if (flashAvailable.count == 1 &amp;&amp;</span><br><span class="line">            flashAvailable.data.u8[0] == ANDROID_FLASH_INFO_AVAILABLE_TRUE) &#123;</span><br><span class="line">        mHasFlashUnit = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mHasFlashUnit = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queryPhysicalCameraIds();</span><br><span class="line"></span><br><span class="line">    // Get physical camera characteristics if applicable</span><br><span class="line">    auto castResult = device::V3_5::ICameraDevice::castFrom(interface);</span><br><span class="line">    if (!castResult.isOk()) &#123;</span><br><span class="line">        ALOGV(&quot;%s: Unable to convert ICameraDevice instance to version 3.5&quot;, __FUNCTION__);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;device::V3_5::ICameraDevice&gt; interface_3_5 = castResult;</span><br><span class="line">    if (interface_3_5 == nullptr) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Converted ICameraDevice instance to nullptr&quot;, __FUNCTION__);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mIsLogicalCamera) &#123;</span><br><span class="line">        for (auto&amp; id : mPhysicalIds) &#123;</span><br><span class="line">            if (std::find(mPublicCameraIds.begin(), mPublicCameraIds.end(), id) !=</span><br><span class="line">                    mPublicCameraIds.end()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            hardware::hidl_string hidlId(id);</span><br><span class="line">            ret = interface_3_5-&gt;getPhysicalCameraCharacteristics(hidlId,</span><br><span class="line">                    [&amp;status, &amp;id, this](Status s, device::V3_2::CameraMetadata metadata) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                if (s == Status::OK) &#123;</span><br><span class="line">                    camera_metadata_t *buffer =</span><br><span class="line">                            reinterpret_cast&lt;camera_metadata_t*&gt;(metadata.data());</span><br><span class="line">                    size_t expectedSize = metadata.size();</span><br><span class="line">                    int res = validate_camera_metadata_structure(buffer, &amp;expectedSize);</span><br><span class="line">                    if (res == OK || res == CAMERA_METADATA_VALIDATION_SHIFTED) &#123;</span><br><span class="line">                        set_camera_metadata_vendor_id(buffer, mProviderTagid);</span><br><span class="line">                        mPhysicalCameraCharacteristics[id] = buffer;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        ALOGE(&quot;%s: Malformed camera metadata received from HAL&quot;, __FUNCTION__);</span><br><span class="line">                        status = Status::INTERNAL_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            if (!ret.isOk()) &#123;</span><br><span class="line">                ALOGE(&quot;%s: Transaction error getting physical camera %s characteristics for %s: %s&quot;,</span><br><span class="line">                        __FUNCTION__, id.c_str(), id.c_str(), ret.description().c_str());</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (status != Status::OK) &#123;</span><br><span class="line">                ALOGE(&quot;%s: Unable to get physical camera %s characteristics for device %s: %s (%d)&quot;,</span><br><span class="line">                        __FUNCTION__, id.c_str(), mId.c_str(),</span><br><span class="line">                        CameraProviderManager::statusToString(status), status);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!kEnableLazyHal) &#123;</span><br><span class="line">        // Save HAL reference indefinitely</span><br><span class="line">        mSavedInterface = interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-8-小结"><a href="#3-1-8-小结" class="headerlink" title="3.1.8 小结"></a>3.1.8 小结</h4><p><img src="/2024/深入理解Android Camera架构二-服务层/cameraserverstart.png" alt="cameraserverstart" style="zoom: 67%;"></p>
<p>当系统启动的时候会首先运行main_cameraserver程序，紧接着调用了CameraService的instantiate方法，该方法最终会调用到CameraService的onFirstRef方法，在这个方法里面便开始了整个CameraService的初始化工作。</p>
<p>而在onFirstRef方法内又调用了enumerateProviders方法，该方法中主要做了两个工作：</p>
<ul>
<li>一个是实例化一个CameraProviderManager对象，该对象管理着有关Camera Provider的一些资源。</li>
<li>一个是调用CameraProviderManager的initialize方法对其进行初始化工作。</li>
</ul>
<p>而在CameraProviderManager初始化的过程中，主要做了三件事：</p>
<ul>
<li>首先通过getService方法获取ICameraProvider代理。</li>
<li>随后实例化了一个ProviderInfo对象，之后调用其initialize方法进行初始化。</li>
<li>最后将ProviderInfo加入到一个内部容器中进行管理。</li>
</ul>
<p>而在调用ProviderInfo的initialize方法进行初始化过程中存在如下几个动作：</p>
<ul>
<li>首先接收了来自CameraProviderManager获取的ICameraProvider代理并将其存入内部成员变量中。</li>
<li>其次由于ProviderInfo实现了ICameraProviderCallback接口，所以紧接着调用了ICameraProvider的setCallback将自身注册到Camera Provider中，接收来自Provider的事件回调。</li>
<li>再然后，通过调用ICameraProvider代理的getCameraDeviceInterface_V3_X接口，获取Provider端的ICameraDevice代理，并且将这个代理作为参数加入到DeviceInfo3对象实例化方法中，而在实例化DeviceInfo3对象的过程中会通过ICameraDevice代理的getCameraCharacteristics方法获取该设备对应的属性配置，并且保存在内部成员变量中。</li>
<li>最后ProviderInfo会将每一个DeviceInfo3存入内部的一个容器中进行统一管理，至此整个初始化的工作已经完成。</li>
</ul>
<p>通过以上的系列动作，Camera Service进程便运行起来了，获取了Camera Provider的代理，同时也将自身关于Camera Provider的回调注册到了Provider中，这就建立了与Provider的通讯，另一边，通过服务的形式将AIDL接口也暴露给了Framework，静静等待来自Framework的请求。</p>
<h3 id="3-2-处理应用请求"><a href="#3-2-处理应用请求" class="headerlink" title="3.2 处理应用请求"></a>3.2 处理应用请求</h3><p>一旦用户打开了相机应用，便会去调用CameraManager的openCamera方法进而走到Framework层处理，Framework通过内部处理，最终将请求下发到Camera Service中，而在Camera Service主要做了获取相机设备属性、打开相机设备，然后App通过返回的相机设备，再次下发创建Session以及下发Request的操作，接下来我们来简单梳理下这一系列请求在Camera Service中是怎么进行处理的。</p>
<h4 id="3-2-1-获取属性"><a href="#3-2-1-获取属性" class="headerlink" title="3.2.1 获取属性"></a>3.2.1 获取属性</h4><p>对于获取相机设备属性动作，逻辑比较简单，由于在Camera Service启动初始化的时候已经获取了相应相机设备的属性配置，并存储在DeviceInfo3中，所以该方法就是从对应的DeviceInfo3中取出属性返回即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraProviderManager::getCameraCharacteristics(const std::string &amp;id,</span><br><span class="line">        CameraMetadata* characteristics) const &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(mInterfaceMutex);</span><br><span class="line">    return getCameraCharacteristicsLocked(id, characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t CameraProviderManager::getCameraCharacteristicsLocked(const std::string &amp;id,</span><br><span class="line">        CameraMetadata* characteristics) const &#123;</span><br><span class="line">    auto deviceInfo = findDeviceInfoLocked(id, /*minVersion*/ &#123;3,0&#125;, /*maxVersion*/ &#123;5,0&#125;);</span><br><span class="line">    if (deviceInfo != nullptr) &#123;</span><br><span class="line">        return deviceInfo-&gt;getCameraCharacteristics(characteristics);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Find hidden physical camera characteristics</span><br><span class="line">    for (auto&amp; provider : mProviders) &#123;</span><br><span class="line">        for (auto&amp; deviceInfo : provider-&gt;mDevices) &#123;</span><br><span class="line">            status_t res = deviceInfo-&gt;getPhysicalCameraCharacteristics(id, characteristics);</span><br><span class="line">            if (res != NAME_NOT_FOUND) return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NAME_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CameraProviderManager::ProviderInfo::DeviceInfo* CameraProviderManager::findDeviceInfoLocked(</span><br><span class="line">        const std::string&amp; id,</span><br><span class="line">        hardware::hidl_version minVersion, hardware::hidl_version maxVersion) const &#123;</span><br><span class="line">    for (auto&amp; provider : mProviders) &#123;</span><br><span class="line">        for (auto&amp; deviceInfo : provider-&gt;mDevices) &#123;</span><br><span class="line">            if (deviceInfo-&gt;mId == id &amp;&amp;</span><br><span class="line">                    minVersion &lt;= deviceInfo-&gt;mVersion &amp;&amp; maxVersion &gt;= deviceInfo-&gt;mVersion) &#123;</span><br><span class="line">                return deviceInfo.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-打开相机"><a href="#3-2-2-打开相机" class="headerlink" title="3.2.2 打开相机"></a>3.2.2 打开相机</h4><p>对于打开相机设备动作，主要由connectDevice来实现（详细流程见深入理解Camera架构一），内部实现比较复杂，下面详细看下</p>
<h5 id="3-2-2-1-CameraService-connectDevice"><a href="#3-2-2-1-CameraService-connectDevice" class="headerlink" title="3.2.2.1 CameraService::connectDevice"></a>3.2.2.1 CameraService::connectDevice</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Status CameraService::connectDevice(</span><br><span class="line">        const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; cameraCb,</span><br><span class="line">        const String16&amp; cameraId,</span><br><span class="line">        const String16&amp; clientPackageName,</span><br><span class="line">        int clientUid,</span><br><span class="line">        /*out*/</span><br><span class="line">        sp&lt;hardware::camera2::ICameraDeviceUser&gt;* device) &#123;</span><br><span class="line"></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Status ret = Status::ok();</span><br><span class="line">    String8 id = String8(cameraId);</span><br><span class="line">    sp&lt;CameraDeviceClient&gt; client = nullptr;</span><br><span class="line">    String16 clientPackageNameAdj = clientPackageName;</span><br><span class="line">    if (hardware::IPCThreadState::self()-&gt;isServingCall()) &#123;</span><br><span class="line">        std::string vendorClient =</span><br><span class="line">                StringPrintf(&quot;vendor.client.pid&lt;%d&gt;&quot;, CameraThreadState::getCallingPid());</span><br><span class="line">        clientPackageNameAdj = String16(vendorClient.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    //创建CameraDeviceClient</span><br><span class="line">    ret = connectHelper&lt;hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient&gt;(cameraCb, id,</span><br><span class="line">            /*api1CameraId*/-1,</span><br><span class="line">            CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageNameAdj,</span><br><span class="line">            clientUid, USE_CALLING_PID, API_2, /*shimUpdateOnly*/ false, /*out*/client);</span><br><span class="line"></span><br><span class="line">    if(!ret.isOk()) &#123;</span><br><span class="line">        logRejected(id, CameraThreadState::getCallingPid(), String8(clientPackageNameAdj),</span><br><span class="line">                ret.toString8());</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回client给framework</span><br><span class="line">    *device = client;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-2-CameraService-connectHelper"><a href="#3-2-2-2-CameraService-connectHelper" class="headerlink" title="3.2.2.2 CameraService::connectHelper"></a>3.2.2.2 CameraService::connectHelper</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">Status CameraService::connectHelper(const sp&lt;CALLBACK&gt;&amp; cameraCb, const String8&amp; cameraId,</span><br><span class="line">        int api1CameraId, int halVersion, const String16&amp; clientPackageName, int clientUid,</span><br><span class="line">        int clientPid, apiLevel effectiveApiLevel, bool shimUpdateOnly,</span><br><span class="line">        /*out*/sp&lt;CLIENT&gt;&amp; device) &#123;</span><br><span class="line">    binder::Status ret = binder::Status::ok();</span><br><span class="line"></span><br><span class="line">    String8 clientName8(clientPackageName);</span><br><span class="line"></span><br><span class="line">    int originalClientPid = 0;</span><br><span class="line"></span><br><span class="line">    ALOGI(&quot;CameraService::connect call (PID %d \&quot;%s\&quot;, camera ID %s) for HAL version %s and &quot;</span><br><span class="line">            &quot;Camera API version %d&quot;, clientPid, clientName8.string(), cameraId.string(),</span><br><span class="line">            (halVersion == -1) ? &quot;default&quot; : std::to_string(halVersion).c_str(),</span><br><span class="line">            static_cast&lt;int&gt;(effectiveApiLevel));</span><br><span class="line"></span><br><span class="line">    if (shouldRejectHiddenCameraConnection(cameraId)) &#123;</span><br><span class="line">        ALOGW(&quot;Attempting to connect to system-only camera id %s, connection rejected&quot;,</span><br><span class="line">              cameraId.c_str());</span><br><span class="line">        return STATUS_ERROR_FMT(ERROR_DISCONNECTED,</span><br><span class="line">                                &quot;No camera device with ID \&quot;%s\&quot; currently available&quot;,</span><br><span class="line">                                cameraId.string());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;CLIENT&gt; client = nullptr;</span><br><span class="line">    &#123;</span><br><span class="line">        // Acquire mServiceLock and prevent other clients from connecting</span><br><span class="line">        std::unique_ptr&lt;AutoConditionLock&gt; lock =</span><br><span class="line">                AutoConditionLock::waitAndAcquire(mServiceLockWrapper, DEFAULT_CONNECT_TIMEOUT_NS);</span><br><span class="line"></span><br><span class="line">        if (lock == nullptr) &#123;</span><br><span class="line">            ALOGE(&quot;CameraService::connect (PID %d) rejected (too many other clients connecting).&quot;</span><br><span class="line">                    , clientPid);</span><br><span class="line">            return STATUS_ERROR_FMT(ERROR_MAX_CAMERAS_IN_USE,</span><br><span class="line">                    &quot;Cannot open camera %s for \&quot;%s\&quot; (PID %d): Too many other clients connecting&quot;,</span><br><span class="line">                    cameraId.string(), clientName8.string(), clientPid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Enforce client permissions and do basic sanity checks</span><br><span class="line">        if(!(ret = validateConnectLocked(cameraId, clientName8,</span><br><span class="line">                /*inout*/clientUid, /*inout*/clientPid, /*out*/originalClientPid)).isOk()) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check the shim parameters after acquiring lock, if they have already been updated and</span><br><span class="line">        // we were doing a shim update, return immediately</span><br><span class="line">        if (shimUpdateOnly) &#123;</span><br><span class="line">            auto cameraState = getCameraState(cameraId);</span><br><span class="line">            if (cameraState != nullptr) &#123;</span><br><span class="line">                if (!cameraState-&gt;getShimParams().isEmpty()) return ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        status_t err;</span><br><span class="line"></span><br><span class="line">        sp&lt;BasicClient&gt; clientTmp = nullptr;</span><br><span class="line">        std::shared_ptr&lt;resource_policy::ClientDescriptor&lt;String8, sp&lt;BasicClient&gt;&gt;&gt; partial;</span><br><span class="line">        if ((err = handleEvictionsLocked(cameraId, originalClientPid, effectiveApiLevel,</span><br><span class="line">                IInterface::asBinder(cameraCb), clientName8, /*out*/&amp;clientTmp,</span><br><span class="line">                /*out*/&amp;partial)) != NO_ERROR) &#123;</span><br><span class="line">            switch (err) &#123;</span><br><span class="line">                case -ENODEV:</span><br><span class="line">                    return STATUS_ERROR_FMT(ERROR_DISCONNECTED,</span><br><span class="line">                            &quot;No camera device with ID \&quot;%s\&quot; currently available&quot;,</span><br><span class="line">                            cameraId.string());</span><br><span class="line">                case -EBUSY:</span><br><span class="line">                    return STATUS_ERROR_FMT(ERROR_CAMERA_IN_USE,</span><br><span class="line">                            &quot;Higher-priority client using camera, ID \&quot;%s\&quot; currently unavailable&quot;,</span><br><span class="line">                            cameraId.string());</span><br><span class="line">                default:</span><br><span class="line">                    return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,</span><br><span class="line">                            &quot;Unexpected error %s (%d) opening camera \&quot;%s\&quot;&quot;,</span><br><span class="line">                            strerror(-err), err, cameraId.string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (clientTmp.get() != nullptr) &#123;</span><br><span class="line">            // Handle special case for API1 MediaRecorder where the existing client is returned</span><br><span class="line">            device = static_cast&lt;CLIENT*&gt;(clientTmp.get());</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // give flashlight a chance to close devices if necessary.</span><br><span class="line">        mFlashlight-&gt;prepareDeviceOpen(cameraId);</span><br><span class="line"></span><br><span class="line">        int facing = -1;</span><br><span class="line">        int deviceVersion = getDeviceVersion(cameraId, /*out*/&amp;facing);</span><br><span class="line">        if (facing == -1) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Unable to get camera device \&quot;%s\&quot;  facing&quot;, __FUNCTION__, cameraId.string());</span><br><span class="line">            return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,</span><br><span class="line">                    &quot;Unable to get camera device \&quot;%s\&quot; facing&quot;, cameraId.string());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;BasicClient&gt; tmp = nullptr;</span><br><span class="line">        if(!(ret = makeClient(this, cameraCb, clientPackageName,</span><br><span class="line">                cameraId, api1CameraId, facing,</span><br><span class="line">                clientPid, clientUid, getpid(),</span><br><span class="line">                halVersion, deviceVersion, effectiveApiLevel,</span><br><span class="line">                /*out*/&amp;tmp)).isOk()) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        client = static_cast&lt;CLIENT*&gt;(tmp.get());</span><br><span class="line"></span><br><span class="line">        LOG_ALWAYS_FATAL_IF(client.get() == nullptr, &quot;%s: CameraService in invalid state&quot;,</span><br><span class="line">                __FUNCTION__);</span><br><span class="line"></span><br><span class="line">        err = client-&gt;initialize(mCameraProviderManager, mMonitorTags);</span><br><span class="line">        if (err != OK) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Could not initialize client from HAL.&quot;, __FUNCTION__);</span><br><span class="line">            // Errors could be from the HAL module open call or from AppOpsManager</span><br><span class="line">            switch(err) &#123;</span><br><span class="line">                case BAD_VALUE:</span><br><span class="line">                    return STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                            &quot;Illegal argument to HAL module for camera \&quot;%s\&quot;&quot;, cameraId.string());</span><br><span class="line">                case -EBUSY:</span><br><span class="line">                    return STATUS_ERROR_FMT(ERROR_CAMERA_IN_USE,</span><br><span class="line">                            &quot;Camera \&quot;%s\&quot; is already open&quot;, cameraId.string());</span><br><span class="line">                case -EUSERS:</span><br><span class="line">                    return STATUS_ERROR_FMT(ERROR_MAX_CAMERAS_IN_USE,</span><br><span class="line">                            &quot;Too many cameras already open, cannot open camera \&quot;%s\&quot;&quot;,</span><br><span class="line">                            cameraId.string());</span><br><span class="line">                case PERMISSION_DENIED:</span><br><span class="line">                    return STATUS_ERROR_FMT(ERROR_PERMISSION_DENIED,</span><br><span class="line">                            &quot;No permission to open camera \&quot;%s\&quot;&quot;, cameraId.string());</span><br><span class="line">                case -EACCES:</span><br><span class="line">                    return STATUS_ERROR_FMT(ERROR_DISABLED,</span><br><span class="line">                            &quot;Camera \&quot;%s\&quot; disabled by policy&quot;, cameraId.string());</span><br><span class="line">                case -ENODEV:</span><br><span class="line">                default:</span><br><span class="line">                    return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,</span><br><span class="line">                            &quot;Failed to initialize camera \&quot;%s\&quot;: %s (%d)&quot;, cameraId.string(),</span><br><span class="line">                            strerror(-err), err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Update shim paremeters for legacy clients</span><br><span class="line">        if (effectiveApiLevel == API_1) &#123;</span><br><span class="line">            // Assume we have always received a Client subclass for API1</span><br><span class="line">            sp&lt;Client&gt; shimClient = reinterpret_cast&lt;Client*&gt;(client.get());</span><br><span class="line">            String8 rawParams = shimClient-&gt;getParameters();</span><br><span class="line">            CameraParameters params(rawParams);</span><br><span class="line"></span><br><span class="line">            auto cameraState = getCameraState(cameraId);</span><br><span class="line">            if (cameraState != nullptr) &#123;</span><br><span class="line">                cameraState-&gt;setShimParams(params);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ALOGE(&quot;%s: Cannot update shim parameters for camera %s, no such device exists.&quot;,</span><br><span class="line">                        __FUNCTION__, cameraId.string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (shimUpdateOnly) &#123;</span><br><span class="line">            // If only updating legacy shim parameters, immediately disconnect client</span><br><span class="line">            mServiceLock.unlock();</span><br><span class="line">            client-&gt;disconnect();</span><br><span class="line">            mServiceLock.lock();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Otherwise, add client to active clients list</span><br><span class="line">            finishConnectLocked(client, partial);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // lock is destroyed, allow further connect calls</span><br><span class="line"></span><br><span class="line">    // Important: release the mutex here so the client can call back into the service from its</span><br><span class="line">    // destructor (can be at the end of the call)</span><br><span class="line">    device = client;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-3-CameraService-makeClient"><a href="#3-2-2-3-CameraService-makeClient" class="headerlink" title="3.2.2.3 CameraService::makeClient"></a>3.2.2.3 CameraService::makeClient</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Status CameraService::makeClient(const sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        const sp&lt;IInterface&gt;&amp; cameraCb, const String16&amp; packageName, const String8&amp; cameraId,</span><br><span class="line">        int api1CameraId, int facing, int clientPid, uid_t clientUid, int servicePid,</span><br><span class="line">        int halVersion, int deviceVersion, apiLevel effectiveApiLevel,</span><br><span class="line">        /*out*/sp&lt;BasicClient&gt;* client) &#123;</span><br><span class="line"></span><br><span class="line">    if (halVersion &lt; 0 || halVersion == deviceVersion) &#123;</span><br><span class="line">        // Default path: HAL version is unspecified by caller, create CameraClient</span><br><span class="line">        // based on device version reported by the HAL.</span><br><span class="line">        switch(deviceVersion) &#123;</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_1_0:</span><br><span class="line">            if (effectiveApiLevel == API_1) &#123;  // Camera1 API route</span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = static_cast&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = new CameraClient(cameraService, tmp, packageName,</span><br><span class="line">                        api1CameraId, facing, clientPid, clientUid,</span><br><span class="line">                        getpid());</span><br><span class="line">            &#125; else &#123; // Camera2 API route</span><br><span class="line">                ALOGW(&quot;Camera using old HAL version: %d&quot;, deviceVersion);</span><br><span class="line">                return STATUS_ERROR_FMT(ERROR_DEPRECATED_HAL,</span><br><span class="line">                        &quot;Camera device \&quot;%s\&quot; HAL version %d does not support camera2 API&quot;,</span><br><span class="line">                        cameraId.string(), deviceVersion);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_3_0:</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_3_3:</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_3_4:</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_3_5:</span><br><span class="line">            if (effectiveApiLevel == API_1) &#123; // Camera1 API route</span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = static_cast&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = new Camera2Client(cameraService, tmp, packageName,</span><br><span class="line">                        cameraId, api1CameraId,</span><br><span class="line">                        facing, clientPid, clientUid,</span><br><span class="line">                        servicePid);</span><br><span class="line">            &#125; else &#123; // Camera2 API route</span><br><span class="line">                sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt; tmp =</span><br><span class="line">                        static_cast&lt;hardware::camera2::ICameraDeviceCallbacks*&gt;(cameraCb.get());</span><br><span class="line">                *client = new CameraDeviceClient(cameraService, tmp, packageName, cameraId,</span><br><span class="line">                        facing, clientPid, clientUid, servicePid);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          default:</span><br><span class="line">            // Should not be reachable</span><br><span class="line">            ALOGE(&quot;Unknown camera device HAL version: %d&quot;, deviceVersion);</span><br><span class="line">            return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,</span><br><span class="line">                    &quot;Camera device \&quot;%s\&quot; has unknown HAL version %d&quot;,</span><br><span class="line">                    cameraId.string(), deviceVersion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // A particular HAL version is requested by caller. Create CameraClient</span><br><span class="line">        // based on the requested HAL version.</span><br><span class="line">        if (deviceVersion &gt; CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp;</span><br><span class="line">            halVersion == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">            // Only support higher HAL version device opened as HAL1.0 device.</span><br><span class="line">            sp&lt;ICameraClient&gt; tmp = static_cast&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">            *client = new CameraClient(cameraService, tmp, packageName,</span><br><span class="line">                    api1CameraId, facing, clientPid, clientUid,</span><br><span class="line">                    servicePid);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet.</span><br><span class="line">            ALOGE(&quot;Invalid camera HAL version %x: HAL %x device can only be&quot;</span><br><span class="line">                    &quot; opened as HAL %x device&quot;, halVersion, deviceVersion,</span><br><span class="line">                    CAMERA_DEVICE_API_VERSION_1_0);</span><br><span class="line">            return STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                    &quot;Camera device \&quot;%s\&quot; (HAL version %d) cannot be opened as HAL version %d&quot;,</span><br><span class="line">                    cameraId.string(), deviceVersion, halVersion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Status::ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h6 id="new-CameraDeviceClient"><a href="#new-CameraDeviceClient" class="headerlink" title="new CameraDeviceClient"></a>new CameraDeviceClient</h6></li>
</ul>
<p>​      [-&gt;frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// Interface used by CameraService</span><br><span class="line"></span><br><span class="line">CameraDeviceClient::CameraDeviceClient(const sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; remoteCallback,</span><br><span class="line">        const String16&amp; clientPackageName,</span><br><span class="line">        const String8&amp; cameraId,</span><br><span class="line">        int cameraFacing,</span><br><span class="line">        int clientPid,</span><br><span class="line">        uid_t clientUid,</span><br><span class="line">        int servicePid) :</span><br><span class="line">    Camera2ClientBase(cameraService, remoteCallback, clientPackageName,</span><br><span class="line">                cameraId, /*API1 camera ID*/ -1,</span><br><span class="line">                cameraFacing, clientPid, clientUid, servicePid),</span><br><span class="line">    mInputStream(),</span><br><span class="line">    mStreamingRequestId(REQUEST_ID_NONE),</span><br><span class="line">    mRequestIdCounter(0),</span><br><span class="line">    mPrivilegedClient(false) &#123;</span><br><span class="line"></span><br><span class="line">    char value[PROPERTY_VALUE_MAX];</span><br><span class="line">    property_get(&quot;persist.vendor.camera.privapp.list&quot;, value, &quot;&quot;);</span><br><span class="line">    String16 packagelist(value);</span><br><span class="line">    if (packagelist.contains(clientPackageName.string())) &#123;</span><br><span class="line">        mPrivilegedClient = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(&quot;CameraDeviceClient %s: Opened&quot;, cameraId.string());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Interface used by CameraService</span><br><span class="line">template &lt;typename TClientBase&gt;</span><br><span class="line">Camera2ClientBase&lt;TClientBase&gt;::Camera2ClientBase(</span><br><span class="line">        const sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        const sp&lt;TCamCallbacks&gt;&amp; remoteCallback,</span><br><span class="line">        const String16&amp; clientPackageName,</span><br><span class="line">        const String8&amp; cameraId,</span><br><span class="line">        int api1CameraId,</span><br><span class="line">        int cameraFacing,</span><br><span class="line">        int clientPid,</span><br><span class="line">        uid_t clientUid,</span><br><span class="line">        int servicePid):</span><br><span class="line">        TClientBase(cameraService, remoteCallback, clientPackageName,</span><br><span class="line">                cameraId, api1CameraId, cameraFacing, clientPid, clientUid, servicePid),</span><br><span class="line">        mSharedCameraCallbacks(remoteCallback),</span><br><span class="line">        mDeviceVersion(cameraService-&gt;getDeviceVersion(TClientBase::mCameraIdStr)),</span><br><span class="line">        mDevice(new Camera3Device(cameraId, clientPackageName)), //实例化Camera3Device</span><br><span class="line">        mDeviceActive(false), mApi1CameraId(api1CameraId)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(&quot;Camera %s: Opened. Client: %s (PID %d, UID %d)&quot;, cameraId.string(),</span><br><span class="line">            String8(clientPackageName).string(), clientPid, clientUid);</span><br><span class="line"></span><br><span class="line">    mInitialClientPid = clientPid;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDevice == 0, &quot;Device should never be NULL here.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>new Camera3Device</p>
<p>[-&gt;frameworks\av\services\camera\libcameraservice\Camera3Device.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Camera3Device::Camera3Device(const String8 &amp;id, const String16&amp; clientPackageName):</span><br><span class="line">        sizePerFace(3),</span><br><span class="line">        faceNumPerGroup(10),</span><br><span class="line">        sizePerFaceGroup(sizePerFace * faceNumPerGroup),</span><br><span class="line">        instaTagBase(0),</span><br><span class="line">        instaTagSection(&quot;org.qti.camera.intro&quot;),</span><br><span class="line">        instaFirstTagName(&quot;instaInputMetadata&quot;),</span><br><span class="line">        inputMetadata(9),</span><br><span class="line">        mId(id),</span><br><span class="line">        mOperatingMode(NO_MODE),</span><br><span class="line">        mIsConstrainedHighSpeedConfiguration(false),</span><br><span class="line">        mStatus(STATUS_UNINITIALIZED),</span><br><span class="line">        mStatusWaiters(0),</span><br><span class="line">        mUsePartialResult(false),</span><br><span class="line">        mNumPartialResults(1),</span><br><span class="line">        mTimestampOffset(0),</span><br><span class="line">        mNextResultFrameNumber(0),</span><br><span class="line">        mNextReprocessResultFrameNumber(0),</span><br><span class="line">        mNextZslStillResultFrameNumber(0),</span><br><span class="line">        mNextShutterFrameNumber(0),</span><br><span class="line">        mNextReprocessShutterFrameNumber(0),</span><br><span class="line">        mNextZslStillShutterFrameNumber(0),</span><br><span class="line">        mListener(NULL),</span><br><span class="line">        mVendorTagId(CAMERA_METADATA_INVALID_VENDOR_ID),</span><br><span class="line">        mLastTemplateId(-1),</span><br><span class="line">        mNeedFixupMonochromeTags(false)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    packge_name = clientPackageName;</span><br><span class="line">    if (!strcmp(String8(packge_name).string(), &quot;com.alibaba.dingtalk.focus&quot;)) &#123;</span><br><span class="line">        property_set(&quot;vendor.select.mulicamera&quot;, &quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!strcmp(String8(packge_name).string(), &quot;com.tencent.wemeet.rooms&quot;)) &#123;</span><br><span class="line">        property_set(&quot;vendor.select.mulicamera&quot;, &quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!strcmp(String8(packge_name).string(), &quot;com.ss.meetx.room&quot;)) &#123;</span><br><span class="line">        property_set(&quot;vendor.select.mulicamera&quot;, &quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    isLogicCam = mId == &quot;3&quot;;</span><br><span class="line">    char value[PROPERTY_VALUE_MAX];</span><br><span class="line">    property_get(&quot;vendor.select.mulicamera&quot;, value, &quot;0&quot;);</span><br><span class="line">    bool enableMultiCam = atoi(value) == 1;</span><br><span class="line">    if (enableMultiCam &amp;&amp; !isLogicCam) &#123;</span><br><span class="line">        isLogicCam = (mId == &quot;0&quot;) || (mId == &quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGD(&quot;%s: %s created device for camera %s&quot;, __FUNCTION__, String8(clientPackageName).c_str(), mId.string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-2-2-4-CameraDeviceClient-initialize"><a href="#3-2-2-4-CameraDeviceClient-initialize" class="headerlink" title="3.2.2.4 CameraDeviceClient::initialize"></a>3.2.2.4 CameraDeviceClient::initialize</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraDeviceClient::initialize(sp&lt;CameraProviderManager&gt; manager,</span><br><span class="line">        const String8&amp; monitorTags) &#123;</span><br><span class="line">    return initializeImpl(manager, monitorTags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename TProviderPtr&gt;</span><br><span class="line">status_t CameraDeviceClient::initializeImpl(TProviderPtr providerPtr, const String8&amp; monitorTags) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    status_t res;</span><br><span class="line"></span><br><span class="line">    res = Camera2ClientBase::initialize(providerPtr, monitorTags);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String8 threadName;</span><br><span class="line">    mFrameProcessor = new FrameProcessorBase(mDevice);</span><br><span class="line">    threadName = String8::format(&quot;CDU-%s-FrameProc&quot;, mCameraIdStr.string());</span><br><span class="line">    mFrameProcessor-&gt;run(threadName.string());</span><br><span class="line"></span><br><span class="line">    mFrameProcessor-&gt;registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID,</span><br><span class="line">                                      FRAME_PROCESSOR_LISTENER_MAX_ID,</span><br><span class="line">                                      /*listener*/this,</span><br><span class="line">                                      /*sendPartials*/true);</span><br><span class="line"></span><br><span class="line">    auto deviceInfo = mDevice-&gt;info();</span><br><span class="line">    camera_metadata_entry_t physicalKeysEntry = deviceInfo.find(</span><br><span class="line">            ANDROID_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS);</span><br><span class="line">    if (physicalKeysEntry.count &gt; 0) &#123;</span><br><span class="line">        mSupportedPhysicalRequestKeys.insert(mSupportedPhysicalRequestKeys.begin(),</span><br><span class="line">                physicalKeysEntry.data.i32,</span><br><span class="line">                physicalKeysEntry.data.i32 + physicalKeysEntry.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mProviderManager = providerPtr;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Camera2ClientBase::initialize</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename TClientBase&gt;</span><br><span class="line">status_t Camera2ClientBase&lt;TClientBase&gt;::initialize(sp&lt;CameraProviderManager&gt; manager,</span><br><span class="line">        const String8&amp; monitorTags) &#123;</span><br><span class="line">    return initializeImpl(manager, monitorTags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename TClientBase&gt;</span><br><span class="line">template &lt;typename TProviderPtr&gt;</span><br><span class="line">status_t Camera2ClientBase&lt;TClientBase&gt;::initializeImpl(TProviderPtr providerPtr,</span><br><span class="line">        const String8&amp; monitorTags) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;%s: Initializing client for camera %s&quot;, __FUNCTION__,</span><br><span class="line">          TClientBase::mCameraIdStr.string());</span><br><span class="line">    status_t res;</span><br><span class="line"></span><br><span class="line">    // Verify ops permissions</span><br><span class="line">    res = TClientBase::startCameraOps();</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mDevice == NULL) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Camera %s: No device connected&quot;,</span><br><span class="line">                __FUNCTION__, TClientBase::mCameraIdStr.string());</span><br><span class="line">        return NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = mDevice-&gt;initialize(providerPtr, monitorTags);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Camera %s: unable to initialize device: %s (%d)&quot;,</span><br><span class="line">                __FUNCTION__, TClientBase::mCameraIdStr.string(), strerror(-res), res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wp&lt;CameraDeviceBase::NotificationListener&gt; weakThis(this);</span><br><span class="line">    res = mDevice-&gt;setNotifyCallback(weakThis);</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>new FrameProcessorBase</p>
<p> [-&gt;frameworks\av\services\camera\libcameraservice\common\FrameProcessorBase.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FrameProcessorBase::FrameProcessorBase(wp&lt;CameraDeviceBase&gt; device) :</span><br><span class="line">    Thread(/*canCallJava*/false),</span><br><span class="line">    mDevice(device),</span><br><span class="line">    mNumPartialResults(1) &#123;</span><br><span class="line">    sp&lt;CameraDeviceBase&gt; cameraDevice = device.promote();</span><br><span class="line">    if (cameraDevice != 0) &#123;</span><br><span class="line">        CameraMetadata staticInfo = cameraDevice-&gt;info();</span><br><span class="line">        camera_metadata_entry_t entry = staticInfo.find(ANDROID_REQUEST_PARTIAL_RESULT_COUNT);</span><br><span class="line">        if (entry.count &gt; 0) &#123;</span><br><span class="line">            mNumPartialResults = entry.data.i32[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Camera3Device::initialize</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">status_t Camera3Device::initialize(sp&lt;CameraProviderManager&gt; manager, const String8&amp; monitorTags) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::Autolock il(mInterfaceLock);</span><br><span class="line">    Mutex::Autolock l(mLock);</span><br><span class="line"></span><br><span class="line">    ALOGD(&quot;%s: Initializing HIDL device for camera %s&quot;, __FUNCTION__, mId.string());</span><br><span class="line">    if (mStatus != STATUS_UNINITIALIZED) &#123;</span><br><span class="line">        CLOGE(&quot;Already initialized!&quot;);</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    if (manager == nullptr) return INVALID_OPERATION;</span><br><span class="line"></span><br><span class="line">    sp&lt;ICameraDeviceSession&gt; session;</span><br><span class="line">    ATRACE_BEGIN(&quot;CameraHal::openSession&quot;);</span><br><span class="line">    //获取ICameraDeviceSession代理</span><br><span class="line">    status_t res = manager-&gt;openSession(mId.string(), this,</span><br><span class="line">            /*out*/ &amp;session);</span><br><span class="line">    ATRACE_END();</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        SET_ERR_L(&quot;Could not open camera session: %s (%d)&quot;, strerror(-res), res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = manager-&gt;getCameraCharacteristics(mId.string(), &amp;mDeviceInfo);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        SET_ERR_L(&quot;Could not retrieve camera characteristics: %s (%d)&quot;, strerror(-res), res);</span><br><span class="line">        session-&gt;close();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; physicalCameraIds;</span><br><span class="line">    bool isLogical = manager-&gt;isLogicalCamera(mId.string(), &amp;physicalCameraIds);</span><br><span class="line">    if (isLogical) &#123;</span><br><span class="line">        for (auto&amp; physicalId : physicalCameraIds) &#123;</span><br><span class="line">            res = manager-&gt;getCameraCharacteristics(</span><br><span class="line">                    physicalId, &amp;mPhysicalDeviceInfoMap[physicalId]);</span><br><span class="line">            if (res != OK) &#123;</span><br><span class="line">                SET_ERR_L(&quot;Could not retrieve camera %s characteristics: %s (%d)&quot;,</span><br><span class="line">                        physicalId.c_str(), strerror(-res), res);</span><br><span class="line">                session-&gt;close();</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DistortionMapper::isDistortionSupported(mPhysicalDeviceInfoMap[physicalId])) &#123;</span><br><span class="line">                mDistortionMappers[physicalId].setupStaticInfo(mPhysicalDeviceInfoMap[physicalId]);</span><br><span class="line">                if (res != OK) &#123;</span><br><span class="line">                    SET_ERR_L(&quot;Unable to read camera %s&apos;s calibration fields for distortion &quot;</span><br><span class="line">                            &quot;correction&quot;, physicalId.c_str());</span><br><span class="line">                    session-&gt;close();</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;RequestMetadataQueue&gt; queue;</span><br><span class="line">    auto requestQueueRet = session-&gt;getCaptureRequestMetadataQueue(</span><br><span class="line">        [&amp;queue](const auto&amp; descriptor) &#123;</span><br><span class="line">            queue = std::make_shared&lt;RequestMetadataQueue&gt;(descriptor);</span><br><span class="line">            if (!queue-&gt;isValid() || queue-&gt;availableToWrite() &lt;= 0) &#123;</span><br><span class="line">                ALOGE(&quot;HAL returns empty request metadata fmq, not use it&quot;);</span><br><span class="line">                queue = nullptr;</span><br><span class="line">                // don&apos;t use the queue onwards.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    if (!requestQueueRet.isOk()) &#123;</span><br><span class="line">        ALOGE(&quot;Transaction error when getting request metadata fmq: %s, not use it&quot;,</span><br><span class="line">                requestQueueRet.description().c_str());</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;ResultMetadataQueue&gt;&amp; resQueue = mResultMetadataQueue;</span><br><span class="line">    auto resultQueueRet = session-&gt;getCaptureResultMetadataQueue(</span><br><span class="line">        [&amp;resQueue](const auto&amp; descriptor) &#123;</span><br><span class="line">            resQueue = std::make_unique&lt;ResultMetadataQueue&gt;(descriptor);</span><br><span class="line">            if (!resQueue-&gt;isValid() || resQueue-&gt;availableToWrite() &lt;= 0) &#123;</span><br><span class="line">                ALOGE(&quot;HAL returns empty result metadata fmq, not use it&quot;);</span><br><span class="line">                resQueue = nullptr;</span><br><span class="line">                // Don&apos;t use the resQueue onwards.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    if (!resultQueueRet.isOk()) &#123;</span><br><span class="line">        ALOGE(&quot;Transaction error when getting result metadata queue from camera session: %s&quot;,</span><br><span class="line">                resultQueueRet.description().c_str());</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    IF_ALOGV() &#123;</span><br><span class="line">        session-&gt;interfaceChain([](</span><br><span class="line">            ::android::hardware::hidl_vec&lt;::android::hardware::hidl_string&gt; interfaceChain) &#123;</span><br><span class="line">                ALOGV(&quot;Session interface chain:&quot;);</span><br><span class="line">                for (const auto&amp; iface : interfaceChain) &#123;</span><br><span class="line">                    ALOGV(&quot;  %s&quot;, iface.c_str());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    camera_metadata_entry bufMgrMode =</span><br><span class="line">            mDeviceInfo.find(ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION);</span><br><span class="line">    if (bufMgrMode.count &gt; 0) &#123;</span><br><span class="line">         mUseHalBufManager = (bufMgrMode.data.u8[0] ==</span><br><span class="line">            ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION_HIDL_DEVICE_3_5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInterface = new HalInterface(session, queue, mUseHalBufManager);</span><br><span class="line">    std::string providerType;</span><br><span class="line">    mVendorTagId = manager-&gt;getProviderTagIdLocked(mId.string());</span><br><span class="line">    mTagMonitor.initialize(mVendorTagId);</span><br><span class="line">    if (!monitorTags.isEmpty()) &#123;</span><br><span class="line">        mTagMonitor.parseTagsToMonitor(String8(monitorTags));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Metadata tags needs fixup for monochrome camera device version less</span><br><span class="line">    // than 3.5.</span><br><span class="line">    hardware::hidl_version maxVersion&#123;0,0&#125;;</span><br><span class="line">    res = manager-&gt;getHighestSupportedVersion(mId.string(), &amp;maxVersion);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Error in getting camera device version id: %s (%d)&quot;,</span><br><span class="line">                __FUNCTION__, strerror(-res), res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int deviceVersion = HARDWARE_DEVICE_API_VERSION(</span><br><span class="line">            maxVersion.get_major(), maxVersion.get_minor());</span><br><span class="line"></span><br><span class="line">    bool isMonochrome = false;</span><br><span class="line">    camera_metadata_entry_t entry = mDeviceInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);</span><br><span class="line">    for (size_t i = 0; i &lt; entry.count; i++) &#123;</span><br><span class="line">        uint8_t capability = entry.data.u8[i];</span><br><span class="line">        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME) &#123;</span><br><span class="line">            isMonochrome = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNeedFixupMonochromeTags = (isMonochrome &amp;&amp; deviceVersion &lt; CAMERA_DEVICE_API_VERSION_3_5);</span><br><span class="line"></span><br><span class="line">    return initializeCommonLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t Camera3Device::initializeCommonLocked() &#123;</span><br><span class="line"></span><br><span class="line">    /** Start up status tracker thread */</span><br><span class="line">    mStatusTracker = new StatusTracker(this);</span><br><span class="line">    status_t res = mStatusTracker-&gt;run(String8::format(&quot;C3Dev-%s-Status&quot;, mId.string()).string());</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        SET_ERR_L(&quot;Unable to start status tracking thread: %s (%d)&quot;,</span><br><span class="line">                strerror(-res), res);</span><br><span class="line">        mInterface-&gt;close();</span><br><span class="line">        mStatusTracker.clear();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Register in-flight map to the status tracker */</span><br><span class="line">    mInFlightStatusId = mStatusTracker-&gt;addComponent();</span><br><span class="line"></span><br><span class="line">    if (mUseHalBufManager) &#123;</span><br><span class="line">        res = mRequestBufferSM.initialize(mStatusTracker);</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            SET_ERR_L(&quot;Unable to start request buffer state machine: %s (%d)&quot;,</span><br><span class="line">                    strerror(-res), res);</span><br><span class="line">            mInterface-&gt;close();</span><br><span class="line">            mStatusTracker.clear();</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Create buffer manager */</span><br><span class="line">    mBufferManager = new Camera3BufferManager();</span><br><span class="line"></span><br><span class="line">    Vector&lt;int32_t&gt; sessionParamKeys;</span><br><span class="line">    camera_metadata_entry_t sessionKeysEntry = mDeviceInfo.find(</span><br><span class="line">            ANDROID_REQUEST_AVAILABLE_SESSION_KEYS);</span><br><span class="line">    if (sessionKeysEntry.count &gt; 0) &#123;</span><br><span class="line">        sessionParamKeys.insertArrayAt(sessionKeysEntry.data.i32, 0, sessionKeysEntry.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Start up request queue thread */</span><br><span class="line">    mRequestThread = new RequestThread(</span><br><span class="line">            this, mStatusTracker, mInterface, sessionParamKeys, mUseHalBufManager);</span><br><span class="line">    res = mRequestThread-&gt;run(String8::format(&quot;C3Dev-%s-ReqQueue&quot;, mId.string()).string());</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        SET_ERR_L(&quot;Unable to start request queue thread: %s (%d)&quot;,</span><br><span class="line">                strerror(-res), res);</span><br><span class="line">        mInterface-&gt;close();</span><br><span class="line">        mRequestThread.clear();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPreparerThread = new PreparerThread();</span><br><span class="line"></span><br><span class="line">    internalUpdateStatusLocked(STATUS_UNCONFIGURED);</span><br><span class="line">    mNextStreamId = 0;</span><br><span class="line">    mDummyStreamId = NO_STREAM;</span><br><span class="line">    mNeedConfig = true;</span><br><span class="line">    mPauseStateNotify = false;</span><br><span class="line"></span><br><span class="line">    // Measure the clock domain offset between camera and video/hw_composer</span><br><span class="line">    camera_metadata_entry timestampSource =</span><br><span class="line">            mDeviceInfo.find(ANDROID_SENSOR_INFO_TIMESTAMP_SOURCE);</span><br><span class="line">    if (timestampSource.count &gt; 0 &amp;&amp; timestampSource.data.u8[0] ==</span><br><span class="line">            ANDROID_SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME) &#123;</span><br><span class="line">        mTimestampOffset = getMonoToBoottimeOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Will the HAL be sending in early partial result metadata?</span><br><span class="line">    camera_metadata_entry partialResultsCount =</span><br><span class="line">            mDeviceInfo.find(ANDROID_REQUEST_PARTIAL_RESULT_COUNT);</span><br><span class="line">    if (partialResultsCount.count &gt; 0) &#123;</span><br><span class="line">        mNumPartialResults = partialResultsCount.data.i32[0];</span><br><span class="line">        mUsePartialResult = (mNumPartialResults &gt; 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    camera_metadata_entry configs =</span><br><span class="line">            mDeviceInfo.find(ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS);</span><br><span class="line">    for (uint32_t i = 0; i &lt; configs.count; i += 4) &#123;</span><br><span class="line">        if (configs.data.i32[i] == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED &amp;&amp;</span><br><span class="line">                configs.data.i32[i + 3] ==</span><br><span class="line">                ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_INPUT) &#123;</span><br><span class="line">            mSupportedOpaqueInputSizes.add(Size(configs.data.i32[i + 1],</span><br><span class="line">                    configs.data.i32[i + 2]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DistortionMapper::isDistortionSupported(mDeviceInfo)) &#123;</span><br><span class="line">        res = mDistortionMappers[mId.c_str()].setupStaticInfo(mDeviceInfo);</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            SET_ERR_L(&quot;Unable to read necessary calibration fields for distortion correction&quot;);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyCameraState(true);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CameraProviderManager::openSession</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraProviderManager::openSession(const std::string &amp;id,</span><br><span class="line">        const sp&lt;device::V3_2::ICameraDeviceCallback&gt;&amp; callback,</span><br><span class="line">        /*out*/</span><br><span class="line">        sp&lt;device::V3_2::ICameraDeviceSession&gt; *session) &#123;</span><br><span class="line"></span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(mInterfaceMutex);</span><br><span class="line"></span><br><span class="line">    auto deviceInfo = findDeviceInfoLocked(id,</span><br><span class="line">            /*minVersion*/ &#123;3,0&#125;, /*maxVersion*/ &#123;4,0&#125;);</span><br><span class="line">    if (deviceInfo == nullptr) return NAME_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    auto *deviceInfo3 = static_cast&lt;ProviderInfo::DeviceInfo3*&gt;(deviceInfo);</span><br><span class="line">    const sp&lt;provider::V2_4::ICameraProvider&gt; provider =</span><br><span class="line">            deviceInfo-&gt;mParentProvider-&gt;startProviderInterface();</span><br><span class="line">    if (provider == nullptr) &#123;</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    saveRef(DeviceMode::CAMERA, id, provider);</span><br><span class="line"></span><br><span class="line">    Status status;</span><br><span class="line">    hardware::Return&lt;void&gt; ret;</span><br><span class="line">    auto interface = deviceInfo3-&gt;startDeviceInterface&lt;</span><br><span class="line">            CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT&gt;();</span><br><span class="line">    if (interface == nullptr) &#123;</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = interface-&gt;open(callback, [&amp;status, &amp;session]</span><br><span class="line">            (Status s, const sp&lt;device::V3_2::ICameraDeviceSession&gt;&amp; cameraSession) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                if (status == Status::OK) &#123;</span><br><span class="line">                    *session = cameraSession;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    if (!ret.isOk()) &#123;</span><br><span class="line">        removeRef(DeviceMode::CAMERA, id);</span><br><span class="line">        ALOGE(&quot;%s: Transaction error opening a session for camera device %s: %s&quot;,</span><br><span class="line">                __FUNCTION__, id.c_str(), ret.description().c_str());</span><br><span class="line">        return DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    return mapToStatusT(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-2-2-5-小结"><a href="#3-2-2-5-小结" class="headerlink" title="3.2.2.5 小结"></a>3.2.2.5 小结</h5><p>对于打开相机设备动作，主要由connectDevice来实现；</p>
<p>当CameraFramework通过调用ICameraService的connectDevice接口的时候，主要做了两件事情：</p>
<ul>
<li>一个是创建CameraDeviceClient。</li>
<li>一个是对CameraDeviceClient进行初始化，并将其给Framework。</li>
</ul>
<p>而其中创建CameraDevcieClient的工作是通过makeClient方法来实现的，在该方法中首先实例化一个CameraDeviceClient，并且将来自Framework针对ICameraDeviceCallbacks的实现类CameraDeviceImpl.CameraDeviceCallbacks存入CameraDeviceClient中，这样一旦有结果产生便可以将结果通过这个回调回传给Framework，其次还实例化了一个Camera3Device对象。</p>
<p>其中的CameraDeviceClient的初始化工作是通过调用其initialize方法来完成的，在该方法中：</p>
<ul>
<li>首先调用父类Camera2ClientBase的initialize方法进行初始化。</li>
<li>其次实例化FrameProcessorBase对象并且将内部的Camera3Device对象传入其中，这样就建立了FrameProcessorBase和Camera3Device的联系，之后将内部线程运行起来，等待来自Camera3Device的结果。</li>
<li>最后将CameraDeviceClient注册到FrameProcessorBase内部，这样就建立了与CameraDeviceClient的联系。</li>
</ul>
<p>而在Camera2ClientBase的intialize方法中会调用Camera3Device的intialize方法对其进行初始化工作，并且通过调用Camera3Device的setNotifyCallback方法将自身注册到Camera3Device内部，这样一旦Camera3Device有结果产生就可以发送到CameraDeviceClient中。</p>
<p>而在Camera3Device的初始化过程中，首先通过调用CameraProviderManager的openSession方法打开并获取一个Provider中的ICameraDeviceSession代理，其次实例化一个HalInterface对象，将之前获取的ICameraDeviceSession代理存入其中，最后将RequestThread线程运行起来，等待Request的下发。</p>
<p>而对于CameraProviderManager的openSession方法，它会通过内部的DeviceInfo保存ICameraDevice代理，调用其open方法从Camera Provider中打开并获取一个ICameraDeviceSession远程代理，并且由于Camera3Device实现了Provider中ICameraDeviceCallback方法，会通过该open方法传入到Provider中，接收来自Provider的结果回传。</p>
<p>至此，整个connectDevice方法已经运行完毕，此时App已经获取了一个Camera设备，紧接着，由于需要采集图像，所以需要再次调用CameraDevice的createCaptureSession操作，到达Framework，再通过ICameraDeviceUser代理进行了一系列操作，分别包含了cancelRequest/beginConfigure/deleteStream/createStream以及endConfigure方法来进行数据流的配置。</p>
<h4 id="3-2-3-配置数据流"><a href="#3-2-3-配置数据流" class="headerlink" title="3.2.3 配置数据流"></a>3.2.3 配置数据流</h4><h5 id="3-2-3-1-cancelRequest"><a href="#3-2-3-1-cancelRequest" class="headerlink" title="3.2.3.1 cancelRequest"></a>3.2.3.1 cancelRequest</h5><p>[-&gt;frameworks\av\services\camera\libcameraservice\CameraDeviceClient.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">binder::Status CameraDeviceClient::cancelRequest(</span><br><span class="line">        int requestId,</span><br><span class="line">        /*out*/</span><br><span class="line">        int64_t* lastFrameNumber) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;%s, requestId = %d&quot;, __FUNCTION__, requestId);</span><br><span class="line"></span><br><span class="line">    status_t err;</span><br><span class="line">    binder::Status res;</span><br><span class="line"></span><br><span class="line">    if (!(res = checkPidStatus(__FUNCTION__)).isOk()) return res;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock icl(mBinderSerializationLock);</span><br><span class="line"></span><br><span class="line">    if (!mDevice.get()) &#123;</span><br><span class="line">        return STATUS_ERROR(CameraService::ERROR_DISCONNECTED, &quot;Camera device no longer alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock idLock(mStreamingRequestIdLock);</span><br><span class="line">    if (mStreamingRequestId != requestId) &#123;</span><br><span class="line">        String8 msg = String8::format(&quot;Camera %s: Canceling request ID %d doesn&apos;t match &quot;</span><br><span class="line">                &quot;current request ID %d&quot;, mCameraIdStr.string(), requestId, mStreamingRequestId);</span><br><span class="line">        ALOGE(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = mDevice-&gt;clearStreamingRequest(lastFrameNumber);</span><br><span class="line"></span><br><span class="line">    if (err == OK) &#123;</span><br><span class="line">        ALOGV(&quot;%s: Camera %s: Successfully cleared streaming request&quot;,</span><br><span class="line">                __FUNCTION__, mCameraIdStr.string());</span><br><span class="line">        mStreamingRequestId = REQUEST_ID_NONE;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res = STATUS_ERROR_FMT(CameraService::ERROR_INVALID_OPERATION,</span><br><span class="line">                &quot;Camera %s: Error clearing streaming request: %s (%d)&quot;,</span><br><span class="line">                mCameraIdStr.string(), strerror(-err), err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-2-beginConfigure"><a href="#3-2-3-2-beginConfigure" class="headerlink" title="3.2.3.2 beginConfigure"></a>3.2.3.2 beginConfigure</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">binder::Status CameraDeviceClient::beginConfigure() &#123;</span><br><span class="line">    // TODO: Implement this.</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;%s: Not implemented yet.&quot;, __FUNCTION__);</span><br><span class="line">    return binder::Status::ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-3-deleteStream"><a href="#3-2-3-3-deleteStream" class="headerlink" title="3.2.3.3 deleteStream"></a>3.2.3.3 deleteStream</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">binder::Status CameraDeviceClient::deleteStream(int streamId) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;%s (streamId = 0x%x)&quot;, __FUNCTION__, streamId);</span><br><span class="line"></span><br><span class="line">    binder::Status res;</span><br><span class="line">    if (!(res = checkPidStatus(__FUNCTION__)).isOk()) return res;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock icl(mBinderSerializationLock);</span><br><span class="line"></span><br><span class="line">    if (!mDevice.get()) &#123;</span><br><span class="line">        return STATUS_ERROR(CameraService::ERROR_DISCONNECTED, &quot;Camera device no longer alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isInput = false;</span><br><span class="line">    std::vector&lt;sp&lt;IBinder&gt;&gt; surfaces;</span><br><span class="line">    ssize_t dIndex = NAME_NOT_FOUND;</span><br><span class="line">    ssize_t compositeIndex  = NAME_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    if (mInputStream.configured &amp;&amp; mInputStream.id == streamId) &#123;</span><br><span class="line">        isInput = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Guard against trying to delete non-created streams</span><br><span class="line">        for (size_t i = 0; i &lt; mStreamMap.size(); ++i) &#123;</span><br><span class="line">            if (streamId == mStreamMap.valueAt(i).streamId()) &#123;</span><br><span class="line">                surfaces.push_back(mStreamMap.keyAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // See if this stream is one of the deferred streams.</span><br><span class="line">        for (size_t i = 0; i &lt; mDeferredStreams.size(); ++i) &#123;</span><br><span class="line">            if (streamId == mDeferredStreams[i]) &#123;</span><br><span class="line">                dIndex = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (size_t i = 0; i &lt; mCompositeStreamMap.size(); ++i) &#123;</span><br><span class="line">            if (streamId == mCompositeStreamMap.valueAt(i)-&gt;getStreamId()) &#123;</span><br><span class="line">                compositeIndex = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (surfaces.empty() &amp;&amp; dIndex == NAME_NOT_FOUND) &#123;</span><br><span class="line">            String8 msg = String8::format(&quot;Camera %s: Invalid stream ID (%d) specified, no such&quot;</span><br><span class="line">                    &quot; stream created yet&quot;, mCameraIdStr.string(), streamId);</span><br><span class="line">            ALOGW(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">            return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Also returns BAD_VALUE if stream ID was not valid</span><br><span class="line">    status_t err = mDevice-&gt;deleteStream(streamId);</span><br><span class="line"></span><br><span class="line">    if (err != OK) &#123;</span><br><span class="line">        String8 msg = String8::format(&quot;Camera %s: Unexpected error %s (%d) when deleting stream %d&quot;,</span><br><span class="line">                mCameraIdStr.string(), strerror(-err), err, streamId);</span><br><span class="line">        ALOGE(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">        res = STATUS_ERROR(CameraService::ERROR_INVALID_OPERATION, msg.string());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (isInput) &#123;</span><br><span class="line">            mInputStream.configured = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (auto&amp; surface : surfaces) &#123;</span><br><span class="line">                mStreamMap.removeItem(surface);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mConfiguredOutputs.removeItem(streamId);</span><br><span class="line"></span><br><span class="line">            if (dIndex != NAME_NOT_FOUND) &#123;</span><br><span class="line">                mDeferredStreams.removeItemsAt(dIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (compositeIndex != NAME_NOT_FOUND) &#123;</span><br><span class="line">                status_t ret;</span><br><span class="line">                if ((ret = mCompositeStreamMap.valueAt(compositeIndex)-&gt;deleteStream())</span><br><span class="line">                        != OK) &#123;</span><br><span class="line">                    String8 msg = String8::format(&quot;Camera %s: Unexpected error %s (%d) when &quot;</span><br><span class="line">                            &quot;deleting composite stream %d&quot;, mCameraIdStr.string(), strerror(-err), err,</span><br><span class="line">                            streamId);</span><br><span class="line">                    ALOGE(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">                    res = STATUS_ERROR(CameraService::ERROR_INVALID_OPERATION, msg.string());</span><br><span class="line">                &#125;</span><br><span class="line">                mCompositeStreamMap.removeItemsAt(compositeIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-4-createStream"><a href="#3-2-3-4-createStream" class="headerlink" title="3.2.3.4  createStream"></a>3.2.3.4  createStream</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">binder::Status CameraDeviceClient::createStream(</span><br><span class="line">        const hardware::camera2::params::OutputConfiguration &amp;outputConfiguration,</span><br><span class="line">        /*out*/</span><br><span class="line">        int32_t* newStreamId) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    binder::Status res;</span><br><span class="line">    if (!(res = checkPidStatus(__FUNCTION__)).isOk()) return res;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock icl(mBinderSerializationLock);</span><br><span class="line"></span><br><span class="line">    const std::vector&lt;sp&lt;IGraphicBufferProducer&gt;&gt;&amp; bufferProducers =</span><br><span class="line">            outputConfiguration.getGraphicBufferProducers();</span><br><span class="line">    size_t numBufferProducers = bufferProducers.size();</span><br><span class="line">    bool deferredConsumer = outputConfiguration.isDeferred();</span><br><span class="line">    bool isShared = outputConfiguration.isShared();</span><br><span class="line">    String8 physicalCameraId = String8(outputConfiguration.getPhysicalCameraId());</span><br><span class="line">    bool deferredConsumerOnly = deferredConsumer &amp;&amp; numBufferProducers == 0;</span><br><span class="line"></span><br><span class="line">    res = checkSurfaceTypeLocked(numBufferProducers, deferredConsumer,</span><br><span class="line">            outputConfiguration.getSurfaceType());</span><br><span class="line">    if (!res.isOk()) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!mDevice.get()) &#123;</span><br><span class="line">        return STATUS_ERROR(CameraService::ERROR_DISCONNECTED, &quot;Camera device no longer alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = checkPhysicalCameraIdLocked(physicalCameraId);</span><br><span class="line">    if (!res.isOk()) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;sp&lt;Surface&gt;&gt; surfaces;</span><br><span class="line">    std::vector&lt;sp&lt;IBinder&gt;&gt; binders;</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    // Create stream for deferred surface case.</span><br><span class="line">    if (deferredConsumerOnly) &#123;</span><br><span class="line">        return createDeferredSurfaceStreamLocked(outputConfiguration, isShared, newStreamId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OutputStreamInfo streamInfo;</span><br><span class="line">    bool isStreamInfoValid = false;</span><br><span class="line">    for (auto&amp; bufferProducer : bufferProducers) &#123;</span><br><span class="line">        // Don&apos;t create multiple streams for the same target surface</span><br><span class="line">        sp&lt;IBinder&gt; binder = IInterface::asBinder(bufferProducer);</span><br><span class="line">        ssize_t index = mStreamMap.indexOfKey(binder);</span><br><span class="line">        if (index != NAME_NOT_FOUND) &#123;</span><br><span class="line">            String8 msg = String8::format(&quot;Camera %s: Surface already has a stream created for it &quot;</span><br><span class="line">                    &quot;(ID %zd)&quot;, mCameraIdStr.string(), index);</span><br><span class="line">            ALOGW(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">            return STATUS_ERROR(CameraService::ERROR_ALREADY_EXISTS, msg.string());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;Surface&gt; surface;</span><br><span class="line">        res = createSurfaceFromGbp(streamInfo, isStreamInfoValid, surface, bufferProducer,</span><br><span class="line">                physicalCameraId);</span><br><span class="line"></span><br><span class="line">        if (!res.isOk())</span><br><span class="line">            return res;</span><br><span class="line"></span><br><span class="line">        if (!isStreamInfoValid) &#123;</span><br><span class="line">            isStreamInfoValid = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        binders.push_back(IInterface::asBinder(bufferProducer));</span><br><span class="line">        surfaces.push_back(surface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int streamId = camera3::CAMERA3_STREAM_ID_INVALID;</span><br><span class="line">    std::vector&lt;int&gt; surfaceIds;</span><br><span class="line">    bool isDepthCompositeStream = camera3::DepthCompositeStream::isDepthCompositeStream(surfaces[0]);</span><br><span class="line">    bool isHeicCompisiteStream = camera3::HeicCompositeStream::isHeicCompositeStream(surfaces[0]);</span><br><span class="line">    if (isDepthCompositeStream || isHeicCompisiteStream) &#123;</span><br><span class="line">        sp&lt;CompositeStream&gt; compositeStream;</span><br><span class="line">        if (isDepthCompositeStream) &#123;</span><br><span class="line">            compositeStream = new camera3::DepthCompositeStream(mDevice, getRemoteCallback());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            compositeStream = new camera3::HeicCompositeStream(mDevice, getRemoteCallback());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = compositeStream-&gt;createStream(surfaces, deferredConsumer, streamInfo.width,</span><br><span class="line">                streamInfo.height, streamInfo.format,</span><br><span class="line">                static_cast&lt;camera3_stream_rotation_t&gt;(outputConfiguration.getRotation()),</span><br><span class="line">                &amp;streamId, physicalCameraId, &amp;surfaceIds, outputConfiguration.getSurfaceSetID(),</span><br><span class="line">                isShared);</span><br><span class="line">        if (err == OK) &#123;</span><br><span class="line">            mCompositeStreamMap.add(IInterface::asBinder(surfaces[0]-&gt;getIGraphicBufferProducer()),</span><br><span class="line">                    compositeStream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err = mDevice-&gt;createStream(surfaces, deferredConsumer, streamInfo.width,</span><br><span class="line">                streamInfo.height, streamInfo.format, streamInfo.dataSpace,</span><br><span class="line">                static_cast&lt;camera3_stream_rotation_t&gt;(outputConfiguration.getRotation()),</span><br><span class="line">                &amp;streamId, physicalCameraId, &amp;surfaceIds, outputConfiguration.getSurfaceSetID(),</span><br><span class="line">                isShared);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err != OK) &#123;</span><br><span class="line">        res = STATUS_ERROR_FMT(CameraService::ERROR_INVALID_OPERATION,</span><br><span class="line">                &quot;Camera %s: Error creating output stream (%d x %d, fmt %x, dataSpace %x): %s (%d)&quot;,</span><br><span class="line">                mCameraIdStr.string(), streamInfo.width, streamInfo.height, streamInfo.format,</span><br><span class="line">                streamInfo.dataSpace, strerror(-err), err);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (auto&amp; binder : binders) &#123;</span><br><span class="line">            ALOGV(&quot;%s: mStreamMap add binder %p streamId %d, surfaceId %d&quot;,</span><br><span class="line">                    __FUNCTION__, binder.get(), streamId, i);</span><br><span class="line">            mStreamMap.add(binder, StreamSurfaceId(streamId, surfaceIds[i]));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mConfiguredOutputs.add(streamId, outputConfiguration);</span><br><span class="line">        mStreamInfoMap[streamId] = streamInfo;</span><br><span class="line"></span><br><span class="line">        ALOGV(&quot;%s: Camera %s: Successfully created a new stream ID %d for output surface&quot;</span><br><span class="line">                    &quot; (%d x %d) with format 0x%x.&quot;,</span><br><span class="line">                  __FUNCTION__, mCameraIdStr.string(), streamId, streamInfo.width,</span><br><span class="line">                  streamInfo.height, streamInfo.format);</span><br><span class="line"></span><br><span class="line">        // Set transform flags to ensure preview to be rotated correctly.</span><br><span class="line">        res = setStreamTransformLocked(streamId);</span><br><span class="line"></span><br><span class="line">        *newStreamId = streamId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-5-endConfigure"><a href="#3-2-3-5-endConfigure" class="headerlink" title="3.2.3.5 endConfigure"></a>3.2.3.5 endConfigure</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">binder::Status CameraDeviceClient::endConfigure(int operatingMode,</span><br><span class="line">        const hardware::camera2::impl::CameraMetadataNative&amp; sessionParams) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;%s: ending configure (%d input stream, %zu output surfaces)&quot;,</span><br><span class="line">            __FUNCTION__, mInputStream.configured ? 1 : 0,</span><br><span class="line">            mStreamMap.size());</span><br><span class="line"></span><br><span class="line">    binder::Status res;</span><br><span class="line">    if (!(res = checkPidStatus(__FUNCTION__)).isOk()) return res;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock icl(mBinderSerializationLock);</span><br><span class="line"></span><br><span class="line">    if (!mDevice.get()) &#123;</span><br><span class="line">        return STATUS_ERROR(CameraService::ERROR_DISCONNECTED, &quot;Camera device no longer alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = checkOperatingModeLocked(operatingMode);</span><br><span class="line">    if (!res.isOk()) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = mDevice-&gt;configureStreams(sessionParams, operatingMode);</span><br><span class="line">    if (err == BAD_VALUE) &#123;</span><br><span class="line">        String8 msg = String8::format(&quot;Camera %s: Unsupported set of inputs/outputs provided&quot;,</span><br><span class="line">                mCameraIdStr.string());</span><br><span class="line">        ALOGE(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">        res = STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());</span><br><span class="line">    &#125; else if (err != OK) &#123;</span><br><span class="line">        String8 msg = String8::format(&quot;Camera %s: Error configuring streams: %s (%d)&quot;,</span><br><span class="line">                mCameraIdStr.string(), strerror(-err), err);</span><br><span class="line">        ALOGE(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">        res = STATUS_ERROR(CameraService::ERROR_INVALID_OPERATION, msg.string());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (size_t i = 0; i &lt; mCompositeStreamMap.size(); ++i) &#123;</span><br><span class="line">            err = mCompositeStreamMap.valueAt(i)-&gt;configureStream();</span><br><span class="line">            if (err != OK ) &#123;</span><br><span class="line">                String8 msg = String8::format(&quot;Camera %s: Error configuring composite &quot;</span><br><span class="line">                        &quot;streams: %s (%d)&quot;, mCameraIdStr.string(), strerror(-err), err);</span><br><span class="line">                ALOGE(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">                res = STATUS_ERROR(CameraService::ERROR_INVALID_OPERATION, msg.string());</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-6-小结"><a href="#3-2-3-6-小结" class="headerlink" title="3.2.3.6 小结"></a>3.2.3.6 小结</h5><p>cancelRequest逻辑比较简单，对应的方法是CameraDeviceClient的cancelRequest方法，在该方法中会去通知Camera3Device将RequestThread中的Request队列清空，停止Request的继续下发。</p>
<p>beginConfigure方法是空实现。</p>
<p>deleteStream/createStream 分别是用于删除之前的数据流以及为新的操作创建数据流。</p>
<p>紧接着调用位于整个调用流程的末尾endConfigure方法，该方法对应着CameraDeviceClient的endConfigure方法，其逻辑比较简单，在该方法中会调用Camera3Device的configureStreams的方法，而该方法又会去通过ICameraDeviceSession的configureStreams_3_4的方法最终将需求传递给Provider。</p>
<p>到这里整个数据流已经配置完成，并且App也获取了Framework中的CameraCaptureSession对象，之后便可进行图像需求的下发了，在下发之前需要先创建一个Request，而App通过调用CameraDeviceImpl中的createCaptureRequest来实现，该方法在Framework中实现，内部会再去调用Camera Service中的AIDL接口createDefaultRequest，该接口的实现是CameraDeviceClient，在其内部又会去调用Camera3Device的createDefaultRequest方法，最后通过ICameraDeviceSession代理的constructDefaultRequestSettings方法将需求下发到Provider端去创建一个默认的Request配置，一旦操作完成，Provider会将配置上传至Service，进而给到App中。</p>
<h4 id="3-2-4-处理图像需求"><a href="#3-2-4-处理图像需求" class="headerlink" title="3.2.4 处理图像需求"></a>3.2.4 处理图像需求</h4><h5 id="3-2-4-1-createDefaultRequest"><a href="#3-2-4-1-createDefaultRequest" class="headerlink" title="3.2.4.1 createDefaultRequest"></a>3.2.4.1 createDefaultRequest</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Create a request object from a template.</span><br><span class="line">binder::Status CameraDeviceClient::createDefaultRequest(int templateId,</span><br><span class="line">        /*out*/</span><br><span class="line">        hardware::camera2::impl::CameraMetadataNative* request)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;%s (templateId = 0x%x)&quot;, __FUNCTION__, templateId);</span><br><span class="line"></span><br><span class="line">    binder::Status res;</span><br><span class="line">    if (!(res = checkPidStatus(__FUNCTION__)).isOk()) return res;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock icl(mBinderSerializationLock);</span><br><span class="line"></span><br><span class="line">    if (!mDevice.get()) &#123;</span><br><span class="line">        return STATUS_ERROR(CameraService::ERROR_DISCONNECTED, &quot;Camera device no longer alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CameraMetadata metadata;</span><br><span class="line">    status_t err;</span><br><span class="line">    if ( (err = mDevice-&gt;createDefaultRequest(templateId, &amp;metadata) ) == OK &amp;&amp;</span><br><span class="line">        request != NULL) &#123;</span><br><span class="line"></span><br><span class="line">        request-&gt;swap(metadata);</span><br><span class="line">    &#125; else if (err == BAD_VALUE) &#123;</span><br><span class="line">        res = STATUS_ERROR_FMT(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                &quot;Camera %s: Template ID %d is invalid or not supported: %s (%d)&quot;,</span><br><span class="line">                mCameraIdStr.string(), templateId, strerror(-err), err);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res = STATUS_ERROR_FMT(CameraService::ERROR_INVALID_OPERATION,</span><br><span class="line">                &quot;Camera %s: Error creating default request for template %d: %s (%d)&quot;,</span><br><span class="line">                mCameraIdStr.string(), templateId, strerror(-err), err);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-4-2-createDefaultRequest"><a href="#3-2-4-2-createDefaultRequest" class="headerlink" title="3.2.4.2 createDefaultRequest"></a>3.2.4.2 createDefaultRequest</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">status_t Camera3Device::createDefaultRequest(int templateId,</span><br><span class="line">        CameraMetadata *request) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;%s: for template %d&quot;, __FUNCTION__, templateId);</span><br><span class="line"></span><br><span class="line">    if (templateId &lt;= 0 || templateId &gt;= CAMERA3_TEMPLATE_COUNT) &#123;</span><br><span class="line">        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, &quot;26866110&quot;,</span><br><span class="line">                CameraThreadState::getCallingUid(), nullptr, 0);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock il(mInterfaceLock);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock l(mLock);</span><br><span class="line">        switch (mStatus) &#123;</span><br><span class="line">            case STATUS_ERROR:</span><br><span class="line">                CLOGE(&quot;Device has encountered a serious error&quot;);</span><br><span class="line">                return INVALID_OPERATION;</span><br><span class="line">            case STATUS_UNINITIALIZED:</span><br><span class="line">                CLOGE(&quot;Device is not initialized!&quot;);</span><br><span class="line">                return INVALID_OPERATION;</span><br><span class="line">            case STATUS_UNCONFIGURED:</span><br><span class="line">            case STATUS_CONFIGURED:</span><br><span class="line">            case STATUS_ACTIVE:</span><br><span class="line">                // OK</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                SET_ERR_L(&quot;Unexpected status: %d&quot;, mStatus);</span><br><span class="line">                return INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mRequestTemplateCache[templateId].isEmpty()) &#123;</span><br><span class="line">            *request = mRequestTemplateCache[templateId];</span><br><span class="line">            mLastTemplateId = templateId;</span><br><span class="line">            return OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    camera_metadata_t *rawRequest;</span><br><span class="line">    status_t res = mInterface-&gt;constructDefaultRequestSettings(</span><br><span class="line">            (camera3_request_template_t) templateId, &amp;rawRequest);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock l(mLock);</span><br><span class="line">        if (res == BAD_VALUE) &#123;</span><br><span class="line">            ALOGI(&quot;%s: template %d is not supported on this camera device&quot;,</span><br><span class="line">                  __FUNCTION__, templateId);</span><br><span class="line">            return res;</span><br><span class="line">        &#125; else if (res != OK) &#123;</span><br><span class="line">            CLOGE(&quot;Unable to construct request template %d: %s (%d)&quot;,</span><br><span class="line">                    templateId, strerror(-res), res);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_camera_metadata_vendor_id(rawRequest, mVendorTagId);</span><br><span class="line">        mRequestTemplateCache[templateId].acquire(rawRequest);</span><br><span class="line"></span><br><span class="line">        *request = mRequestTemplateCache[templateId];</span><br><span class="line">        mLastTemplateId = templateId;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-4-3-submitRequestList"><a href="#3-2-4-3-submitRequestList" class="headerlink" title="3.2.4.3 submitRequestList"></a>3.2.4.3 submitRequestList</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line">binder::Status CameraDeviceClient::submitRequestList(</span><br><span class="line">        const std::vector&lt;hardware::camera2::CaptureRequest&gt;&amp; requests,</span><br><span class="line">        bool streaming,</span><br><span class="line">        /*out*/</span><br><span class="line">        hardware::camera2::utils::SubmitInfo *submitInfo) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;%s-start of function. Request list size %zu&quot;, __FUNCTION__, requests.size());</span><br><span class="line"></span><br><span class="line">    binder::Status res = binder::Status::ok();</span><br><span class="line">    status_t err;</span><br><span class="line">    if ( !(res = checkPidStatus(__FUNCTION__) ).isOk()) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock icl(mBinderSerializationLock);</span><br><span class="line"></span><br><span class="line">    if (!mDevice.get()) &#123;</span><br><span class="line">        return STATUS_ERROR(CameraService::ERROR_DISCONNECTED, &quot;Camera device no longer alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (requests.empty()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Camera %s: Sent null request. Rejecting request.&quot;,</span><br><span class="line">              __FUNCTION__, mCameraIdStr.string());</span><br><span class="line">        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, &quot;Empty request list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;const CameraDeviceBase::PhysicalCameraSettingsList&gt; metadataRequestList;</span><br><span class="line">    std::list&lt;const SurfaceMap&gt; surfaceMapList;</span><br><span class="line">    submitInfo-&gt;mRequestId = mRequestIdCounter;</span><br><span class="line">    uint32_t loopCounter = 0;</span><br><span class="line"></span><br><span class="line">    for (auto&amp;&amp; request: requests) &#123;</span><br><span class="line">        if (request.mIsReprocess) &#123;</span><br><span class="line">            if (!mInputStream.configured) &#123;</span><br><span class="line">                ALOGE(&quot;%s: Camera %s: no input stream is configured.&quot;, __FUNCTION__,</span><br><span class="line">                        mCameraIdStr.string());</span><br><span class="line">                return STATUS_ERROR_FMT(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                        &quot;No input configured for camera %s but request is for reprocessing&quot;,</span><br><span class="line">                        mCameraIdStr.string());</span><br><span class="line">            &#125; else if (streaming) &#123;</span><br><span class="line">                ALOGE(&quot;%s: Camera %s: streaming reprocess requests not supported.&quot;, __FUNCTION__,</span><br><span class="line">                        mCameraIdStr.string());</span><br><span class="line">                return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                        &quot;Repeating reprocess requests not supported&quot;);</span><br><span class="line">            &#125; else if (request.mPhysicalCameraSettings.size() &gt; 1) &#123;</span><br><span class="line">                ALOGE(&quot;%s: Camera %s: reprocess requests not supported for &quot;</span><br><span class="line">                        &quot;multiple physical cameras.&quot;, __FUNCTION__,</span><br><span class="line">                        mCameraIdStr.string());</span><br><span class="line">                return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                        &quot;Reprocess requests not supported for multiple cameras&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (request.mPhysicalCameraSettings.empty()) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Camera %s: request doesn&apos;t contain any settings.&quot;, __FUNCTION__,</span><br><span class="line">                    mCameraIdStr.string());</span><br><span class="line">            return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                    &quot;Request doesn&apos;t contain any settings&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //The first capture settings should always match the logical camera id</span><br><span class="line">        String8 logicalId(request.mPhysicalCameraSettings.begin()-&gt;id.c_str());</span><br><span class="line">        if (mDevice-&gt;getId() != logicalId) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Camera %s: Invalid camera request settings.&quot;, __FUNCTION__,</span><br><span class="line">                    mCameraIdStr.string());</span><br><span class="line">            return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                    &quot;Invalid camera request settings&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (request.mSurfaceList.isEmpty() &amp;&amp; request.mStreamIdxList.size() == 0) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Camera %s: Requests must have at least one surface target. &quot;</span><br><span class="line">                    &quot;Rejecting request.&quot;, __FUNCTION__, mCameraIdStr.string());</span><br><span class="line">            return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                    &quot;Request has no output targets&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Write in the output stream IDs and map from stream ID to surface ID</span><br><span class="line">         * which we calculate from the capture request&apos;s list of surface target</span><br><span class="line">         */</span><br><span class="line">        SurfaceMap surfaceMap;</span><br><span class="line">        Vector&lt;int32_t&gt; outputStreamIds;</span><br><span class="line">        std::vector&lt;std::string&gt; requestedPhysicalIds;</span><br><span class="line">        if (request.mSurfaceList.size() &gt; 0) &#123;</span><br><span class="line">            for (const sp&lt;Surface&gt;&amp; surface : request.mSurfaceList) &#123;</span><br><span class="line">                if (surface == 0) continue;</span><br><span class="line"></span><br><span class="line">                int32_t streamId;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; gbp = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">                res = insertGbpLocked(gbp, &amp;surfaceMap, &amp;outputStreamIds, &amp;streamId);</span><br><span class="line">                if (!res.isOk()) &#123;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ssize_t index = mConfiguredOutputs.indexOfKey(streamId);</span><br><span class="line">                if (index &gt;= 0) &#123;</span><br><span class="line">                    String8 requestedPhysicalId(</span><br><span class="line">                            mConfiguredOutputs.valueAt(index).getPhysicalCameraId());</span><br><span class="line">                    requestedPhysicalIds.push_back(requestedPhysicalId.string());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ALOGW(&quot;%s: Output stream Id not found among configured outputs!&quot;, __FUNCTION__);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (size_t i = 0; i &lt; request.mStreamIdxList.size(); i++) &#123;</span><br><span class="line">                int streamId = request.mStreamIdxList.itemAt(i);</span><br><span class="line">                int surfaceIdx = request.mSurfaceIdxList.itemAt(i);</span><br><span class="line"></span><br><span class="line">                ssize_t index = mConfiguredOutputs.indexOfKey(streamId);</span><br><span class="line">                if (index &lt; 0) &#123;</span><br><span class="line">                    ALOGE(&quot;%s: Camera %s: Tried to submit a request with a surface that&quot;</span><br><span class="line">                            &quot; we have not called createStream on: stream %d&quot;,</span><br><span class="line">                            __FUNCTION__, mCameraIdStr.string(), streamId);</span><br><span class="line">                    return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                            &quot;Request targets Surface that is not part of current capture session&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const auto&amp; gbps = mConfiguredOutputs.valueAt(index).getGraphicBufferProducers();</span><br><span class="line">                if ((size_t)surfaceIdx &gt;= gbps.size()) &#123;</span><br><span class="line">                    ALOGE(&quot;%s: Camera %s: Tried to submit a request with a surface that&quot;</span><br><span class="line">                            &quot; we have not called createStream on: stream %d, surfaceIdx %d&quot;,</span><br><span class="line">                            __FUNCTION__, mCameraIdStr.string(), streamId, surfaceIdx);</span><br><span class="line">                    return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                            &quot;Request targets Surface has invalid surface index&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                res = insertGbpLocked(gbps[surfaceIdx], &amp;surfaceMap, &amp;outputStreamIds, nullptr);</span><br><span class="line">                if (!res.isOk()) &#123;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String8 requestedPhysicalId(</span><br><span class="line">                        mConfiguredOutputs.valueAt(index).getPhysicalCameraId());</span><br><span class="line">                requestedPhysicalIds.push_back(requestedPhysicalId.string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CameraDeviceBase::PhysicalCameraSettingsList physicalSettingsList;</span><br><span class="line">        for (const auto&amp; it : request.mPhysicalCameraSettings) &#123;</span><br><span class="line">            if (it.settings.isEmpty()) &#123;</span><br><span class="line">                ALOGE(&quot;%s: Camera %s: Sent empty metadata packet. Rejecting request.&quot;,</span><br><span class="line">                        __FUNCTION__, mCameraIdStr.string());</span><br><span class="line">                return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                        &quot;Request settings are empty&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String8 physicalId(it.id.c_str());</span><br><span class="line">            if (physicalId != mDevice-&gt;getId()) &#123;</span><br><span class="line">                auto found = std::find(requestedPhysicalIds.begin(), requestedPhysicalIds.end(),</span><br><span class="line">                        it.id);</span><br><span class="line">                if (found == requestedPhysicalIds.end()) &#123;</span><br><span class="line">                    ALOGE(&quot;%s: Camera %s: Physical camera id: %s not part of attached outputs.&quot;,</span><br><span class="line">                            __FUNCTION__, mCameraIdStr.string(), physicalId.string());</span><br><span class="line">                    return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                            &quot;Invalid physical camera id&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!mSupportedPhysicalRequestKeys.empty()) &#123;</span><br><span class="line">                    // Filter out any unsupported physical request keys.</span><br><span class="line">                    CameraMetadata filteredParams(mSupportedPhysicalRequestKeys.size());</span><br><span class="line">                    camera_metadata_t *meta = const_cast&lt;camera_metadata_t *&gt;(</span><br><span class="line">                            filteredParams.getAndLock());</span><br><span class="line">                    set_camera_metadata_vendor_id(meta, mDevice-&gt;getVendorTagId());</span><br><span class="line">                    filteredParams.unlock(meta);</span><br><span class="line"></span><br><span class="line">                    for (const auto&amp; keyIt : mSupportedPhysicalRequestKeys) &#123;</span><br><span class="line">                        camera_metadata_ro_entry entry = it.settings.find(keyIt);</span><br><span class="line">                        if (entry.count &gt; 0) &#123;</span><br><span class="line">                            filteredParams.update(entry);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    physicalSettingsList.push_back(&#123;it.id, filteredParams&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                physicalSettingsList.push_back(&#123;it.id, it.settings&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!enforceRequestPermissions(physicalSettingsList.begin()-&gt;metadata)) &#123;</span><br><span class="line">            // Callee logs</span><br><span class="line">            return STATUS_ERROR(CameraService::ERROR_PERMISSION_DENIED,</span><br><span class="line">                    &quot;Caller does not have permission to change restricted controls&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        physicalSettingsList.begin()-&gt;metadata.update(ANDROID_REQUEST_OUTPUT_STREAMS,</span><br><span class="line">                &amp;outputStreamIds[0], outputStreamIds.size());</span><br><span class="line"></span><br><span class="line">        if (request.mIsReprocess) &#123;</span><br><span class="line">            physicalSettingsList.begin()-&gt;metadata.update(ANDROID_REQUEST_INPUT_STREAMS,</span><br><span class="line">                    &amp;mInputStream.id, 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        physicalSettingsList.begin()-&gt;metadata.update(ANDROID_REQUEST_ID,</span><br><span class="line">                &amp;(submitInfo-&gt;mRequestId), /*size*/1);</span><br><span class="line">        loopCounter++; // loopCounter starts from 1</span><br><span class="line">        ALOGV(&quot;%s: Camera %s: Creating request with ID %d (%d of %zu)&quot;,</span><br><span class="line">                __FUNCTION__, mCameraIdStr.string(), submitInfo-&gt;mRequestId,</span><br><span class="line">                loopCounter, requests.size());</span><br><span class="line">        metadataRequestList.push_back(physicalSettingsList);</span><br><span class="line">        surfaceMapList.push_back(surfaceMap);</span><br><span class="line">    &#125;</span><br><span class="line">    mRequestIdCounter++;</span><br><span class="line"></span><br><span class="line">    if (streaming) &#123;</span><br><span class="line">        err = mDevice-&gt;setStreamingRequestList(metadataRequestList, surfaceMapList,</span><br><span class="line">                &amp;(submitInfo-&gt;mLastFrameNumber));</span><br><span class="line">        if (err != OK) &#123;</span><br><span class="line">            String8 msg = String8::format(</span><br><span class="line">                &quot;Camera %s:  Got error %s (%d) after trying to set streaming request&quot;,</span><br><span class="line">                mCameraIdStr.string(), strerror(-err), err);</span><br><span class="line">            ALOGE(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">            res = STATUS_ERROR(CameraService::ERROR_INVALID_OPERATION,</span><br><span class="line">                    msg.string());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Mutex::Autolock idLock(mStreamingRequestIdLock);</span><br><span class="line">            mStreamingRequestId = submitInfo-&gt;mRequestId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err = mDevice-&gt;captureList(metadataRequestList, surfaceMapList,</span><br><span class="line">                &amp;(submitInfo-&gt;mLastFrameNumber));</span><br><span class="line">        if (err != OK) &#123;</span><br><span class="line">            String8 msg = String8::format(</span><br><span class="line">                &quot;Camera %s: Got error %s (%d) after trying to submit capture request&quot;,</span><br><span class="line">                mCameraIdStr.string(), strerror(-err), err);</span><br><span class="line">            ALOGE(&quot;%s: %s&quot;, __FUNCTION__, msg.string());</span><br><span class="line">            res = STATUS_ERROR(CameraService::ERROR_INVALID_OPERATION,</span><br><span class="line">                    msg.string());</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGV(&quot;%s: requestId = %d &quot;, __FUNCTION__, submitInfo-&gt;mRequestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;%s: Camera %s: End of function&quot;, __FUNCTION__, mCameraIdStr.string());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-4-4-setStreamingRequestList"><a href="#3-2-4-4-setStreamingRequestList" class="headerlink" title="3.2.4.4 setStreamingRequestList"></a>3.2.4.4 setStreamingRequestList</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">status_t Camera3Device::setStreamingRequestList(</span><br><span class="line">        const List&lt;const PhysicalCameraSettingsList&gt; &amp;requestsList,</span><br><span class="line">        const std::list&lt;const SurfaceMap&gt; &amp;surfaceMaps, int64_t *lastFrameNumber) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    return submitRequestsHelper(requestsList, surfaceMaps, /*repeating*/true, lastFrameNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t Camera3Device::submitRequestsHelper(</span><br><span class="line">        const List&lt;const PhysicalCameraSettingsList&gt; &amp;requests,</span><br><span class="line">        const std::list&lt;const SurfaceMap&gt; &amp;surfaceMaps,</span><br><span class="line">        bool repeating,</span><br><span class="line">        /*out*/</span><br><span class="line">        int64_t *lastFrameNumber) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::Autolock il(mInterfaceLock);</span><br><span class="line">    Mutex::Autolock l(mLock);</span><br><span class="line"></span><br><span class="line">    status_t res = checkStatusOkToCaptureLocked();</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        // error logged by previous call</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RequestList requestList;</span><br><span class="line"></span><br><span class="line">    res = convertMetadataListToRequestListLocked(requests, surfaceMaps,</span><br><span class="line">            repeating, /*out*/&amp;requestList);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        // error logged by previous call</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (repeating) &#123;</span><br><span class="line">        res = mRequestThread-&gt;setRepeatingRequests(requestList, lastFrameNumber);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res = mRequestThread-&gt;queueRequestList(requestList, lastFrameNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (res == OK) &#123;</span><br><span class="line">        waitUntilStateThenRelock(/*active*/true, kActiveTimeout);</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            SET_ERR_L(&quot;Can&apos;t transition to active in %f seconds!&quot;,</span><br><span class="line">                    kActiveTimeout/1e9);</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGV(&quot;Camera %s: Capture request %&quot; PRId32 &quot; enqueued&quot;, mId.string(),</span><br><span class="line">              (*(requestList.begin()))-&gt;mResultExtras.requestId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        CLOGE(&quot;Cannot queue request. Impossible.&quot;);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-4-5-sendRequestsBatch"><a href="#3-2-4-5-sendRequestsBatch" class="headerlink" title="3.2.4.5 sendRequestsBatch"></a>3.2.4.5 sendRequestsBatch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">bool Camera3Device::RequestThread::sendRequestsBatch() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    status_t res;</span><br><span class="line">    size_t batchSize = mNextRequests.size();</span><br><span class="line">    std::vector&lt;camera3_capture_request_t*&gt; requests(batchSize);</span><br><span class="line">    uint32_t numRequestProcessed = 0;</span><br><span class="line">    for (size_t i = 0; i &lt; batchSize; i++) &#123;</span><br><span class="line">        requests[i] = &amp;mNextRequests.editItemAt(i).halRequest;</span><br><span class="line">        ATRACE_ASYNC_BEGIN(&quot;frame capture&quot;, mNextRequests[i].halRequest.frame_number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = mInterface-&gt;processBatchCaptureRequests(requests, &amp;numRequestProcessed);</span><br><span class="line"></span><br><span class="line">    bool triggerRemoveFailed = false;</span><br><span class="line">    NextRequest&amp; triggerFailedRequest = mNextRequests.editItemAt(0);</span><br><span class="line">    for (size_t i = 0; i &lt; numRequestProcessed; i++) &#123;</span><br><span class="line">        NextRequest&amp; nextRequest = mNextRequests.editItemAt(i);</span><br><span class="line">        nextRequest.submitted = true;</span><br><span class="line"></span><br><span class="line">        updateNextRequest(nextRequest);</span><br><span class="line"></span><br><span class="line">        if (!triggerRemoveFailed) &#123;</span><br><span class="line">            // Remove any previously queued triggers (after unlock)</span><br><span class="line">            status_t removeTriggerRes = removeTriggers(mPrevRequest);</span><br><span class="line">            if (removeTriggerRes != OK) &#123;</span><br><span class="line">                triggerRemoveFailed = true;</span><br><span class="line">                triggerFailedRequest = nextRequest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (triggerRemoveFailed) &#123;</span><br><span class="line">        SET_ERR(&quot;RequestThread: Unable to remove triggers &quot;</span><br><span class="line">              &quot;(capture request %d, HAL device: %s (%d)&quot;,</span><br><span class="line">              triggerFailedRequest.halRequest.frame_number, strerror(-res), res);</span><br><span class="line">        cleanUpFailedRequests(/*sendRequestError*/ false);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        // Should only get a failure here for malformed requests or device-level</span><br><span class="line">        // errors, so consider all errors fatal.  Bad metadata failures should</span><br><span class="line">        // come through notify.</span><br><span class="line">        SET_ERR(&quot;RequestThread: Unable to submit capture request %d to HAL device: %s (%d)&quot;,</span><br><span class="line">                mNextRequests[numRequestProcessed].halRequest.frame_number,</span><br><span class="line">                strerror(-res), res);</span><br><span class="line">        cleanUpFailedRequests(/*sendRequestError*/ false);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-4-6-processBatchCaptureRequests"><a href="#3-2-4-6-processBatchCaptureRequests" class="headerlink" title="3.2.4.6 processBatchCaptureRequests"></a>3.2.4.6 processBatchCaptureRequests</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">status_t Camera3Device::HalInterface::processBatchCaptureRequests(</span><br><span class="line">        std::vector&lt;camera3_capture_request_t*&gt;&amp; requests,/*out*/uint32_t* numRequestProcessed) &#123;</span><br><span class="line">    ATRACE_NAME(&quot;CameraHal::processBatchCaptureRequests&quot;);</span><br><span class="line">    if (!valid()) return INVALID_OPERATION;</span><br><span class="line"></span><br><span class="line">    sp&lt;device::V3_4::ICameraDeviceSession&gt; hidlSession_3_4;</span><br><span class="line">    auto castResult_3_4 = device::V3_4::ICameraDeviceSession::castFrom(mHidlSession);</span><br><span class="line">    if (castResult_3_4.isOk()) &#123;</span><br><span class="line">        hidlSession_3_4 = castResult_3_4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hardware::hidl_vec&lt;device::V3_2::CaptureRequest&gt; captureRequests;</span><br><span class="line">    hardware::hidl_vec&lt;device::V3_4::CaptureRequest&gt; captureRequests_3_4;</span><br><span class="line">    size_t batchSize = requests.size();</span><br><span class="line">    if (hidlSession_3_4 != nullptr) &#123;</span><br><span class="line">        captureRequests_3_4.resize(batchSize);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        captureRequests.resize(batchSize);</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;native_handle_t*&gt; handlesCreated;</span><br><span class="line">    std::vector&lt;std::pair&lt;int32_t, int32_t&gt;&gt; inflightBuffers;</span><br><span class="line"></span><br><span class="line">    status_t res = OK;</span><br><span class="line">    for (size_t i = 0; i &lt; batchSize; i++) &#123;</span><br><span class="line">        if (hidlSession_3_4 != nullptr) &#123;</span><br><span class="line">            res = wrapAsHidlRequest(requests[i], /*out*/&amp;captureRequests_3_4[i].v3_2,</span><br><span class="line">                    /*out*/&amp;handlesCreated, /*out*/&amp;inflightBuffers);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res = wrapAsHidlRequest(requests[i], /*out*/&amp;captureRequests[i],</span><br><span class="line">                    /*out*/&amp;handlesCreated, /*out*/&amp;inflightBuffers);</span><br><span class="line">        &#125;</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            popInflightBuffers(inflightBuffers);</span><br><span class="line">            cleanupNativeHandles(&amp;handlesCreated);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;device::V3_2::BufferCache&gt; cachesToRemove;</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mBufferIdMapLock);</span><br><span class="line">        for (auto&amp; pair : mFreedBuffers) &#123;</span><br><span class="line">            // The stream might have been removed since onBufferFreed</span><br><span class="line">            if (mBufferIdMaps.find(pair.first) != mBufferIdMaps.end()) &#123;</span><br><span class="line">                cachesToRemove.push_back(&#123;pair.first, pair.second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mFreedBuffers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    common::V1_0::Status status = common::V1_0::Status::INTERNAL_ERROR;</span><br><span class="line">    *numRequestProcessed = 0;</span><br><span class="line"></span><br><span class="line">    // Write metadata to FMQ.</span><br><span class="line">    for (size_t i = 0; i &lt; batchSize; i++) &#123;</span><br><span class="line">        camera3_capture_request_t* request = requests[i];</span><br><span class="line">        device::V3_2::CaptureRequest* captureRequest;</span><br><span class="line">        if (hidlSession_3_4 != nullptr) &#123;</span><br><span class="line">            captureRequest = &amp;captureRequests_3_4[i].v3_2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            captureRequest = &amp;captureRequests[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (request-&gt;settings != nullptr) &#123;</span><br><span class="line">            size_t settingsSize = get_camera_metadata_size(request-&gt;settings);</span><br><span class="line">            if (mRequestMetadataQueue != nullptr &amp;&amp; mRequestMetadataQueue-&gt;write(</span><br><span class="line">                    reinterpret_cast&lt;const uint8_t*&gt;(request-&gt;settings), settingsSize)) &#123;</span><br><span class="line">                captureRequest-&gt;settings.resize(0);</span><br><span class="line">                captureRequest-&gt;fmqSettingsSize = settingsSize;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mRequestMetadataQueue != nullptr) &#123;</span><br><span class="line">                    ALOGW(&quot;%s: couldn&apos;t utilize fmq, fallback to hwbinder&quot;, __FUNCTION__);</span><br><span class="line">                &#125;</span><br><span class="line">                captureRequest-&gt;settings.setToExternal(</span><br><span class="line">                        reinterpret_cast&lt;uint8_t*&gt;(const_cast&lt;camera_metadata_t*&gt;(request-&gt;settings)),</span><br><span class="line">                        get_camera_metadata_size(request-&gt;settings));</span><br><span class="line">                captureRequest-&gt;fmqSettingsSize = 0u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // A null request settings maps to a size-0 CameraMetadata</span><br><span class="line">            captureRequest-&gt;settings.resize(0);</span><br><span class="line">            captureRequest-&gt;fmqSettingsSize = 0u;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (hidlSession_3_4 != nullptr) &#123;</span><br><span class="line">            captureRequests_3_4[i].physicalCameraSettings.resize(request-&gt;num_physcam_settings);</span><br><span class="line">            for (size_t j = 0; j &lt; request-&gt;num_physcam_settings; j++) &#123;</span><br><span class="line">                if (request-&gt;physcam_settings != nullptr) &#123;</span><br><span class="line">                    size_t settingsSize = get_camera_metadata_size(request-&gt;physcam_settings[j]);</span><br><span class="line">                    if (mRequestMetadataQueue != nullptr &amp;&amp; mRequestMetadataQueue-&gt;write(</span><br><span class="line">                                reinterpret_cast&lt;const uint8_t*&gt;(request-&gt;physcam_settings[j]),</span><br><span class="line">                                settingsSize)) &#123;</span><br><span class="line">                        captureRequests_3_4[i].physicalCameraSettings[j].settings.resize(0);</span><br><span class="line">                        captureRequests_3_4[i].physicalCameraSettings[j].fmqSettingsSize =</span><br><span class="line">                            settingsSize;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (mRequestMetadataQueue != nullptr) &#123;</span><br><span class="line">                            ALOGW(&quot;%s: couldn&apos;t utilize fmq, fallback to hwbinder&quot;, __FUNCTION__);</span><br><span class="line">                        &#125;</span><br><span class="line">                        captureRequests_3_4[i].physicalCameraSettings[j].settings.setToExternal(</span><br><span class="line">                                reinterpret_cast&lt;uint8_t*&gt;(const_cast&lt;camera_metadata_t*&gt;(</span><br><span class="line">                                        request-&gt;physcam_settings[j])),</span><br><span class="line">                                get_camera_metadata_size(request-&gt;physcam_settings[j]));</span><br><span class="line">                        captureRequests_3_4[i].physicalCameraSettings[j].fmqSettingsSize = 0u;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    captureRequests_3_4[i].physicalCameraSettings[j].fmqSettingsSize = 0u;</span><br><span class="line">                    captureRequests_3_4[i].physicalCameraSettings[j].settings.resize(0);</span><br><span class="line">                &#125;</span><br><span class="line">                captureRequests_3_4[i].physicalCameraSettings[j].physicalCameraId =</span><br><span class="line">                    request-&gt;physcam_id[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hardware::details::return_status err;</span><br><span class="line">    auto resultCallback =</span><br><span class="line">        [&amp;status, &amp;numRequestProcessed] (auto s, uint32_t n) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                *numRequestProcessed = n;</span><br><span class="line">        &#125;;</span><br><span class="line">    if (hidlSession_3_4 != nullptr) &#123;</span><br><span class="line">        err = hidlSession_3_4-&gt;processCaptureRequest_3_4(captureRequests_3_4, cachesToRemove,</span><br><span class="line">                                                         resultCallback);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err = mHidlSession-&gt;processCaptureRequest(captureRequests, cachesToRemove,</span><br><span class="line">                                                  resultCallback);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!err.isOk()) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Transaction error: %s&quot;, __FUNCTION__, err.description().c_str());</span><br><span class="line">        status = common::V1_0::Status::CAMERA_DISCONNECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (status == common::V1_0::Status::OK &amp;&amp; *numRequestProcessed != batchSize) &#123;</span><br><span class="line">        ALOGE(&quot;%s: processCaptureRequest returns OK but processed %d/%zu requests&quot;,</span><br><span class="line">                __FUNCTION__, *numRequestProcessed, batchSize);</span><br><span class="line">        status = common::V1_0::Status::INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = CameraProviderManager::mapToStatusT(status);</span><br><span class="line">    if (res == OK) &#123;</span><br><span class="line">        if (mHidlSession-&gt;isRemote()) &#123;</span><br><span class="line">            // Only close acquire fence FDs when the HIDL transaction succeeds (so the FDs have been</span><br><span class="line">            // sent to camera HAL processes)</span><br><span class="line">            cleanupNativeHandles(&amp;handlesCreated, /*closeFd*/true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // In passthrough mode the FDs are now owned by HAL</span><br><span class="line">            cleanupNativeHandles(&amp;handlesCreated);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        popInflightBuffers(inflightBuffers);</span><br><span class="line">        cleanupNativeHandles(&amp;handlesCreated);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-4-7-小结"><a href="#3-2-4-7-小结" class="headerlink" title="3.2.4.7 小结"></a>3.2.4.7 小结</h5><p>在创建Request成功之后，便可下发图像采集需求了，这里大致分为两个流程，一个是预览，一个拍照，两者差异主要体现在Camera Service中针对Request获取优先级上，一般拍照的Request优先级高于预览，具体表现是当预览Request在不断下发的时候，来了一次拍照需求，在Camera3Device 的RequestThread线程中，会优先下发此次拍照的Request。这里我们主要梳理下下发拍照request的大体流程：</p>
<p>下发拍照Request到Camera Service，其操作主要是由CameraDevcieClient的submitRequestList方法来实现，在该方法中，会调用Camera3Device的setStreamingRequestList方法，将需求发送到Camera3Device中，而Camera3Device将需求又加入到RequestThread中的RequestQueue中，并唤醒RequestThread线程，在该线程被唤醒后，会从RequestQueue中取出Request，通过之前获取的ICameraDeviceSession代理的processCaptureRequest_3_4方法将需求发送至Provider中，由于谷歌对于processCaptureRequest_3_4的限制，使其必须是非阻塞实现，所以一旦发送成功，便立即返回，在App端便等待这结果的回传。</p>
<h4 id="3-2-5-接收图像结果"><a href="#3-2-5-接收图像结果" class="headerlink" title="3.2.5 接收图像结果"></a>3.2.5 接收图像结果</h4><p>针对结果的获取是通过异步实现，主要分别两个部分，一个是事件的回传，一个是数据的回传，而数据中又根据流程的差异主要分为Meta Data和Image Data两个部分，接下来我们详细介绍下：</p>
<p>在下发Request之后，首先从Provider端传来的是Shutter Notify</p>
<h5 id="3-2-5-1-notify"><a href="#3-2-5-1-notify" class="headerlink" title="3.2.5.1 notify"></a>3.2.5.1 notify</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void Camera3Device::notify(const camera3_notify_msg *msg) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    sp&lt;NotificationListener&gt; listener;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock l(mOutputLock);</span><br><span class="line">        listener = mListener.promote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (msg == NULL) &#123;</span><br><span class="line">        SET_ERR(&quot;HAL sent NULL notify message!&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (msg-&gt;type) &#123;</span><br><span class="line">        case CAMERA3_MSG_ERROR: &#123;</span><br><span class="line">            notifyError(msg-&gt;message.error, listener);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case CAMERA3_MSG_SHUTTER: &#123;</span><br><span class="line">            notifyShutter(msg-&gt;message.shutter, listener);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            SET_ERR(&quot;Unknown notify message from HAL: %d&quot;,</span><br><span class="line">                    msg-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-5-2-Camera3Device-notifyShutter"><a href="#3-2-5-2-Camera3Device-notifyShutter" class="headerlink" title="3.2.5.2 Camera3Device::notifyShutter"></a>3.2.5.2 Camera3Device::notifyShutter</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">void Camera3Device::notifyShutter(const camera3_shutter_msg_t &amp;msg,</span><br><span class="line">        sp&lt;NotificationListener&gt; listener) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ssize_t idx;</span><br><span class="line"></span><br><span class="line">    // Set timestamp for the request in the in-flight tracking</span><br><span class="line">    // and get the request ID to send upstream</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock l(mInFlightLock);</span><br><span class="line">        idx = mInFlightMap.indexOfKey(msg.frame_number);</span><br><span class="line">        if (idx &gt;= 0) &#123;</span><br><span class="line">            InFlightRequest &amp;r = mInFlightMap.editValueAt(idx);</span><br><span class="line"></span><br><span class="line">            // Verify ordering of shutter notifications</span><br><span class="line">            &#123;</span><br><span class="line">                Mutex::Autolock l(mOutputLock);</span><br><span class="line">                // TODO: need to track errors for tighter bounds on expected frame number.</span><br><span class="line">                if (r.hasInputBuffer) &#123;</span><br><span class="line">                    if (msg.frame_number &lt; mNextReprocessShutterFrameNumber) &#123;</span><br><span class="line">                        SET_ERR(&quot;Reprocess shutter notification out-of-order. Expected &quot;</span><br><span class="line">                                &quot;notification for frame %d, got frame %d&quot;,</span><br><span class="line">                                mNextReprocessShutterFrameNumber, msg.frame_number);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mNextReprocessShutterFrameNumber = msg.frame_number + 1;</span><br><span class="line">                &#125; else if (r.zslCapture &amp;&amp; r.stillCapture) &#123;</span><br><span class="line">                    if (msg.frame_number &lt; mNextZslStillShutterFrameNumber) &#123;</span><br><span class="line">                        SET_ERR(&quot;ZSL still capture shutter notification out-of-order. Expected &quot;</span><br><span class="line">                                &quot;notification for frame %d, got frame %d&quot;,</span><br><span class="line">                                mNextZslStillShutterFrameNumber, msg.frame_number);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mNextZslStillShutterFrameNumber = msg.frame_number + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (msg.frame_number &lt; mNextShutterFrameNumber) &#123;</span><br><span class="line">                        SET_ERR(&quot;Shutter notification out-of-order. Expected &quot;</span><br><span class="line">                                &quot;notification for frame %d, got frame %d&quot;,</span><br><span class="line">                                mNextShutterFrameNumber, msg.frame_number);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mNextShutterFrameNumber = msg.frame_number + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.shutterTimestamp = msg.timestamp;</span><br><span class="line">            if (r.hasCallback) &#123;</span><br><span class="line">                ALOGVV(&quot;Camera %s: %s: Shutter fired for frame %d (id %d) at %&quot; PRId64,</span><br><span class="line">                    mId.string(), __FUNCTION__,</span><br><span class="line">                    msg.frame_number, r.resultExtras.requestId, msg.timestamp);</span><br><span class="line">                // Call listener, if any</span><br><span class="line">                if (listener != NULL) &#123;</span><br><span class="line">                    listener-&gt;notifyShutter(r.resultExtras, msg.timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                // send pending result and buffers</span><br><span class="line">                sendCaptureResult(r.pendingMetadata, r.resultExtras,</span><br><span class="line">                    r.collectedPartialResult, msg.frame_number,</span><br><span class="line">                    r.hasInputBuffer, r.zslCapture &amp;&amp; r.stillCapture,</span><br><span class="line">                    r.physicalMetadatas);</span><br><span class="line">            &#125;</span><br><span class="line">            bool timestampIncreasing = !(r.zslCapture || r.hasInputBuffer);</span><br><span class="line">            returnOutputBuffers(r.pendingOutputBuffers.array(),</span><br><span class="line">                    r.pendingOutputBuffers.size(), r.shutterTimestamp, timestampIncreasing,</span><br><span class="line">                    r.outputSurfaces, r.resultExtras);</span><br><span class="line">            r.pendingOutputBuffers.clear();</span><br><span class="line"></span><br><span class="line">            removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (idx &lt; 0) &#123;</span><br><span class="line">        SET_ERR(&quot;Shutter notification for non-existent frame number %d&quot;,</span><br><span class="line">                msg.frame_number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-5-3-CameraDeviceClient-notifyShutter"><a href="#3-2-5-3-CameraDeviceClient-notifyShutter" class="headerlink" title="3.2.5.3 CameraDeviceClient::notifyShutter"></a>3.2.5.3 CameraDeviceClient::notifyShutter</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void CameraDeviceClient::notifyShutter(const CaptureResultExtras&amp; resultExtras,</span><br><span class="line">        nsecs_t timestamp) &#123;</span><br><span class="line">    // Thread safe. Don&apos;t bother locking.</span><br><span class="line">    sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt; remoteCb = getRemoteCallback();</span><br><span class="line">    if (remoteCb != 0) &#123;</span><br><span class="line">        remoteCb-&gt;onCaptureStarted(resultExtras, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">    Camera2ClientBase::notifyShutter(resultExtras, timestamp);</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; mCompositeStreamMap.size(); i++) &#123;</span><br><span class="line">        mCompositeStreamMap.valueAt(i)-&gt;onShutter(resultExtras, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename TClientBase&gt;</span><br><span class="line">void Camera2ClientBase&lt;TClientBase&gt;::notifyShutter(const CaptureResultExtras&amp; resultExtras,</span><br><span class="line">                                                   nsecs_t timestamp) &#123;</span><br><span class="line">    (void)resultExtras;</span><br><span class="line">    (void)timestamp;</span><br><span class="line"></span><br><span class="line">    if (!mDeviceActive) &#123;</span><br><span class="line">        getCameraService()-&gt;updateProxyDeviceState(</span><br><span class="line">            hardware::ICameraServiceProxy::CAMERA_STATE_ACTIVE, TClientBase::mCameraIdStr,</span><br><span class="line">            TClientBase::mCameraFacing, TClientBase::mClientPackageName,</span><br><span class="line">            ((mApi1CameraId &lt; 0) ? hardware::ICameraServiceProxy::CAMERA_API_LEVEL_2 :</span><br><span class="line">             hardware::ICameraServiceProxy::CAMERA_API_LEVEL_1));</span><br><span class="line">    &#125;</span><br><span class="line">    mDeviceActive = true;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;%s: Shutter notification for request id %&quot; PRId32 &quot; at time %&quot; PRId64,</span><br><span class="line">            __FUNCTION__, resultExtras.requestId, timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-5-4-sendCaptureResult"><a href="#3-2-5-4-sendCaptureResult" class="headerlink" title="3.2.5.4 sendCaptureResult"></a>3.2.5.4 sendCaptureResult</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">void Camera3Device::sendCaptureResult(CameraMetadata &amp;pendingMetadata,</span><br><span class="line">        CaptureResultExtras &amp;resultExtras,</span><br><span class="line">        CameraMetadata &amp;collectedPartialResult,</span><br><span class="line">        uint32_t frameNumber,</span><br><span class="line">        bool reprocess, bool zslStillCapture,</span><br><span class="line">        const std::vector&lt;PhysicalCaptureResultInfo&gt;&amp; physicalMetadatas) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    if (pendingMetadata.isEmpty())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock l(mOutputLock);</span><br><span class="line"></span><br><span class="line">    // TODO: need to track errors for tighter bounds on expected frame number</span><br><span class="line">    if (reprocess) &#123;</span><br><span class="line">        if (frameNumber &lt; mNextReprocessResultFrameNumber) &#123;</span><br><span class="line">            SET_ERR(&quot;Out-of-order reprocess capture result metadata submitted! &quot;</span><br><span class="line">                &quot;(got frame number %d, expecting %d)&quot;,</span><br><span class="line">                frameNumber, mNextReprocessResultFrameNumber);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mNextReprocessResultFrameNumber = frameNumber + 1;</span><br><span class="line">    &#125; else if (zslStillCapture) &#123;</span><br><span class="line">        if (frameNumber &lt; mNextZslStillResultFrameNumber) &#123;</span><br><span class="line">            SET_ERR(&quot;Out-of-order ZSL still capture result metadata submitted! &quot;</span><br><span class="line">                &quot;(got frame number %d, expecting %d)&quot;,</span><br><span class="line">                frameNumber, mNextZslStillResultFrameNumber);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mNextZslStillResultFrameNumber = frameNumber + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (frameNumber &lt; mNextResultFrameNumber) &#123;</span><br><span class="line">            SET_ERR(&quot;Out-of-order capture result metadata submitted! &quot;</span><br><span class="line">                    &quot;(got frame number %d, expecting %d)&quot;,</span><br><span class="line">                    frameNumber, mNextResultFrameNumber);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mNextResultFrameNumber = frameNumber + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CaptureResult captureResult;</span><br><span class="line">    captureResult.mResultExtras = resultExtras;</span><br><span class="line">    captureResult.mMetadata = pendingMetadata;</span><br><span class="line">    captureResult.mPhysicalMetadatas = physicalMetadatas;</span><br><span class="line"></span><br><span class="line">    // Append any previous partials to form a complete result</span><br><span class="line">    if (mUsePartialResult &amp;&amp; !collectedPartialResult.isEmpty()) &#123;</span><br><span class="line">        captureResult.mMetadata.append(collectedPartialResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    captureResult.mMetadata.sort();</span><br><span class="line"></span><br><span class="line">    // Check that there&apos;s a timestamp in the result metadata</span><br><span class="line">    camera_metadata_entry timestamp = captureResult.mMetadata.find(ANDROID_SENSOR_TIMESTAMP);</span><br><span class="line">    if (timestamp.count == 0) &#123;</span><br><span class="line">        SET_ERR(&quot;No timestamp provided by HAL for frame %d!&quot;,</span><br><span class="line">                frameNumber);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    nsecs_t sensorTimestamp = timestamp.data.i64[0];</span><br><span class="line"></span><br><span class="line">    for (auto&amp; physicalMetadata : captureResult.mPhysicalMetadatas) &#123;</span><br><span class="line">        camera_metadata_entry timestamp =</span><br><span class="line">                physicalMetadata.mPhysicalCameraMetadata.find(ANDROID_SENSOR_TIMESTAMP);</span><br><span class="line">        if (timestamp.count == 0) &#123;</span><br><span class="line">            SET_ERR(&quot;No timestamp provided by HAL for physical camera %s frame %d!&quot;,</span><br><span class="line">                    String8(physicalMetadata.mPhysicalCameraId).c_str(), frameNumber);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fix up some result metadata to account for HAL-level distortion correction</span><br><span class="line">    status_t res =</span><br><span class="line">            mDistortionMappers[mId.c_str()].correctCaptureResult(&amp;captureResult.mMetadata);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        SET_ERR(&quot;Unable to correct capture result metadata for frame %d: %s (%d)&quot;,</span><br><span class="line">                frameNumber, strerror(res), res);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto&amp; physicalMetadata : captureResult.mPhysicalMetadatas) &#123;</span><br><span class="line">        String8 cameraId8(physicalMetadata.mPhysicalCameraId);</span><br><span class="line">        if (mDistortionMappers.find(cameraId8.c_str()) == mDistortionMappers.end()) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        res = mDistortionMappers[cameraId8.c_str()].correctCaptureResult(</span><br><span class="line">                &amp;physicalMetadata.mPhysicalCameraMetadata);</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            SET_ERR(&quot;Unable to correct physical capture result metadata for frame %d: %s (%d)&quot;,</span><br><span class="line">                    frameNumber, strerror(res), res);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fix up result metadata for monochrome camera.</span><br><span class="line">    res = fixupMonochromeTags(mDeviceInfo, captureResult.mMetadata);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        SET_ERR(&quot;Failed to override result metadata: %s (%d)&quot;, strerror(-res), res);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto&amp; physicalMetadata : captureResult.mPhysicalMetadatas) &#123;</span><br><span class="line">        String8 cameraId8(physicalMetadata.mPhysicalCameraId);</span><br><span class="line">        res = fixupMonochromeTags(mPhysicalDeviceInfoMap.at(cameraId8.c_str()),</span><br><span class="line">                physicalMetadata.mPhysicalCameraMetadata);</span><br><span class="line">        if (res != OK) &#123;</span><br><span class="line">            SET_ERR(&quot;Failed to override result metadata: %s (%d)&quot;, strerror(-res), res);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;std::string, CameraMetadata&gt; monitoredPhysicalMetadata;</span><br><span class="line">    for (auto&amp; m : physicalMetadatas) &#123;</span><br><span class="line">        monitoredPhysicalMetadata.emplace(String8(m.mPhysicalCameraId).string(),</span><br><span class="line">                CameraMetadata(m.mPhysicalCameraMetadata));</span><br><span class="line">    &#125;</span><br><span class="line">    mTagMonitor.monitorMetadata(TagMonitor::RESULT,</span><br><span class="line">            frameNumber, sensorTimestamp, captureResult.mMetadata,</span><br><span class="line">            monitoredPhysicalMetadata);</span><br><span class="line"></span><br><span class="line">    insertResultLocked(&amp;captureResult, frameNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-5-5-insertResultLocked"><a href="#3-2-5-5-insertResultLocked" class="headerlink" title="3.2.5.5 insertResultLocked"></a>3.2.5.5 insertResultLocked</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void Camera3Device::insertResultLocked(CaptureResult *result,</span><br><span class="line">        uint32_t frameNumber) &#123;</span><br><span class="line">    if (result == nullptr) return;</span><br><span class="line"></span><br><span class="line">    camera_metadata_t *meta = const_cast&lt;camera_metadata_t *&gt;(</span><br><span class="line">            result-&gt;mMetadata.getAndLock());</span><br><span class="line">    set_camera_metadata_vendor_id(meta, mVendorTagId);</span><br><span class="line">    result-&gt;mMetadata.unlock(meta);</span><br><span class="line"></span><br><span class="line">    if (result-&gt;mMetadata.update(ANDROID_REQUEST_FRAME_COUNT,</span><br><span class="line">            (int32_t*)&amp;frameNumber, 1) != OK) &#123;</span><br><span class="line">        SET_ERR(&quot;Failed to set frame number %d in metadata&quot;, frameNumber);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result-&gt;mMetadata.update(ANDROID_REQUEST_ID, &amp;result-&gt;mResultExtras.requestId, 1) != OK) &#123;</span><br><span class="line">        SET_ERR(&quot;Failed to set request ID in metadata for frame %d&quot;, frameNumber);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Update vendor tag id for physical metadata</span><br><span class="line">    for (auto&amp; physicalMetadata : result-&gt;mPhysicalMetadatas) &#123;</span><br><span class="line">        camera_metadata_t *pmeta = const_cast&lt;camera_metadata_t *&gt;(</span><br><span class="line">                physicalMetadata.mPhysicalCameraMetadata.getAndLock());</span><br><span class="line">        set_camera_metadata_vendor_id(pmeta, mVendorTagId);</span><br><span class="line">        physicalMetadata.mPhysicalCameraMetadata.unlock(pmeta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String8 tagString = String8(&quot;org.qti.camera.customControl.multicamInfo&quot;);</span><br><span class="line">    camera_metadata_entry entry;</span><br><span class="line">    getMetaDataFromResults(result-&gt;mMetadata, tagString, &amp;entry);</span><br><span class="line">    if (entry.count != 0) &#123;</span><br><span class="line">        CHIMULTICAMINFO *multiCam;</span><br><span class="line">        multiCam = (CHIMULTICAMINFO *)(entry.data.u8);</span><br><span class="line">        ALOGVV(&quot;%s: add_metadata_log, get data succeed, data count: %zu, data: %d, %d&quot;,</span><br><span class="line">            __FUNCTION__, entry.count, multiCam-&gt;camraId, multiCam-&gt;testDataSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tagString = String8(&quot;org.qti.camera.cameraSnInfo.sensorSnNum&quot;);</span><br><span class="line">    getMetaDataFromResults(result-&gt;mMetadata, tagString, &amp;entry);</span><br><span class="line">    if (entry.count != 0) &#123;</span><br><span class="line">        int64_t* cameraSnNumber;</span><br><span class="line">        cameraSnNumber = reinterpret_cast&lt;int64_t*&gt;(entry.data.u8);</span><br><span class="line">        ALOGVV(&quot;%s: add_metadata_log, get data succeed, data count: %zu, data: %&quot; PRId64 &quot;&quot;,</span><br><span class="line">            __FUNCTION__, entry.count, *cameraSnNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Valid result, insert into queue</span><br><span class="line">    List&lt;CaptureResult&gt;::iterator queuedResult =</span><br><span class="line">            mResultQueue.insert(mResultQueue.end(), CaptureResult(*result));</span><br><span class="line">    ALOGVV(&quot;%s: result requestId = %&quot; PRId32 &quot;, frameNumber = %&quot; PRId64</span><br><span class="line">           &quot;, burstId = %&quot; PRId32, __FUNCTION__,</span><br><span class="line">           queuedResult-&gt;mResultExtras.requestId,</span><br><span class="line">           queuedResult-&gt;mResultExtras.frameNumber,</span><br><span class="line">           queuedResult-&gt;mResultExtras.burstId);</span><br><span class="line"></span><br><span class="line">    mResultSignal.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-5-6-processNewFrames"><a href="#3-2-5-6-processNewFrames" class="headerlink" title="3.2.5.6 processNewFrames"></a>3.2.5.6 processNewFrames</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">bool FrameProcessorBase::threadLoop() &#123;</span><br><span class="line">    status_t res;</span><br><span class="line"></span><br><span class="line">    sp&lt;CameraDeviceBase&gt; device;</span><br><span class="line">    &#123;</span><br><span class="line">        device = mDevice.promote();</span><br><span class="line">        if (device == 0) return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = device-&gt;waitForNextFrame(kWaitDuration);</span><br><span class="line">    if (res == OK) &#123;</span><br><span class="line">        processNewFrames(device);</span><br><span class="line">    &#125; else if (res != TIMED_OUT) &#123;</span><br><span class="line">        ALOGE(&quot;FrameProcessorBase: Error waiting for new &quot;</span><br><span class="line">                &quot;frames: %s (%d)&quot;, strerror(-res), res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FrameProcessorBase::processNewFrames(const sp&lt;CameraDeviceBase&gt; &amp;device) &#123;</span><br><span class="line">    status_t res;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    CaptureResult result;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;%s: Camera %s: Process new frames&quot;, __FUNCTION__, device-&gt;getId().string());</span><br><span class="line"></span><br><span class="line">    while ( (res = device-&gt;getNextResult(&amp;result)) == OK) &#123;</span><br><span class="line"></span><br><span class="line">        // TODO: instead of getting frame number from metadata, we should read</span><br><span class="line">        // this from result.mResultExtras when CameraDeviceBase interface is fixed.</span><br><span class="line">        camera_metadata_entry_t entry;</span><br><span class="line"></span><br><span class="line">        entry = result.mMetadata.find(ANDROID_REQUEST_FRAME_COUNT);</span><br><span class="line">        if (entry.count == 0) &#123;</span><br><span class="line">            ALOGE(&quot;%s: Camera %s: Error reading frame number&quot;,</span><br><span class="line">                    __FUNCTION__, device-&gt;getId().string());</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ATRACE_INT(&quot;cam2_frame&quot;, entry.data.i32[0]);</span><br><span class="line"></span><br><span class="line">        if (!processSingleFrame(result, device)) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!result.mMetadata.isEmpty()) &#123;</span><br><span class="line">            Mutex::Autolock al(mLastFrameMutex);</span><br><span class="line">            mLastFrame.acquire(result.mMetadata);</span><br><span class="line"></span><br><span class="line">            mLastPhysicalFrames = std::move(result.mPhysicalMetadatas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (res != NOT_ENOUGH_DATA) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Camera %s: Error getting next frame: %s (%d)&quot;,</span><br><span class="line">                __FUNCTION__, device-&gt;getId().string(), strerror(-res), res);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-5-7-processSingleFrame"><a href="#3-2-5-7-processSingleFrame" class="headerlink" title="3.2.5.7 processSingleFrame"></a>3.2.5.7 processSingleFrame</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">bool FrameProcessorBase::processSingleFrame(CaptureResult &amp;result,</span><br><span class="line">                                            const sp&lt;CameraDeviceBase&gt; &amp;device) &#123;</span><br><span class="line">    ALOGV(&quot;%s: Camera %s: Process single frame (is empty? %d)&quot;,</span><br><span class="line">            __FUNCTION__, device-&gt;getId().string(), result.mMetadata.isEmpty());</span><br><span class="line">    return processListeners(result, device) == OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t FrameProcessorBase::processListeners(const CaptureResult &amp;result,</span><br><span class="line">        const sp&lt;CameraDeviceBase&gt; &amp;device) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    camera_metadata_ro_entry_t entry;</span><br><span class="line"></span><br><span class="line">    // Check if this result is partial.</span><br><span class="line">    bool isPartialResult =</span><br><span class="line">            result.mResultExtras.partialResultCount &lt; mNumPartialResults;</span><br><span class="line"></span><br><span class="line">    // TODO: instead of getting requestID from CameraMetadata, we should get it</span><br><span class="line">    // from CaptureResultExtras. This will require changing Camera2Device.</span><br><span class="line">    // Currently Camera2Device uses MetadataQueue to store results, which does not</span><br><span class="line">    // include CaptureResultExtras.</span><br><span class="line">    entry = result.mMetadata.find(ANDROID_REQUEST_ID);</span><br><span class="line">    if (entry.count == 0) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Camera %s: Error reading frame id&quot;, __FUNCTION__, device-&gt;getId().string());</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    int32_t requestId = entry.data.i32[0];</span><br><span class="line"></span><br><span class="line">    List&lt;sp&lt;FilteredListener&gt; &gt; listeners;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock l(mInputMutex);</span><br><span class="line"></span><br><span class="line">        List&lt;RangeListener&gt;::iterator item = mRangeListeners.begin();</span><br><span class="line">        // Don&apos;t deliver partial results to listeners that don&apos;t want them</span><br><span class="line">        while (item != mRangeListeners.end()) &#123;</span><br><span class="line">            if (requestId &gt;= item-&gt;minId &amp;&amp; requestId &lt; item-&gt;maxId &amp;&amp;</span><br><span class="line">                    (!isPartialResult || item-&gt;sendPartials)) &#123;</span><br><span class="line">                sp&lt;FilteredListener&gt; listener = item-&gt;listener.promote();</span><br><span class="line">                if (listener == 0) &#123;</span><br><span class="line">                    item = mRangeListeners.erase(item);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    listeners.push_back(listener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            item++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGV(&quot;%s: Camera %s: Got %zu range listeners out of %zu&quot;, __FUNCTION__,</span><br><span class="line">          device-&gt;getId().string(), listeners.size(), mRangeListeners.size());</span><br><span class="line"></span><br><span class="line">    List&lt;sp&lt;FilteredListener&gt; &gt;::iterator item = listeners.begin();</span><br><span class="line">    for (; item != listeners.end(); item++) &#123;</span><br><span class="line">        (*item)-&gt;onResultAvailable(result);</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-5-8-returnOutputBuffers"><a href="#3-2-5-8-returnOutputBuffers" class="headerlink" title="3.2.5.8 returnOutputBuffers"></a>3.2.5.8 returnOutputBuffers</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">void Camera3Device::returnOutputBuffers(</span><br><span class="line">        const camera3_stream_buffer_t *outputBuffers, size_t numBuffers,</span><br><span class="line">        nsecs_t timestamp, bool timestampIncreasing,</span><br><span class="line">        const SurfaceMap&amp; outputSurfaces,</span><br><span class="line">        const CaptureResultExtras &amp;inResultExtras) &#123;</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; numBuffers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (outputBuffers[i].buffer == nullptr) &#123;</span><br><span class="line">            if (!mUseHalBufManager) &#123;</span><br><span class="line">                // With HAL buffer management API, HAL sometimes will have to return buffers that</span><br><span class="line">                // has not got a output buffer handle filled yet. This is though illegal if HAL</span><br><span class="line">                // buffer management API is not being used.</span><br><span class="line">                ALOGE(&quot;%s: cannot return a null buffer!&quot;, __FUNCTION__);</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Camera3StreamInterface *stream = Camera3Stream::cast(outputBuffers[i].stream);</span><br><span class="line">        int streamId = stream-&gt;getId();</span><br><span class="line">        const auto&amp; it = outputSurfaces.find(streamId);</span><br><span class="line">        status_t res = OK;</span><br><span class="line">        if (it != outputSurfaces.end()) &#123;</span><br><span class="line">            res = stream-&gt;returnBuffer(</span><br><span class="line">                    outputBuffers[i], timestamp, timestampIncreasing, it-&gt;second,</span><br><span class="line">                    inResultExtras.frameNumber);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res = stream-&gt;returnBuffer(</span><br><span class="line">                    outputBuffers[i], timestamp, timestampIncreasing, std::vector&lt;size_t&gt; (),</span><br><span class="line">                    inResultExtras.frameNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Note: stream may be deallocated at this point, if this buffer was</span><br><span class="line">        // the last reference to it.</span><br><span class="line">        if (res == NO_INIT || res == DEAD_OBJECT) &#123;</span><br><span class="line">            ALOGV(&quot;Can&apos;t return buffer to its stream: %s (%d)&quot;, strerror(-res), res);</span><br><span class="line">        &#125; else if (res != OK) &#123;</span><br><span class="line">            ALOGE(&quot;Can&apos;t return buffer to its stream: %s (%d)&quot;, strerror(-res), res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Long processing consumers can cause returnBuffer timeout for shared stream</span><br><span class="line">        // If that happens, cancel the buffer and send a buffer error to client</span><br><span class="line">        if (it != outputSurfaces.end() &amp;&amp; res == TIMED_OUT &amp;&amp;</span><br><span class="line">                outputBuffers[i].status == CAMERA3_BUFFER_STATUS_OK) &#123;</span><br><span class="line">            // cancel the buffer</span><br><span class="line">            camera3_stream_buffer_t sb = outputBuffers[i];</span><br><span class="line">            sb.status = CAMERA3_BUFFER_STATUS_ERROR;</span><br><span class="line">            stream-&gt;returnBuffer(sb, /*timestamp*/0, timestampIncreasing, std::vector&lt;size_t&gt; (),</span><br><span class="line">                    inResultExtras.frameNumber);</span><br><span class="line"></span><br><span class="line">            // notify client buffer error</span><br><span class="line">            sp&lt;NotificationListener&gt; listener;</span><br><span class="line">            &#123;</span><br><span class="line">                Mutex::Autolock l(mOutputLock);</span><br><span class="line">                listener = mListener.promote();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (listener != nullptr) &#123;</span><br><span class="line">                CaptureResultExtras extras = inResultExtras;</span><br><span class="line">                extras.errorStreamId = streamId;</span><br><span class="line">                listener-&gt;notifyError(</span><br><span class="line">                        hardware::camera2::ICameraDeviceCallbacks::ERROR_CAMERA_BUFFER,</span><br><span class="line">                        extras);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-5-9-小结"><a href="#3-2-5-9-小结" class="headerlink" title="3.2.5.9 小结"></a>3.2.5.9 小结</h5><p>在下发Request之后，首先从Provider端传来的是Shutter Notify，因为之前已经将Camera3Device作为ICameraDeviceCallback的实现传入Provider中，所以此时会调用Camera3Device的notify方法将事件传入Camera Service中，紧接着通过层层调用，将事件通过CameraDeviceClient的notifyShutter方法发送到CameraDeviceClient中，之后又通过打开相机设备时传入的Framework的CameraDeviceCallbacks接口的onCaptureStarted方法将事件最终传入Framework，进而给到App端。</p>
<p>在Shutter事件上报完成之后，当一旦有Meta Data生成，Camera Provider便会通过ICameraDeviceCallback的processCaptureResult_3_4方法将数据给到Camera Service，而该接口的实现对应的是Camera3Device的processCaptureResult_3_4方法，在该方法会通过层层调用，调用sendCaptureResult方法将Result放入一个mResultQueue中，并且通知FrameProcessorBase的线程去取出Result，并且将其发送至CameraDeviceClient中，之后通过内部的CameraDeviceCallbacks远程代理的onResultReceived方法将结果上传至Framework层，进而给到App中进行处理。</p>
<p>随后Image Data前期也会按照类似的流程走到Camera3Device中，但是会通过调用returnOutputBuffers方法将数据给到Camera3OutputStream中，而该Stream中会通过BufferQueue这一生产者消费者模式中的生产者的queue方法通知消费者对该buffer进行消费，而消费者正是App端的诸如ImageReader等拥有Surface的类，最后App便可以将图像数据取出进行后期处理了。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>初代Android相机框架中，Camera Service层就已经存在了，主要用于向上与Camera Framework保持低耦合关联，承接其图像请求，内部封装了Camera Hal Module模块，通过HAL接口对其进行控制，所以该层从一开始就是谷歌按照分层思想，将硬件抽象层抽离出来放入Service中进行管理，这样的好处显而易见，将平台厂商实现的硬件抽象层与系统层解耦，独立进行控制。之后随着谷歌将平台厂商的实现放入vendor分区中，彻底将系统与平台厂商在系统分区上保持了隔离，此时，谷歌便顺势将Camera HAL Moudle从Camera Service中解耦出来放到了vendor分区下的独立进程Camera Provider中，所以之后，Camera Service 的职责便是承接来自Camera Framework的请求，之后将请求转发至Camera Provider中，作为一个中转站的角色存在在系统中。</p>

      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android-Camera/" rel="tag">#Android Camera</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/深入理解Android Camera架构一-应用层/" rel="next" title="深入理解Android Camera架构一-应用层">
                <i class="fa fa-chevron-left"></i> 深入理解Android Camera架构一-应用层
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/深入理解Android Camera架构三-硬件抽象层/" rel="prev" title="深入理解Android Camera架构三-硬件抽象层">
                深入理解Android Camera架构三-硬件抽象层 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Camera-AIDL-接口"><span class="nav-text">二、Camera AIDL 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-ICameraService-aidl"><span class="nav-text">2.1 ICameraService.aidl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-ICameraDeviceCallbacks-aidl"><span class="nav-text">2.2 ICameraDeviceCallbacks.aidl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-ICameraDeviceUser-aidl"><span class="nav-text">2.3 ICameraDeviceUser.aidl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-ICameraServiceListener-aidl"><span class="nav-text">2.4 ICameraServiceListener.aidl</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、Camera-Service"><span class="nav-text">三、Camera Service</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-启动初始化"><span class="nav-text">3.1 启动初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-cameraserver-rc"><span class="nav-text">3.1.1 cameraserver.rc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-main-cameraserver-cpp"><span class="nav-text">3.1.2 main_cameraserver.cpp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-CameraService-onFirstRef"><span class="nav-text">3.1.3 CameraService::onFirstRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-CameraService-enumerateProviders"><span class="nav-text">3.1.4 CameraService::enumerateProviders</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5-mCameraProviderManager-initialize"><span class="nav-text">3.1.5 mCameraProviderManager::initialize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-6-addProviderLocked"><span class="nav-text">3.1.6 addProviderLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-7-ProviderInfo-initialize"><span class="nav-text">3.1.7 ProviderInfo::initialize</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-7-1-initializeDeviceInfo"><span class="nav-text">3.1.7.1 initializeDeviceInfo</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-7-2-startDeviceInterface"><span class="nav-text">3.1.7.2 startDeviceInterface</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-7-3-new-DeviceInfo3"><span class="nav-text">3.1.7.3 new DeviceInfo3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-8-小结"><span class="nav-text">3.1.8 小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-处理应用请求"><span class="nav-text">3.2 处理应用请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-获取属性"><span class="nav-text">3.2.1 获取属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-打开相机"><span class="nav-text">3.2.2 打开相机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-1-CameraService-connectDevice"><span class="nav-text">3.2.2.1 CameraService::connectDevice</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-2-CameraService-connectHelper"><span class="nav-text">3.2.2.2 CameraService::connectHelper</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-3-CameraService-makeClient"><span class="nav-text">3.2.2.3 CameraService::makeClient</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#new-CameraDeviceClient"><span class="nav-text">new CameraDeviceClient</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-4-CameraDeviceClient-initialize"><span class="nav-text">3.2.2.4 CameraDeviceClient::initialize</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-5-小结"><span class="nav-text">3.2.2.5 小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-配置数据流"><span class="nav-text">3.2.3 配置数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-1-cancelRequest"><span class="nav-text">3.2.3.1 cancelRequest</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-2-beginConfigure"><span class="nav-text">3.2.3.2 beginConfigure</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-3-deleteStream"><span class="nav-text">3.2.3.3 deleteStream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-4-createStream"><span class="nav-text">3.2.3.4  createStream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-5-endConfigure"><span class="nav-text">3.2.3.5 endConfigure</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-6-小结"><span class="nav-text">3.2.3.6 小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-处理图像需求"><span class="nav-text">3.2.4 处理图像需求</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-1-createDefaultRequest"><span class="nav-text">3.2.4.1 createDefaultRequest</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-2-createDefaultRequest"><span class="nav-text">3.2.4.2 createDefaultRequest</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-3-submitRequestList"><span class="nav-text">3.2.4.3 submitRequestList</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-4-setStreamingRequestList"><span class="nav-text">3.2.4.4 setStreamingRequestList</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-5-sendRequestsBatch"><span class="nav-text">3.2.4.5 sendRequestsBatch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-6-processBatchCaptureRequests"><span class="nav-text">3.2.4.6 processBatchCaptureRequests</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-7-小结"><span class="nav-text">3.2.4.7 小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-接收图像结果"><span class="nav-text">3.2.5 接收图像结果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-1-notify"><span class="nav-text">3.2.5.1 notify</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-2-Camera3Device-notifyShutter"><span class="nav-text">3.2.5.2 Camera3Device::notifyShutter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-3-CameraDeviceClient-notifyShutter"><span class="nav-text">3.2.5.3 CameraDeviceClient::notifyShutter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-4-sendCaptureResult"><span class="nav-text">3.2.5.4 sendCaptureResult</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-5-insertResultLocked"><span class="nav-text">3.2.5.5 insertResultLocked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-6-processNewFrames"><span class="nav-text">3.2.5.6 processNewFrames</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-7-processSingleFrame"><span class="nav-text">3.2.5.7 processSingleFrame</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-8-returnOutputBuffers"><span class="nav-text">3.2.5.8 returnOutputBuffers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-9-小结"><span class="nav-text">3.2.5.9 小结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、总结"><span class="nav-text">四、总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2024/深入理解Android Camera架构二-服务层/';
      var disqus_title = "深入理解Android Camera架构二-服务层";
      var disqus_url = 'http://zproo.github.io/2024/深入理解Android Camera架构二-服务层/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
