<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="View,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="一、概述本文将从startActivity开始讲解Android屏幕刷新机制，前面的文章有分析过startActivity的启动过程，这里将重点分析WMS相关的过程，从而了解Android屏幕刷新机制原理。前面介绍的startActivity启动过程的流程图如下：  二、View的绘制过程从启动过程中的performLaunchActivity开始分析，View真正的绘制是在Activity中的o">
<meta name="keywords" content="View">
<meta property="og:type" content="article">
<meta property="og:title" content="Android刷新机制-View绘制原理">
<meta property="og:url" content="http://zproo.github.io/2020/Android刷新机制-View绘制原理/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="一、概述本文将从startActivity开始讲解Android屏幕刷新机制，前面的文章有分析过startActivity的启动过程，这里将重点分析WMS相关的过程，从而了解Android屏幕刷新机制原理。前面介绍的startActivity启动过程的流程图如下：  二、View的绘制过程从启动过程中的performLaunchActivity开始分析，View真正的绘制是在Activity中的o">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2020/Android刷新机制-View绘制原理/startActivity.jpg">
<meta property="og:image" content="http://zproo.github.io/2020/Android刷新机制-View绘制原理/window_decoreview.png">
<meta property="og:image" content="http://zproo.github.io/2020/Android刷新机制-View绘制原理/phonewindow.jpg">
<meta property="og:updated_time" content="2020-07-29T08:41:52.534Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android刷新机制-View绘制原理">
<meta name="twitter:description" content="一、概述本文将从startActivity开始讲解Android屏幕刷新机制，前面的文章有分析过startActivity的启动过程，这里将重点分析WMS相关的过程，从而了解Android屏幕刷新机制原理。前面介绍的startActivity启动过程的流程图如下：  二、View的绘制过程从启动过程中的performLaunchActivity开始分析，View真正的绘制是在Activity中的o">
<meta name="twitter:image" content="http://zproo.github.io/2020/Android刷新机制-View绘制原理/startActivity.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2020/Android刷新机制-View绘制原理/">

  <title> Android刷新机制-View绘制原理 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/View/" rel="tag" title="View">View</a>
      
      </div>
      <h1>Android刷新机制-View绘制原理</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2020-06-10T20:10:23+08:00" content="2020-06-10" title="2020-06-10 20:10:23">
          2020-06-10
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android刷新机制-View绘制原理
              
            
          </h1>
        

        <div class="post-meta">
		  

          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-06-10T20:10:23+08:00" content="2020-06-10">
              2020-06-10
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/Android刷新机制-View绘制原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/Android刷新机制-View绘制原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>本文将从startActivity开始讲解Android屏幕刷新机制，前面的文章有分析过<a href="https://skytoby.github.io/2019/startActivity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">startActivity的启动过程</a>，这里将重点分析WMS相关的过程，从而了解Android屏幕刷新机制原理。前面介绍的startActivity启动过程的流程图如下：</p>
<p><img src="/2020/Android刷新机制-View绘制原理/startActivity.jpg" alt="startActivity" style="zoom: 67%;"></p>
<h2 id="二、View的绘制过程"><a href="#二、View的绘制过程" class="headerlink" title="二、View的绘制过程"></a>二、View的绘制过程</h2><p>从启动过程中的performLaunchActivity开始分析，View真正的绘制是在Activity中的onResume方法中。</p>
<h3 id="2-1-AT-performLaunchActivity"><a href="#2-1-AT-performLaunchActivity" class="headerlink" title="2.1 AT.performLaunchActivity"></a>2.1 AT.performLaunchActivity</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">       ... </span><br><span class="line">       //创建Application</span><br><span class="line">       Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">       ...</span><br><span class="line">       //见2.2节</span><br><span class="line">       activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">       ...</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">             mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        ...        </span><br><span class="line">       return activity;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Activity-attach"><a href="#2-2-Activity-attach" class="headerlink" title="2.2 Activity.attach"></a>2.2 Activity.attach</h3><p>[-&gt;Activity.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">           Instrumentation instr, IBinder token, int ident,</span><br><span class="line">           Application application, Intent intent, ActivityInfo info,</span><br><span class="line">           CharSequence title, Activity parent, String id,</span><br><span class="line">           NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">           Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">           Window window, ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">       attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">       mFragments.attachHost(null /*parent*/);</span><br><span class="line">       //创建PhoneWindow</span><br><span class="line">       mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">       mWindow.setWindowControllerCallback(this);</span><br><span class="line">       mWindow.setCallback(this);</span><br><span class="line">       mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">       mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">       if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">           mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">       &#125;</span><br><span class="line">       if (info.uiOptions != 0) &#123;</span><br><span class="line">           mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">       &#125;</span><br><span class="line">       mUiThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">       mMainThread = aThread;</span><br><span class="line">       mInstrumentation = instr;</span><br><span class="line">       mToken = token;</span><br><span class="line">       mIdent = ident;</span><br><span class="line">       mApplication = application;</span><br><span class="line">       mIntent = intent;</span><br><span class="line">       mReferrer = referrer;</span><br><span class="line">       mComponent = intent.getComponent();</span><br><span class="line">       mActivityInfo = info;</span><br><span class="line">       mTitle = title;</span><br><span class="line">       mParent = parent;</span><br><span class="line">       mEmbeddedID = id;</span><br><span class="line">       mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">       if (voiceInteractor != null) &#123;</span><br><span class="line">           if (lastNonConfigurationInstances != null) &#123;</span><br><span class="line">               mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,</span><br><span class="line">                       Looper.myLooper());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mWindow.setWindowManager(</span><br><span class="line">               (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">               mToken, mComponent.flattenToString(),</span><br><span class="line">               (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">       if (mParent != null) &#123;</span><br><span class="line">           mWindow.setContainer(mParent.getWindow());</span><br><span class="line">       &#125;</span><br><span class="line">       mWindowManager = mWindow.getWindowManager();</span><br><span class="line">       mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">       mWindow.setColorMode(info.colorMode);</span><br><span class="line"></span><br><span class="line">       setAutofillCompatibilityEnabled(application.isAutofillCompatibilityEnabled());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里比较重要的操作是创建PhoneWindow，PhoneWindow是window唯一的实现类。每一个Activity都有一个PhoneWindow对象，PhoneWindow对象中有一个DecorView实例，通过这个实例来进行View相关的操作。</p>
<p><img src="/2020/Android刷新机制-View绘制原理/window_decoreview.png" alt="window_decoreview"></p>
<h3 id="2-3-Activity-setContentView"><a href="#2-3-Activity-setContentView" class="headerlink" title="2.3 Activity.setContentView"></a>2.3 Activity.setContentView</h3><p>[-&gt;Activity.java]</p>
<p>onCreate方法里面有一个setContentView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">      getWindow().setContentView(layoutResID);</span><br><span class="line">      initWindowDecorActionBar();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">public Window getWindow() &#123;</span><br><span class="line">      return mWindow;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>mWindow为上面创建的PhoneWindow对象，其类结构如下图所示</p>
<p><img src="/2020/Android刷新机制-View绘制原理/phonewindow.jpg" alt="phonewindow"></p>
<p>[-&gt;PhoneWindow.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">       // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">       // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">       // before this happens.</span><br><span class="line">       if (mContentParent == null) &#123;</span><br><span class="line">           installDecor();</span><br><span class="line">       &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">           mContentParent.removeAllViews();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">           final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                   getContext());</span><br><span class="line">           transitionTo(newScene);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           //加载布局</span><br><span class="line">           mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">       &#125;</span><br><span class="line">       mContentParent.requestApplyInsets();</span><br><span class="line">       final Callback cb = getCallback();</span><br><span class="line">       if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">           cb.onContentChanged();</span><br><span class="line">       &#125;</span><br><span class="line">       mContentParentExplicitlySet = true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-installDecor"><a href="#2-3-1-installDecor" class="headerlink" title="2.3.1 installDecor"></a>2.3.1 installDecor</h4><p>[-&gt;PhoneWindow.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">       mForceDecorInstall = false;</span><br><span class="line">       //如果mDecor没有初始化，则进行初始化</span><br><span class="line">       if (mDecor == null) &#123;</span><br><span class="line">           mDecor = generateDecor(-1);</span><br><span class="line">           mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">           mDecor.setIsRootNamespace(true);</span><br><span class="line">           if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123;</span><br><span class="line">               mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           mDecor.setWindow(this);</span><br><span class="line">       &#125;</span><br><span class="line">       //mContentParent为空则初始化</span><br><span class="line">       if (mContentParent == null) &#123;</span><br><span class="line">           mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">           // Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span><br><span class="line">           mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">           final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                   R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">           if (decorContentParent != null) &#123;</span><br><span class="line">               mDecorContentParent = decorContentParent;</span><br><span class="line">               mDecorContentParent.setWindowCallback(getCallback());</span><br><span class="line">               if (mDecorContentParent.getTitle() == null) &#123;</span><br><span class="line">                   mDecorContentParent.setWindowTitle(mTitle);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final int localFeatures = getLocalFeatures();</span><br><span class="line">               for (int i = 0; i &lt; FEATURE_MAX; i++) &#123;</span><br><span class="line">                   if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123;</span><br><span class="line">                       mDecorContentParent.initFeature(i);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               mDecorContentParent.setUiOptions(mUiOptions);</span><br><span class="line"></span><br><span class="line">               if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != 0 ||</span><br><span class="line">                       (mIconRes != 0 &amp;&amp; !mDecorContentParent.hasIcon())) &#123;</span><br><span class="line">                   mDecorContentParent.setIcon(mIconRes);</span><br><span class="line">               &#125; else if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == 0 &amp;&amp;</span><br><span class="line">                       mIconRes == 0 &amp;&amp; !mDecorContentParent.hasIcon()) &#123;</span><br><span class="line">                   mDecorContentParent.setIcon(</span><br><span class="line">                           getContext().getPackageManager().getDefaultActivityIcon());</span><br><span class="line">                   mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != 0 ||</span><br><span class="line">                       (mLogoRes != 0 &amp;&amp; !mDecorContentParent.hasLogo())) &#123;</span><br><span class="line">                   mDecorContentParent.setLogo(mLogoRes);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Invalidate if the panel menu hasn&apos;t been created before this.</span><br><span class="line">               // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu</span><br><span class="line">               // being called in the middle of onCreate or similar.</span><br><span class="line">               // A pending invalidation will typically be resolved before the posted message</span><br><span class="line">               // would run normally in order to satisfy instance state restoration.</span><br><span class="line">               PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false);</span><br><span class="line">               if (!isDestroyed() &amp;&amp; (st == null || st.menu == null) &amp;&amp; !mIsStartingWindow) &#123;</span><br><span class="line">                   invalidatePanelMenu(FEATURE_ACTION_BAR);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mTitleView = findViewById(R.id.title);</span><br><span class="line">               if (mTitleView != null) &#123;</span><br><span class="line">                   if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123;</span><br><span class="line">                       final View titleContainer = findViewById(R.id.title_container);</span><br><span class="line">                       if (titleContainer != null) &#123;</span><br><span class="line">                           titleContainer.setVisibility(View.GONE);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           mTitleView.setVisibility(View.GONE);</span><br><span class="line">                       &#125;</span><br><span class="line">                       mContentParent.setForeground(null);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       mTitleView.setText(mTitle);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123;</span><br><span class="line">               mDecor.setBackgroundFallback(mBackgroundFallbackResource);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Only inflate or create a new TransitionManager if the caller hasn&apos;t</span><br><span class="line">           // already set a custom one.</span><br><span class="line">           if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123;</span><br><span class="line">               if (mTransitionManager == null) &#123;</span><br><span class="line">                   final int transitionRes = getWindowStyle().getResourceId(</span><br><span class="line">                           R.styleable.Window_windowContentTransitionManager,</span><br><span class="line">                           0);</span><br><span class="line">                   if (transitionRes != 0) &#123;</span><br><span class="line">                       final TransitionInflater inflater = TransitionInflater.from(getContext());</span><br><span class="line">                       mTransitionManager = inflater.inflateTransitionManager(transitionRes,</span><br><span class="line">                               mContentParent);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       mTransitionManager = new TransitionManager();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               mEnterTransition = getTransition(mEnterTransition, null,</span><br><span class="line">                       R.styleable.Window_windowEnterTransition);</span><br><span class="line">               mReturnTransition = getTransition(mReturnTransition, USE_DEFAULT_TRANSITION,</span><br><span class="line">                       R.styleable.Window_windowReturnTransition);</span><br><span class="line">               mExitTransition = getTransition(mExitTransition, null,</span><br><span class="line">                       R.styleable.Window_windowExitTransition);</span><br><span class="line">               mReenterTransition = getTransition(mReenterTransition, USE_DEFAULT_TRANSITION,</span><br><span class="line">                       R.styleable.Window_windowReenterTransition);</span><br><span class="line">               mSharedElementEnterTransition = getTransition(mSharedElementEnterTransition, null,</span><br><span class="line">                       R.styleable.Window_windowSharedElementEnterTransition);</span><br><span class="line">               mSharedElementReturnTransition = getTransition(mSharedElementReturnTransition,</span><br><span class="line">                       USE_DEFAULT_TRANSITION,</span><br><span class="line">                       R.styleable.Window_windowSharedElementReturnTransition);</span><br><span class="line">               mSharedElementExitTransition = getTransition(mSharedElementExitTransition, null,</span><br><span class="line">                       R.styleable.Window_windowSharedElementExitTransition);</span><br><span class="line">               mSharedElementReenterTransition = getTransition(mSharedElementReenterTransition,</span><br><span class="line">                       USE_DEFAULT_TRANSITION,</span><br><span class="line">                       R.styleable.Window_windowSharedElementReenterTransition);</span><br><span class="line">               if (mAllowEnterTransitionOverlap == null) &#123;</span><br><span class="line">                   mAllowEnterTransitionOverlap = getWindowStyle().getBoolean(</span><br><span class="line">                           R.styleable.Window_windowAllowEnterTransitionOverlap, true);</span><br><span class="line">               &#125;</span><br><span class="line">               if (mAllowReturnTransitionOverlap == null) &#123;</span><br><span class="line">                   mAllowReturnTransitionOverlap = getWindowStyle().getBoolean(</span><br><span class="line">                           R.styleable.Window_windowAllowReturnTransitionOverlap, true);</span><br><span class="line">               &#125;</span><br><span class="line">               if (mBackgroundFadeDurationMillis &lt; 0) &#123;</span><br><span class="line">                   mBackgroundFadeDurationMillis = getWindowStyle().getInteger(</span><br><span class="line">                           R.styleable.Window_windowTransitionBackgroundFadeDuration,</span><br><span class="line">                           DEFAULT_BACKGROUND_FADE_DURATION_MS);</span><br><span class="line">               &#125;</span><br><span class="line">               if (mSharedElementsUseOverlay == null) &#123;</span><br><span class="line">                   mSharedElementsUseOverlay = getWindowStyle().getBoolean(</span><br><span class="line">                           R.styleable.Window_windowSharedElementsUseOverlay, true);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-DecorView创建"><a href="#2-3-2-DecorView创建" class="headerlink" title="2.3.2 DecorView创建"></a>2.3.2 DecorView创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected DecorView generateDecor(int featureId) &#123;</span><br><span class="line">      // System process doesn&apos;t have application context and in that case we need to directly use</span><br><span class="line">      // the context we have. Otherwise we want the application context, so we don&apos;t cling to the</span><br><span class="line">      // activity.</span><br><span class="line">      Context context;</span><br><span class="line">      if (mUseDecorContext) &#123;</span><br><span class="line">          Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">          if (applicationContext == null) &#123;</span><br><span class="line">              context = getContext();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              context = new DecorContext(applicationContext, getContext());</span><br><span class="line">              if (mTheme != -1) &#123;</span><br><span class="line">                  context.setTheme(mTheme);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          context = getContext();</span><br><span class="line">      &#125;</span><br><span class="line">      return new DecorView(context, featureId, this, getAttributes());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>DecorView继承于FrameLayout，通过setContentView将Activity中的布局view添加DecorView中</p>
<h4 id="2-3-3-generateLayout"><a href="#2-3-3-generateLayout" class="headerlink" title="2.3.3 generateLayout"></a>2.3.3 generateLayout</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">        // Apply data from current theme.</span><br><span class="line"></span><br><span class="line">        TypedArray a = getWindowStyle();</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            System.out.println(&quot;From style:&quot;);</span><br><span class="line">            String s = &quot;Attrs:&quot;;</span><br><span class="line">            for (int i = 0; i &lt; R.styleable.Window.length; i++) &#123;</span><br><span class="line">                s = s + &quot; &quot; + Integer.toHexString(R.styleable.Window[i]) + &quot;=&quot;</span><br><span class="line">                        + a.getString(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false);</span><br><span class="line">        int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)</span><br><span class="line">                &amp; (~getForcedWindowFlags());</span><br><span class="line">        if (mIsFloating) &#123;</span><br><span class="line">            setLayout(WRAP_CONTENT, WRAP_CONTENT);</span><br><span class="line">            setFlags(0, flagsToUpdate);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line"></span><br><span class="line">        if (params.windowAnimations == 0) &#123;</span><br><span class="line">            params.windowAnimations = a.getResourceId(</span><br><span class="line">                    R.styleable.Window_windowAnimationStyle, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // The rest are only done if this window is not embedded; otherwise,</span><br><span class="line">        // the values are inherited from our container.</span><br><span class="line">        if (getContainer() == null) &#123;</span><br><span class="line">            if (mBackgroundDrawable == null) &#123;</span><br><span class="line">                if (mBackgroundResource == 0) &#123;</span><br><span class="line">                    mBackgroundResource = a.getResourceId(</span><br><span class="line">                            R.styleable.Window_windowBackground, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mFrameResource == 0) &#123;</span><br><span class="line">                    mFrameResource = a.getResourceId(R.styleable.Window_windowFrame, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                mBackgroundFallbackResource = a.getResourceId(</span><br><span class="line">                        R.styleable.Window_windowBackgroundFallback, 0);</span><br><span class="line">                if (false) &#123;</span><br><span class="line">                    System.out.println(&quot;Background: &quot;</span><br><span class="line">                            + Integer.toHexString(mBackgroundResource) + &quot; Frame: &quot;</span><br><span class="line">                            + Integer.toHexString(mFrameResource));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mLoadElevation) &#123;</span><br><span class="line">                mElevation = a.getDimension(R.styleable.Window_windowElevation, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            mClipToOutline = a.getBoolean(R.styleable.Window_windowClipToOutline, false);</span><br><span class="line">            mTextColor = a.getColor(R.styleable.Window_textColor, Color.TRANSPARENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Inflate the window decor.</span><br><span class="line"></span><br><span class="line">        int layoutResource;</span><br><span class="line">        int features = getLocalFeatures();</span><br><span class="line">        // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123;</span><br><span class="line">            layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">            setCloseOnSwipeEnabled(true);</span><br><span class="line">        &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123;</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                TypedValue res = new TypedValue();</span><br><span class="line">                getContext().getTheme().resolveAttribute(</span><br><span class="line">                        R.attr.dialogTitleIconsDecorLayout, res, true);</span><br><span class="line">                layoutResource = res.resourceId;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                layoutResource = R.layout.screen_title_icons;</span><br><span class="line">            &#125;</span><br><span class="line">            // XXX Remove this once action bar supports these features.</span><br><span class="line">            removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">            // System.out.println(&quot;Title Icons!&quot;);</span><br><span class="line">        &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0</span><br><span class="line">                &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123;</span><br><span class="line">            // Special case for a window with only a progress bar (and title).</span><br><span class="line">            // XXX Need to have a no-title version of embedded windows.</span><br><span class="line">            layoutResource = R.layout.screen_progress;</span><br><span class="line">            // System.out.println(&quot;Progress!&quot;);</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123;</span><br><span class="line">            // Special case for a window with a custom title.</span><br><span class="line">            // If the window is floating, we need a dialog layout</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                TypedValue res = new TypedValue();</span><br><span class="line">                getContext().getTheme().resolveAttribute(</span><br><span class="line">                        R.attr.dialogCustomTitleDecorLayout, res, true);</span><br><span class="line">                layoutResource = res.resourceId;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                layoutResource = R.layout.screen_custom_title;</span><br><span class="line">            &#125;</span><br><span class="line">            // XXX Remove this once action bar supports these features.</span><br><span class="line">            removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123;</span><br><span class="line">            // If no other features and not embedded, only need a title.</span><br><span class="line">            // If the window is floating, we need a dialog layout</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                TypedValue res = new TypedValue();</span><br><span class="line">                getContext().getTheme().resolveAttribute(</span><br><span class="line">                        R.attr.dialogTitleDecorLayout, res, true);</span><br><span class="line">                layoutResource = res.resourceId;</span><br><span class="line">            &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123;</span><br><span class="line">                layoutResource = a.getResourceId(</span><br><span class="line">                        R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                        R.layout.screen_action_bar);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                layoutResource = R.layout.screen_title;</span><br><span class="line">            &#125;</span><br><span class="line">            // System.out.println(&quot;Title!&quot;);</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123;</span><br><span class="line">            layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Embedded, so no decoration is needed.</span><br><span class="line">            layoutResource = R.layout.screen_simple;</span><br><span class="line">            // System.out.println(&quot;Simple!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDecor.startChanging();</span><br><span class="line">        mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">        //找到contentview ID</span><br><span class="line">        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">        if (contentParent == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) &#123;</span><br><span class="line">            ProgressBar progress = getCircularProgressBar(false);</span><br><span class="line">            if (progress != null) &#123;</span><br><span class="line">                progress.setIndeterminate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123;</span><br><span class="line">            registerSwipeCallbacks(contentParent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Remaining setup -- of background and title -- that only applies</span><br><span class="line">        // to top-level windows.</span><br><span class="line">        //设置背景和title</span><br><span class="line">        if (getContainer() == null) &#123;</span><br><span class="line">            final Drawable background;</span><br><span class="line">            if (mBackgroundResource != 0) &#123;</span><br><span class="line">                background = getContext().getDrawable(mBackgroundResource);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                background = mBackgroundDrawable;</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setWindowBackground(background);</span><br><span class="line"></span><br><span class="line">            final Drawable frame;</span><br><span class="line">            if (mFrameResource != 0) &#123;</span><br><span class="line">                frame = getContext().getDrawable(mFrameResource);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                frame = null;</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setWindowFrame(frame);</span><br><span class="line"></span><br><span class="line">            mDecor.setElevation(mElevation);</span><br><span class="line">            mDecor.setClipToOutline(mClipToOutline);</span><br><span class="line"></span><br><span class="line">            if (mTitle != null) &#123;</span><br><span class="line">                setTitle(mTitle);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mTitleColor == 0) &#123;</span><br><span class="line">                mTitleColor = mTextColor;</span><br><span class="line">            &#125;</span><br><span class="line">            setTitleColor(mTitleColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDecor.finishChanging();</span><br><span class="line"></span><br><span class="line">        return contentParent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>contentParent通过findviewById(com.android.internal.R.id.content)得到，后面通过mLayoutInflater.inflate(layoutResID, mContentParent)加载setContentView中的布局文件。</p>
<h3 id="2-4-AT-handleResumeActivity"><a href="#2-4-AT-handleResumeActivity" class="headerlink" title="2.4 AT.handleResumeActivity"></a>2.4 AT.handleResumeActivity</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">          String reason) &#123;</span><br><span class="line">      // If we are getting ready to gc after going to the background, well</span><br><span class="line">      // we are back active so skip it.</span><br><span class="line">      unscheduleGcIdler();</span><br><span class="line">      mSomeActivitiesChanged = true;</span><br><span class="line"></span><br><span class="line">      // TODO Push resumeArgs into the activity for consideration</span><br><span class="line">      //调用Activity的onResume方法</span><br><span class="line">      final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">      if (r == null) &#123;</span><br><span class="line">          // We didn&apos;t actually resume the activity, so skipping any follow-up actions.</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">      if (localLOGV) &#123;</span><br><span class="line">          Slog.v(TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity</span><br><span class="line">                  + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final int forwardBit = isForward</span><br><span class="line">              ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</span><br><span class="line"></span><br><span class="line">      // If the window hasn&apos;t yet been added to the window manager,</span><br><span class="line">      // and this guy didn&apos;t finish itself or start another activity,</span><br><span class="line">      // then go ahead and add the window.</span><br><span class="line">      boolean willBeVisible = !a.mStartedActivity;</span><br><span class="line">      if (!willBeVisible) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              willBeVisible = ActivityManager.getService().willActivityBeVisible(</span><br><span class="line">                      a.getActivityToken());</span><br><span class="line">          &#125; catch (RemoteException e) &#123;</span><br><span class="line">              throw e.rethrowFromSystemServer();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">          r.window = r.activity.getWindow();</span><br><span class="line">          View decor = r.window.getDecorView();</span><br><span class="line">          decor.setVisibility(View.INVISIBLE);</span><br><span class="line">          ViewManager wm = a.getWindowManager();</span><br><span class="line">          WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">          a.mDecor = decor;</span><br><span class="line">          l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">          l.softInputMode |= forwardBit;</span><br><span class="line">          if (r.mPreserveWindow) &#123;</span><br><span class="line">              a.mWindowAdded = true;</span><br><span class="line">              r.mPreserveWindow = false;</span><br><span class="line">              // Normally the ViewRoot sets up callbacks with the Activity</span><br><span class="line">              // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span><br><span class="line">              // the decor view we have to notify the view root that the</span><br><span class="line">              // callbacks may have changed.</span><br><span class="line">              ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">              if (impl != null) &#123;</span><br><span class="line">                  impl.notifyChildRebuilt();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (a.mVisibleFromClient) &#123;</span><br><span class="line">              if (!a.mWindowAdded) &#123;</span><br><span class="line">                  a.mWindowAdded = true;</span><br><span class="line">                  wm.addView(decor, l);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  // The activity will get a callback for this &#123;@link LayoutParams&#125; change</span><br><span class="line">                  // earlier. However, at that time the decor will not be set (this is set</span><br><span class="line">                  // in this method), so no action will be taken. This call ensures the</span><br><span class="line">                  // callback occurs with the decor set.</span><br><span class="line">                  a.onWindowAttributesChanged(l);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // If the window has already been added, but during resume</span><br><span class="line">          // we started another activity, then don&apos;t yet make the</span><br><span class="line">          // window visible.</span><br><span class="line">      &#125; else if (!willBeVisible) &#123;</span><br><span class="line">          if (localLOGV) Slog.v(TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">          r.hideForNow = true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Get rid of anything left hanging around.</span><br><span class="line">      cleanUpPendingRemoveWindows(r, false /* force */);</span><br><span class="line"></span><br><span class="line">      // The window is now visible if it has been added, we are not</span><br><span class="line">      // simply finishing, and we are not starting another activity.</span><br><span class="line">      // 窗口开始设置可见</span><br><span class="line">      if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">          if (r.newConfig != null) &#123;</span><br><span class="line">              performConfigurationChangedForActivity(r, r.newConfig);</span><br><span class="line">              if (DEBUG_CONFIGURATION) &#123;</span><br><span class="line">                  Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot;</span><br><span class="line">                          + r.activity.mCurrentConfig);</span><br><span class="line">              &#125;</span><br><span class="line">              r.newConfig = null;</span><br><span class="line">          &#125;</span><br><span class="line">          if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward);</span><br><span class="line">          WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">          if ((l.softInputMode</span><br><span class="line">                  &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                  != forwardBit) &#123;</span><br><span class="line">              l.softInputMode = (l.softInputMode</span><br><span class="line">                      &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                      | forwardBit;</span><br><span class="line">              if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                  ViewManager wm = a.getWindowManager();</span><br><span class="line">                  View decor = r.window.getDecorView();</span><br><span class="line">                  wm.updateViewLayout(decor, l);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          r.activity.mVisibleFromServer = true;</span><br><span class="line">          mNumVisibleActivities++;</span><br><span class="line">          if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">              //见2.5节</span><br><span class="line">              r.activity.makeVisible();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      r.nextIdle = mNewActivities;</span><br><span class="line">      mNewActivities = r;</span><br><span class="line">      if (localLOGV) Slog.v(TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">      Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Activity-makeVisible"><a href="#2-5-Activity-makeVisible" class="headerlink" title="2.5 Activity.makeVisible"></a>2.5 Activity.makeVisible</h3><p>[-&gt;Activity.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void makeVisible() &#123;</span><br><span class="line">      if (!mWindowAdded) &#123;</span><br><span class="line">          ViewManager wm = getWindowManager();</span><br><span class="line">          wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">          mWindowAdded = true;</span><br><span class="line">      &#125;</span><br><span class="line">      mDecor.setVisibility(View.VISIBLE);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在 Activity.attach方法中进行的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">mWindowManager = mWindow.getWindowManager();</span><br></pre></td></tr></table></figure>
<p>  mWindowManager 在Window中初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);</span><br></pre></td></tr></table></figure>
<h3 id="2-6-WMI-addView"><a href="#2-6-WMI-addView" class="headerlink" title="2.6 WMI.addView"></a>2.6 WMI.addView</h3><p>[-&gt;WindowManagerImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">@Override</span><br><span class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">       applyDefaultToken(params);</span><br><span class="line">       //添加view</span><br><span class="line">       mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-WMG-addView"><a href="#2-7-WMG-addView" class="headerlink" title="2.7 WMG.addView"></a>2.7 WMG.addView</h3><p>[-&gt;WindowManagerGlobal.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">            Display display, Window parentWindow) &#123;</span><br><span class="line">        if (view == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;view must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (display == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;display must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!(params instanceof WindowManager.LayoutParams)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">        if (parentWindow != null) &#123;</span><br><span class="line">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If there&apos;s no parent, then hardware acceleration for this view is</span><br><span class="line">            // set from the application&apos;s hardware acceleration setting.</span><br><span class="line">            final Context context = view.getContext();</span><br><span class="line">            if (context != null</span><br><span class="line">                    &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                            &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123;</span><br><span class="line">                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ViewRootImpl root;</span><br><span class="line">        View panelParentView = null;</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            // Start watching for system property changes.</span><br><span class="line">            if (mSystemPropertyUpdater == null) &#123;</span><br><span class="line">                mSystemPropertyUpdater = new Runnable() &#123;</span><br><span class="line">                    @Override public void run() &#123;</span><br><span class="line">                        synchronized (mLock) &#123;</span><br><span class="line">                            for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                                mRoots.get(i).loadSystemProperties();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int index = findViewLocked(view, false);</span><br><span class="line">            if (index &gt;= 0) &#123;</span><br><span class="line">                if (mDyingViews.contains(view)) &#123;</span><br><span class="line">                    // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue.</span><br><span class="line">                    mRoots.get(index).doDie();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;View &quot; + view</span><br><span class="line">                            + &quot; has already been added to the window manager.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                // The previous removeView() had not completed executing. Now it has.</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If this is a panel window, then find the window it is being</span><br><span class="line">            // attached to for future reference.</span><br><span class="line">            if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                    wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">                final int count = mViews.size();</span><br><span class="line">                for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                    if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                        panelParentView = mViews.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">            view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">            mViews.add(view);</span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">            // do this last because it fires off messages to start doing things</span><br><span class="line">            try &#123;</span><br><span class="line">                //见2.8节</span><br><span class="line">                root.setView(view, wparams, panelParentView);</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                // BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">                if (index &gt;= 0) &#123;</span><br><span class="line">                    removeViewLocked(index, true);</span><br><span class="line">                &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>WindowManagerGlobal是WindowManagerImpl中的成员变量，其和ViewRootImpl，WindowSession关系图如下，WindowManager和WindowManagerService是通过Session进行通信的。具体可参考WMS启动分析</p>
<h3 id="2-8-VRI-setView"><a href="#2-8-VRI-setView" class="headerlink" title="2.8 VRI.setView"></a>2.8 VRI.setView</h3><p>[-&gt;ViewRootImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mView == null) &#123;</span><br><span class="line">                mView = view;</span><br><span class="line"></span><br><span class="line">                mAttachInfo.mDisplayState = mDisplay.getState();</span><br><span class="line">                mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line"></span><br><span class="line">                mViewLayoutDirectionInitial = mView.getRawLayoutDirection();</span><br><span class="line">                mFallbackEventHandler.setView(view);</span><br><span class="line">                mWindowAttributes.copyFrom(attrs);</span><br><span class="line">                if (mWindowAttributes.packageName == null) &#123;</span><br><span class="line">                    mWindowAttributes.packageName = mBasePackageName;</span><br><span class="line">                &#125;</span><br><span class="line">                attrs = mWindowAttributes;</span><br><span class="line">                setTag();</span><br><span class="line"></span><br><span class="line">                if (DEBUG_KEEP_SCREEN_ON &amp;&amp; (mClientWindowLayoutFlags</span><br><span class="line">                        &amp; WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) != 0</span><br><span class="line">                        &amp;&amp; (attrs.flags&amp;WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) == 0) &#123;</span><br><span class="line">                    Slog.d(mTag, &quot;setView: FLAG_KEEP_SCREEN_ON changed from true to false!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                // Keep track of the actual window flags supplied by the client.</span><br><span class="line">                mClientWindowLayoutFlags = attrs.flags;</span><br><span class="line"></span><br><span class="line">                setAccessibilityFocus(null, null);</span><br><span class="line"></span><br><span class="line">                if (view instanceof RootViewSurfaceTaker) &#123;</span><br><span class="line">                    mSurfaceHolderCallback =</span><br><span class="line">                            ((RootViewSurfaceTaker)view).willYouTakeTheSurface();</span><br><span class="line">                    if (mSurfaceHolderCallback != null) &#123;</span><br><span class="line">                        mSurfaceHolder = new TakenSurfaceHolder();</span><br><span class="line">                        mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);</span><br><span class="line">                        mSurfaceHolder.addCallback(mSurfaceHolderCallback);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Compute surface insets required to draw at specified Z value.</span><br><span class="line">                // TODO: Use real shadow insets for a constant max Z.</span><br><span class="line">                if (!attrs.hasManualSurfaceInsets) &#123;</span><br><span class="line">                    attrs.setSurfaceInsets(view, false /*manual*/, true /*preservePrevious*/);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                CompatibilityInfo compatibilityInfo =</span><br><span class="line">                        mDisplay.getDisplayAdjustments().getCompatibilityInfo();</span><br><span class="line">                mTranslator = compatibilityInfo.getTranslator();</span><br><span class="line"></span><br><span class="line">                // If the application owns the surface, don&apos;t enable hardware acceleration</span><br><span class="line">                if (mSurfaceHolder == null) &#123;</span><br><span class="line">                    // While this is supposed to enable only, it can effectively disable</span><br><span class="line">                    // the acceleration too.</span><br><span class="line">                    enableHardwareAcceleration(attrs);</span><br><span class="line">                    final boolean useMTRenderer = MT_RENDERER_AVAILABLE</span><br><span class="line">                            &amp;&amp; mAttachInfo.mThreadedRenderer != null;</span><br><span class="line">                    if (mUseMTRenderer != useMTRenderer) &#123;</span><br><span class="line">                        // Shouldn&apos;t be resizing, as it&apos;s done only in window setup,</span><br><span class="line">                        // but end just in case.</span><br><span class="line">                        endDragResizing();</span><br><span class="line">                        mUseMTRenderer = useMTRenderer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                boolean restore = false;</span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    mSurface.setCompatibilityTranslator(mTranslator);</span><br><span class="line">                    restore = true;</span><br><span class="line">                    attrs.backup();</span><br><span class="line">                    mTranslator.translateWindowLayout(attrs);</span><br><span class="line">                &#125;</span><br><span class="line">                if (DEBUG_LAYOUT) Log.d(mTag, &quot;WindowLayout in setView:&quot; + attrs);</span><br><span class="line"></span><br><span class="line">                if (!compatibilityInfo.supportsScreen()) &#123;</span><br><span class="line">                    attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">                    mLastInCompatMode = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mSoftInputMode = attrs.softInputMode;</span><br><span class="line">                mWindowAttributesChanged = true;</span><br><span class="line">                mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;</span><br><span class="line">                mAttachInfo.mRootView = view;</span><br><span class="line">                mAttachInfo.mScalingRequired = mTranslator != null;</span><br><span class="line">                mAttachInfo.mApplicationScale =</span><br><span class="line">                        mTranslator == null ? 1.0f : mTranslator.applicationScale;</span><br><span class="line">                if (panelParentView != null) &#123;</span><br><span class="line">                    mAttachInfo.mPanelParentWindowToken</span><br><span class="line">                            = panelParentView.getApplicationWindowToken();</span><br><span class="line">                &#125;</span><br><span class="line">                mAdded = true;</span><br><span class="line">                int res; /* = WindowManagerImpl.ADD_OKAY; */</span><br><span class="line"></span><br><span class="line">                // Schedule the first layout -before- adding to the window</span><br><span class="line">                // manager, to make sure we do the relayout before receiving</span><br><span class="line">                // any other events from the system.</span><br><span class="line">                //调用该方法进行view的绘制</span><br><span class="line">                requestLayout();</span><br><span class="line">                </span><br><span class="line">                if ((mWindowAttributes.inputFeatures</span><br><span class="line">                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;</span><br><span class="line">                    mInputChannel = new InputChannel();</span><br><span class="line">                &#125;</span><br><span class="line">                mForceDecorViewVisibility = (mWindowAttributes.privateFlags</span><br><span class="line">                        &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                    mAttachInfo.mRecomputeGlobalAttributes = true;</span><br><span class="line">                    collectViewAttributes();</span><br><span class="line">                    //通过WindowSession和WindowManagerService进行通信，添加到显示</span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    mAdded = false;</span><br><span class="line">                    mView = null;</span><br><span class="line">                    mAttachInfo.mRootView = null;</span><br><span class="line">                    mInputChannel = null;</span><br><span class="line">                    mFallbackEventHandler.setView(null);</span><br><span class="line">                    unscheduleTraversals();</span><br><span class="line">                    setAccessibilityFocus(null, null);</span><br><span class="line">                    throw new RuntimeException(&quot;Adding window failed&quot;, e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (restore) &#123;</span><br><span class="line">                        attrs.restore();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingOverscanInsets.set(0, 0, 0, 0);</span><br><span class="line">                mPendingContentInsets.set(mAttachInfo.mContentInsets);</span><br><span class="line">                mPendingStableInsets.set(mAttachInfo.mStableInsets);</span><br><span class="line">                mPendingDisplayCutout.set(mAttachInfo.mDisplayCutout);</span><br><span class="line">                mPendingVisibleInsets.set(0, 0, 0, 0);</span><br><span class="line">                mAttachInfo.mAlwaysConsumeNavBar =</span><br><span class="line">                        (res &amp; WindowManagerGlobal.ADD_FLAG_ALWAYS_CONSUME_NAV_BAR) != 0;</span><br><span class="line">                mPendingAlwaysConsumeNavBar = mAttachInfo.mAlwaysConsumeNavBar;</span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Added window &quot; + mWindow);</span><br><span class="line">                //根据结果进行相应的处理</span><br><span class="line">                if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">                    mAttachInfo.mRootView = null;</span><br><span class="line">                    mAdded = false;</span><br><span class="line">                    mFallbackEventHandler.setView(null);</span><br><span class="line">                    unscheduleTraversals();</span><br><span class="line">                    setAccessibilityFocus(null, null);</span><br><span class="line">                    switch (res) &#123;</span><br><span class="line">                        case WindowManagerGlobal.ADD_BAD_APP_TOKEN:</span><br><span class="line">                        case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</span><br><span class="line">                            throw new WindowManager.BadTokenException(</span><br><span class="line">                                    &quot;Unable to add window -- token &quot; + attrs.token</span><br><span class="line">                                    + &quot; is not valid; is your activity running?&quot;);</span><br><span class="line">                        case WindowManagerGlobal.ADD_NOT_APP_TOKEN:</span><br><span class="line">                            throw new WindowManager.BadTokenException(</span><br><span class="line">                                    &quot;Unable to add window -- token &quot; + attrs.token</span><br><span class="line">                                    + &quot; is not for an application&quot;);</span><br><span class="line">                        case WindowManagerGlobal.ADD_APP_EXITING:</span><br><span class="line">                            throw new WindowManager.BadTokenException(</span><br><span class="line">                                    &quot;Unable to add window -- app for token &quot; + attrs.token</span><br><span class="line">                                    + &quot; is exiting&quot;);</span><br><span class="line">                        case WindowManagerGlobal.ADD_DUPLICATE_ADD:</span><br><span class="line">                            throw new WindowManager.BadTokenException(</span><br><span class="line">                                    &quot;Unable to add window -- window &quot; + mWindow</span><br><span class="line">                                    + &quot; has already been added&quot;);</span><br><span class="line">                        case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:</span><br><span class="line">                            // Silently ignore -- we would have just removed it</span><br><span class="line">                            // right away, anyway.</span><br><span class="line">                            return;</span><br><span class="line">                        case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:</span><br><span class="line">                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;</span><br><span class="line">                                    + mWindow + &quot; -- another window of type &quot;</span><br><span class="line">                                    + mWindowAttributes.type + &quot; already exists&quot;);</span><br><span class="line">                        case WindowManagerGlobal.ADD_PERMISSION_DENIED:</span><br><span class="line">                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;</span><br><span class="line">                                    + mWindow + &quot; -- permission denied for window type &quot;</span><br><span class="line">                                    + mWindowAttributes.type);</span><br><span class="line">                        case WindowManagerGlobal.ADD_INVALID_DISPLAY:</span><br><span class="line">                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;</span><br><span class="line">                                    + mWindow + &quot; -- the specified display can not be found&quot;);</span><br><span class="line">                        case WindowManagerGlobal.ADD_INVALID_TYPE:</span><br><span class="line">                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;</span><br><span class="line">                                    + mWindow + &quot; -- the specified window type &quot;</span><br><span class="line">                                    + mWindowAttributes.type + &quot; is not valid&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    throw new RuntimeException(</span><br><span class="line">                            &quot;Unable to add window -- unknown error code &quot; + res);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (view instanceof RootViewSurfaceTaker) &#123;</span><br><span class="line">                    mInputQueueCallback =</span><br><span class="line">                        ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();</span><br><span class="line">                &#125;</span><br><span class="line">                if (mInputChannel != null) &#123;</span><br><span class="line">                    if (mInputQueueCallback != null) &#123;</span><br><span class="line">                        mInputQueue = new InputQueue();</span><br><span class="line">                        mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                            Looper.myLooper());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                view.assignParent(this);</span><br><span class="line">                mAddedTouchMode = (res &amp; WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;</span><br><span class="line">                mAppVisible = (res &amp; WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;</span><br><span class="line"></span><br><span class="line">                if (mAccessibilityManager.isEnabled()) &#123;</span><br><span class="line">                    mAccessibilityInteractionConnectionManager.ensureConnection();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</span><br><span class="line">                    view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Set up the input pipeline.</span><br><span class="line">                CharSequence counterSuffix = attrs.getTitle();</span><br><span class="line">                mSyntheticInputStage = new SyntheticInputStage();</span><br><span class="line">                InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);</span><br><span class="line">                InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,</span><br><span class="line">                        &quot;aq:native-post-ime:&quot; + counterSuffix);</span><br><span class="line">                InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);</span><br><span class="line">                InputStage imeStage = new ImeInputStage(earlyPostImeStage,</span><br><span class="line">                        &quot;aq:ime:&quot; + counterSuffix);</span><br><span class="line">                InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);</span><br><span class="line">                InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,</span><br><span class="line">                        &quot;aq:native-pre-ime:&quot; + counterSuffix);</span><br><span class="line"></span><br><span class="line">                mFirstInputStage = nativePreImeStage;</span><br><span class="line">                mFirstPostImeInputStage = earlyPostImeStage;</span><br><span class="line">                mPendingInputEventQueueLengthCounterName = &quot;aq:pending:&quot; + counterSuffix;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-9-VRI-requestLayout"><a href="#2-9-VRI-requestLayout" class="headerlink" title="2.9 VRI.requestLayout"></a>2.9 VRI.requestLayout</h3><p>[-&gt;ViewRootImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void requestLayout() &#123;</span><br><span class="line">     if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">         checkThread();</span><br><span class="line">         mLayoutRequested = true;</span><br><span class="line">         scheduleTraversals();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-9-1-VRI-scheduleTraversals"><a href="#2-9-1-VRI-scheduleTraversals" class="headerlink" title="2.9.1 VRI.scheduleTraversals"></a>2.9.1 VRI.scheduleTraversals</h4><p>[-&gt;ViewRootImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">       if (!mTraversalScheduled) &#123;</span><br><span class="line">           mTraversalScheduled = true;</span><br><span class="line">           mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">           //这里向Choreographer发送消息</span><br><span class="line">           mChoreographer.postCallback(</span><br><span class="line">                   Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">           if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">               scheduleConsumeBatchedInput();</span><br><span class="line">           &#125;</span><br><span class="line">           notifyRendererOfFramePending();</span><br><span class="line">           pokeDrawLockIfNeeded();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>mTraversalRunnable实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           doTraversal();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里向Choreographer发送一个Runnable消息，Choreographer主要作用是获取Vsync同步信号并控制应用主线程完成图像绘制的类。</p>
<h4 id="2-9-2-Choreographer-postCallback"><a href="#2-9-2-Choreographer-postCallback" class="headerlink" title="2.9.2 Choreographer.postCallback"></a>2.9.2 Choreographer.postCallback</h4><p>[-&gt;Choreographer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void postCallback(int callbackType, Runnable action, Object token) &#123;</span><br><span class="line">       postCallbackDelayed(callbackType, action, token, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private void postCallbackDelayedInternal(int callbackType,</span><br><span class="line">           Object action, Object token, long delayMillis) &#123;</span><br><span class="line">      </span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           final long now = SystemClock.uptimeMillis();</span><br><span class="line">           final long dueTime = now + delayMillis;</span><br><span class="line">           //将action Runnable添加到mCallbackQueues队列</span><br><span class="line">           mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">            </span><br><span class="line">           if (dueTime &lt;= now) &#123; //没有延迟</span><br><span class="line">               scheduleFrameLocked(now);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //如果有延迟则发送并行消息</span><br><span class="line">               Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">               msg.arg1 = callbackType;</span><br><span class="line">               msg.setAsynchronous(true);</span><br><span class="line">               mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最后延迟和非延迟都会执行到scheduleFrameLocked方法</p>
<h5 id="2-9-2-1-scheduleFrameLocked"><a href="#2-9-2-1-scheduleFrameLocked" class="headerlink" title="2.9.2.1 scheduleFrameLocked"></a>2.9.2.1 scheduleFrameLocked</h5><p>[-&gt;Choreographer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void scheduleFrameLocked(long now) &#123;</span><br><span class="line">        if (!mFrameScheduled) &#123;</span><br><span class="line">            mFrameScheduled = true;</span><br><span class="line">            if (USE_VSYNC) &#123;</span><br><span class="line">                if (DEBUG_FRAMES) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;Scheduling next frame on vsync.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If running on the Looper thread, then schedule the vsync immediately,</span><br><span class="line">                // otherwise post a message to schedule the vsync from the UI thread</span><br><span class="line">                // as soon as possible.</span><br><span class="line">                //如果是在同一线程</span><br><span class="line">                if (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                    scheduleVsyncLocked();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    //插到最前面</span><br><span class="line">                    mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final long nextFrameTime = Math.max(</span><br><span class="line">                        mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">                if (DEBUG_FRAMES) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;Scheduling next frame in &quot; + (nextFrameTime - now) + &quot; ms.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">                msg.setAsynchronous(true);</span><br><span class="line">                mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>USE_VSYNC默认是true,当前线程和Choreographer绑定的线程一致，调用scheduleVsyncLocked，否则通过mHandler发送消息，在Choreographer线程中处理。这两个分支最后都会执行scheduleVsyncLocked方法。</p>
<h5 id="2-9-2-2-scheduleVsyncLocked"><a href="#2-9-2-2-scheduleVsyncLocked" class="headerlink" title="2.9.2.2 scheduleVsyncLocked"></a>2.9.2.2 scheduleVsyncLocked</h5><p>[-&gt;Choreographer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void scheduleVsyncLocked() &#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-9-2-3-scheduleVsync"><a href="#2-9-2-3-scheduleVsync" class="headerlink" title="2.9.2.3 scheduleVsync"></a>2.9.2.3 scheduleVsync</h5><p>[-&gt;DisplayEventReceiver.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleVsync() &#123;</span><br><span class="line">       if (mReceiverPtr == 0) &#123;</span><br><span class="line">           Log.w(TAG, &quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span><br><span class="line">                   + &quot;receiver has already been disposed.&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里调用到了native方法，这里主要是向底层注册Vsync信号，当底层有Vsync信号来时，会调用onVsync方法。后面文章会详细介绍Choreographer这里相关的操作。</p>
<h5 id="2-9-2-4-FrameDisplayEventReceiver"><a href="#2-9-2-4-FrameDisplayEventReceiver" class="headerlink" title="2.9.2.4 FrameDisplayEventReceiver"></a>2.9.2.4 FrameDisplayEventReceiver</h5><p>[-&gt;FrameDisplayEventReceiver.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">private final class FrameDisplayEventReceiver extends DisplayEventReceiver</span><br><span class="line">           implements Runnable &#123;</span><br><span class="line">       private boolean mHavePendingVsync;</span><br><span class="line">       private long mTimestampNanos;</span><br><span class="line">       private int mFrame;</span><br><span class="line"></span><br><span class="line">       public FrameDisplayEventReceiver(Looper looper, int vsyncSource) &#123;</span><br><span class="line">           super(looper, vsyncSource);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;</span><br><span class="line">           // Ignore vsync from secondary display.</span><br><span class="line">           // This can be problematic because the call to scheduleVsync() is a one-shot.</span><br><span class="line">           // We need to ensure that we will still receive the vsync from the primary</span><br><span class="line">           // display which is the one we really care about.  Ideally we should schedule</span><br><span class="line">           // vsync for a particular display.</span><br><span class="line">           // At this time Surface Flinger won&apos;t send us vsyncs for secondary displays</span><br><span class="line">           // but that could change in the future so let&apos;s log a message to help us remember</span><br><span class="line">           // that we need to fix this.</span><br><span class="line">           if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">               Log.d(TAG, &quot;Received vsync from secondary display, but we don&apos;t support &quot;</span><br><span class="line">                       + &quot;this case yet.  Choreographer needs a way to explicitly request &quot;</span><br><span class="line">                       + &quot;vsync for a specific display to ensure it doesn&apos;t lose track &quot;</span><br><span class="line">                       + &quot;of its scheduled vsync.&quot;);</span><br><span class="line">               scheduleVsync();</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Post the vsync event to the Handler.</span><br><span class="line">           // The idea is to prevent incoming vsync events from completely starving</span><br><span class="line">           // the message queue.  If there are no messages in the queue with timestamps</span><br><span class="line">           // earlier than the frame time, then the vsync event will be processed immediately.</span><br><span class="line">           // Otherwise, messages that predate the vsync event will be handled first.</span><br><span class="line">           long now = System.nanoTime();</span><br><span class="line">           if (timestampNanos &gt; now) &#123;</span><br><span class="line">               Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f)</span><br><span class="line">                       + &quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span><br><span class="line">                       + &quot;timestamps using the correct timebase.&quot;);</span><br><span class="line">               timestampNanos = now;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (mHavePendingVsync) &#123;</span><br><span class="line">               Log.w(TAG, &quot;Already have a pending vsync event.  There should only be &quot;</span><br><span class="line">                       + &quot;one at a time.&quot;);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mHavePendingVsync = true;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mTimestampNanos = timestampNanos;</span><br><span class="line">           mFrame = frame;</span><br><span class="line">           //发送该Runnable</span><br><span class="line">           Message msg = Message.obtain(mHandler, this);</span><br><span class="line">           msg.setAsynchronous(true);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           mHavePendingVsync = false;</span><br><span class="line">           doFrame(mTimestampNanos, mFrame);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>发送异步消息，最后会执行doFrame方法</p>
<h5 id="2-9-2-5-doFrame"><a href="#2-9-2-5-doFrame" class="headerlink" title="2.9.2.5 doFrame"></a>2.9.2.5 doFrame</h5><p>[-&gt;Choreographer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">void doFrame(long frameTimeNanos, int frame) &#123;</span><br><span class="line">        final long startNanos;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            if (!mFrameScheduled) &#123;</span><br><span class="line">                return; // no work to do</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DEBUG_JANK &amp;&amp; mDebugPrintNextFrameTimeDelta) &#123;</span><br><span class="line">                mDebugPrintNextFrameTimeDelta = false;</span><br><span class="line">                Log.d(TAG, &quot;Frame time delta: &quot;</span><br><span class="line">                        + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + &quot; ms&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">            startNanos = System.nanoTime();</span><br><span class="line">            final long jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">            //间隔时间大于1/60ms</span><br><span class="line">            if (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">                final long skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">                if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                    Log.i(TAG, &quot;Skipped &quot; + skippedFrames + &quot; frames!  &quot;</span><br><span class="line">                            + &quot;The application may be doing too much work on its main thread.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">                if (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;Missed vsync by &quot; + (jitterNanos * 0.000001f) + &quot; ms &quot;</span><br><span class="line">                            + &quot;which is more than the frame interval of &quot;</span><br><span class="line">                            + (mFrameIntervalNanos * 0.000001f) + &quot; ms!  &quot;</span><br><span class="line">                            + &quot;Skipping &quot; + skippedFrames + &quot; frames and setting frame &quot;</span><br><span class="line">                            + &quot;time to &quot; + (lastFrameOffset * 0.000001f) + &quot; ms in the past.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">                if (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;Frame time appears to be going backwards.  May be due to a &quot;</span><br><span class="line">                            + &quot;previously skipped frame.  Waiting for next vsync.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mFPSDivisor &gt; 1) &#123;</span><br><span class="line">                long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;</span><br><span class="line">                if (timeSinceVsync &lt; (mFrameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; 0) &#123;</span><br><span class="line">                    scheduleVsyncLocked();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">            mFrameScheduled = false;</span><br><span class="line">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;Choreographer#doFrame&quot;);</span><br><span class="line">            AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">            </span><br><span class="line">            //这里开始执行四种类型的Callback</span><br><span class="line">            mFrameInfo.markInputHandlingStart();</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">            mFrameInfo.markAnimationsStart();</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">            mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            AnimationUtils.unlockAnimationClock();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_FRAMES) &#123;</span><br><span class="line">            final long endNanos = System.nanoTime();</span><br><span class="line">            Log.d(TAG, &quot;Frame &quot; + frame + &quot;: Finished, took &quot;</span><br><span class="line">                    + (endNanos - startNanos) * 0.000001f + &quot; ms, latency &quot;</span><br><span class="line">                    + (startNanos - frameTimeNanos) * 0.000001f + &quot; ms.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是执行队列里面的任务，例如之前添加的mTraversalRunnable。</p>
<h5 id="2-9-2-6-doCallbacks"><a href="#2-9-2-6-doCallbacks" class="headerlink" title="2.9.2.6 doCallbacks"></a>2.9.2.6 doCallbacks</h5><p>[-&gt;Choreographer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void doCallbacks(int callbackType, long frameTimeNanos) &#123;</span><br><span class="line">       CallbackRecord callbacks;</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           // We use &quot;now&quot; to determine when callbacks become due because it&apos;s possible</span><br><span class="line">           // for earlier processing phases in a frame to post callbacks that should run</span><br><span class="line">           // in a following phase, such as an input event that causes an animation to start.</span><br><span class="line">           final long now = System.nanoTime();</span><br><span class="line">           callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                   now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">           if (callbacks == null) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           mCallbacksRunning = true;</span><br><span class="line"></span><br><span class="line">           // Update the frame time if necessary when committing the frame.</span><br><span class="line">           // We only update the frame time if we are more than 2 frames late reaching</span><br><span class="line">           // the commit phase.  This ensures that the frame time which is observed by the</span><br><span class="line">           // callbacks will always increase from one frame to the next and never repeat.</span><br><span class="line">           // We never want the next frame&apos;s starting frame time to end up being less than</span><br><span class="line">           // or equal to the previous frame&apos;s commit frame time.  Keep in mind that the</span><br><span class="line">           // next frame has most likely already been scheduled by now so we play it</span><br><span class="line">           // safe by ensuring the commit time is always at least one frame behind.</span><br><span class="line">           if (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">               final long jitterNanos = now - frameTimeNanos;</span><br><span class="line">               Trace.traceCounter(Trace.TRACE_TAG_VIEW, &quot;jitterNanos&quot;, (int) jitterNanos);</span><br><span class="line">               if (jitterNanos &gt;= 2 * mFrameIntervalNanos) &#123;</span><br><span class="line">                   final long lastFrameOffset = jitterNanos % mFrameIntervalNanos</span><br><span class="line">                           + mFrameIntervalNanos;</span><br><span class="line">                   if (DEBUG_JANK) &#123;</span><br><span class="line">                       Log.d(TAG, &quot;Commit callback delayed by &quot; + (jitterNanos * 0.000001f)</span><br><span class="line">                               + &quot; ms which is more than twice the frame interval of &quot;</span><br><span class="line">                               + (mFrameIntervalNanos * 0.000001f) + &quot; ms!  &quot;</span><br><span class="line">                               + &quot;Setting frame time to &quot; + (lastFrameOffset * 0.000001f)</span><br><span class="line">                               + &quot; ms in the past.&quot;);</span><br><span class="line">                       mDebugPrintNextFrameTimeDelta = true;</span><br><span class="line">                   &#125;</span><br><span class="line">                   frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                   mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);</span><br><span class="line">           for (CallbackRecord c = callbacks; c != null; c = c.next) &#123;</span><br><span class="line">               if (DEBUG_FRAMES) &#123;</span><br><span class="line">                   Log.d(TAG, &quot;RunCallback: type=&quot; + callbackType</span><br><span class="line">                           + &quot;, action=&quot; + c.action + &quot;, token=&quot; + c.token</span><br><span class="line">                           + &quot;, latencyMillis=&quot; + (SystemClock.uptimeMillis() - c.dueTime));</span><br><span class="line">               &#125;</span><br><span class="line">               //执行任务里面的run方法</span><br><span class="line">               c.run(frameTimeNanos);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           synchronized (mLock) &#123;</span><br><span class="line">               mCallbacksRunning = false;</span><br><span class="line">               do &#123;</span><br><span class="line">                   final CallbackRecord next = callbacks.next;</span><br><span class="line">                   recycleCallbackLocked(callbacks);</span><br><span class="line">                   callbacks = next;</span><br><span class="line">               &#125; while (callbacks != null);</span><br><span class="line">           &#125;</span><br><span class="line">           Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-9-3-VRI-doTraversal"><a href="#2-9-3-VRI-doTraversal" class="headerlink" title="2.9.3  VRI.doTraversal"></a>2.9.3  VRI.doTraversal</h4><p>[-&gt;ViewRootImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void doTraversal() &#123;</span><br><span class="line">       if (mTraversalScheduled) &#123;</span><br><span class="line">           mTraversalScheduled = false;</span><br><span class="line">           //去除屏障</span><br><span class="line">           mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">           if (mProfile) &#123;</span><br><span class="line">               Debug.startMethodTracing(&quot;ViewAncestor&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           //见2.9.4节</span><br><span class="line">           performTraversals();</span><br><span class="line"></span><br><span class="line">           if (mProfile) &#123;</span><br><span class="line">               Debug.stopMethodTracing();</span><br><span class="line">               mProfile = false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-9-4-VRI-performTraversals"><a href="#2-9-4-VRI-performTraversals" class="headerlink" title="2.9.4 VRI.performTraversals"></a>2.9.4 VRI.performTraversals</h4><p>[-&gt;ViewRootImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">       // cache mView since it is used so much below...</span><br><span class="line">       final View host = mView;</span><br><span class="line"></span><br><span class="line">       if (DBG) &#123;</span><br><span class="line">           System.out.println(&quot;======================================&quot;);</span><br><span class="line">           System.out.println(&quot;performTraversals&quot;);</span><br><span class="line">           host.debug();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (host == null || !mAdded)</span><br><span class="line">           return;</span><br><span class="line"></span><br><span class="line">       mIsInTraversal = true;</span><br><span class="line">       mWillDrawSoon = true;</span><br><span class="line">       boolean windowSizeMayChange = false;</span><br><span class="line">       boolean newSurface = false;</span><br><span class="line">       boolean surfaceChanged = false;</span><br><span class="line">       WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line"></span><br><span class="line">       int desiredWindowWidth;</span><br><span class="line">       int desiredWindowHeight;</span><br><span class="line"></span><br><span class="line">       final int viewVisibility = getHostVisibility();</span><br><span class="line">       final boolean viewVisibilityChanged = !mFirst</span><br><span class="line">               &amp;&amp; (mViewVisibility != viewVisibility || mNewSurfaceNeeded</span><br><span class="line">               // Also check for possible double visibility update, which will make current</span><br><span class="line">               // viewVisibility value equal to mViewVisibility and we may miss it.</span><br><span class="line">               || mAppVisibilityChanged);</span><br><span class="line">       mAppVisibilityChanged = false;</span><br><span class="line">       final boolean viewUserVisibilityChanged = !mFirst &amp;&amp;</span><br><span class="line">               ((mViewVisibility == View.VISIBLE) != (viewVisibility == View.VISIBLE));</span><br><span class="line"></span><br><span class="line">       WindowManager.LayoutParams params = null;</span><br><span class="line">       if (mWindowAttributesChanged) &#123;</span><br><span class="line">           mWindowAttributesChanged = false;</span><br><span class="line">           surfaceChanged = true;</span><br><span class="line">           params = lp;</span><br><span class="line">       &#125;</span><br><span class="line">       CompatibilityInfo compatibilityInfo =</span><br><span class="line">               mDisplay.getDisplayAdjustments().getCompatibilityInfo();</span><br><span class="line">       if (compatibilityInfo.supportsScreen() == mLastInCompatMode) &#123;</span><br><span class="line">           params = lp;</span><br><span class="line">           mFullRedrawNeeded = true;</span><br><span class="line">           mLayoutRequested = true;</span><br><span class="line">           if (mLastInCompatMode) &#123;</span><br><span class="line">               params.privateFlags &amp;= ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">               mLastInCompatMode = false;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">               mLastInCompatMode = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mWindowAttributesChangesFlag = 0;</span><br><span class="line"></span><br><span class="line">       Rect frame = mWinFrame;</span><br><span class="line">       if (mFirst) &#123;</span><br><span class="line">           mFullRedrawNeeded = true;</span><br><span class="line">           mLayoutRequested = true;</span><br><span class="line"></span><br><span class="line">           final Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">           if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">               // NOTE -- system code, won&apos;t try to do compat mode.</span><br><span class="line">               Point size = new Point();</span><br><span class="line">               mDisplay.getRealSize(size);</span><br><span class="line">               desiredWindowWidth = size.x;</span><br><span class="line">               desiredWindowHeight = size.y;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               desiredWindowWidth = mWinFrame.width();</span><br><span class="line">               desiredWindowHeight = mWinFrame.height();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // We used to use the following condition to choose 32 bits drawing caches:</span><br><span class="line">           // PixelFormat.hasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888</span><br><span class="line">           // However, windows are now always 32 bits by default, so choose 32 bits</span><br><span class="line">           mAttachInfo.mUse32BitDrawingCache = true;</span><br><span class="line">           mAttachInfo.mHasWindowFocus = false;</span><br><span class="line">           mAttachInfo.mWindowVisibility = viewVisibility;</span><br><span class="line">           mAttachInfo.mRecomputeGlobalAttributes = false;</span><br><span class="line">           mLastConfigurationFromResources.setTo(config);</span><br><span class="line">           mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;</span><br><span class="line">           // Set the layout direction if it has not been set before (inherit is the default)</span><br><span class="line">           if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) &#123;</span><br><span class="line">               host.setLayoutDirection(config.getLayoutDirection());</span><br><span class="line">           &#125;</span><br><span class="line">           host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">           mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);</span><br><span class="line">           dispatchApplyInsets(host);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           desiredWindowWidth = frame.width();</span><br><span class="line">           desiredWindowHeight = frame.height();</span><br><span class="line">           if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">               if (DEBUG_ORIENTATION) Log.v(mTag, &quot;View &quot; + host + &quot; resized to: &quot; + frame);</span><br><span class="line">               mFullRedrawNeeded = true;</span><br><span class="line">               mLayoutRequested = true;</span><br><span class="line">               windowSizeMayChange = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (viewVisibilityChanged) &#123;</span><br><span class="line">           mAttachInfo.mWindowVisibility = viewVisibility;</span><br><span class="line">           host.dispatchWindowVisibilityChanged(viewVisibility);</span><br><span class="line">           if (viewUserVisibilityChanged) &#123;</span><br><span class="line">               host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);</span><br><span class="line">           &#125;</span><br><span class="line">           if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) &#123;</span><br><span class="line">               endDragResizing();</span><br><span class="line">               destroyHardwareResources();</span><br><span class="line">           &#125;</span><br><span class="line">           if (viewVisibility == View.GONE) &#123;</span><br><span class="line">               // After making a window gone, we will count it as being</span><br><span class="line">               // shown for the first time the next time it gets focus.</span><br><span class="line">               mHasHadWindowFocus = false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Non-visible windows can&apos;t hold accessibility focus.</span><br><span class="line">       if (mAttachInfo.mWindowVisibility != View.VISIBLE) &#123;</span><br><span class="line">           host.clearAccessibilityFocus();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Execute enqueued actions on every traversal in case a detached view enqueued an action</span><br><span class="line">       getRunQueue().executeActions(mAttachInfo.mHandler);</span><br><span class="line"></span><br><span class="line">       boolean insetsChanged = false;</span><br><span class="line"></span><br><span class="line">       boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">       if (layoutRequested) &#123;</span><br><span class="line"></span><br><span class="line">           final Resources res = mView.getContext().getResources();</span><br><span class="line"></span><br><span class="line">           if (mFirst) &#123;</span><br><span class="line">               // make sure touch mode code executes by setting cached value</span><br><span class="line">               // to opposite of the added touch mode.</span><br><span class="line">               mAttachInfo.mInTouchMode = !mAddedTouchMode;</span><br><span class="line">               ensureTouchModeLocally(mAddedTouchMode);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">                   insetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) &#123;</span><br><span class="line">                   insetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) &#123;</span><br><span class="line">                   insetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (!mPendingDisplayCutout.equals(mAttachInfo.mDisplayCutout)) &#123;</span><br><span class="line">                   insetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) &#123;</span><br><span class="line">                   mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                   if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                           + mAttachInfo.mVisibleInsets);</span><br><span class="line">               &#125;</span><br><span class="line">               if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) &#123;</span><br><span class="line">                   insetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) &#123;</span><br><span class="line">                   insetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                       || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                   windowSizeMayChange = true;</span><br><span class="line"></span><br><span class="line">                   if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                       // NOTE -- system code, won&apos;t try to do compat mode.</span><br><span class="line">                       Point size = new Point();</span><br><span class="line">                       mDisplay.getRealSize(size);</span><br><span class="line">                       desiredWindowWidth = size.x;</span><br><span class="line">                       desiredWindowHeight = size.y;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       Configuration config = res.getConfiguration();</span><br><span class="line">                       desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                       desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Ask host how big it wants to be</span><br><span class="line">           windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                   desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (collectViewAttributes()) &#123;</span><br><span class="line">           params = lp;</span><br><span class="line">       &#125;</span><br><span class="line">       if (mAttachInfo.mForceReportNewAttributes) &#123;</span><br><span class="line">           mAttachInfo.mForceReportNewAttributes = false;</span><br><span class="line">           params = lp;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (mFirst || mAttachInfo.mViewVisibilityChanged) &#123;</span><br><span class="line">           mAttachInfo.mViewVisibilityChanged = false;</span><br><span class="line">           int resizeMode = mSoftInputMode &amp;</span><br><span class="line">                   WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;</span><br><span class="line">           // If we are in auto resize mode, then we need to determine</span><br><span class="line">           // what mode to use now.</span><br><span class="line">           if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123;</span><br><span class="line">               final int N = mAttachInfo.mScrollContainers.size();</span><br><span class="line">               for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                   if (mAttachInfo.mScrollContainers.get(i).isShown()) &#123;</span><br><span class="line">                       resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (resizeMode == 0) &#123;</span><br><span class="line">                   resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((lp.softInputMode &amp;</span><br><span class="line">                       WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) &#123;</span><br><span class="line">                   lp.softInputMode = (lp.softInputMode &amp;</span><br><span class="line">                           ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) |</span><br><span class="line">                           resizeMode;</span><br><span class="line">                   params = lp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (params != null) &#123;</span><br><span class="line">           if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123;</span><br><span class="line">               if (!PixelFormat.formatHasAlpha(params.format)) &#123;</span><br><span class="line">                   params.format = PixelFormat.TRANSLUCENT;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mAttachInfo.mOverscanRequested = (params.flags</span><br><span class="line">                   &amp; WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (mApplyInsetsRequested) &#123;</span><br><span class="line">           mApplyInsetsRequested = false;</span><br><span class="line">           mLastOverscanRequested = mAttachInfo.mOverscanRequested;</span><br><span class="line">           dispatchApplyInsets(host);</span><br><span class="line">           if (mLayoutRequested) &#123;</span><br><span class="line">               // Short-circuit catching a new layout request here, so</span><br><span class="line">               // we don&apos;t need to go through two layout passes when things</span><br><span class="line">               // change due to fitting system windows, which can happen a lot.</span><br><span class="line">               windowSizeMayChange |= measureHierarchy(host, lp,</span><br><span class="line">                       mView.getContext().getResources(),</span><br><span class="line">                       desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (layoutRequested) &#123;</span><br><span class="line">           // Clear this now, so that if anything requests a layout in the</span><br><span class="line">           // rest of this function we will catch it and re-run a full</span><br><span class="line">           // layout pass.</span><br><span class="line">           mLayoutRequested = false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       boolean windowShouldResize = layoutRequested &amp;&amp; windowSizeMayChange</span><br><span class="line">           &amp;&amp; ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight())</span><br><span class="line">               || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                       frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth)</span><br><span class="line">               || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                       frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight));</span><br><span class="line">       windowShouldResize |= mDragResizing &amp;&amp; mResizeMode == RESIZE_MODE_FREEFORM;</span><br><span class="line"></span><br><span class="line">       // If the activity was just relaunched, it might have unfrozen the task bounds (while</span><br><span class="line">       // relaunching), so we need to force a call into window manager to pick up the latest</span><br><span class="line">       // bounds.</span><br><span class="line">       windowShouldResize |= mActivityRelaunched;</span><br><span class="line"></span><br><span class="line">       // Determine whether to compute insets.</span><br><span class="line">       // If there are no inset listeners remaining then we may still need to compute</span><br><span class="line">       // insets in case the old insets were non-empty and must be reset.</span><br><span class="line">       final boolean computesInternalInsets =</span><br><span class="line">               mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners()</span><br><span class="line">               || mAttachInfo.mHasNonEmptyGivenInternalInsets;</span><br><span class="line"></span><br><span class="line">       boolean insetsPending = false;</span><br><span class="line">       int relayoutResult = 0;</span><br><span class="line">       boolean updatedConfiguration = false;</span><br><span class="line"></span><br><span class="line">       final int surfaceGenerationId = mSurface.getGenerationId();</span><br><span class="line"></span><br><span class="line">       final boolean isViewVisible = viewVisibility == View.VISIBLE;</span><br><span class="line">       final boolean windowRelayoutWasForced = mForceNextWindowRelayout;</span><br><span class="line">       if (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">               viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123;</span><br><span class="line">           mForceNextWindowRelayout = false;</span><br><span class="line"></span><br><span class="line">           if (isViewVisible) &#123;</span><br><span class="line">               // If this window is giving internal insets to the window</span><br><span class="line">               // manager, and it is being added or changing its visibility,</span><br><span class="line">               // then we want to first give the window manager &quot;fake&quot;</span><br><span class="line">               // insets to cause it to effectively ignore the content of</span><br><span class="line">               // the window during layout.  This avoids it briefly causing</span><br><span class="line">               // other windows to resize/move based on the raw frame of the</span><br><span class="line">               // window, waiting until we can finish laying out this window</span><br><span class="line">               // and get back to the window manager with the ultimately</span><br><span class="line">               // computed insets.</span><br><span class="line">               insetsPending = computesInternalInsets &amp;&amp; (mFirst || viewVisibilityChanged);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (mSurfaceHolder != null) &#123;</span><br><span class="line">               mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">               mDrawingAllowed = true;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           boolean hwInitialized = false;</span><br><span class="line">           boolean contentInsetsChanged = false;</span><br><span class="line">           boolean hadSurface = mSurface.isValid();</span><br><span class="line"></span><br><span class="line">           try &#123;</span><br><span class="line">               if (DEBUG_LAYOUT) &#123;</span><br><span class="line">                   Log.i(mTag, &quot;host=w:&quot; + host.getMeasuredWidth() + &quot;, h:&quot; +</span><br><span class="line">                           host.getMeasuredHeight() + &quot;, params=&quot; + params);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (mAttachInfo.mThreadedRenderer != null) &#123;</span><br><span class="line">                   // relayoutWindow may decide to destroy mSurface. As that decision</span><br><span class="line">                   // happens in WindowManager service, we need to be defensive here</span><br><span class="line">                   // and stop using the surface in case it gets destroyed.</span><br><span class="line">                   if (mAttachInfo.mThreadedRenderer.pauseSurface(mSurface)) &#123;</span><br><span class="line">                       // Animations were running so we need to push a frame</span><br><span class="line">                       // to resume them</span><br><span class="line">                       mDirty.set(0, 0, mWidth, mHeight);</span><br><span class="line">                   &#125;</span><br><span class="line">                   mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);</span><br><span class="line">               &#125;</span><br><span class="line">               relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line"></span><br><span class="line">               if (DEBUG_LAYOUT) Log.v(mTag, &quot;relayout: frame=&quot; + frame.toShortString()</span><br><span class="line">                       + &quot; overscan=&quot; + mPendingOverscanInsets.toShortString()</span><br><span class="line">                       + &quot; content=&quot; + mPendingContentInsets.toShortString()</span><br><span class="line">                       + &quot; visible=&quot; + mPendingVisibleInsets.toShortString()</span><br><span class="line">                       + &quot; stable=&quot; + mPendingStableInsets.toShortString()</span><br><span class="line">                       + &quot; cutout=&quot; + mPendingDisplayCutout.get().toString()</span><br><span class="line">                       + &quot; outsets=&quot; + mPendingOutsets.toShortString()</span><br><span class="line">                       + &quot; surface=&quot; + mSurface);</span><br><span class="line"></span><br><span class="line">               // If the pending &#123;@link MergedConfiguration&#125; handed back from</span><br><span class="line">               // &#123;@link #relayoutWindow&#125; does not match the one last reported,</span><br><span class="line">               // WindowManagerService has reported back a frame from a configuration not yet</span><br><span class="line">               // handled by the client. In this case, we need to accept the configuration so we</span><br><span class="line">               // do not lay out and draw with the wrong configuration.</span><br><span class="line">               if (!mPendingMergedConfiguration.equals(mLastReportedMergedConfiguration)) &#123;</span><br><span class="line">                   if (DEBUG_CONFIGURATION) Log.v(mTag, &quot;Visible with new config: &quot;</span><br><span class="line">                           + mPendingMergedConfiguration.getMergedConfiguration());</span><br><span class="line">                   performConfigurationChange(mPendingMergedConfiguration, !mFirst,</span><br><span class="line">                           INVALID_DISPLAY /* same display */);</span><br><span class="line">                   updatedConfiguration = true;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final boolean overscanInsetsChanged = !mPendingOverscanInsets.equals(</span><br><span class="line">                       mAttachInfo.mOverscanInsets);</span><br><span class="line">               contentInsetsChanged = !mPendingContentInsets.equals(</span><br><span class="line">                       mAttachInfo.mContentInsets);</span><br><span class="line">               final boolean visibleInsetsChanged = !mPendingVisibleInsets.equals(</span><br><span class="line">                       mAttachInfo.mVisibleInsets);</span><br><span class="line">               final boolean stableInsetsChanged = !mPendingStableInsets.equals(</span><br><span class="line">                       mAttachInfo.mStableInsets);</span><br><span class="line">               final boolean cutoutChanged = !mPendingDisplayCutout.equals(</span><br><span class="line">                       mAttachInfo.mDisplayCutout);</span><br><span class="line">               final boolean outsetsChanged = !mPendingOutsets.equals(mAttachInfo.mOutsets);</span><br><span class="line">               final boolean surfaceSizeChanged = (relayoutResult</span><br><span class="line">                       &amp; WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;</span><br><span class="line">               surfaceChanged |= surfaceSizeChanged;</span><br><span class="line">               final boolean alwaysConsumeNavBarChanged =</span><br><span class="line">                       mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;</span><br><span class="line">               if (contentInsetsChanged) &#123;</span><br><span class="line">                   mAttachInfo.mContentInsets.set(mPendingContentInsets);</span><br><span class="line">                   if (DEBUG_LAYOUT) Log.v(mTag, &quot;Content insets changing to: &quot;</span><br><span class="line">                           + mAttachInfo.mContentInsets);</span><br><span class="line">               &#125;</span><br><span class="line">               if (overscanInsetsChanged) &#123;</span><br><span class="line">                   mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);</span><br><span class="line">                   if (DEBUG_LAYOUT) Log.v(mTag, &quot;Overscan insets changing to: &quot;</span><br><span class="line">                           + mAttachInfo.mOverscanInsets);</span><br><span class="line">                   // Need to relayout with content insets.</span><br><span class="line">                   contentInsetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (stableInsetsChanged) &#123;</span><br><span class="line">                   mAttachInfo.mStableInsets.set(mPendingStableInsets);</span><br><span class="line">                   if (DEBUG_LAYOUT) Log.v(mTag, &quot;Decor insets changing to: &quot;</span><br><span class="line">                           + mAttachInfo.mStableInsets);</span><br><span class="line">                   // Need to relayout with content insets.</span><br><span class="line">                   contentInsetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (cutoutChanged) &#123;</span><br><span class="line">                   mAttachInfo.mDisplayCutout.set(mPendingDisplayCutout);</span><br><span class="line">                   if (DEBUG_LAYOUT) &#123;</span><br><span class="line">                       Log.v(mTag, &quot;DisplayCutout changing to: &quot; + mAttachInfo.mDisplayCutout);</span><br><span class="line">                   &#125;</span><br><span class="line">                   // Need to relayout with content insets.</span><br><span class="line">                   contentInsetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (alwaysConsumeNavBarChanged) &#123;</span><br><span class="line">                   mAttachInfo.mAlwaysConsumeNavBar = mPendingAlwaysConsumeNavBar;</span><br><span class="line">                   contentInsetsChanged = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (contentInsetsChanged || mLastSystemUiVisibility !=</span><br><span class="line">                       mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested</span><br><span class="line">                       || mLastOverscanRequested != mAttachInfo.mOverscanRequested</span><br><span class="line">                       || outsetsChanged) &#123;</span><br><span class="line">                   mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;</span><br><span class="line">                   mLastOverscanRequested = mAttachInfo.mOverscanRequested;</span><br><span class="line">                   mAttachInfo.mOutsets.set(mPendingOutsets);</span><br><span class="line">                   mApplyInsetsRequested = false;</span><br><span class="line">                   dispatchApplyInsets(host);</span><br><span class="line">               &#125;</span><br><span class="line">               if (visibleInsetsChanged) &#123;</span><br><span class="line">                   mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                   if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                           + mAttachInfo.mVisibleInsets);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (!hadSurface) &#123;</span><br><span class="line">                   if (mSurface.isValid()) &#123;</span><br><span class="line">                       // If we are creating a new surface, then we need to</span><br><span class="line">                       // completely redraw it.  Also, when we get to the</span><br><span class="line">                       // point of drawing it we will hold off and schedule</span><br><span class="line">                       // a new traversal instead.  This is so we can tell the</span><br><span class="line">                       // window manager about all of the windows being displayed</span><br><span class="line">                       // before actually drawing them, so it can display then</span><br><span class="line">                       // all at once.</span><br><span class="line">                       newSurface = true;</span><br><span class="line">                       mFullRedrawNeeded = true;</span><br><span class="line">                       mPreviousTransparentRegion.setEmpty();</span><br><span class="line"></span><br><span class="line">                       // Only initialize up-front if transparent regions are not</span><br><span class="line">                       // requested, otherwise defer to see if the entire window</span><br><span class="line">                       // will be transparent</span><br><span class="line">                       if (mAttachInfo.mThreadedRenderer != null) &#123;</span><br><span class="line">                           try &#123;</span><br><span class="line">                               hwInitialized = mAttachInfo.mThreadedRenderer.initialize(</span><br><span class="line">                                       mSurface);</span><br><span class="line">                               if (hwInitialized &amp;&amp; (host.mPrivateFlags</span><br><span class="line">                                       &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) &#123;</span><br><span class="line">                                   // Don&apos;t pre-allocate if transparent regions</span><br><span class="line">                                   // are requested as they may not be needed</span><br><span class="line">                                   mAttachInfo.mThreadedRenderer.allocateBuffers(mSurface);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; catch (OutOfResourcesException e) &#123;</span><br><span class="line">                               handleOutOfResourcesException(e);</span><br><span class="line">                               return;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else if (!mSurface.isValid()) &#123;</span><br><span class="line">                   // If the surface has been removed, then reset the scroll</span><br><span class="line">                   // positions.</span><br><span class="line">                   if (mLastScrolledFocus != null) &#123;</span><br><span class="line">                       mLastScrolledFocus.clear();</span><br><span class="line">                   &#125;</span><br><span class="line">                   mScrollY = mCurScrollY = 0;</span><br><span class="line">                   if (mView instanceof RootViewSurfaceTaker) &#123;</span><br><span class="line">                       ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (mScroller != null) &#123;</span><br><span class="line">                       mScroller.abortAnimation();</span><br><span class="line">                   &#125;</span><br><span class="line">                   // Our surface is gone</span><br><span class="line">                   if (mAttachInfo.mThreadedRenderer != null &amp;&amp;</span><br><span class="line">                           mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">                       mAttachInfo.mThreadedRenderer.destroy();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else if ((surfaceGenerationId != mSurface.getGenerationId()</span><br><span class="line">                       || surfaceSizeChanged || windowRelayoutWasForced)</span><br><span class="line">                       &amp;&amp; mSurfaceHolder == null</span><br><span class="line">                       &amp;&amp; mAttachInfo.mThreadedRenderer != null) &#123;</span><br><span class="line">                   mFullRedrawNeeded = true;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       // Need to do updateSurface (which leads to CanvasContext::setSurface and</span><br><span class="line">                       // re-create the EGLSurface) if either the Surface changed (as indicated by</span><br><span class="line">                       // generation id), or WindowManager changed the surface size. The latter is</span><br><span class="line">                       // because on some chips, changing the consumer side&apos;s BufferQueue size may</span><br><span class="line">                       // not take effect immediately unless we create a new EGLSurface.</span><br><span class="line">                       // Note that frame size change doesn&apos;t always imply surface size change (eg.</span><br><span class="line">                       // drag resizing uses fullscreen surface), need to check surfaceSizeChanged</span><br><span class="line">                       // flag from WindowManager.</span><br><span class="line">                       mAttachInfo.mThreadedRenderer.updateSurface(mSurface);</span><br><span class="line">                   &#125; catch (OutOfResourcesException e) &#123;</span><br><span class="line">                       handleOutOfResourcesException(e);</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final boolean freeformResizing = (relayoutResult</span><br><span class="line">                       &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;</span><br><span class="line">               final boolean dockedResizing = (relayoutResult</span><br><span class="line">                       &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;</span><br><span class="line">               final boolean dragResizing = freeformResizing || dockedResizing;</span><br><span class="line">               if (mDragResizing != dragResizing) &#123;</span><br><span class="line">                   if (dragResizing) &#123;</span><br><span class="line">                       mResizeMode = freeformResizing</span><br><span class="line">                               ? RESIZE_MODE_FREEFORM</span><br><span class="line">                               : RESIZE_MODE_DOCKED_DIVIDER;</span><br><span class="line">                       // TODO: Need cutout?</span><br><span class="line">                       startDragResizing(mPendingBackDropFrame,</span><br><span class="line">                               mWinFrame.equals(mPendingBackDropFrame), mPendingVisibleInsets,</span><br><span class="line">                               mPendingStableInsets, mResizeMode);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // We shouldn&apos;t come here, but if we come we should end the resize.</span><br><span class="line">                       endDragResizing();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (!mUseMTRenderer) &#123;</span><br><span class="line">                   if (dragResizing) &#123;</span><br><span class="line">                       mCanvasOffsetX = mWinFrame.left;</span><br><span class="line">                       mCanvasOffsetY = mWinFrame.top;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       mCanvasOffsetX = mCanvasOffsetY = 0;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (RemoteException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (DEBUG_ORIENTATION) Log.v(</span><br><span class="line">                   TAG, &quot;Relayout returned: frame=&quot; + frame + &quot;, surface=&quot; + mSurface);</span><br><span class="line"></span><br><span class="line">           mAttachInfo.mWindowLeft = frame.left;</span><br><span class="line">           mAttachInfo.mWindowTop = frame.top;</span><br><span class="line"></span><br><span class="line">           // !!FIXME!! This next section handles the case where we did not get the</span><br><span class="line">           // window size we asked for. We should avoid this by getting a maximum size from</span><br><span class="line">           // the window session beforehand.</span><br><span class="line">           if (mWidth != frame.width() || mHeight != frame.height()) &#123;</span><br><span class="line">               mWidth = frame.width();</span><br><span class="line">               mHeight = frame.height();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (mSurfaceHolder != null) &#123;</span><br><span class="line">               // The app owns the surface; tell it about what is going on.</span><br><span class="line">               if (mSurface.isValid()) &#123;</span><br><span class="line">                   // XXX .copyFrom() doesn&apos;t work!</span><br><span class="line">                   //mSurfaceHolder.mSurface.copyFrom(mSurface);</span><br><span class="line">                   mSurfaceHolder.mSurface = mSurface;</span><br><span class="line">               &#125;</span><br><span class="line">               mSurfaceHolder.setSurfaceFrameSize(mWidth, mHeight);</span><br><span class="line">               mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">               if (mSurface.isValid()) &#123;</span><br><span class="line">                   if (!hadSurface) &#123;</span><br><span class="line">                       mSurfaceHolder.ungetCallbacks();</span><br><span class="line"></span><br><span class="line">                       mIsCreating = true;</span><br><span class="line">                       SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                       if (callbacks != null) &#123;</span><br><span class="line">                           for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                               c.surfaceCreated(mSurfaceHolder);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       surfaceChanged = true;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) &#123;</span><br><span class="line">                       SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                       if (callbacks != null) &#123;</span><br><span class="line">                           for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                               c.surfaceChanged(mSurfaceHolder, lp.format,</span><br><span class="line">                                       mWidth, mHeight);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   mIsCreating = false;</span><br><span class="line">               &#125; else if (hadSurface) &#123;</span><br><span class="line">                   notifySurfaceDestroyed();</span><br><span class="line">                   mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">                   try &#123;</span><br><span class="line">                       mSurfaceHolder.mSurface = new Surface();</span><br><span class="line">                   &#125; finally &#123;</span><br><span class="line">                       mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           final ThreadedRenderer threadedRenderer = mAttachInfo.mThreadedRenderer;</span><br><span class="line">           if (threadedRenderer != null &amp;&amp; threadedRenderer.isEnabled()) &#123;</span><br><span class="line">               if (hwInitialized</span><br><span class="line">                       || mWidth != threadedRenderer.getWidth()</span><br><span class="line">                       || mHeight != threadedRenderer.getHeight()</span><br><span class="line">                       || mNeedsRendererSetup) &#123;</span><br><span class="line">                   threadedRenderer.setup(mWidth, mHeight, mAttachInfo,</span><br><span class="line">                           mWindowAttributes.surfaceInsets);</span><br><span class="line">                   mNeedsRendererSetup = false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">               boolean focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                       (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);</span><br><span class="line">               if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                       || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                       updatedConfiguration) &#123;</span><br><span class="line">                   int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                   int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                   if (DEBUG_LAYOUT) Log.v(mTag, &quot;Ooops, something changed!  mWidth=&quot;</span><br><span class="line">                           + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth()</span><br><span class="line">                           + &quot; mHeight=&quot; + mHeight</span><br><span class="line">                           + &quot; measuredHeight=&quot; + host.getMeasuredHeight()</span><br><span class="line">                           + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                    // Ask host how big it wants to be</span><br><span class="line">                   performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                   // Implementation of weights from WindowManager.LayoutParams</span><br><span class="line">                   // We just grow the dimensions as needed and re-measure if</span><br><span class="line">                   // needs be</span><br><span class="line">                   int width = host.getMeasuredWidth();</span><br><span class="line">                   int height = host.getMeasuredHeight();</span><br><span class="line">                   boolean measureAgain = false;</span><br><span class="line"></span><br><span class="line">                   if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                       width += (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                       childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                               MeasureSpec.EXACTLY);</span><br><span class="line">                       measureAgain = true;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                       height += (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                       childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                               MeasureSpec.EXACTLY);</span><br><span class="line">                       measureAgain = true;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   if (measureAgain) &#123;</span><br><span class="line">                       if (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                               &quot;And hey let&apos;s measure once more: width=&quot; + width</span><br><span class="line">                               + &quot; height=&quot; + height);</span><br><span class="line">                       performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   layoutRequested = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // Not the first pass and no window/insets/visibility change but the window</span><br><span class="line">           // may have moved and we need check that and if so to update the left and right</span><br><span class="line">           // in the attach info. We translate only the window frame since on window move</span><br><span class="line">           // the window manager tells us only for the new frame but the insets are the</span><br><span class="line">           // same and we do not want to translate them more than once.</span><br><span class="line">           maybeHandleWindowMove(frame);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">       boolean triggerGlobalLayoutListener = didLayout</span><br><span class="line">               || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">       if (didLayout) &#123;</span><br><span class="line">           performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">           // By this point all views have been sized and positioned</span><br><span class="line">           // We can compute the transparent area</span><br><span class="line"></span><br><span class="line">           if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123;</span><br><span class="line">               // start out transparent</span><br><span class="line">               // TODO: AVOID THAT CALL BY CACHING THE RESULT?</span><br><span class="line">               host.getLocationInWindow(mTmpLocation);</span><br><span class="line">               mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1],</span><br><span class="line">                       mTmpLocation[0] + host.mRight - host.mLeft,</span><br><span class="line">                       mTmpLocation[1] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">               host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">               if (mTranslator != null) &#123;</span><br><span class="line">                   mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">                   mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">                   mFullRedrawNeeded = true;</span><br><span class="line">                   // reconfigure window manager</span><br><span class="line">                   try &#123;</span><br><span class="line">                       mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">                   &#125; catch (RemoteException e) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (DBG) &#123;</span><br><span class="line">               System.out.println(&quot;======================================&quot;);</span><br><span class="line">               System.out.println(&quot;performTraversals -- after setFrame&quot;);</span><br><span class="line">               host.debug();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (triggerGlobalLayoutListener) &#123;</span><br><span class="line">           mAttachInfo.mRecomputeGlobalAttributes = false;</span><br><span class="line">           mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (computesInternalInsets) &#123;</span><br><span class="line">           // Clear the original insets.</span><br><span class="line">           final ViewTreeObserver.InternalInsetsInfo insets = mAttachInfo.mGivenInternalInsets;</span><br><span class="line">           insets.reset();</span><br><span class="line"></span><br><span class="line">           // Compute new insets in place.</span><br><span class="line">           mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);</span><br><span class="line">           mAttachInfo.mHasNonEmptyGivenInternalInsets = !insets.isEmpty();</span><br><span class="line"></span><br><span class="line">           // Tell the window manager.</span><br><span class="line">           if (insetsPending || !mLastGivenInsets.equals(insets)) &#123;</span><br><span class="line">               mLastGivenInsets.set(insets);</span><br><span class="line"></span><br><span class="line">               // Translate insets to screen coordinates if needed.</span><br><span class="line">               final Rect contentInsets;</span><br><span class="line">               final Rect visibleInsets;</span><br><span class="line">               final Region touchableRegion;</span><br><span class="line">               if (mTranslator != null) &#123;</span><br><span class="line">                   contentInsets = mTranslator.getTranslatedContentInsets(insets.contentInsets);</span><br><span class="line">                   visibleInsets = mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);</span><br><span class="line">                   touchableRegion = mTranslator.getTranslatedTouchableArea(insets.touchableRegion);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   contentInsets = insets.contentInsets;</span><br><span class="line">                   visibleInsets = insets.visibleInsets;</span><br><span class="line">                   touchableRegion = insets.touchableRegion;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                   mWindowSession.setInsets(mWindow, insets.mTouchableInsets,</span><br><span class="line">                           contentInsets, visibleInsets, touchableRegion);</span><br><span class="line">               &#125; catch (RemoteException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (mFirst) &#123;</span><br><span class="line">           if (sAlwaysAssignFocus || !isInTouchMode()) &#123;</span><br><span class="line">               // handle first focus request</span><br><span class="line">               if (DEBUG_INPUT_RESIZE) &#123;</span><br><span class="line">                   Log.v(mTag, &quot;First: mView.hasFocus()=&quot; + mView.hasFocus());</span><br><span class="line">               &#125;</span><br><span class="line">               if (mView != null) &#123;</span><br><span class="line">                   if (!mView.hasFocus()) &#123;</span><br><span class="line">                       mView.restoreDefaultFocus();</span><br><span class="line">                       if (DEBUG_INPUT_RESIZE) &#123;</span><br><span class="line">                           Log.v(mTag, &quot;First: requested focused view=&quot; + mView.findFocus());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       if (DEBUG_INPUT_RESIZE) &#123;</span><br><span class="line">                           Log.v(mTag, &quot;First: existing focused view=&quot; + mView.findFocus());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // Some views (like ScrollView) won&apos;t hand focus to descendants that aren&apos;t within</span><br><span class="line">               // their viewport. Before layout, there&apos;s a good change these views are size 0</span><br><span class="line">               // which means no children can get focus. After layout, this view now has size, but</span><br><span class="line">               // is not guaranteed to hand-off focus to a focusable child (specifically, the edge-</span><br><span class="line">               // case where the child has a size prior to layout and thus won&apos;t trigger</span><br><span class="line">               // focusableViewAvailable).</span><br><span class="line">               View focused = mView.findFocus();</span><br><span class="line">               if (focused instanceof ViewGroup</span><br><span class="line">                       &amp;&amp; ((ViewGroup) focused).getDescendantFocusability()</span><br><span class="line">                               == ViewGroup.FOCUS_AFTER_DESCENDANTS) &#123;</span><br><span class="line">                   focused.restoreDefaultFocus();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final boolean changedVisibility = (viewVisibilityChanged || mFirst) &amp;&amp; isViewVisible;</span><br><span class="line">       final boolean hasWindowFocus = mAttachInfo.mHasWindowFocus &amp;&amp; isViewVisible;</span><br><span class="line">       final boolean regainedFocus = hasWindowFocus &amp;&amp; mLostWindowFocus;</span><br><span class="line">       if (regainedFocus) &#123;</span><br><span class="line">           mLostWindowFocus = false;</span><br><span class="line">       &#125; else if (!hasWindowFocus &amp;&amp; mHadWindowFocus) &#123;</span><br><span class="line">           mLostWindowFocus = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (changedVisibility || regainedFocus) &#123;</span><br><span class="line">           // Toasts are presented as notifications - don&apos;t present them as windows as well</span><br><span class="line">           boolean isToast = (mWindowAttributes == null) ? false</span><br><span class="line">                   : (mWindowAttributes.type == WindowManager.LayoutParams.TYPE_TOAST);</span><br><span class="line">           if (!isToast) &#123;</span><br><span class="line">               host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mFirst = false;</span><br><span class="line">       mWillDrawSoon = false;</span><br><span class="line">       mNewSurfaceNeeded = false;</span><br><span class="line">       mActivityRelaunched = false;</span><br><span class="line">       mViewVisibility = viewVisibility;</span><br><span class="line">       mHadWindowFocus = hasWindowFocus;</span><br><span class="line"></span><br><span class="line">       if (hasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123;</span><br><span class="line">           final boolean imTarget = WindowManager.LayoutParams</span><br><span class="line">                   .mayUseInputMethod(mWindowAttributes.flags);</span><br><span class="line">           if (imTarget != mLastWasImTarget) &#123;</span><br><span class="line">               mLastWasImTarget = imTarget;</span><br><span class="line">               InputMethodManager imm = InputMethodManager.peekInstance();</span><br><span class="line">               if (imm != null &amp;&amp; imTarget) &#123;</span><br><span class="line">                   imm.onPreWindowFocus(mView, hasWindowFocus);</span><br><span class="line">                   imm.onPostWindowFocus(mView, mView.findFocus(),</span><br><span class="line">                           mWindowAttributes.softInputMode,</span><br><span class="line">                           !mHasHadWindowFocus, mWindowAttributes.flags);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Remember if we must report the next draw.</span><br><span class="line">       if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123;</span><br><span class="line">           reportNextDraw();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line"></span><br><span class="line">       if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">           if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">               for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                   mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingTransitions.clear();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           performDraw();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (isViewVisible) &#123;</span><br><span class="line">               // Try again</span><br><span class="line">               scheduleTraversals();</span><br><span class="line">           &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">               for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                   mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingTransitions.clear();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mIsInTraversal = false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是判断是否需要执行performMeasure() ，performLayout()，performDraw()这三个过程都会遍历View树刷新需要更新的view。</p>
<h3 id="2-10-Session-addToDisplay"><a href="#2-10-Session-addToDisplay" class="headerlink" title="2.10 Session.addToDisplay"></a>2.10 Session.addToDisplay</h3><p>[-&gt;Session.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,</span><br><span class="line">          int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets,</span><br><span class="line">          Rect outStableInsets, Rect outOutsets,</span><br><span class="line">          DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel) &#123;</span><br><span class="line">      return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outFrame,</span><br><span class="line">              outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-11-WMS-addWindow"><a href="#2-11-WMS-addWindow" class="headerlink" title="2.11 WMS.addWindow"></a>2.11 WMS.addWindow</h3><p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br></pre></td><td class="code"><pre><span class="line">public int addWindow(Session session, IWindow client, int seq,</span><br><span class="line">          LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame,</span><br><span class="line">          Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span><br><span class="line">          DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel) &#123;</span><br><span class="line">      int[] appOp = new int[1];</span><br><span class="line">      //此处mPolicy为PhoneWindowManager</span><br><span class="line">      int res = mPolicy.checkAddPermission(attrs, appOp);</span><br><span class="line">      if (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">          return res;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      boolean reportNewConfig = false;</span><br><span class="line">      WindowState parentWindow = null;</span><br><span class="line">      long origId;</span><br><span class="line">      final int callingUid = Binder.getCallingUid();</span><br><span class="line">      final int type = attrs.type;</span><br><span class="line"></span><br><span class="line">      synchronized(mWindowMap) &#123;</span><br><span class="line">          if (!mDisplayReady) &#123;</span><br><span class="line">              throw new IllegalStateException(&quot;Display has not been initialialized&quot;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final DisplayContent displayContent = getDisplayContentOrCreate(displayId);</span><br><span class="line"></span><br><span class="line">          if (displayContent == null) &#123;</span><br><span class="line">              Slog.w(TAG_WM, &quot;Attempted to add window to a display that does not exist: &quot;</span><br><span class="line">                      + displayId + &quot;.  Aborting.&quot;);</span><br><span class="line">              return WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">          &#125;</span><br><span class="line">          if (!displayContent.hasAccess(session.mUid)</span><br><span class="line">                  &amp;&amp; !mDisplayManagerInternal.isUidPresentOnDisplay(session.mUid, displayId)) &#123;</span><br><span class="line">              Slog.w(TAG_WM, &quot;Attempted to add window to a display for which the application &quot;</span><br><span class="line">                      + &quot;does not have access: &quot; + displayId + &quot;.  Aborting.&quot;);</span><br><span class="line">              return WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (mWindowMap.containsKey(client.asBinder())) &#123;</span><br><span class="line">              Slog.w(TAG_WM, &quot;Window &quot; + client + &quot; is already added&quot;);</span><br><span class="line">              return WindowManagerGlobal.ADD_DUPLICATE_ADD;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">              parentWindow = windowForClientLocked(null, attrs.token, false);</span><br><span class="line">              if (parentWindow == null) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add window with token that is not a window: &quot;</span><br><span class="line">                        + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">              if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW</span><br><span class="line">                      &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add window with token that is a sub-window: &quot;</span><br><span class="line">                          + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (type == TYPE_PRIVATE_PRESENTATION &amp;&amp; !displayContent.isPrivate()) &#123;</span><br><span class="line">              Slog.w(TAG_WM, &quot;Attempted to add private presentation window to a non-private display.  Aborting.&quot;);</span><br><span class="line">              return WindowManagerGlobal.ADD_PERMISSION_DENIED;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          AppWindowToken atoken = null;</span><br><span class="line">          final boolean hasParent = parentWindow != null;</span><br><span class="line">          // Use existing parent window token for child windows since they go in the same token</span><br><span class="line">          // as there parent window so we can apply the same policy on them.</span><br><span class="line">          WindowToken token = displayContent.getWindowToken(</span><br><span class="line">                  hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">          // If this is a child window, we want to apply the same type checking rules as the</span><br><span class="line">          // parent window type.</span><br><span class="line">          final int rootType = hasParent ? parentWindow.mAttrs.type : type;</span><br><span class="line"></span><br><span class="line">          boolean addToastWindowRequiresToken = false;</span><br><span class="line">          //判读token</span><br><span class="line">          if (token == null) &#123;</span><br><span class="line">              if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add application window with unknown token &quot;</span><br><span class="line">                        + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">              if (rootType == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add input method window with unknown token &quot;</span><br><span class="line">                        + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">              if (rootType == TYPE_VOICE_INTERACTION) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add voice interaction window with unknown token &quot;</span><br><span class="line">                        + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">              if (rootType == TYPE_WALLPAPER) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add wallpaper window with unknown token &quot;</span><br><span class="line">                        + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">              if (rootType == TYPE_DREAM) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add Dream window with unknown token &quot;</span><br><span class="line">                        + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">              if (rootType == TYPE_QS_DIALOG) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add QS dialog window with unknown token &quot;</span><br><span class="line">                        + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">              if (rootType == TYPE_ACCESSIBILITY_OVERLAY) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add Accessibility overlay window with unknown token &quot;</span><br><span class="line">                          + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">              if (type == TYPE_TOAST) &#123;</span><br><span class="line">                  // Apps targeting SDK above N MR1 cannot arbitrary add toast windows.</span><br><span class="line">                  if (doesAddToastWindowRequireToken(attrs.packageName, callingUid,</span><br><span class="line">                          parentWindow)) &#123;</span><br><span class="line">                      Slog.w(TAG_WM, &quot;Attempted to add a toast window with unknown token &quot;</span><br><span class="line">                              + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                      return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              final IBinder binder = attrs.token != null ? attrs.token : client.asBinder();</span><br><span class="line">              final boolean isRoundedCornerOverlay =</span><br><span class="line">                      (attrs.privateFlags &amp; PRIVATE_FLAG_IS_ROUNDED_CORNERS_OVERLAY) != 0;</span><br><span class="line">              token = new WindowToken(this, binder, type, false, displayContent,</span><br><span class="line">                      session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">          &#125; else if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">              atoken = token.asAppWindowToken();</span><br><span class="line">              if (atoken == null) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add window with non-application token &quot;</span><br><span class="line">                        + token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_NOT_APP_TOKEN;</span><br><span class="line">              &#125; else if (atoken.removed) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add window with exiting application token &quot;</span><br><span class="line">                        + token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">              &#125; else if (type == TYPE_APPLICATION_STARTING &amp;&amp; atoken.startingWindow != null) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add starting window to token with already existing&quot;</span><br><span class="line">                          + &quot; starting window&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_DUPLICATE_ADD;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if (rootType == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">              if (token.windowType != TYPE_INPUT_METHOD) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add input method window with bad token &quot;</span><br><span class="line">                          + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                    return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if (rootType == TYPE_VOICE_INTERACTION) &#123;</span><br><span class="line">              if (token.windowType != TYPE_VOICE_INTERACTION) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add voice interaction window with bad token &quot;</span><br><span class="line">                          + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                    return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if (rootType == TYPE_WALLPAPER) &#123;</span><br><span class="line">              if (token.windowType != TYPE_WALLPAPER) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add wallpaper window with bad token &quot;</span><br><span class="line">                          + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                    return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if (rootType == TYPE_DREAM) &#123;</span><br><span class="line">              if (token.windowType != TYPE_DREAM) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add Dream window with bad token &quot;</span><br><span class="line">                          + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                    return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if (rootType == TYPE_ACCESSIBILITY_OVERLAY) &#123;</span><br><span class="line">              if (token.windowType != TYPE_ACCESSIBILITY_OVERLAY) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add Accessibility overlay window with bad token &quot;</span><br><span class="line">                          + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if (type == TYPE_TOAST) &#123;</span><br><span class="line">              // Apps targeting SDK above N MR1 cannot arbitrary add toast windows.</span><br><span class="line">              addToastWindowRequiresToken = doesAddToastWindowRequireToken(attrs.packageName,</span><br><span class="line">                      callingUid, parentWindow);</span><br><span class="line">              if (addToastWindowRequiresToken &amp;&amp; token.windowType != TYPE_TOAST) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add a toast window with bad token &quot;</span><br><span class="line">                          + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if (type == TYPE_QS_DIALOG) &#123;</span><br><span class="line">              if (token.windowType != TYPE_QS_DIALOG) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Attempted to add QS dialog window with bad token &quot;</span><br><span class="line">                          + attrs.token + &quot;.  Aborting.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if (token.asAppWindowToken() != null) &#123;</span><br><span class="line">              Slog.w(TAG_WM, &quot;Non-null appWindowToken for system window of rootType=&quot; + rootType);</span><br><span class="line">              // It is not valid to use an app token with other system types; we will</span><br><span class="line">              // instead make a new token for it (as if null had been passed in for the token).</span><br><span class="line">              attrs.token = null;</span><br><span class="line">              token = new WindowToken(this, client.asBinder(), type, false, displayContent,</span><br><span class="line">                      session.mCanAddInternalSystemWindow);</span><br><span class="line">          &#125;</span><br><span class="line">          //创建WindowState</span><br><span class="line">          final WindowState win = new WindowState(this, session, client, token, parentWindow,</span><br><span class="line">                  appOp[0], seq, attrs, viewVisibility, session.mUid,</span><br><span class="line">                  session.mCanAddInternalSystemWindow);</span><br><span class="line">          if (win.mDeathRecipient == null) &#123;</span><br><span class="line">              // Client has apparently died, so there is no reason to</span><br><span class="line">              // continue.</span><br><span class="line">              Slog.w(TAG_WM, &quot;Adding window client &quot; + client.asBinder()</span><br><span class="line">                      + &quot; that is dead, aborting.&quot;);</span><br><span class="line">              return WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (win.getDisplayContent() == null) &#123;</span><br><span class="line">              Slog.w(TAG_WM, &quot;Adding window to Display that has been removed.&quot;);</span><br><span class="line">              return WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final boolean hasStatusBarServicePermission =</span><br><span class="line">                  mContext.checkCallingOrSelfPermission(permission.STATUS_BAR_SERVICE)</span><br><span class="line">                          == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">          //调整WindowManager的LayoutParams参数                </span><br><span class="line">          mPolicy.adjustWindowParamsLw(win, win.mAttrs, hasStatusBarServicePermission);</span><br><span class="line">          win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs));</span><br><span class="line"></span><br><span class="line">          res = mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">          if (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">              return res;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final boolean openInputChannels = (outInputChannel != null</span><br><span class="line">                  &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);</span><br><span class="line">          if  (openInputChannels) &#123;</span><br><span class="line">              //打开输入通道</span><br><span class="line">              win.openInputChannel(outInputChannel);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // If adding a toast requires a token for this app we always schedule hiding</span><br><span class="line">          // toast windows to make sure they don&apos;t stick around longer then necessary.</span><br><span class="line">          // We hide instead of remove such windows as apps aren&apos;t prepared to handle</span><br><span class="line">          // windows being removed under them.</span><br><span class="line">          //</span><br><span class="line">          // If the app is older it can add toasts without a token and hence overlay</span><br><span class="line">          // other apps. To be maximally compatible with these apps we will hide the</span><br><span class="line">          // window after the toast timeout only if the focused window is from another</span><br><span class="line">          // UID, otherwise we allow unlimited duration. When a UID looses focus we</span><br><span class="line">          // schedule hiding all of its toast windows.</span><br><span class="line">          if (type == TYPE_TOAST) &#123;</span><br><span class="line">              if (!getDefaultDisplayContentLocked().canAddToastWindowForUid(callingUid)) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, &quot;Adding more than one toast window for UID at a time.&quot;);</span><br><span class="line">                  return WindowManagerGlobal.ADD_DUPLICATE_ADD;</span><br><span class="line">              &#125;</span><br><span class="line">              // Make sure this happens before we moved focus as one can make the</span><br><span class="line">              // toast focusable to force it not being hidden after the timeout.</span><br><span class="line">              // Focusable toasts are always timed out to prevent a focused app to</span><br><span class="line">              // show a focusable toasts while it has focus which will be kept on</span><br><span class="line">              // the screen after the activity goes away.</span><br><span class="line">              if (addToastWindowRequiresToken</span><br><span class="line">                      || (attrs.flags &amp; LayoutParams.FLAG_NOT_FOCUSABLE) == 0</span><br><span class="line">                      || mCurrentFocus == null</span><br><span class="line">                      || mCurrentFocus.mOwnerUid != callingUid) &#123;</span><br><span class="line">                  mH.sendMessageDelayed(</span><br><span class="line">                          mH.obtainMessage(H.WINDOW_HIDE_TIMEOUT, win),</span><br><span class="line">                          win.mAttrs.hideTimeoutMilliseconds);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // From now on, no exceptions or errors allowed!</span><br><span class="line"></span><br><span class="line">          res = WindowManagerGlobal.ADD_OKAY;</span><br><span class="line">          if (mCurrentFocus == null) &#123;</span><br><span class="line">              mWinAddedSinceNullFocus.add(win);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (excludeWindowTypeFromTapOutTask(type)) &#123;</span><br><span class="line">              displayContent.mTapExcludedWindows.add(win);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          origId = Binder.clearCallingIdentity();</span><br><span class="line">          //见2.11.2节</span><br><span class="line">          win.attach();</span><br><span class="line">          mWindowMap.put(client.asBinder(), win);</span><br><span class="line"></span><br><span class="line">          win.initAppOpsState();</span><br><span class="line"></span><br><span class="line">          final boolean suspended = mPmInternal.isPackageSuspended(win.getOwningPackage(),</span><br><span class="line">                  UserHandle.getUserId(win.getOwningUid()));</span><br><span class="line">          win.setHiddenWhileSuspended(suspended);</span><br><span class="line"></span><br><span class="line">          final boolean hideSystemAlertWindows = !mHidingNonSystemOverlayWindows.isEmpty();</span><br><span class="line">          win.setForceHideNonSystemOverlayWindowIfNeeded(hideSystemAlertWindows);</span><br><span class="line"></span><br><span class="line">          final AppWindowToken aToken = token.asAppWindowToken();</span><br><span class="line">          if (type == TYPE_APPLICATION_STARTING &amp;&amp; aToken != null) &#123;</span><br><span class="line">              aToken.startingWindow = win;</span><br><span class="line">              if (DEBUG_STARTING_WINDOW) Slog.v (TAG_WM, &quot;addWindow: &quot; + aToken</span><br><span class="line">                      + &quot; startingWindow=&quot; + win);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          boolean imMayMove = true;</span><br><span class="line"></span><br><span class="line">          win.mToken.addWindow(win);</span><br><span class="line">          if (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">              win.mGivenInsetsPending = true;</span><br><span class="line">              setInputMethodWindowLocked(win);</span><br><span class="line">              imMayMove = false;</span><br><span class="line">          &#125; else if (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">              displayContent.computeImeTarget(true /* updateImeTarget */);</span><br><span class="line">              imMayMove = false;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              if (type == TYPE_WALLPAPER) &#123;</span><br><span class="line">                  displayContent.mWallpaperController.clearLastWallpaperTimeoutTime();</span><br><span class="line">                  displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">              &#125; else if ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != 0) &#123;</span><br><span class="line">                  displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">              &#125; else if (displayContent.mWallpaperController.isBelowWallpaperTarget(win)) &#123;</span><br><span class="line">                  // If there is currently a wallpaper being shown, and</span><br><span class="line">                  // the base layer of the new window is below the current</span><br><span class="line">                  // layer of the target window, then adjust the wallpaper.</span><br><span class="line">                  // This is to avoid a new window being placed between the</span><br><span class="line">                  // wallpaper and its target.</span><br><span class="line">                  displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // If the window is being added to a stack that&apos;s currently adjusted for IME,</span><br><span class="line">          // make sure to apply the same adjust to this new window.</span><br><span class="line">          win.applyAdjustForImeIfNeeded();</span><br><span class="line"></span><br><span class="line">          if (type == TYPE_DOCK_DIVIDER) &#123;</span><br><span class="line">              mRoot.getDisplayContent(displayId).getDockedDividerController().setWindow(win);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line">          winAnimator.mEnterAnimationPending = true;</span><br><span class="line">          winAnimator.mEnteringAnimation = true;</span><br><span class="line">          // Check if we need to prepare a transition for replacing window first.</span><br><span class="line">          if (atoken != null &amp;&amp; atoken.isVisible()</span><br><span class="line">                  &amp;&amp; !prepareWindowReplacementTransition(atoken)) &#123;</span><br><span class="line">              // If not, check if need to set up a dummy transition during display freeze</span><br><span class="line">              // so that the unfreeze wait for the apps to draw. This might be needed if</span><br><span class="line">              // the app is relaunching.</span><br><span class="line">              prepareNoneTransitionForRelaunching(atoken);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final DisplayFrames displayFrames = displayContent.mDisplayFrames;</span><br><span class="line">          // TODO: Not sure if onDisplayInfoUpdated() call is needed.</span><br><span class="line">          final DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">          displayFrames.onDisplayInfoUpdated(displayInfo,</span><br><span class="line">                  displayContent.calculateDisplayCutoutForRotation(displayInfo.rotation));</span><br><span class="line">          final Rect taskBounds;</span><br><span class="line">          if (atoken != null &amp;&amp; atoken.getTask() != null) &#123;</span><br><span class="line">              taskBounds = mTmpRect;</span><br><span class="line">              atoken.getTask().getBounds(mTmpRect);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              taskBounds = null;</span><br><span class="line">          &#125;</span><br><span class="line">          if (mPolicy.getLayoutHintLw(win.mAttrs, taskBounds, displayFrames, outFrame,</span><br><span class="line">                  outContentInsets, outStableInsets, outOutsets, outDisplayCutout)) &#123;</span><br><span class="line">              res |= WindowManagerGlobal.ADD_FLAG_ALWAYS_CONSUME_NAV_BAR;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (mInTouchMode) &#123;</span><br><span class="line">              res |= WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE;</span><br><span class="line">          &#125;</span><br><span class="line">          if (win.mAppToken == null || !win.mAppToken.isClientHidden()) &#123;</span><br><span class="line">              res |= WindowManagerGlobal.ADD_FLAG_APP_VISIBLE;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          mInputMonitor.setUpdateInputWindowsNeededLw();</span><br><span class="line"></span><br><span class="line">          boolean focusChanged = false;</span><br><span class="line">          if (win.canReceiveKeys()) &#123;</span><br><span class="line">             //当该窗口可以接收按键事件，则更新窗口</span><br><span class="line">              focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                      false /*updateInputWindows*/);</span><br><span class="line">              if (focusChanged) &#123;</span><br><span class="line">                  imMayMove = false;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (imMayMove) &#123;</span><br><span class="line">              displayContent.computeImeTarget(true /* updateImeTarget */);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Don&apos;t do layout here, the window must call</span><br><span class="line">          // relayout to be displayed, so we&apos;ll do it there.</span><br><span class="line">          win.getParent().assignChildLayers();</span><br><span class="line"></span><br><span class="line">          if (focusChanged) &#123;</span><br><span class="line">              mInputMonitor.setInputFocusLw(mCurrentFocus, false /*updateInputWindows*/);</span><br><span class="line">          &#125;</span><br><span class="line">          //更新输入窗口</span><br><span class="line">          mInputMonitor.updateInputWindowsLw(false /*force*/);</span><br><span class="line"></span><br><span class="line">          if (localLOGV || DEBUG_ADD_REMOVE) Slog.v(TAG_WM, &quot;addWindow: New client &quot;</span><br><span class="line">                  + client.asBinder() + &quot;: window=&quot; + win + &quot; Callers=&quot; + Debug.getCallers(5));</span><br><span class="line"></span><br><span class="line">          if (win.isVisibleOrAdding() &amp;&amp; updateOrientationFromAppTokensLocked(displayId)) &#123;</span><br><span class="line">              reportNewConfig = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (reportNewConfig) &#123;</span><br><span class="line">          sendNewConfiguration(displayId);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-11-1-WindowState"><a href="#2-11-1-WindowState" class="headerlink" title="2.11.1 WindowState"></a>2.11.1 WindowState</h4><p>[-&gt;WindowState.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,</span><br><span class="line">           WindowState parentWindow, int appOp, int seq, WindowManager.LayoutParams a,</span><br><span class="line">           int viewVisibility, int ownerId, boolean ownerCanAddInternalSystemWindow,</span><br><span class="line">           PowerManagerWrapper powerManagerWrapper) &#123;</span><br><span class="line">       super(service);</span><br><span class="line">       //Session的Binder服务端</span><br><span class="line">       mSession = s; </span><br><span class="line">       //IWindow的代理端</span><br><span class="line">       mClient = c;</span><br><span class="line">       mAppOp = appOp;</span><br><span class="line">       mToken = token;</span><br><span class="line">       mAppToken = mToken.asAppWindowToken();</span><br><span class="line">       //对应app的uid</span><br><span class="line">       mOwnerUid = ownerId;</span><br><span class="line">       mOwnerCanAddInternalSystemWindow = ownerCanAddInternalSystemWindow;</span><br><span class="line">       mWindowId = new WindowId(this);</span><br><span class="line">       mAttrs.copyFrom(a);</span><br><span class="line">       mLastSurfaceInsets.set(mAttrs.surfaceInsets);</span><br><span class="line">       mViewVisibility = viewVisibility;</span><br><span class="line">       mPolicy = mService.mPolicy;</span><br><span class="line">       mContext = mService.mContext;</span><br><span class="line">       DeathRecipient deathRecipient = new DeathRecipient();</span><br><span class="line">       mSeq = seq;</span><br><span class="line">       mEnforceSizeCompat = (mAttrs.privateFlags &amp; PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0;</span><br><span class="line">       mPowerManagerWrapper = powerManagerWrapper;</span><br><span class="line">       mForceSeamlesslyRotate = token.mRoundedCornerOverlay;</span><br><span class="line">       if (localLOGV) Slog.v(</span><br><span class="line">           TAG, &quot;Window &quot; + this + &quot; client=&quot; + c.asBinder()</span><br><span class="line">           + &quot; token=&quot; + token + &quot; (&quot; + mAttrs.token + &quot;)&quot; + &quot; params=&quot; + a);</span><br><span class="line">       try &#123;</span><br><span class="line">           c.asBinder().linkToDeath(deathRecipient, 0);</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           mDeathRecipient = null;</span><br><span class="line">           mIsChildWindow = false;</span><br><span class="line">           mLayoutAttached = false;</span><br><span class="line">           mIsImWindow = false;</span><br><span class="line">           mIsWallpaper = false;</span><br><span class="line">           mIsFloatingLayer = false;</span><br><span class="line">           mBaseLayer = 0;</span><br><span class="line">           mSubLayer = 0;</span><br><span class="line">           mInputWindowHandle = null;</span><br><span class="line">           mWinAnimator = null;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       mDeathRecipient = deathRecipient;</span><br><span class="line"></span><br><span class="line">       if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">           // The multiplier here is to reserve space for multiple</span><br><span class="line">           // windows in the same type layer.</span><br><span class="line">           mBaseLayer = mPolicy.getWindowLayerLw(parentWindow)</span><br><span class="line">                   * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">           mSubLayer = mPolicy.getSubWindowLayerFromTypeLw(a.type);</span><br><span class="line">           mIsChildWindow = true;</span><br><span class="line"></span><br><span class="line">           if (DEBUG_ADD_REMOVE) Slog.v(TAG, &quot;Adding &quot; + this + &quot; to &quot; + parentWindow);</span><br><span class="line">           parentWindow.addChild(this, sWindowSubLayerComparator);</span><br><span class="line"></span><br><span class="line">           mLayoutAttached = mAttrs.type !=</span><br><span class="line">                   WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG;</span><br><span class="line">           mIsImWindow = parentWindow.mAttrs.type == TYPE_INPUT_METHOD</span><br><span class="line">                   || parentWindow.mAttrs.type == TYPE_INPUT_METHOD_DIALOG;</span><br><span class="line">           mIsWallpaper = parentWindow.mAttrs.type == TYPE_WALLPAPER;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // The multiplier here is to reserve space for multiple</span><br><span class="line">           // windows in the same type layer.</span><br><span class="line">           mBaseLayer = mPolicy.getWindowLayerLw(this)</span><br><span class="line">                   * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">           mSubLayer = 0;</span><br><span class="line">           mIsChildWindow = false;</span><br><span class="line">           mLayoutAttached = false;</span><br><span class="line">           mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD</span><br><span class="line">                   || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;</span><br><span class="line">           mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;</span><br><span class="line">       &#125;</span><br><span class="line">       mIsFloatingLayer = mIsImWindow || mIsWallpaper;</span><br><span class="line"></span><br><span class="line">       if (mAppToken != null &amp;&amp; mAppToken.mShowForAllUsers) &#123;</span><br><span class="line">           // Windows for apps that can show for all users should also show when the device is</span><br><span class="line">           // locked.</span><br><span class="line">           mAttrs.flags |= FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mWinAnimator = new WindowStateAnimator(this);</span><br><span class="line">       mWinAnimator.mAlpha = a.alpha;</span><br><span class="line"></span><br><span class="line">       mRequestedWidth = 0;</span><br><span class="line">       mRequestedHeight = 0;</span><br><span class="line">       mLastRequestedWidth = 0;</span><br><span class="line">       mLastRequestedHeight = 0;</span><br><span class="line">       mLayer = 0;</span><br><span class="line">       mInputWindowHandle = new InputWindowHandle(</span><br><span class="line">               mAppToken != null ? mAppToken.mInputApplicationHandle : null, this, c,</span><br><span class="line">                   getDisplayId());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-11-2-ws-attach"><a href="#2-11-2-ws-attach" class="headerlink" title="2.11.2 ws.attach"></a>2.11.2 ws.attach</h4><p>[-&gt;WindowState.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void attach() &#123;</span><br><span class="line">      if (localLOGV) Slog.v(TAG, &quot;Attaching &quot; + this + &quot; token=&quot; + mToken);</span><br><span class="line">      mSession.windowAddedLocked(mAttrs.packageName);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>[-&gt;Session.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void windowAddedLocked(String packageName) &#123;</span><br><span class="line">       mPackageName = packageName;</span><br><span class="line">       mRelayoutTag = &quot;relayoutWindow: &quot; + mPackageName;</span><br><span class="line">       if (mSurfaceSession == null) &#123;</span><br><span class="line">           if (WindowManagerService.localLOGV) Slog.v(</span><br><span class="line">               TAG_WM, &quot;First window added to &quot; + this + &quot;, creating SurfaceSession&quot;);</span><br><span class="line">           //创建SurfaceSession对象</span><br><span class="line">           mSurfaceSession = new SurfaceSession();</span><br><span class="line">           if (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                   TAG_WM, &quot;  NEW SURFACE SESSION &quot; + mSurfaceSession);</span><br><span class="line">           //将当前Session添加到mSessions</span><br><span class="line">           mService.mSessions.add(this);</span><br><span class="line">           if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">               mService.dispatchNewAnimatorScaleLocked(this);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       mNumWindow++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-11-3-创建SurfaceSession"><a href="#2-11-3-创建SurfaceSession" class="headerlink" title="2.11.3 创建SurfaceSession"></a>2.11.3 创建SurfaceSession</h4><p>[-&gt;SurfaceSession.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SurfaceSession() &#123;</span><br><span class="line">      mNativeClient = nativeCreate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>[-&gt;core/jni/android_view_SurfaceSession.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static jlong nativeCreate(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">    SurfaceComposerClient* client = new SurfaceComposerClient();</span><br><span class="line">    client-&gt;incStrong((void*)nativeCreate);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建SurfaceComposerClient，作为SurfaceFlinger通信的对象</p>
<h3 id="2-12-WMS-updateFocusedWindowLocked"><a href="#2-12-WMS-updateFocusedWindowLocked" class="headerlink" title="2.12 WMS.updateFocusedWindowLocked"></a>2.12 WMS.updateFocusedWindowLocked</h3><p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">boolean updateFocusedWindowLocked(int mode, boolean updateInputWindows) &#123;</span><br><span class="line">       WindowState newFocus = mRoot.computeFocusedWindow();</span><br><span class="line">       //当前焦点改变</span><br><span class="line">       if (mCurrentFocus != newFocus) &#123;</span><br><span class="line">           Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;wmUpdateFocus&quot;);</span><br><span class="line">           // This check makes sure that we don&apos;t already have the focus</span><br><span class="line">           // change message pending.</span><br><span class="line">           mH.removeMessages(H.REPORT_FOCUS_CHANGE);</span><br><span class="line">           mH.sendEmptyMessage(H.REPORT_FOCUS_CHANGE);</span><br><span class="line">           // TODO(multidisplay): Focused windows on default display only.</span><br><span class="line">           final DisplayContent displayContent = getDefaultDisplayContentLocked();</span><br><span class="line">           boolean imWindowChanged = false;</span><br><span class="line">           if (mInputMethodWindow != null) &#123;</span><br><span class="line">               final WindowState prevTarget = mInputMethodTarget;</span><br><span class="line">               final WindowState newTarget =</span><br><span class="line">                       displayContent.computeImeTarget(true /* updateImeTarget*/);</span><br><span class="line"></span><br><span class="line">               imWindowChanged = prevTarget != newTarget;</span><br><span class="line"></span><br><span class="line">               if (mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS</span><br><span class="line">                       &amp;&amp; mode != UPDATE_FOCUS_WILL_PLACE_SURFACES) &#123;</span><br><span class="line">                   final int prevImeAnimLayer = mInputMethodWindow.mWinAnimator.mAnimLayer;</span><br><span class="line">                   displayContent.assignWindowLayers(false /* setLayoutNeeded */);</span><br><span class="line">                   imWindowChanged |=</span><br><span class="line">                           prevImeAnimLayer != mInputMethodWindow.mWinAnimator.mAnimLayer;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (imWindowChanged) &#123;</span><br><span class="line">               mWindowsChanged = true;</span><br><span class="line">               displayContent.setLayoutNeeded();</span><br><span class="line">               newFocus = mRoot.computeFocusedWindow();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (DEBUG_FOCUS_LIGHT || localLOGV) Slog.v(TAG_WM, &quot;Changing focus from &quot; +</span><br><span class="line">                   mCurrentFocus + &quot; to &quot; + newFocus + &quot; Callers=&quot; + Debug.getCallers(4));</span><br><span class="line">           final WindowState oldFocus = mCurrentFocus;</span><br><span class="line">           mCurrentFocus = newFocus;</span><br><span class="line">           mLosingFocus.remove(newFocus);</span><br><span class="line"></span><br><span class="line">           if (mCurrentFocus != null) &#123;</span><br><span class="line">               mWinAddedSinceNullFocus.clear();</span><br><span class="line">               mWinRemovedSinceNullFocus.clear();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           int focusChanged = mPolicy.focusChangedLw(oldFocus, newFocus);</span><br><span class="line"></span><br><span class="line">           if (imWindowChanged &amp;&amp; oldFocus != mInputMethodWindow) &#123;</span><br><span class="line">               // Focus of the input method window changed. Perform layout if needed.</span><br><span class="line">               // 如果焦点改变，则执行layout</span><br><span class="line">               if (mode == UPDATE_FOCUS_PLACING_SURFACES) &#123;</span><br><span class="line">                   displayContent.performLayout(true /*initial*/,  updateInputWindows);</span><br><span class="line">                   focusChanged &amp;= ~FINISH_LAYOUT_REDO_LAYOUT;</span><br><span class="line">               &#125; else if (mode == UPDATE_FOCUS_WILL_PLACE_SURFACES) &#123;</span><br><span class="line">                   // Client will do the layout, but we need to assign layers</span><br><span class="line">                   // for handleNewWindowLocked() below.</span><br><span class="line">                   displayContent.assignWindowLayers(false /* setLayoutNeeded */);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if ((focusChanged &amp; FINISH_LAYOUT_REDO_LAYOUT) != 0) &#123;</span><br><span class="line">               // The change in focus caused us to need to do a layout.  Okay.</span><br><span class="line">               displayContent.setLayoutNeeded();</span><br><span class="line">               if (mode == UPDATE_FOCUS_PLACING_SURFACES) &#123;</span><br><span class="line">                   displayContent.performLayout(true /*initial*/, updateInputWindows);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS) &#123;</span><br><span class="line">               // If we defer assigning layers, then the caller is responsible for</span><br><span class="line">               // doing this part.</span><br><span class="line">               mInputMonitor.setInputFocusLw(mCurrentFocus, updateInputWindows);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           displayContent.adjustForImeIfNeeded();</span><br><span class="line"></span><br><span class="line">           // We may need to schedule some toast windows to be removed. The toasts for an app that</span><br><span class="line">           // does not have input focus are removed within a timeout to prevent apps to redress</span><br><span class="line">           // other apps&apos; UI.</span><br><span class="line">           displayContent.scheduleToastWindowsTimeoutIfNeededLocked(oldFocus, newFocus);</span><br><span class="line"></span><br><span class="line">           Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本文详细分析了Android屏幕刷新机制中的View的绘制过程，这里只介绍到framework层。</p>
<p>1.从Activity的启动流程开始分析，在performLaunchActivity方法中调用Activity.attach方法创建PhoneWindow；</p>
<p>2.PhoneWindow中有一个DecorView实例，DecorView继承于FrameLayout，通过setContentView将Activity中的布局view添加DecorView中；</p>
<p>3.调用handleResumeActivity，进入到Activity的onResume方法，后面再调用Activity.makeVisible方法；</p>
<p>4.makeVisible方法调用了WindowManagerGlobal.addView方法，创建了ViewRootImpl对象；</p>
<p>5.调用ViewRootImlp中的requestLayout，再调用到里面的scheduleTraversals进行绘制；</p>
<p>6.scheduleTraversals方法，向主线程发送同步屏障消息，通过mChoreographer.postCallback将mTraversalRunnable放到mCallbackQueues队列里面，在同一个帧内，多次请求requestLayout，只会调用一次scheduleTraversals。</p>
<p>7.如果当前线程是主线程则调用nativeScheduleVsync，如果不是则通过handler发送到主线程进行处理；</p>
<p>8.native方法主要是向底层注册监听Vsync屏幕刷新信号，当下一个Vsync信号发出时，底层会回调onVsync方法</p>
<p>9.onVsync方法，会向主线程发送Runnable异步消息，里面会执行doFrame方法；</p>
<p>10.doFrame会执行mCallbackQueues队列里面的任务，取出来的任务会执行doTraversal方法</p>
<p>11.doTraversal方法会先移除主线程中同步屏障，然后调用performTraversals，根据当前的状态判断是否需要执行performMeasure，performLayout，performDraw，这三个过程都会遍历View树刷新需要更新的view。</p>
<p>12.通过Session.addToDisplay向WMS添加Window，WMS建立SurfaceComposerClient，然后会在SurfaceFlinger创建Client与之对应，后面通过ISurfaceComposerClient和SurfaceFlinger进行通信。</p>

      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/View/" rel="tag">#View</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/Android JNI 原理分析/" rel="next" title="Android JNI原理分析">
                <i class="fa fa-chevron-left"></i> Android JNI原理分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/Android刷新机制-Choreographer原理/" rel="prev" title="Android刷新机制-Choreographer原理">
                Android刷新机制-Choreographer原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、View的绘制过程"><span class="nav-text">二、View的绘制过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-AT-performLaunchActivity"><span class="nav-text">2.1 AT.performLaunchActivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Activity-attach"><span class="nav-text">2.2 Activity.attach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Activity-setContentView"><span class="nav-text">2.3 Activity.setContentView</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-installDecor"><span class="nav-text">2.3.1 installDecor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-DecorView创建"><span class="nav-text">2.3.2 DecorView创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-generateLayout"><span class="nav-text">2.3.3 generateLayout</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-AT-handleResumeActivity"><span class="nav-text">2.4 AT.handleResumeActivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Activity-makeVisible"><span class="nav-text">2.5 Activity.makeVisible</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-WMI-addView"><span class="nav-text">2.6 WMI.addView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-WMG-addView"><span class="nav-text">2.7 WMG.addView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-VRI-setView"><span class="nav-text">2.8 VRI.setView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-VRI-requestLayout"><span class="nav-text">2.9 VRI.requestLayout</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-1-VRI-scheduleTraversals"><span class="nav-text">2.9.1 VRI.scheduleTraversals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-2-Choreographer-postCallback"><span class="nav-text">2.9.2 Choreographer.postCallback</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-2-1-scheduleFrameLocked"><span class="nav-text">2.9.2.1 scheduleFrameLocked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-2-2-scheduleVsyncLocked"><span class="nav-text">2.9.2.2 scheduleVsyncLocked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-2-3-scheduleVsync"><span class="nav-text">2.9.2.3 scheduleVsync</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-2-4-FrameDisplayEventReceiver"><span class="nav-text">2.9.2.4 FrameDisplayEventReceiver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-2-5-doFrame"><span class="nav-text">2.9.2.5 doFrame</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-2-6-doCallbacks"><span class="nav-text">2.9.2.6 doCallbacks</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-3-VRI-doTraversal"><span class="nav-text">2.9.3  VRI.doTraversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-4-VRI-performTraversals"><span class="nav-text">2.9.4 VRI.performTraversals</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-Session-addToDisplay"><span class="nav-text">2.10 Session.addToDisplay</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-WMS-addWindow"><span class="nav-text">2.11 WMS.addWindow</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-11-1-WindowState"><span class="nav-text">2.11.1 WindowState</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-11-2-ws-attach"><span class="nav-text">2.11.2 ws.attach</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-11-3-创建SurfaceSession"><span class="nav-text">2.11.3 创建SurfaceSession</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-WMS-updateFocusedWindowLocked"><span class="nav-text">2.12 WMS.updateFocusedWindowLocked</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、总结"><span class="nav-text">三、总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2020/Android刷新机制-View绘制原理/';
      var disqus_title = "Android刷新机制-View绘制原理";
      var disqus_url = 'http://zproo.github.io/2020/Android刷新机制-View绘制原理/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
