<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Binder机制,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="一、概述1.1 Binder架构Android内核基于Linux系统，而Linux系统进程间通信方式有很多，如管道，共g享内存，信号，信号量，消息队列，套接字。而Android为什么要用binder进行进程间的通信，这里引用gityuan在知乎上的回答： （1）从性能的角度数据拷贝次数 Binder数据拷贝只需要一次，而管道，消息队列，Socket都需要二次，但共享内存连一次拷贝都不需要；从性能角">
<meta name="keywords" content="Binder机制">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Binder机制4-bindService过程分析">
<meta property="og:url" content="http://zproo.github.io/2020/深入理解Binder机制4-bindService过程分析/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="一、概述1.1 Binder架构Android内核基于Linux系统，而Linux系统进程间通信方式有很多，如管道，共g享内存，信号，信号量，消息队列，套接字。而Android为什么要用binder进行进程间的通信，这里引用gityuan在知乎上的回答： （1）从性能的角度数据拷贝次数 Binder数据拷贝只需要一次，而管道，消息队列，Socket都需要二次，但共享内存连一次拷贝都不需要；从性能角">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2020/深入理解Binder机制4-bindService过程分析/bindservice_binder_frame.PNG">
<meta property="og:image" content="http://zproo.github.io/2020/深入理解Binder机制4-bindService过程分析/bindservice.png">
<meta property="og:image" content="http://zproo.github.io/2020/深入理解Binder机制4-bindService过程分析/bindservice_cm_frame.PNG">
<meta property="og:image" content="http://zproo.github.io/2020/深入理解Binder机制4-bindService过程分析/binderservice_cm_pro.PNG">
<meta property="og:image" content="http://zproo.github.io/2020/深入理解Binder机制4-bindService过程分析/bindservice_data.png">
<meta property="og:updated_time" content="2020-05-05T02:14:34.154Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Binder机制4-bindService过程分析">
<meta name="twitter:description" content="一、概述1.1 Binder架构Android内核基于Linux系统，而Linux系统进程间通信方式有很多，如管道，共g享内存，信号，信号量，消息队列，套接字。而Android为什么要用binder进行进程间的通信，这里引用gityuan在知乎上的回答： （1）从性能的角度数据拷贝次数 Binder数据拷贝只需要一次，而管道，消息队列，Socket都需要二次，但共享内存连一次拷贝都不需要；从性能角">
<meta name="twitter:image" content="http://zproo.github.io/2020/深入理解Binder机制4-bindService过程分析/bindservice_binder_frame.PNG">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2020/深入理解Binder机制4-bindService过程分析/">

  <title> 深入理解Binder机制4-bindService过程分析 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/Binder机制/" rel="tag" title="Binder机制">Binder机制</a>
      
      </div>
      <h1>深入理解Binder机制4-bindService过程分析</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2020-02-10T21:28:28+08:00" content="2020-02-10" title="2020-02-10 21:28:28">
          2020-02-10
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解Binder机制4-bindService过程分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-02-10T21:28:28+08:00" content="2020-02-10">
              2020-02-10
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/深入理解Binder机制4-bindService过程分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/深入理解Binder机制4-bindService过程分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-Binder架构"><a href="#1-1-Binder架构" class="headerlink" title="1.1 Binder架构"></a>1.1 Binder架构</h3><p>Android内核基于Linux系统，而Linux系统进程间通信方式有很多，如管道，共g享内存，信号，信号量，消息队列，套接字。而Android为什么要用binder进行进程间的通信，这里引用<a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">gityuan在知乎</a>上的回答：</p>
<p><strong>（1）从性能的角度数据拷贝次数</strong></p>
<p>Binder数据拷贝只需要一次，而管道，消息队列，Socket都需要二次，但共享内存连一次拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</p>
<p><strong>（2）从稳定性的角度</strong></p>
<p>Binder基于C/S架构，Server端和Client端相对独立，稳定性较好，而共享内存实现方式复杂，需要考虑到同步并发的问题。从稳定性方面，Binder架构优于共享内存。</p>
<p><strong>（3）从安全的角度</strong></p>
<p>传统Linux进程间通信无法获取对方进程可靠的UID/PID，无法鉴别对方身份；而Android为每个应用程序分配UID，Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限。</p>
<p><strong>（4）从语言层面的角度</strong></p>
<p>Linux是基于C语言，而Android是基于Java语言，Binder符合面向对象的思想，Binder将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法。Binder对象作为一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却可以在系统的每个进程之中。</p>
<p><strong>（5）从公司战略的角度</strong></p>
<p>Linux内核源码许可基于GPL协议，为了避免遵循GPL协议，就不能在应用层调用底层kernel，Binder基于开源的OpenBinder实现，作者在Google工作，OpenBinder用Apache-2.0协议保护。</p>
<p>Binder架构采用分层架构设计，每一层都有不同的功能。</p>
<p>分层的架构设计主要特点如下：</p>
<ul>
<li>层与层具有独立性；</li>
<li>设计灵活，层与层之间都定义好接口，接口不变就不会有影响；</li>
<li>结构的解耦合，让每一层可以用适合自己的技术方案和语言；</li>
<li>方便维护，可分层调试和定位问题</li>
</ul>
<p>Binder架构分成四层，应用层，Framework层，Native层和内核层</p>
<p>应用层：Java应用层通过调用IActivityManager.bindService,经过层层调用到AMS.bindService；</p>
<p>Framework层：Jave IPC Binder通信采用C/S架构，在Framework层实现BinderProxy和Binder;</p>
<p>Native层：Native IPC，在Native层的C/S架构，实现了BpBinder和BBinder(JavaBBinder);</p>
<p>Kernel层：Binder驱动，运行在内核空间，可共享。其它三层是在用户空间，不可共享。</p>
<h3 id="1-2-Binder-IPC原理"><a href="#1-2-Binder-IPC原理" class="headerlink" title="1.2 Binder IPC原理"></a>1.2 Binder IPC原理</h3><p>Binder通信采用C/S架构，包含Client，Server，ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务，下面是以AMS服务为例的架构图：</p>
<p><img src="/2020/深入理解Binder机制4-bindService过程分析/bindservice_binder_frame.PNG" alt="bindservice_binder_frame" style="zoom:67%;"></p>
<p>无论是注册服务还是获取服务的过程都需要ServiceManager，此处的ServiceManager是指Native层的ServiceManager(C++)，并非指framework层的ServiceManager（Java）。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程。Client端和Server端通信时都需要先获取ServiceManager接口，才能开始通信服务，查找到目标信息可以缓存起来则不需要每次都向ServiceManager请求。</p>
<p>图中Client/Server/ServiceManager之间的相互通信都是基于Binder机制，其主要分为三个过程：</p>
<p>1.注册服务：AMS注册到ServiceManager。这个过程AMS所在的进程(system_server)是客户端，ServiceManager是服务端。</p>
<p>2.获取服务：Client进程使用AMS前，必须向ServiceManager中获取AMS的代理类。这个过程：AMS的代理类是客户端，ServiceManager是服务端。</p>
<p>3.使用服务：app进程根据得到的代理类，便可以直接与AMS所在进程交互。这个过程：代理类所在进程是客户端，AMS所在进程(system_server)是服务端。</p>
<p>Client,Server，ServiceManager之间不是直接交互的，都是通过与Binder Driver进行交互的，从而实现IPC通信方式。Binder驱动位于内核层，Client,Server,ServiceManager位于用户空间。Binder驱动和ServiceManager可以看做是Android平台的基础架构，而Client和Server是Android应用层。</p>
<p>前面已经分析过第一第二个过程注册服务和获取服务，本文主要介绍第三个过程使用服务，以bindService过程为例。</p>
<h3 id="1-3-bindService流程"><a href="#1-3-bindService流程" class="headerlink" title="1.3 bindService流程"></a>1.3 bindService流程</h3><p>bindService流程如下图，从客户端调用bindService到服务器端通过ServiceConnected对象返回代理类给客户端，下面将从源码的角度分析这个过程。</p>
<p><img src="/2020/深入理解Binder机制4-bindService过程分析/bindservice.png" alt="bindservice" style="zoom: 67%;"></p>
<h2 id="二、客户端进程"><a href="#二、客户端进程" class="headerlink" title="二、客户端进程"></a>二、客户端进程</h2><h3 id="2-1-CL-bindService"><a href="#2-1-CL-bindService" class="headerlink" title="2.1 CL.bindService"></a>2.1 CL.bindService</h3><p>[-&gt;ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public boolean bindService(Intent service, ServiceConnection conn,</span><br><span class="line">         int flags) &#123;</span><br><span class="line">     warnIfCallingFromSystemProcess();</span><br><span class="line">     return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), getUser());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-CL-bindServiceCommon"><a href="#2-2-CL-bindServiceCommon" class="headerlink" title="2.2 CL.bindServiceCommon"></a>2.2 CL.bindServiceCommon</h3><p>[-&gt;ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler</span><br><span class="line">          handler, UserHandle user) &#123;</span><br><span class="line">      // Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span><br><span class="line">      IServiceConnection sd;</span><br><span class="line">      if (conn == null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;connection is null&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (mPackageInfo != null) &#123;</span><br><span class="line">          //获取的内部静态类InnerConnection</span><br><span class="line">          sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          throw new RuntimeException(&quot;Not supported in system context&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      validateServiceIntent(service);</span><br><span class="line">      try &#123;</span><br><span class="line">          IBinder token = getActivityToken();</span><br><span class="line">          if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null</span><br><span class="line">                  &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                  &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">              flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">          &#125;</span><br><span class="line">          service.prepareToLeaveProcess(this);</span><br><span class="line">          //bindservice见2.3节</span><br><span class="line">          int res = ActivityManager.getService().bindService(</span><br><span class="line">              mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">              service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">              sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">          if (res &lt; 0) &#123;</span><br><span class="line">              throw new SecurityException(</span><br><span class="line">                      &quot;Not allowed to bind to service &quot; + service);</span><br><span class="line">          &#125;</span><br><span class="line">          return res != 0;</span><br><span class="line">      &#125; catch (RemoteException e) &#123;</span><br><span class="line">          throw e.rethrowFromSystemServer();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>主要的工作如下：</p>
<ul>
<li><p>创建对象LoadedApk.ServiceDispatcher对象</p>
</li>
<li><p>向AMS发送bindservice请求</p>
</li>
</ul>
<h4 id="2-2-1-getServiceDispatcher"><a href="#2-2-1-getServiceDispatcher" class="headerlink" title="2.2.1 getServiceDispatcher"></a>2.2.1 getServiceDispatcher</h4><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final IServiceConnection getServiceDispatcher(ServiceConnection c,</span><br><span class="line">           Context context, Handler handler, int flags) &#123;</span><br><span class="line">       synchronized (mServices) &#123;</span><br><span class="line">           LoadedApk.ServiceDispatcher sd = null;</span><br><span class="line">           ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">           if (map != null) &#123;</span><br><span class="line">               if (DEBUG) Slog.d(TAG, &quot;Returning existing dispatcher &quot; + sd + &quot; for conn &quot; + c);</span><br><span class="line">               sd = map.get(c);</span><br><span class="line">           &#125;</span><br><span class="line">           if (sd == null) &#123;</span><br><span class="line">               //创建服务分发对象</span><br><span class="line">               sd = new ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">               if (DEBUG) Slog.d(TAG, &quot;Creating new dispatcher &quot; + sd + &quot; for conn &quot; + c);</span><br><span class="line">               if (map == null) &#123;</span><br><span class="line">                   map = new ArrayMap&lt;&gt;();</span><br><span class="line">                   mServices.put(context, map);</span><br><span class="line">               &#125;</span><br><span class="line">               //ServiceConnection为key，ServiceDispatcher为value保存到map</span><br><span class="line">               map.put(c, sd);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               sd.validate(context, handler);</span><br><span class="line">           &#125;</span><br><span class="line">           return sd.getIServiceConnection();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mServices记录所有context里面每个ServiceConnection以及所对应的所对应的LoadedApk.ServiceDispatcher对象；同一个ServiceConnection只会创建一次，</li>
</ul>
<ul>
<li>返回的对象是ServiceConnection.InnerConnection,该对象继承于IServiceConnection.Stub。</li>
</ul>
<h4 id="2-2-2-ServiceDispatcher"><a href="#2-2-2-ServiceDispatcher" class="headerlink" title="2.2.2 ServiceDispatcher"></a>2.2.2 ServiceDispatcher</h4><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static final class ServiceDispatcher &#123;</span><br><span class="line">        private final ServiceDispatcher.InnerConnection mIServiceConnection;</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        private final ServiceConnection mConnection;</span><br><span class="line">        @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)</span><br><span class="line">        private final Context mContext;</span><br><span class="line">        private final Handler mActivityThread;</span><br><span class="line">        private final ServiceConnectionLeaked mLocation;</span><br><span class="line">        private final int mFlags;</span><br><span class="line"></span><br><span class="line">        private RuntimeException mUnbindLocation;</span><br><span class="line"></span><br><span class="line">        private boolean mForgotten;</span><br><span class="line"></span><br><span class="line">        private static class ConnectionInfo &#123;</span><br><span class="line">            IBinder binder;</span><br><span class="line">            IBinder.DeathRecipient deathMonitor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static class InnerConnection extends IServiceConnection.Stub &#123;</span><br><span class="line">            @UnsupportedAppUsage</span><br><span class="line">            final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">            InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">                //创建ServiceDispatcher弱引用</span><br><span class="line">                mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void connected(ComponentName name, IBinder service, boolean dead)</span><br><span class="line">                    throws RemoteException &#123;</span><br><span class="line">                LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">                if (sd != null) &#123;</span><br><span class="line">                    sd.connected(name, service, dead);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private final ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt; mActiveConnections</span><br><span class="line">            = new ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt;();</span><br><span class="line"></span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        ServiceDispatcher(ServiceConnection conn,</span><br><span class="line">                Context context, Handler activityThread, int flags) &#123;</span><br><span class="line">            //新建InnerConnection</span><br><span class="line">            mIServiceConnection = new InnerConnection(this);</span><br><span class="line">            mConnection = conn;</span><br><span class="line">            mContext = context;</span><br><span class="line">            mActivityThread = activityThread;</span><br><span class="line">            mLocation = new ServiceConnectionLeaked(null);</span><br><span class="line">            mLocation.fillInStackTrace();</span><br><span class="line">            mFlags = flags;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">         @UnsupportedAppUsage</span><br><span class="line">        IServiceConnection getIServiceConnection() &#123;</span><br><span class="line">            //返回上面初始化的 mIServiceConnection</span><br><span class="line">            return mIServiceConnection;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> getServiceDispatcher返回的是构造方法中的InnerConnection对象。</p>
<h4 id="2-2-3-AM-getService"><a href="#2-2-3-AM-getService" class="headerlink" title="2.2.3 AM.getService"></a>2.2.3 AM.getService</h4><p>[-&gt;ActivityManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static IActivityManager getService() &#123;</span><br><span class="line">     return IActivityManagerSingleton.get();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> @UnsupportedAppUsage</span><br><span class="line"> private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">      new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             protected IActivityManager create() &#123;</span><br><span class="line">                 //获取IBinder</span><br><span class="line">                 final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                 //见2.2.5节，获取代理</span><br><span class="line">                 final IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                 return am;</span><br><span class="line">             &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>在前面<a href="https://skytoby.github.io/2020/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder%E6%9C%BA%E5%88%B63-%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1getService/" target="_blank" rel="noopener">获取服务</a>那篇文章中可以看出ServiceManager.getService(Context.ACTIVITY_SERVICE);等价于new BinderProxy(nativeData)，这里的b相当于BinderProxy对象。</p>
<h4 id="2-2-4-asInterface"><a href="#2-2-4-asInterface" class="headerlink" title="2.2.4 asInterface"></a>2.2.4 asInterface</h4><p>[-&gt;IActivityManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static android.app.IActivityManager asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">         if ((obj == null)) &#123;</span><br><span class="line">             return null;</span><br><span class="line">         &#125;</span><br><span class="line">         android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">         //如果不是代理，这里不会走这里</span><br><span class="line">         if (((iin != null) &amp;&amp; (iin instanceof android.app.IActivityManager))) &#123;</span><br><span class="line">             return ((android.app.IActivityManager) iin);</span><br><span class="line">         &#125;</span><br><span class="line">         return new android.app.IActivityManager.Stub.Proxy(obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-创建Proxy"><a href="#2-2-5-创建Proxy" class="headerlink" title="2.2.5 创建Proxy"></a>2.2.5 创建Proxy</h4><p>[-&gt;IActivityManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static class Proxy implements android.app.IActivityManager &#123;</span><br><span class="line">     private android.os.IBinder mRemote;</span><br><span class="line">      Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">             mRemote = remote;</span><br><span class="line">      &#125; </span><br><span class="line">      ...</span><br><span class="line">        @Override</span><br><span class="line">  public int bindService(android.app.IApplicationThread caller, android.os.IBinder token, android.content.Intent service, String resolvedType, android.app.IServiceConnection connection, int flags, String callingPackage, int userId) throws android.os.RemoteException &#123;</span><br><span class="line">             android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">             android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">             int _result;</span><br><span class="line">             try &#123;</span><br><span class="line">                 _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                 //将ApplicationThread对象传递给systemserver</span><br><span class="line">                 _data.writeStrongBinder((((caller != null)) ? (caller.asBinder()) : (null)));</span><br><span class="line">                 _data.writeStrongBinder(token);</span><br><span class="line">                 if ((service != null)) &#123;</span><br><span class="line">                     _data.writeInt(1);</span><br><span class="line">                     service.writeToParcel(_data, 0);</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     _data.writeInt(0);</span><br><span class="line">                 &#125;</span><br><span class="line">                 _data.writeString(resolvedType);</span><br><span class="line">                 //将InnerConnection对象传递给systemserver</span><br><span class="line">                 _data.writeStrongBinder((((connection != null)) ? (connection.asBinder()) : (null)));</span><br><span class="line">                 _data.writeInt(flags);</span><br><span class="line">                 _data.writeString(callingPackage);</span><br><span class="line">                 _data.writeInt(userId);</span><br><span class="line">                 //通过bind调用，进入到systemserver</span><br><span class="line">                 mRemote.transact(Stub.TRANSACTION_bindService, _data, _reply, 0);</span><br><span class="line">                 _reply.readException();</span><br><span class="line">                 _result = _reply.readInt();</span><br><span class="line">             &#125; finally &#123;</span><br><span class="line">                 _reply.recycle();</span><br><span class="line">                 _data.recycle();</span><br><span class="line">             &#125;</span><br><span class="line">             return _result;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里mRemote为BinderProxy对象，通过mRemote向服务端传输数据。</p>
<p>writeStrongBinder、transact操作在<a href="https://skytoby.github.io/2020/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder%E6%9C%BA%E5%88%B62-%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1addService/" target="_blank" rel="noopener">注册服务</a>那篇文章有详细的介绍，这里不再分析，向目标进程写入BINDER_WORK_TRANSACTION命令，下面进入服务端systemserver进程。</p>
<h2 id="三、system-server进程"><a href="#三、system-server进程" class="headerlink" title="三、system_server进程"></a>三、system_server进程</h2><p>在<a href="https://skytoby.github.io/2019/Android%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">进程的启动</a>那篇文章15.2节中，systemserver进程启动时会启动binder线程</p>
<h3 id="3-1-onZygoteInit"><a href="#3-1-onZygoteInit" class="headerlink" title="3.1 onZygoteInit()"></a>3.1 onZygoteInit()</h3><p>[-&gt;app_main.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virtual void onZygoteInit()</span><br><span class="line">  &#123;</span><br><span class="line">      sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">      ALOGV(&quot;App process: starting thread pool./n&quot;);</span><br><span class="line">      proc-&gt;startThreadPool(); //启动新的binder线程</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1-startThreadPool"><a href="#3-1-1-startThreadPool" class="headerlink" title="3.1.1  startThreadPool"></a>3.1.1  startThreadPool</h4><p>[-&gt;ProcessState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void ProcessState::startThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    if (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted = true;</span><br><span class="line">        spawnPooledThread(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2-spawnPooledThread"><a href="#3-1-2-spawnPooledThread" class="headerlink" title="3.1.2  spawnPooledThread"></a>3.1.2  spawnPooledThread</h4><p>[-&gt;ProcessState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void ProcessState::spawnPooledThread(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    if (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = makeBinderThreadName();</span><br><span class="line">        ALOGV(&quot;Spawning new pooled thread, name=%s/n&quot;, name.string());</span><br><span class="line">        //创建线程池</span><br><span class="line">        sp&lt;Thread&gt; t = new PoolThread(isMain);</span><br><span class="line">        //执行threadLoop方法</span><br><span class="line">        t-&gt;run(name.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-new-PoolThread"><a href="#3-1-3-new-PoolThread" class="headerlink" title="3.1.3  new PoolThread"></a>3.1.3  new PoolThread</h4><p>[-&gt;ProcessState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class PoolThread : public Thread</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    explicit PoolThread(bool isMain)</span><br><span class="line">        : mIsMain(isMain)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected:</span><br><span class="line">    virtual bool threadLoop()</span><br><span class="line">    &#123;</span><br><span class="line">        //见3.2节</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const bool mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-joinThreadPool"><a href="#3-2-joinThreadPool" class="headerlink" title="3.2 joinThreadPool"></a>3.2 joinThreadPool</h3><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::joinThreadPool(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_THREADPOOL(&quot;**** THREAD %p (PID %d) IS JOINING THE THREAD POOL/n&quot;, (void*)pthread_self(), getpid());</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    status_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        //处理对象引用</span><br><span class="line">        processPendingDerefs();</span><br><span class="line">        // now get the next command to be processed, waiting if necessary</span><br><span class="line">        //获取并执行命令，见2.3节</span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line"></span><br><span class="line">        if (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF)        &#123;</span><br><span class="line">            ALOGE(&quot;getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting&quot;,</span><br><span class="line">                  mProcess-&gt;mDriverFD, result);</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Let this thread exit the thread pool if it is no longer</span><br><span class="line">        // needed and it is not the main process thread.</span><br><span class="line">        //对于binder非主线程，不再使用则退出</span><br><span class="line">        if(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"></span><br><span class="line">    LOG_THREADPOOL(&quot;**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%d/n&quot;,</span><br><span class="line">        (void*)pthread_self(), getpid(), result);</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    //和binder驱动交互</span><br><span class="line">    talkWithDriver(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>system_server进程，通过这个while循环来获取并执行binder命令。</p>
<h3 id="3-3-IPC-getAndExecuteCommand"><a href="#3-3-IPC-getAndExecuteCommand" class="headerlink" title="3.3 IPC.getAndExecuteCommand"></a>3.3 IPC.getAndExecuteCommand</h3><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::getAndExecuteCommand()</span><br><span class="line">&#123;</span><br><span class="line">    status_t result;</span><br><span class="line">    int32_t cmd;</span><br><span class="line">    //和Binder Driver交互</span><br><span class="line">    result = talkWithDriver();</span><br><span class="line">    if (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        size_t IN = mIn.dataAvail();</span><br><span class="line">        if (IN &lt; sizeof(int32_t)) return result;</span><br><span class="line">        //读取命令</span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Processing top-level Command: &quot;</span><br><span class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount++;</span><br><span class="line">        if (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs == 0) &#123;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        //见3.4节</span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount--;</span><br><span class="line">        if (mProcess-&gt;mExecutingThreadsCount &lt; mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs != 0) &#123;</span><br><span class="line">            int64_t starvationTimeMs = uptimeMillis() - mProcess-&gt;mStarvationStartTimeMs;</span><br><span class="line">            if (starvationTimeMs &gt; 100) &#123;</span><br><span class="line">                ALOGE(&quot;binder thread pool (%zu threads) starved for %&quot; PRId64 &quot; ms&quot;,</span><br><span class="line">                      mProcess-&gt;mMaxThreads, starvationTimeMs);</span><br><span class="line">            &#125;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_cond_broadcast(&amp;mProcess-&gt;mThreadCountDecrement);</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里system_server的binder线程空闲，停在binder_thread_read方法来处理进程/线程的事务。前面收到BINDER_WORK_TRANSACTION命令，经过binder_thread_read后生成命令cmd=BR_TRANSACTION，再将cmd和数据写回用户空间。</p>
<h3 id="3-4-IPC-executeCommand"><a href="#3-4-IPC-executeCommand" class="headerlink" title="3.4 IPC.executeCommand"></a>3.4 IPC.executeCommand</h3><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line">     ...</span><br><span class="line">     case BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result = mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR,</span><br><span class="line">                &quot;Not enough command data for brTRANSACTION&quot;);</span><br><span class="line">            if (result != NO_ERROR) break;</span><br><span class="line"></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            //当buffer对象回收时，通过调用freeBuffer来回收内存</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);</span><br><span class="line"></span><br><span class="line">            const pid_t origPid = mCallingPid;</span><br><span class="line">            const uid_t origUid = mCallingUid;</span><br><span class="line">            const int32_t origStrictModePolicy = mStrictModePolicy;</span><br><span class="line">            const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;</span><br><span class="line">            //设置调用者的pid、uid</span><br><span class="line">            mCallingPid = tr.sender_pid;</span><br><span class="line">            mCallingUid = tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags = tr.flags;</span><br><span class="line"></span><br><span class="line">            //ALOGI(&quot;&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d/n&quot;, mCallingPid, mCallingUid);</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            status_t error;</span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BR_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self()</span><br><span class="line">                    &lt;&lt; &quot; / obj &quot; &lt;&lt; tr.target.ptr &lt;&lt; &quot; / code &quot;</span><br><span class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; buffer</span><br><span class="line">                    &lt;&lt; dedent &lt;&lt; endl</span><br><span class="line">                    &lt;&lt; &quot;Data addr = &quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer)</span><br><span class="line">                    &lt;&lt; &quot;, offsets addr=&quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            if (tr.target.ptr) &#123;</span><br><span class="line">                // We only have a weak reference on the target object, so we must first try to</span><br><span class="line">                // safely acquire a strong reference before doing anything else with it.</span><br><span class="line">                // 尝试通过弱引用获取强引用</span><br><span class="line">                if (reinterpret_cast&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(this)) &#123;</span><br><span class="line">                    //tr.cookie存放的是BBinder子类的JavaBBinder    </span><br><span class="line">                    error = reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    error = UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //ALOGI(&quot;&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d/n&quot;,</span><br><span class="line">            //     mCallingPid, origPid, origUid);</span><br><span class="line"></span><br><span class="line">            if ((tr.flags &amp; TF_ONE_WAY) == 0) &#123;</span><br><span class="line">                //对于非oneway，需要通过reply通信过程，向binder驱动发送BC_REPLY命令</span><br><span class="line">                LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">                if (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                sendReply(reply, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">            &#125;</span><br><span class="line">            //恢复pid和uid信息</span><br><span class="line">            mCallingPid = origPid;</span><br><span class="line">            mCallingUid = origUid;</span><br><span class="line">            mStrictModePolicy = origStrictModePolicy;</span><br><span class="line">            mLastTransactionBinderFlags = origTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BC_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / obj &quot;</span><br><span class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result != NO_ERROR) &#123;</span><br><span class="line">        mLastError = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于oneway的情况，执行完本次transact则全部结束</p>
</li>
<li><p>对于非oneway的情况，需要reply的通信过程，则向Binder驱动发送RC_REPLY命令</p>
</li>
</ul>
<h4 id="3-4-1-ipcSetDataReference"><a href="#3-4-1-ipcSetDataReference" class="headerlink" title="3.4.1 ipcSetDataReference"></a>3.4.1 ipcSetDataReference</h4><p>[-&gt;Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,</span><br><span class="line">    const binder_size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)</span><br><span class="line">&#123;</span><br><span class="line">    binder_size_t minOffset = 0;</span><br><span class="line">    //见3.4.2小节</span><br><span class="line">    freeDataNoInit();</span><br><span class="line">    mError = NO_ERROR;</span><br><span class="line">    mData = const_cast&lt;uint8_t*&gt;(data);</span><br><span class="line">    mDataSize = mDataCapacity = dataSize;</span><br><span class="line">    //ALOGI(&quot;setDataReference Setting data size of %p to %lu (pid=%d)&quot;, this, mDataSize, getpid());</span><br><span class="line">    mDataPos = 0;</span><br><span class="line">    ALOGV(&quot;setDataReference Setting data pos of %p to %zu&quot;, this, mDataPos);</span><br><span class="line">    mObjects = const_cast&lt;binder_size_t*&gt;(objects);</span><br><span class="line">    mObjectsSize = mObjectsCapacity = objectsCount;</span><br><span class="line">    mNextObjectHint = 0;</span><br><span class="line">    mObjectsSorted = false;</span><br><span class="line">    mOwner = relFunc;</span><br><span class="line">    mOwnerCookie = relCookie;</span><br><span class="line">    for (size_t i = 0; i &lt; mObjectsSize; i++) &#123;</span><br><span class="line">        binder_size_t offset = mObjects[i];</span><br><span class="line">        if (offset &lt; minOffset) &#123;</span><br><span class="line">            ALOGE(&quot;%s: bad object offset %&quot; PRIu64 &quot; &lt; %&quot; PRIu64 &quot;/n&quot;,</span><br><span class="line">                  __func__, (uint64_t)offset, (uint64_t)minOffset);</span><br><span class="line">            mObjectsSize = 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset = offset + sizeof(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Parcel成员变量说明：</p>
<p>mData：parcel数据起始地址</p>
<p>mDataSize：parcel数据大小</p>
<p>mObjects：flat_binder_object地址偏移量</p>
<p>mObjectsSize：parcel中flat_binder_object个数</p>
<p>mOwner：释放函数freeBuffer</p>
<p>mOwnerCookie：释放函数所需信息</p>
<h4 id="3-4-2-freeDataNoInit"><a href="#3-4-2-freeDataNoInit" class="headerlink" title="3.4.2 freeDataNoInit"></a>3.4.2 freeDataNoInit</h4><p>[-&gt;Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void Parcel::freeDataNoInit()</span><br><span class="line">&#123;</span><br><span class="line">    if (mOwner) &#123;</span><br><span class="line">        LOG_ALLOC(&quot;Parcel %p: freeing other owner data&quot;, this);</span><br><span class="line">        //ALOGI(&quot;Freeing data ref of %p (pid=%d)&quot;, this, getpid());</span><br><span class="line">        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //为空进入这里</span><br><span class="line">        LOG_ALLOC(&quot;Parcel %p: freeing allocated data&quot;, this);</span><br><span class="line">        releaseObjects();</span><br><span class="line">        if (mData) &#123;</span><br><span class="line">            LOG_ALLOC(&quot;Parcel %p: freeing with %zu capacity&quot;, this, mDataCapacity);</span><br><span class="line">            pthread_mutex_lock(&amp;gParcelGlobalAllocSizeLock);</span><br><span class="line">            if (mDataCapacity &lt;= gParcelGlobalAllocSize) &#123;</span><br><span class="line">              gParcelGlobalAllocSize = gParcelGlobalAllocSize - mDataCapacity;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              gParcelGlobalAllocSize = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (gParcelGlobalAllocCount &gt; 0) &#123;</span><br><span class="line">              gParcelGlobalAllocCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;gParcelGlobalAllocSizeLock);</span><br><span class="line">            free(mData);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mObjects) free(mObjects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-3-releaseObjects"><a href="#3-4-3-releaseObjects" class="headerlink" title="3.4.3 releaseObjects"></a>3.4.3 releaseObjects</h4><p>[-&gt;Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Parcel::releaseObjects()</span><br><span class="line">&#123;</span><br><span class="line">    const sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    size_t i = mObjectsSize;</span><br><span class="line">    uint8_t* const data = mData;</span><br><span class="line">    binder_size_t* const objects = mObjects;</span><br><span class="line">    while (i &gt; 0) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        const flat_binder_object* flat</span><br><span class="line">            = reinterpret_cast&lt;flat_binder_object*&gt;(data+objects[i]);</span><br><span class="line">        //见3.4.3小节</span><br><span class="line">        release_object(proc, *flat, this, &amp;mOpenAshmemSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-4-release-object"><a href="#3-4-4-release-object" class="headerlink" title="3.4.4 release_object"></a>3.4.4 release_object</h4><p>[-&gt;Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static void release_object(const sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    const flat_binder_object&amp; obj, const void* who, size_t* outAshmemSize)</span><br><span class="line">&#123;</span><br><span class="line">    switch (obj.hdr.type) &#123;</span><br><span class="line">        case BINDER_TYPE_BINDER:</span><br><span class="line">            if (obj.binder) &#123;</span><br><span class="line">                LOG_REFS(&quot;Parcel %p releasing reference on local %p&quot;, who, obj.cookie);</span><br><span class="line">                reinterpret_cast&lt;IBinder*&gt;(obj.cookie)-&gt;decStrong(who);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        case BINDER_TYPE_WEAK_BINDER:</span><br><span class="line">            if (obj.binder)</span><br><span class="line">                reinterpret_cast&lt;RefBase::weakref_type*&gt;(obj.binder)-&gt;decWeak(who);</span><br><span class="line">            return;</span><br><span class="line">        case BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">            const sp&lt;IBinder&gt; b = proc-&gt;getStrongProxyForHandle(obj.handle);</span><br><span class="line">            if (b != NULL) &#123;</span><br><span class="line">                LOG_REFS(&quot;Parcel %p releasing reference on remote %p&quot;, who, b.get());</span><br><span class="line">                b-&gt;decStrong(who);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        case BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            const wp&lt;IBinder&gt; b = proc-&gt;getWeakProxyForHandle(obj.handle);</span><br><span class="line">            if (b != NULL) b.get_refs()-&gt;decWeak(who);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        case BINDER_TYPE_FD: &#123;</span><br><span class="line">            if (obj.cookie != 0) &#123; // owned</span><br><span class="line">                if ((outAshmemSize != NULL) &amp;&amp; ashmem_valid(obj.handle)) &#123;</span><br><span class="line">                    int size = ashmem_get_size_region(obj.handle);</span><br><span class="line">                    if (size &gt; 0) &#123;</span><br><span class="line">                        *outAshmemSize -= size;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                close(obj.handle);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGE(&quot;Invalid object type 0x%08x&quot;, obj.hdr.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据flat_binder_object的类型，来减少相应的强弱引用。</p>
<h4 id="3-4-5-Parcel"><a href="#3-4-5-Parcel" class="headerlink" title="3.4.5 ~Parcel"></a>3.4.5 ~Parcel</h4><p>[-&gt;Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Parcel::~Parcel()</span><br><span class="line">&#123;</span><br><span class="line">    freeDataNoInit();</span><br><span class="line">    LOG_ALLOC(&quot;Parcel %p: destroyed&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line">void Parcel::freeDataNoInit()</span><br><span class="line">&#123;</span><br><span class="line">    if (mOwner) &#123;</span><br><span class="line">        LOG_ALLOC(&quot;Parcel %p: freeing other owner data&quot;, this);</span><br><span class="line">        //ALOGI(&quot;Freeing data ref of %p (pid=%d)&quot;, this, getpid());</span><br><span class="line">        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>执行完executeCommand方法后，会释放局部变量Parcelbuffer，则会析构Parcel。接下来，则会执行freeBuffer方法</p>
<h4 id="3-4-6-freeBuffer"><a href="#3-4-6-freeBuffer" class="headerlink" title="3.4.6  freeBuffer"></a>3.4.6  freeBuffer</h4><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::freeBuffer(Parcel* parcel, const uint8_t* data,</span><br><span class="line">                                size_t /*dataSize*/,</span><br><span class="line">                                const binder_size_t* /*objects*/,</span><br><span class="line">                                size_t /*objectsSize*/, void* /*cookie*/)</span><br><span class="line">&#123;</span><br><span class="line">    //ALOGI(&quot;Freeing parcel %p&quot;, &amp;parcel);</span><br><span class="line">    IF_LOG_COMMANDS() &#123;</span><br><span class="line">        alog &lt;&lt; &quot;Writing BC_FREE_BUFFER for &quot; &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ALOG_ASSERT(data != NULL, &quot;Called with NULL data&quot;);</span><br><span class="line">    if (parcel != NULL) parcel-&gt;closeFileDescriptors();</span><br><span class="line">    IPCThreadState* state = self();</span><br><span class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.writePointer((uintptr_t)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向binder驱动写入BC_FREE_BUFFER命令。</p>
<h3 id="3-5-BBbinder-transact"><a href="#3-5-BBbinder-transact" class="headerlink" title="3.5 BBbinder.transact"></a>3.5 BBbinder.transact</h3><p>[-&gt;binder/Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">status_t BBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    data.setDataPosition(0);</span><br><span class="line"></span><br><span class="line">    status_t err = NO_ERROR;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case PING_TRANSACTION:</span><br><span class="line">            reply-&gt;writeInt32(pingBinder());</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            //见3.5.1节</span><br><span class="line">            err = onTransact(code, data, reply, flags);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (reply != NULL) &#123;</span><br><span class="line">        reply-&gt;setDataPosition(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-1-onTransact"><a href="#3-5-1-onTransact" class="headerlink" title="3.5.1 onTransact"></a>3.5.1 onTransact</h4><p>[-&gt;android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">status_t onTransact(</span><br><span class="line">        uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) override</span><br><span class="line">    &#123;</span><br><span class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</span><br><span class="line"></span><br><span class="line">        ALOGV(&quot;onTransact() on %p calling object %p in env %p vm %p/n&quot;, this, mObject, env, mVM);</span><br><span class="line"></span><br><span class="line">        IPCThreadState* thread_state = IPCThreadState::self();</span><br><span class="line">        const int32_t strict_policy_before = thread_state-&gt;getStrictModePolicy();</span><br><span class="line"></span><br><span class="line">        //printf(&quot;Transact from %p to Java code sending: &quot;, this);</span><br><span class="line">        //data.print();</span><br><span class="line">        //printf(&quot;/n&quot;);</span><br><span class="line">        //调用Binder.execTransact方法</span><br><span class="line">        jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">            code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags);</span><br><span class="line"></span><br><span class="line">        if (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">            //发生异常，清理JNI本地引用</span><br><span class="line">            ScopedLocalRef&lt;jthrowable&gt; excep(env, env-&gt;ExceptionOccurred());</span><br><span class="line">            report_exception(env, excep.get(),</span><br><span class="line">                &quot;*** Uncaught remote exception!  &quot;</span><br><span class="line">                &quot;(Exceptions are not yet supported across processes.)&quot;);</span><br><span class="line">            res = JNI_FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if the strict mode state changed while processing the</span><br><span class="line">        // call.  The Binder state will be restored by the underlying</span><br><span class="line">        // Binder system in IPCThreadState, however we need to take care</span><br><span class="line">        // of the parallel Java state as well.</span><br><span class="line">        if (thread_state-&gt;getStrictModePolicy() != strict_policy_before) &#123;</span><br><span class="line">            set_dalvik_blockguard_policy(env, strict_policy_before);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">            //发生异常，清理JNI本地引用</span><br><span class="line">            ScopedLocalRef&lt;jthrowable&gt; excep(env, env-&gt;ExceptionOccurred());</span><br><span class="line">            report_exception(env, excep.get(),</span><br><span class="line">                &quot;*** Uncaught exception in onBinderStrictModePolicyChange&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Need to always call through the native implementation of</span><br><span class="line">        // SYSPROPS_TRANSACTION.</span><br><span class="line">        if (code == SYSPROPS_TRANSACTION) &#123;</span><br><span class="line">            BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //aout &lt;&lt; &quot;onTransact to Java code; result=&quot; &lt;&lt; res &lt;&lt; endl</span><br><span class="line">        //    &lt;&lt; &quot;Transact from &quot; &lt;&lt; this &lt;&lt; &quot; to Java code returning &quot;</span><br><span class="line">        //    &lt;&lt; reply &lt;&lt; &quot;: &quot; &lt;&lt; *reply &lt;&lt; endl;</span><br><span class="line">        return res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>mObject是在服务注册addService过程中，会调用WriteStrongBinder方法，将Binder传入JavaBBinder构造函数的参数，最终赋值给mObject。</p>
<p>gBinderOffsets在int_register_android_os_Binder函数中进行的初始化。</p>
<p>这样通过JNI的方式，从C++回到Java代码，进入IActivityManager.execTransact方法。</p>
<p>[-&gt;android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int int_register_android_os_Binder(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz = FindClassOrDie(env, kBinderPathName);</span><br><span class="line"></span><br><span class="line">    gBinderOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, &quot;execTransact&quot;, &quot;(IJJI)Z&quot;);</span><br><span class="line">    gBinderOffsets.mGetInterfaceDescriptor = GetMethodIDOrDie(env, clazz, &quot;getInterfaceDescriptor&quot;,</span><br><span class="line">        &quot;()Ljava/lang/String;&quot;);</span><br><span class="line">    gBinderOffsets.mObject = GetFieldIDOrDie(env, clazz, &quot;mObject&quot;, &quot;J&quot;);</span><br><span class="line"></span><br><span class="line">    return RegisterMethodsOrDie(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, NELEM(gBinderMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-execTransact"><a href="#3-5-2-execTransact" class="headerlink" title="3.5.2 execTransact"></a>3.5.2 execTransact</h4><p>[-&gt;Binder.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// Entry point from android_util_Binder.cpp&apos;s onTransact</span><br><span class="line"> @UnsupportedAppUsage</span><br><span class="line"> private boolean execTransact(int code, long dataObj, long replyObj,</span><br><span class="line">         int flags) &#123;</span><br><span class="line">     BinderCallsStats binderCallsStats = BinderCallsStats.getInstance();</span><br><span class="line">     BinderCallsStats.CallSession callSession = binderCallsStats.callStarted(this, code);</span><br><span class="line">     Parcel data = Parcel.obtain(dataObj);</span><br><span class="line">     Parcel reply = Parcel.obtain(replyObj);</span><br><span class="line">     // theoretically, we should call transact, which will call onTransact,</span><br><span class="line">     // but all that does is rewind it, and we just got these from an IPC,</span><br><span class="line">     // so we&apos;ll just call it directly.</span><br><span class="line">     boolean res;</span><br><span class="line">     // Log any exceptions as warnings, don&apos;t silently suppress them.</span><br><span class="line">     // If the call was FLAG_ONEWAY then these exceptions disappear into the ether.</span><br><span class="line">     final boolean tracingEnabled = Binder.isTracingEnabled();</span><br><span class="line">     try &#123;</span><br><span class="line">         if (tracingEnabled) &#123;</span><br><span class="line">             Trace.traceBegin(Trace.TRACE_TAG_ALWAYS, getClass().getName() + &quot;:&quot; + code);</span><br><span class="line">         &#125;</span><br><span class="line">         //调用子类IActivityManager的execTransact方法</span><br><span class="line">         res = onTransact(code, data, reply, flags);</span><br><span class="line">     &#125; catch (RemoteException|RuntimeException e) &#123;</span><br><span class="line">         if (LOG_RUNTIME_EXCEPTION) &#123;</span><br><span class="line">             Log.w(TAG, &quot;Caught a RuntimeException from the binder stub implementation.&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line">         if ((flags &amp; FLAG_ONEWAY) != 0) &#123;</span><br><span class="line">             if (e instanceof RemoteException) &#123;</span><br><span class="line">                 Log.w(TAG, &quot;Binder call failed.&quot;, e);</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 Log.w(TAG, &quot;Caught a RuntimeException from the binder stub implementation.&quot;, e);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             //非oneway方式，则会将异常写回reply</span><br><span class="line">             reply.setDataPosition(0);</span><br><span class="line">             reply.writeException(e);</span><br><span class="line">         &#125;</span><br><span class="line">         res = true;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         if (tracingEnabled) &#123;</span><br><span class="line">             Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     checkParcel(this, code, reply, &quot;Unreasonably large binder reply buffer&quot;);</span><br><span class="line">     reply.recycle();</span><br><span class="line">     data.recycle();</span><br><span class="line"></span><br><span class="line">     // Just in case -- we are done with the IPC, so there should be no more strict</span><br><span class="line">     // mode violations that have gathered for this thread.  Either they have been</span><br><span class="line">     // parceled and are now in transport off to the caller, or we are returning back</span><br><span class="line">     // to the main transaction loop to wait for another incoming transaction.  Either</span><br><span class="line">     // way, strict mode begone!</span><br><span class="line">     StrictMode.clearGatheredViolations();</span><br><span class="line">     binderCallsStats.callEnded(callSession);</span><br><span class="line"></span><br><span class="line">     return res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-IActivityManager-onTransact"><a href="#3-6-IActivityManager-onTransact" class="headerlink" title="3.6 IActivityManager.onTransact"></a>3.6 IActivityManager.onTransact</h3><p>[-&gt;IActivityManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  public static abstract class Stub extends android.os.Binder implements android.app.IActivityManager &#123;</span><br><span class="line">  ...</span><br><span class="line"> @Override</span><br><span class="line"> public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</span><br><span class="line">        String descriptor = DESCRIPTOR;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">           ...</span><br><span class="line">            //在2.2.5小节传过来的command</span><br><span class="line">           case TRANSACTION_bindService: &#123;</span><br><span class="line">               return this.onTransact$bindService$(data, reply);</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-onTransact-bindService"><a href="#3-7-onTransact-bindService" class="headerlink" title="3.7 onTransact$bindService$"></a>3.7 onTransact$bindService$</h3><p>[-&gt;IActivityManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private boolean onTransact$bindService$(android.os.Parcel data, android.os.Parcel reply) throws  android.os.RemoteException &#123;</span><br><span class="line">           data.enforceInterface(DESCRIPTOR);</span><br><span class="line">           android.app.IApplicationThread _arg0;</span><br><span class="line">            //获取ApplicationThread的代理对象</span><br><span class="line">           _arg0 = android.app.IApplicationThread.Stub.asInterface(data.readStrongBinder());</span><br><span class="line">           android.os.IBinder _arg1;</span><br><span class="line">           _arg1 = data.readStrongBinder();</span><br><span class="line">           android.content.Intent _arg2;</span><br><span class="line">           if ((0 != data.readInt())) &#123;</span><br><span class="line">               _arg2 = android.content.Intent.CREATOR.createFromParcel(data);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               _arg2 = null;</span><br><span class="line">           &#125;</span><br><span class="line">           String _arg3;</span><br><span class="line">           _arg3 = data.readString();</span><br><span class="line">           android.app.IServiceConnection _arg4;</span><br><span class="line">           //获取InnerConnection的代理对象</span><br><span class="line">           _arg4 = android.app.IServiceConnection.Stub.asInterface(data.readStrongBinder());</span><br><span class="line">           int _arg5;</span><br><span class="line">           _arg5 = data.readInt();</span><br><span class="line">           String _arg6;</span><br><span class="line">           _arg6 = data.readString();</span><br><span class="line">           int _arg7;</span><br><span class="line">           _arg7 = data.readInt();</span><br><span class="line">           //见3.3节，调用AMS.bindService</span><br><span class="line">           int _result = this.bindService(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7);</span><br><span class="line">           reply.writeNoException();</span><br><span class="line">           reply.writeInt(_result);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>IPC::waitForResponse对于非oneway方式，还在等待system_server这边的响应，只有收到BR_REPLY或者BR_DEAD_REPLY等其他出错的情况下，才会退出waitForResponse。</p>
<p>当bindService完成后，还需要将bindservice完成的回应消息告诉发起端的进程。在3.4节中IPC.executeCommand过程中处理完成BR_TRANSACTION命令的同时，还会通过 sendReply(reply, 0);向Binder Driver发送BC_RELY消息。这里Rely流程不再详细介绍，还是和进入之前相应的流程类似。</p>
<h3 id="3-8-AMS-bindService"><a href="#3-8-AMS-bindService" class="headerlink" title="3.8 AMS.bindService"></a>3.8 AMS.bindService</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int bindService(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">           String resolvedType, IServiceConnection connection, int flags, String callingPackage,</span><br><span class="line">           int userId) throws TransactionTooLargeException &#123;</span><br><span class="line">       enforceNotIsolatedCaller(&quot;bindService&quot;);</span><br><span class="line"></span><br><span class="line">       // Refuse possible leaked file descriptors</span><br><span class="line">       if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (callingPackage == null) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized(this) &#123;</span><br><span class="line">           //见3.9节</span><br><span class="line">           return mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                   resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-AS-bindServiceLocked"><a href="#3-9-AS-bindServiceLocked" class="headerlink" title="3.9 AS.bindServiceLocked"></a>3.9 AS.bindServiceLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">           String resolvedType, final IServiceConnection connection, int flags,</span><br><span class="line">           String callingPackage, final int userId) throws TransactionTooLargeException &#123;</span><br><span class="line">       if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;bindService: &quot; + service</span><br><span class="line">               + &quot; type=&quot; + resolvedType + &quot; conn=&quot; + connection.asBinder()</span><br><span class="line">               + &quot; flags=0x&quot; + Integer.toHexString(flags));</span><br><span class="line">       //查询发起端所对应的进程记录</span><br><span class="line">       final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">       if (callerApp == null) &#123;</span><br><span class="line">           throw new SecurityException(</span><br><span class="line">                   &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                   + &quot; (pid=&quot; + Binder.getCallingPid()</span><br><span class="line">                   + &quot;) when binding service &quot; + service);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ActivityRecord activity = null;</span><br><span class="line">       //token不为空，代表发起方具有activity的上下文</span><br><span class="line">       if (token != null) &#123;</span><br><span class="line">           activity = ActivityRecord.isInStackLocked(token);</span><br><span class="line">           if (activity == null) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Binding with unknown activity: &quot; + token);</span><br><span class="line">               return 0;  //存在token,却找不到activity为空，则直接返回</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int clientLabel = 0;</span><br><span class="line">       PendingIntent clientIntent = null;</span><br><span class="line">       final boolean isCallerSystem = callerApp.info.uid == Process.SYSTEM_UID;</span><br><span class="line">       //发起端是system进程</span><br><span class="line">       if (isCallerSystem) &#123;</span><br><span class="line">           // Hacky kind of thing -- allow system stuff to tell us</span><br><span class="line">           // what they are, so we can report this elsewhere for</span><br><span class="line">           // others to know why certain services are running.</span><br><span class="line">           service.setDefusable(true);</span><br><span class="line">           clientIntent = service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);</span><br><span class="line">           if (clientIntent != null) &#123;</span><br><span class="line">               clientLabel = service.getIntExtra(Intent.EXTRA_CLIENT_LABEL, 0);</span><br><span class="line">               if (clientLabel != 0) &#123;</span><br><span class="line">                   // There are no useful extras in the intent, trash them.</span><br><span class="line">                   // System code calling with this stuff just needs to know</span><br><span class="line">                   // this will happen.</span><br><span class="line">                   service = service.cloneFilter();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123;</span><br><span class="line">           mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,</span><br><span class="line">                   &quot;BIND_TREAT_LIKE_ACTIVITY&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //不在白名单则抛出异常</span><br><span class="line">       if ((flags &amp; Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0 &amp;&amp; !isCallerSystem) &#123;</span><br><span class="line">           throw new SecurityException(</span><br><span class="line">                   &quot;Non-system caller &quot; + caller + &quot; (pid=&quot; + Binder.getCallingPid()</span><br><span class="line">                   + &quot;) set BIND_ALLOW_WHITELIST_MANAGEMENT when binding service &quot; + service);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if ((flags &amp; Context.BIND_ALLOW_INSTANT) != 0 &amp;&amp; !isCallerSystem) &#123;</span><br><span class="line">           throw new SecurityException(</span><br><span class="line">                   &quot;Non-system caller &quot; + caller + &quot; (pid=&quot; + Binder.getCallingPid()</span><br><span class="line">                           + &quot;) set BIND_ALLOW_INSTANT when binding service &quot; + service);</span><br><span class="line">       &#125;</span><br><span class="line">       //根据发送端所在进程的SchedGroup来决定是否为前台服务</span><br><span class="line">       final boolean callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">       final boolean isBindExternal = (flags &amp; Context.BIND_EXTERNAL_SERVICE) != 0;</span><br><span class="line">       final boolean allowInstant = (flags &amp; Context.BIND_ALLOW_INSTANT) != 0;</span><br><span class="line">       //根据用户端传递进来的intent来检索对应的服务</span><br><span class="line">       ServiceLookupResult res =</span><br><span class="line">           retrieveServiceLocked(service, resolvedType, callingPackage, Binder.getCallingPid(),</span><br><span class="line">                   Binder.getCallingUid(), userId, true, callerFg, isBindExternal, allowInstant);</span><br><span class="line">       if (res == null) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       if (res.record == null) &#123;</span><br><span class="line">           return -1;</span><br><span class="line">       &#125;</span><br><span class="line">       //查询到相应的服务</span><br><span class="line">       ServiceRecord s = res.record;</span><br><span class="line"></span><br><span class="line">       boolean permissionsReviewRequired = false;</span><br><span class="line"></span><br><span class="line">       // If permissions need a review before any of the app components can run,</span><br><span class="line">       // we schedule binding to the service but do not start its process, then</span><br><span class="line">       // we launch a review activity to which is passed a callback to invoke</span><br><span class="line">       // when done to start the bound service&apos;s process to completing the binding.</span><br><span class="line">       //如果需要权限，启动activity通过callback启动服务进程</span><br><span class="line">       if (mAm.mPermissionReviewRequired) &#123;</span><br><span class="line">           if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                   s.packageName, s.userId)) &#123;</span><br><span class="line"></span><br><span class="line">               permissionsReviewRequired = true;</span><br><span class="line"></span><br><span class="line">               // Show a permission review UI only for binding from a foreground app</span><br><span class="line">               if (!callerFg) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;u&quot; + s.userId + &quot; Binding to a service in package&quot;</span><br><span class="line">                           + s.packageName + &quot; requires a permissions review&quot;);</span><br><span class="line">                   return 0;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final ServiceRecord serviceRecord = s;</span><br><span class="line">               final Intent serviceIntent = service;</span><br><span class="line"></span><br><span class="line">               RemoteCallback callback = new RemoteCallback(</span><br><span class="line">                       new RemoteCallback.OnResultListener() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public void onResult(Bundle result) &#123;</span><br><span class="line">                       synchronized(mAm) &#123;</span><br><span class="line">                           final long identity = Binder.clearCallingIdentity();</span><br><span class="line">                           try &#123;</span><br><span class="line">                               if (!mPendingServices.contains(serviceRecord)) &#123;</span><br><span class="line">                                   return;</span><br><span class="line">                               &#125;</span><br><span class="line">                               // If there is still a pending record, then the service</span><br><span class="line">                               // binding request is still valid, so hook them up. We</span><br><span class="line">                               // proceed only if the caller cleared the review requirement</span><br><span class="line">                               // otherwise we unbind because the user didn&apos;t approve.</span><br><span class="line">                               if (!mAm.getPackageManagerInternalLocked()</span><br><span class="line">                                       .isPermissionsReviewRequired(</span><br><span class="line">                                               serviceRecord.packageName,</span><br><span class="line">                                               serviceRecord.userId)) &#123;</span><br><span class="line">                                   try &#123;</span><br><span class="line">                                       bringUpServiceLocked(serviceRecord,</span><br><span class="line">                                               serviceIntent.getFlags(),</span><br><span class="line">                                               callerFg, false, false);</span><br><span class="line">                                   &#125; catch (RemoteException e) &#123;</span><br><span class="line">                                       /* ignore - local call */</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125; else &#123;</span><br><span class="line">                                   unbindServiceLocked(connection);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; finally &#123;</span><br><span class="line">                               Binder.restoreCallingIdentity(identity);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br><span class="line">               final Intent intent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line">               intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK</span><br><span class="line">                       | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">               intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName);</span><br><span class="line">               intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);</span><br><span class="line"></span><br><span class="line">               if (DEBUG_PERMISSIONS_REVIEW) &#123;</span><br><span class="line">                   Slog.i(TAG, &quot;u&quot; + s.userId + &quot; Launching permission review for package &quot;</span><br><span class="line">                           + s.packageName);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               mAm.mHandler.post(new Runnable() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public void run() &#123;</span><br><span class="line">                       //启动activity</span><br><span class="line">                       mAm.mContext.startActivityAsUser(intent, new UserHandle(userId));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final long origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           if (unscheduleServiceRestartLocked(s, callerApp.info.uid, false)) &#123;</span><br><span class="line">               if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;BIND SERVICE WHILE RESTART PENDING: &quot;</span><br><span class="line">                       + s);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123;</span><br><span class="line">               s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">               if (!s.hasAutoCreateConnections()) &#123;</span><br><span class="line">                   // This is the first binding, let the tracker know.</span><br><span class="line">                   ServiceState stracker = s.getTracker();</span><br><span class="line">                   if (stracker != null) &#123;</span><br><span class="line">                       stracker.setBound(true, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                               s.lastActivity);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mAm.startAssociationLocked(callerApp.uid, callerApp.processName, callerApp.curProcState,</span><br><span class="line">                   s.appInfo.uid, s.name, s.processName);</span><br><span class="line">           // Once the apps have become associated, if one of them is caller is ephemeral</span><br><span class="line">           // the target app should now be able to see the calling app</span><br><span class="line">           mAm.grantEphemeralAccessLocked(callerApp.userId, service,</span><br><span class="line">                   s.appInfo.uid, UserHandle.getAppId(callerApp.uid));</span><br><span class="line"></span><br><span class="line">           AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">           //创建对象ConnectionRecord，此处connection来自发起方</span><br><span class="line">           ConnectionRecord c = new ConnectionRecord(b, activity,</span><br><span class="line">                   connection, flags, clientLabel, clientIntent);</span><br><span class="line"></span><br><span class="line">           IBinder binder = connection.asBinder();</span><br><span class="line">           ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">           if (clist == null) &#123;</span><br><span class="line">               clist = new ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">               s.connections.put(binder, clist);</span><br><span class="line">           &#125;</span><br><span class="line">           //clist是ServiceRecord.connection的成员变量</span><br><span class="line">           clist.add(c);  </span><br><span class="line">           b.connections.add(c);//b是指AppBindRecord</span><br><span class="line">           if (activity != null) &#123;</span><br><span class="line">               if (activity.connections == null) &#123;</span><br><span class="line">                   activity.connections = new HashSet&lt;ConnectionRecord&gt;();</span><br><span class="line">               &#125;</span><br><span class="line">               activity.connections.add(c);</span><br><span class="line">           &#125;</span><br><span class="line">           b.client.connections.add(c);</span><br><span class="line">           if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) &#123;</span><br><span class="line">               b.client.hasAboveClient = true;</span><br><span class="line">           &#125;</span><br><span class="line">           if ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) &#123;</span><br><span class="line">               s.whitelistManager = true;</span><br><span class="line">           &#125;</span><br><span class="line">           if (s.app != null) &#123;</span><br><span class="line">               updateServiceClientActivitiesLocked(s.app, c, true);</span><br><span class="line">           &#125;</span><br><span class="line">           clist = mServiceConnections.get(binder);</span><br><span class="line">           if (clist == null) &#123;</span><br><span class="line">               clist = new ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">               mServiceConnections.put(binder, clist);</span><br><span class="line">           &#125;</span><br><span class="line">           clist.add(c);</span><br><span class="line"></span><br><span class="line">           if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123;</span><br><span class="line">               s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">               //启动service，这个过程和startService过程一致，见3.10节</span><br><span class="line">               if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,</span><br><span class="line">                       permissionsReviewRequired) != null) &#123;</span><br><span class="line">                   return 0;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (s.app != null) &#123;</span><br><span class="line">               if ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123;</span><br><span class="line">                   s.app.treatLikeActivity = true;</span><br><span class="line">               &#125;</span><br><span class="line">               if (s.whitelistManager) &#123;</span><br><span class="line">                   s.app.whitelistManager = true;</span><br><span class="line">               &#125;</span><br><span class="line">               // This could have made the service more important.</span><br><span class="line">               //更新service所在进程的优先级</span><br><span class="line">               mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities</span><br><span class="line">                       || s.app.treatLikeActivity, b.client);</span><br><span class="line">               mAm.updateOomAdjLocked(s.app, true);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Bind &quot; + s + &quot; with &quot; + b</span><br><span class="line">                   + &quot;: received=&quot; + b.intent.received</span><br><span class="line">                   + &quot; apps=&quot; + b.intent.apps.size()</span><br><span class="line">                   + &quot; doRebind=&quot; + b.intent.doRebind);</span><br><span class="line"></span><br><span class="line">           if (s.app != null &amp;&amp; b.intent.received) &#123;</span><br><span class="line">               // Service is already running, so we can immediately</span><br><span class="line">               // publish the connection.</span><br><span class="line">               try &#123;</span><br><span class="line">                   //service已经正在运行，则调用InnerConnection的代理对象，见7.1小节</span><br><span class="line">                   c.conn.connected(s.name, b.intent.binder, false);</span><br><span class="line">               &#125; catch (Exception e) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;Failure sending service &quot; + s.shortName</span><br><span class="line">                           + &quot; to connection &quot; + c.conn.asBinder()</span><br><span class="line">                           + &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // If this is the first app connected back to this binding,</span><br><span class="line">               // and the service had previously asked to be told when</span><br><span class="line">               // rebound, then do so.</span><br><span class="line">               //当第一个app连接到该binding，且之前已经被bind过，则回调onRebind方法</span><br><span class="line">               if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">                   requestServiceBindingLocked(s, b.intent, callerFg, true);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else if (!b.intent.requested) &#123;</span><br><span class="line">               //最终回调onBind方法</span><br><span class="line">               requestServiceBindingLocked(s, b.intent, callerFg, false);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);</span><br><span class="line"></span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-AS-bringUpServiceLocked"><a href="#3-10-AS-bringUpServiceLocked" class="headerlink" title="3.10 AS.bringUpServiceLocked"></a>3.10 AS.bringUpServiceLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">            boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line">        //Slog.i(TAG, &quot;Bring up service:&quot;);</span><br><span class="line">        //r.dump(&quot;  &quot;);</span><br><span class="line">        //进程已经存在的情况</span><br><span class="line">        if (r.app != null &amp;&amp; r.app.thread != null) &#123;</span><br><span class="line">            //调用onStartCommand过程</span><br><span class="line">            sendServiceArgsLocked(r, execInFg, false);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!whileRestarting &amp;&amp; mRestartingServices.contains(r)) &#123;</span><br><span class="line">            // If waiting for a restart, then do nothing.</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_SERVICE) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, &quot;Bringing up &quot; + r + &quot; &quot; + r.intent + &quot; fg=&quot; + r.fgRequired);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We are now bringing the service up, so no longer in the</span><br><span class="line">        // restarting state.</span><br><span class="line">        if (mRestartingServices.remove(r)) &#123;</span><br><span class="line">            clearRestartingIfNeededLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure this service is no longer considered delayed, we are starting it now.</span><br><span class="line">        if (r.delayed) &#123;</span><br><span class="line">            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (bring up): &quot; + r);</span><br><span class="line">            getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">            r.delayed = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that the user who owns this service is started.  If not,</span><br><span class="line">        // we don&apos;t want to allow it to run.</span><br><span class="line">        if (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">            String msg = &quot;Unable to launch app &quot;</span><br><span class="line">                    + r.appInfo.packageName + &quot;/&quot;</span><br><span class="line">                    + r.appInfo.uid + &quot; for service &quot;</span><br><span class="line">                    + r.intent.getIntent() + &quot;: user &quot; + r.userId + &quot; is stopped&quot;;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Service is now being launched, its package can&apos;t be stopped.</span><br><span class="line">        //服务正在启动，设置package停止状态为false</span><br><span class="line">        try &#123;</span><br><span class="line">            AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                    r.packageName, false, r.userId);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Failed trying to unstop package &quot;</span><br><span class="line">                    + r.packageName + &quot;: &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;</span><br><span class="line">        final String procName = r.processName;</span><br><span class="line">        String hostingType = &quot;service&quot;;</span><br><span class="line">        ProcessRecord app;</span><br><span class="line"></span><br><span class="line">        if (!isolated) &#123;</span><br><span class="line">            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);</span><br><span class="line">            if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid</span><br><span class="line">                        + &quot; app=&quot; + app);</span><br><span class="line">            if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);</span><br><span class="line">                    //启动服务，见3.11节</span><br><span class="line">                    realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If a dead object exception was thrown -- fall through to</span><br><span class="line">                // restart the application.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If this service runs in an isolated process, then each time</span><br><span class="line">            // we call startProcessLocked() we will get a new isolated</span><br><span class="line">            // process, starting another process if we are currently waiting</span><br><span class="line">            // for a previous process to come up.  To deal with this, we store</span><br><span class="line">            // in the service any current isolated process it is running in or</span><br><span class="line">            // waiting to have come up.</span><br><span class="line">            app = r.isolatedProc;</span><br><span class="line">            if (WebViewZygote.isMultiprocessEnabled()</span><br><span class="line">                    &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123;</span><br><span class="line">                hostingType = &quot;webview_service&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Not running -- get it started, and enqueue this service record</span><br><span class="line">        // to be executed when the app comes up.</span><br><span class="line">        //对于进程没有启动的情况</span><br><span class="line">        if (app == null &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">            //启动service所要运行的进程，最终会调用3.11小节</span><br><span class="line">            if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,</span><br><span class="line">                    hostingType, r.name, false, isolated, false)) == null) &#123;</span><br><span class="line">                String msg = &quot;Unable to launch app &quot;</span><br><span class="line">                        + r.appInfo.packageName + &quot;/&quot;</span><br><span class="line">                        + r.appInfo.uid + &quot; for service &quot;</span><br><span class="line">                        + r.intent.getIntent() + &quot;: process is bad&quot;;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                bringDownServiceLocked(r);</span><br><span class="line">                return msg;</span><br><span class="line">            &#125;</span><br><span class="line">            if (isolated) &#123;</span><br><span class="line">                r.isolatedProc = app;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (r.fgRequired) &#123;</span><br><span class="line">            if (DEBUG_FOREGROUND_SERVICE) &#123;</span><br><span class="line">                Slog.v(TAG, &quot;Whitelisting &quot; + UserHandle.formatUid(r.appInfo.uid)</span><br><span class="line">                        + &quot; for fg-service launch&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.tempWhitelistUidLocked(r.appInfo.uid,</span><br><span class="line">                    SERVICE_START_FOREGROUND_TIMEOUT, &quot;fg-service-launch&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mPendingServices.contains(r)) &#123;</span><br><span class="line">            mPendingServices.add(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (r.delayedStop) &#123;</span><br><span class="line">            // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">            // 要求停止服务</span><br><span class="line">            r.delayedStop = false;</span><br><span class="line">            if (r.startRequested) &#123;</span><br><span class="line">                if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                        &quot;Applying delayed stop (in bring up): &quot; + r);</span><br><span class="line">                stopServiceLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-11-AS-realStartServiceLocked"><a href="#3-11-AS-realStartServiceLocked" class="headerlink" title="3.11 AS.realStartServiceLocked"></a>3.11 AS.realStartServiceLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">           ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">       if (app.thread == null) &#123;</span><br><span class="line">           throw new RemoteException();</span><br><span class="line">       &#125;</span><br><span class="line">       if (DEBUG_MU)</span><br><span class="line">           Slog.v(TAG_MU, &quot;realStartServiceLocked, ServiceRecord.uid = &quot; + r.appInfo.uid</span><br><span class="line">                   + &quot;, ProcessRecord.uid = &quot; + app.uid);</span><br><span class="line">       r.app = app;</span><br><span class="line">       r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">       final boolean newService = app.services.add(r);</span><br><span class="line">       bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);</span><br><span class="line">       mAm.updateLruProcessLocked(app, false, null);</span><br><span class="line">       updateServiceForegroundLocked(r.app, /* oomAdj= */ false);</span><br><span class="line">       mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">       boolean created = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           if (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">               String nameTerm;</span><br><span class="line">               int lastPeriod = r.shortName.lastIndexOf(&apos;.&apos;);</span><br><span class="line">               nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">               EventLogTags.writeAmCreateService(</span><br><span class="line">                       r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">           &#125;</span><br><span class="line">           synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">               r.stats.startLaunchedLocked();</span><br><span class="line">           &#125;</span><br><span class="line">           mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                                PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">           app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">           //服务进入onCreate方法，见流程4.1小节</span><br><span class="line">           app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                   mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                   app.repProcState);</span><br><span class="line">           r.postNotification();</span><br><span class="line">           created = true;</span><br><span class="line">       &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Application dead when creating service &quot; + r);</span><br><span class="line">           mAm.appDiedLocked(app); //应用死亡</span><br><span class="line">           throw e;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (!created) &#123;</span><br><span class="line">               // Keep the executeNesting count accurate.</span><br><span class="line">               final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">               serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">               // Cleanup.</span><br><span class="line">               if (newService) &#123;</span><br><span class="line">                   app.services.remove(r);</span><br><span class="line">                   r.app = null;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Retry.</span><br><span class="line">               //尝试重新启动服务</span><br><span class="line">               if (!inDestroying) &#123;</span><br><span class="line">                   scheduleServiceRestartLocked(r, false);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (r.whitelistManager) &#123;</span><br><span class="line">           app.whitelistManager = true;</span><br><span class="line">       &#125;</span><br><span class="line">       //见流程5.1小节</span><br><span class="line">       requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">       updateServiceClientActivitiesLocked(app, null, true);</span><br><span class="line"></span><br><span class="line">       // If the service is in the started state, and there are no</span><br><span class="line">       // pending arguments, then fake up one so its onStartCommand() will</span><br><span class="line">       // be called.</span><br><span class="line">       if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;</span><br><span class="line">           r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                   null, null, 0));</span><br><span class="line">       &#125;</span><br><span class="line">       //onStartCommand</span><br><span class="line">       sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line"></span><br><span class="line">       if (r.delayed) &#123;</span><br><span class="line">           if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (new proc): &quot; + r);</span><br><span class="line">           getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">           r.delayed = false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (r.delayedStop) &#123;</span><br><span class="line">           // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">           r.delayedStop = false;</span><br><span class="line">           if (r.startRequested) &#123;</span><br><span class="line">               if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                       &quot;Applying delayed stop (from start): &quot; + r);</span><br><span class="line">               stopServiceLocked(r);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、服务端进程"><a href="#四、服务端进程" class="headerlink" title="四、服务端进程"></a>四、服务端进程</h2><h3 id="4-1-AT-scheduleCreateService"><a href="#4-1-AT-scheduleCreateService" class="headerlink" title="4.1 AT.scheduleCreateService"></a>4.1 AT.scheduleCreateService</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleCreateService(IBinder token,</span><br><span class="line">               ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">           updateProcessState(processState, false);</span><br><span class="line">           //准备服务创建所需要的数据</span><br><span class="line">           CreateServiceData s = new CreateServiceData();</span><br><span class="line">           s.token = token;</span><br><span class="line">           s.info = info;</span><br><span class="line">           s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">           sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过handler机制，发送消息给服务端进程的主线程的handler处理。</p>
<h3 id="4-2-AT-handleMessage"><a href="#4-2-AT-handleMessage" class="headerlink" title="4.2 AT.handleMessage"></a>4.2 AT.handleMessage</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">      if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">          switch (msg.what) &#123;</span><br><span class="line">              case CREATE_SERVICE:</span><br><span class="line">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">                  //见4.3小节</span><br><span class="line">                  handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                  break;</span><br><span class="line">                  ....</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-AT-handleCreateService"><a href="#4-3-AT-handleCreateService" class="headerlink" title="4.3 AT.handleCreateService"></a>4.3 AT.handleCreateService</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">       // If we are getting ready to gc after going to the background, well</span><br><span class="line">       // we are back active so skip it.</span><br><span class="line">       //当应用处于后台即将进行gc,而此时被调回到活动，则此时跳过本次gc</span><br><span class="line">       unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">       LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">               data.info.applicationInfo, data.compatInfo);</span><br><span class="line">       Service service = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           //通过反射创建目标服务对象</span><br><span class="line">           java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">           service = packageInfo.getAppFactory()</span><br><span class="line">                   .instantiateService(cl, data.info.name, data.intent);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">               throw new RuntimeException(</span><br><span class="line">                   &quot;Unable to instantiate service &quot; + data.info.name</span><br><span class="line">                   + &quot;: &quot; + e.toString(), e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</span><br><span class="line">           //创建ContextImpl对象</span><br><span class="line">           ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</span><br><span class="line">           context.setOuterContext(service);</span><br><span class="line">           //创建Application对象</span><br><span class="line">           Application app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">           service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                   ActivityManager.getService());</span><br><span class="line">           //调用服务的onCreate方法</span><br><span class="line">           service.onCreate();</span><br><span class="line">           mServices.put(data.token, service);</span><br><span class="line">           try &#123;</span><br><span class="line">               //调用服务创建完成</span><br><span class="line">               ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                       data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">           &#125; catch (RemoteException e) &#123;</span><br><span class="line">               throw e.rethrowFromSystemServer();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">               throw new RuntimeException(</span><br><span class="line">                   &quot;Unable to create service &quot; + data.info.name</span><br><span class="line">                   + &quot;: &quot; + e.toString(), e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>前面3.11中realStartServiceLocked过程，执行完成scheduleCreateService操作后，接下来，继续回到system_server进程，开始执行requestServiceBindingsLocked过程。</p>
<h2 id="五、system-server进程"><a href="#五、system-server进程" class="headerlink" title="五、system_server进程"></a>五、system_server进程</h2><h3 id="5-1-AS-requestServiceBindingsLocked"><a href="#5-1-AS-requestServiceBindingsLocked" class="headerlink" title="5.1 AS.requestServiceBindingsLocked"></a>5.1 AS.requestServiceBindingsLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private final void requestServiceBindingsLocked(ServiceRecord r, boolean execInFg)</span><br><span class="line">           throws TransactionTooLargeException &#123;</span><br><span class="line">       for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">           IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">           if (!requestServiceBindingLocked(r, ibr, execInFg, false)) &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过bindService方式启动服务，那么ServiceRecord的bindings肯定不会为空。</p>
<h3 id="5-2-AS-requestServiceBindingLocked"><a href="#5-2-AS-requestServiceBindingLocked" class="headerlink" title="5.2 AS.requestServiceBindingLocked"></a>5.2 AS.requestServiceBindingLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">            boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;</span><br><span class="line">        if (r.app == null || r.app.thread == null) &#123;</span><br><span class="line">            // If service is not currently running, can&apos;t yet bind.</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (DEBUG_SERVICE) Slog.d(TAG_SERVICE, &quot;requestBind &quot; + i + &quot;: requested=&quot; + i.requested</span><br><span class="line">                + &quot; rebind=&quot; + rebind);</span><br><span class="line">        if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               //发送bind开始的消息</span><br><span class="line">                bumpServiceExecutingLocked(r, execInFg, &quot;bind&quot;);</span><br><span class="line">                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">                //服务进入onBind流程，见流程6.1小节</span><br><span class="line">                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                        r.app.repProcState);</span><br><span class="line">                if (!rebind) &#123;</span><br><span class="line">                    i.requested = true;</span><br><span class="line">                &#125;</span><br><span class="line">                i.hasBound = true;</span><br><span class="line">                i.doRebind = false;</span><br><span class="line">            &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">                // Keep the executeNesting count accurate.</span><br><span class="line">                if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while binding &quot; + r, e);</span><br><span class="line">                final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">                serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while binding &quot; + r);</span><br><span class="line">                // Keep the executeNesting count accurate.</span><br><span class="line">                final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">                serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>scheduleBindService通过Binder代理的方式，调用AT的scheduleBindService，其代理对象由IApplicationThread.aidl生成和AMS类似。</p>
<h2 id="六、服务端进程"><a href="#六、服务端进程" class="headerlink" title="六、服务端进程"></a>六、服务端进程</h2><h3 id="6-1-AT-scheduleBindService"><a href="#6-1-AT-scheduleBindService" class="headerlink" title="6.1 AT.scheduleBindService"></a>6.1 AT.scheduleBindService</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleBindService(IBinder token, Intent intent,</span><br><span class="line">             boolean rebind, int processState) &#123;</span><br><span class="line">         updateProcessState(processState, false);</span><br><span class="line">         BindServiceData s = new BindServiceData();</span><br><span class="line">         s.token = token;</span><br><span class="line">         s.intent = intent;</span><br><span class="line">         s.rebind = rebind;</span><br><span class="line"></span><br><span class="line">         if (DEBUG_SERVICE)</span><br><span class="line">             Slog.v(TAG, &quot;scheduleBindService token=&quot; + token + &quot; intent=&quot; + intent + &quot; uid=&quot;</span><br><span class="line">                     + Binder.getCallingUid() + &quot; pid=&quot; + Binder.getCallingPid());</span><br><span class="line">         sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>发送消息到服务端进程的主线程处理。</p>
<h3 id="6-2-AT-handleMessage"><a href="#6-2-AT-handleMessage" class="headerlink" title="6.2 AT.handleMessage"></a>6.2 AT.handleMessage</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">          if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">          switch (msg.what) &#123;</span><br><span class="line">             ...</span><br><span class="line">              case BIND_SERVICE:</span><br><span class="line">                  //见6.3小节</span><br><span class="line">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceBind&quot;);</span><br><span class="line">                  handleBindService((BindServiceData)msg.obj);</span><br><span class="line">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                  break;</span><br><span class="line">               ...</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-AT-handleBindService"><a href="#6-3-AT-handleBindService" class="headerlink" title="6.3 AT.handleBindService"></a>6.3 AT.handleBindService</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindService(BindServiceData data) &#123;</span><br><span class="line">       Service s = mServices.get(data.token);</span><br><span class="line">       if (DEBUG_SERVICE)</span><br><span class="line">           Slog.v(TAG, &quot;handleBindService s=&quot; + s + &quot; rebind=&quot; + data.rebind);</span><br><span class="line">       if (s != null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">               data.intent.prepareToEnterProcess();</span><br><span class="line">               try &#123;</span><br><span class="line">                   if (!data.rebind) &#123;</span><br><span class="line">                       //执行onBind回调方法</span><br><span class="line">                       IBinder binder = s.onBind(data.intent);</span><br><span class="line">                       //将onBind回来的对象传递回去，见流程6.4小节</span><br><span class="line">                       ActivityManager.getService().publishService(</span><br><span class="line">                               data.token, data.intent, binder);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                      //执行onRebind方法</span><br><span class="line">                       s.onRebind(data.intent);</span><br><span class="line">                       ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                               data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                   throw ex.rethrowFromSystemServer();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                   throw new RuntimeException(</span><br><span class="line">                           &quot;Unable to bind to service &quot; + s</span><br><span class="line">                           + &quot; with &quot; + data.intent + &quot;: &quot; + e.toString(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>经过Binder IPC进入到system_server进程，并将binder传回到system_server进程。</p>
<h2 id="七、system-server进程"><a href="#七、system-server进程" class="headerlink" title="七、system_server进程"></a>七、system_server进程</h2><h3 id="7-1-AMS-publishService"><a href="#7-1-AMS-publishService" class="headerlink" title="7.1 AMS.publishService"></a>7.1 AMS.publishService</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void publishService(IBinder token, Intent intent, IBinder service) &#123;</span><br><span class="line">       // Refuse possible leaked file descriptors</span><br><span class="line">       if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized(this) &#123;</span><br><span class="line">           if (!(token instanceof ServiceRecord)) &#123;</span><br><span class="line">               throw new IllegalArgumentException(&quot;Invalid service token&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>服务端的onBind返回的binder对象，在经过writeStrongBinder传递到底层，再回到system_server进程，经过readStrongBinder获取代理对象。</p>
<h3 id="7-2-AMS-publishServiceLocked"><a href="#7-2-AMS-publishServiceLocked" class="headerlink" title="7.2 AMS.publishServiceLocked"></a>7.2 AMS.publishServiceLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123;</span><br><span class="line">       final long origId = Binder.clearCallingIdentity();</span><br><span class="line">       try &#123;</span><br><span class="line">           if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;PUBLISHING &quot; + r</span><br><span class="line">                   + &quot; &quot; + intent + &quot;: &quot; + service);</span><br><span class="line">           if (r != null) &#123;</span><br><span class="line">               Intent.FilterComparison filter</span><br><span class="line">                       = new Intent.FilterComparison(intent);</span><br><span class="line">               IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">               if (b != null &amp;&amp; !b.received) &#123;</span><br><span class="line">                   b.binder = service;</span><br><span class="line">                   b.requested = true;</span><br><span class="line">                   b.received = true;</span><br><span class="line">                   for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123;</span><br><span class="line">                       ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                       for (int i=0; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                           ConnectionRecord c = clist.get(i);</span><br><span class="line">                           if (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                               if (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                       TAG_SERVICE, &quot;Not publishing to: &quot; + c);</span><br><span class="line">                               if (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                       TAG_SERVICE, &quot;Bound intent: &quot; + c.binding.intent.intent);</span><br><span class="line">                               if (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                       TAG_SERVICE, &quot;Published intent: &quot; + intent);</span><br><span class="line">                               continue;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Publishing to: &quot; + c);</span><br><span class="line">                           try &#123;</span><br><span class="line">                               //见流程8.1</span><br><span class="line">                               c.conn.connected(r.name, service, false);</span><br><span class="line">                           &#125; catch (Exception e) &#123;</span><br><span class="line">                               Slog.w(TAG, &quot;Failure sending service &quot; + r.name +</span><br><span class="line">                                     &quot; to connection &quot; + c.conn.asBinder() +</span><br><span class="line">                                     &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>c.conn是指客户端进程的IServiceConnection.Stub.Proxy代理对象，通过BinderIPC调用，进入客户端的IServiceConnection.Stub对象，回到客户端进程中的InnerConnection对象。</p>
<h2 id="八、客户端进程"><a href="#八、客户端进程" class="headerlink" title="八、客户端进程"></a>八、客户端进程</h2><h3 id="8-1-InnerConnection-connected"><a href="#8-1-InnerConnection-connected" class="headerlink" title="8.1  InnerConnection.connected"></a>8.1  InnerConnection.connected</h3><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static class InnerConnection extends IServiceConnection.Stub &#123;</span><br><span class="line">            @UnsupportedAppUsage</span><br><span class="line">            final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">            InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">                mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void connected(ComponentName name, IBinder service, boolean dead)</span><br><span class="line">                    throws RemoteException &#123;</span><br><span class="line">                LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">                if (sd != null) &#123;</span><br><span class="line">                    //见流程8.2</span><br><span class="line">                    sd.connected(name, service, dead);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-SD-connected"><a href="#8-2-SD-connected" class="headerlink" title="8.2  SD.connected"></a>8.2  SD.connected</h3><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void connected(ComponentName name, IBinder service, boolean dead) &#123;</span><br><span class="line">          if (mActivityThread != null) &#123;</span><br><span class="line">              //这里是主线程的handler</span><br><span class="line">              mActivityThread.post(new RunConnection(name, service, 0, dead));</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              doConnected(name, service, dead);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-new-RunConnection"><a href="#8-3-new-RunConnection" class="headerlink" title="8.3  new RunConnection"></a>8.3  new RunConnection</h3><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final class RunConnection implements Runnable &#123;</span><br><span class="line">          RunConnection(ComponentName name, IBinder service, int command, boolean dead) &#123;</span><br><span class="line">              mName = name;</span><br><span class="line">              mService = service;</span><br><span class="line">              mCommand = command;  //此时为0</span><br><span class="line">              mDead = dead;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          public void run() &#123;</span><br><span class="line">              if (mCommand == 0) &#123;</span><br><span class="line">                  //见流程8.4小节</span><br><span class="line">                  doConnected(mName, mService, mDead);</span><br><span class="line">              &#125; else if (mCommand == 1) &#123;</span><br><span class="line">                  doDeath(mName, mService);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final ComponentName mName;</span><br><span class="line">          final IBinder mService; //onBinder返回的代理对象</span><br><span class="line">          final int mCommand;</span><br><span class="line">          final boolean mDead;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-doConnected"><a href="#8-4-doConnected" class="headerlink" title="8.4 doConnected"></a>8.4 doConnected</h3><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public void doConnected(ComponentName name, IBinder service, boolean dead) &#123;</span><br><span class="line">           ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">           ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               if (mForgotten) &#123;</span><br><span class="line">                   // We unbound before receiving the connection; ignore</span><br><span class="line">                   // any connection received.</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               old = mActiveConnections.get(name);</span><br><span class="line">               if (old != null &amp;&amp; old.binder == service) &#123;</span><br><span class="line">                   // Huh, already have this one.  Oh well!</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (service != null) &#123;</span><br><span class="line">                   // A new service is being connected... set it all up.</span><br><span class="line">                   info = new ConnectionInfo();</span><br><span class="line">                   info.binder = service;</span><br><span class="line">                   //创建死亡监听对象</span><br><span class="line">                   info.deathMonitor = new DeathMonitor(name, service);</span><br><span class="line">                   try &#123;</span><br><span class="line">                       //建立死亡通知</span><br><span class="line">                       service.linkToDeath(info.deathMonitor, 0);</span><br><span class="line">                       mActiveConnections.put(name, info);</span><br><span class="line">                   &#125; catch (RemoteException e) &#123;</span><br><span class="line">                       // This service was dead before we got it...  just</span><br><span class="line">                       // don&apos;t do anything with it.</span><br><span class="line">                       mActiveConnections.remove(name);</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // The named service is being disconnected... clean up.</span><br><span class="line">                   mActiveConnections.remove(name);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (old != null) &#123;</span><br><span class="line">                   old.binder.unlinkToDeath(old.deathMonitor, 0);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // If there was an old service, it is now disconnected.</span><br><span class="line">           if (old != null) &#123;</span><br><span class="line">               mConnection.onServiceDisconnected(name);</span><br><span class="line">           &#125;</span><br><span class="line">           if (dead) &#123;</span><br><span class="line">               mConnection.onBindingDied(name);</span><br><span class="line">           &#125;</span><br><span class="line">           // If there is a new viable service, it is now connected.</span><br><span class="line">           if (service != null) &#123;</span><br><span class="line">               //回调用户自定义的ServiceConnected对象方法</span><br><span class="line">               mConnection.onServiceConnected(name, service);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // The binding machinery worked, but the remote returned null from onBind().</span><br><span class="line">               mConnection.onNullBinding(name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><h3 id="9-1-通信流程"><a href="#9-1-通信流程" class="headerlink" title="9.1 通信流程"></a>9.1 通信流程</h3><p>1.发起端线程向Binder驱动发起binder_ioctl请求后，waitForResponse进入while循环，不断进行talkWithDriver,此时该线程处理阻塞状态，直到收到BR_XX命令才会结束该过程。</p>
<ul>
<li>BR_TRANSACTION_COMPLETE: oneway模式下,收到该命令则退出；</li>
<li>BR_DEAD_REPLY: 目标进程/线程/binder实体为空, 以及释放正在等待reply的binder thread或者binder buffer;</li>
<li>BR_FAILED_REPLY: 情况较多,比如非法handle, 错误事务栈, security, 内存不足, buffer不足, 数据拷贝失败, 节点创建失败, 各种不匹配等问题；</li>
<li>BR_ACQUIRE_RESULT: 目前未使用的协议;</li>
<li>BR_REPLY: 非oneway模式下,收到该命令才退出;</li>
</ul>
<p>2.waitForResponse收到BR_TRANSACTION_COMPLETE，则直接退出循环，不会执行executeCommand方法，除上述五种BR_XXX命令，当收到其他BR命令，则会执行executeCommand方法。</p>
<p>3.目标Binder线程创建之后，便进入joinThreadPool方法，不断循环执行getAndExecuteCommand方法，当bwr的读写buffer没有数据时，则阻塞在binder_thread_read的wait_event过程。正常情况下binder线程一旦创建就不会退出。</p>
<p><img src="/2020/深入理解Binder机制4-bindService过程分析/bindservice_cm_frame.PNG" alt="bindservice_cm_frame" style="zoom:80%;"></p>
<h3 id="9-2-通信协议"><a href="#9-2-通信协议" class="headerlink" title="9.2 通信协议"></a>9.2 通信协议</h3><p>1.Binder客户端和服务端向Binder驱动发送的命令都是以BC_开头，Binder驱动向服务端或客户端发送的命令都是以 BR _开头；</p>
<p>2.只有当BC_TRANSACTION或BC_REPLY时，才会调用binder_transaction来处理事务，并且都会回应调用者BINDER_WORK_TRANSACTION_COMPLETE，经过binder_thread_read转变成BR_TRANSACTION_COMPLETE；</p>
<p>3.bindServie是一个非oneway过程，oneway过程没有BC_REPLY。</p>
<p><img src="/2020/深入理解Binder机制4-bindService过程分析/binderservice_cm_pro.PNG" alt="binderservice_cm_pro" style="zoom:75%;"></p>
<h3 id="9-3-数据流"><a href="#9-3-数据流" class="headerlink" title="9.3 数据流"></a>9.3 数据流</h3><p><strong>用户空间</strong>（下面一些方法在<a href="https://skytoby.github.io/2020/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder%E6%9C%BA%E5%88%B62-%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1addService/" target="_blank" rel="noopener">addservice</a>篇中介绍）</p>
<p>1.bindService：组装flat_binder_object等对象组成Parcel data;</p>
<p>2.IPC.writeTransactionData：组装BC_TRANSACTION和binder_transaction_data结构体，写入mOut;</p>
<p>3.IPC.talkWithDriver：组装BINDER_WRITE_READ和binder_writer_read结构体，通过ioctl传输到驱动层。</p>
<p><strong>进入驱动后</strong></p>
<p>4.binder_thread_write:处理binder_write_read.write_buffer数据</p>
<p>5.binder_transaction:处理write_buffer.binder_transaction_data数据</p>
<ul>
<li>创建binder_transaction结构体，记录事务通信的线程来源以及事务链条等相关信息；</li>
<li>分配binder_buffer结构体，拷贝当前线程binder_transaction_data的data数据到binder_buffer-&gt;data;</li>
</ul>
<p>6.binder_thread_read:处理binder_transaction结构体数据</p>
<ul>
<li>组装cmd= BR_TRANSACTION和binder_transaction_data结构体，写入binder_write_read.read_buffer数据。</li>
</ul>
<p><strong>回到用户空间</strong></p>
<p>7.IPC.executeCommand:处理BR_TRANSACIOTN命令，将binder_transaction_data数据解析成BBinder.transact所需的参数</p>
<p>8.onTransact:层层回调，进入该方法，反序列化数据后，调用bindService方法。</p>
<p><img src="/2020/深入理解Binder机制4-bindService过程分析/bindservice_data.png" alt="bindservice_data"></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>源码路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line">frameworks/base/core/java/android/app/LoadedApk.java</span><br><span class="line">frameworks/base/core/java/android/app/ActivityManager.java</span><br><span class="line">frameworks/base/core/java/android/os/Binder.java</span><br><span class="line">frameworks/base/core/java/android/os/BinderProxy.java</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span><br><span class="line">frameworks/base/core/java/android/os/Binder.java</span><br><span class="line">frameworks/base/core/jni/android_util_Binder.cpp</span><br><span class="line"></span><br><span class="line">native/libs/binder/ProcessState.cpp</span><br><span class="line">native/libs/binder/Parcel.cpp</span><br><span class="line">native/libs/binder/IPCThreadState.cpp</span><br><span class="line">native/libs/binder/Binder.cpp</span><br></pre></td></tr></table></figure>
      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Binder机制/" rel="tag">#Binder机制</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/深入理解Binder机制3-获取服务getService/" rel="next" title="深入理解Binder机制3-获取服务getService">
                <i class="fa fa-chevron-left"></i> 深入理解Binder机制3-获取服务getService
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/深入理解Binder机制5-binder驱动分析/" rel="prev" title="深入理解Binder机制5-binder驱动分析">
                深入理解Binder机制5-binder驱动分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Binder架构"><span class="nav-text">1.1 Binder架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Binder-IPC原理"><span class="nav-text">1.2 Binder IPC原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-bindService流程"><span class="nav-text">1.3 bindService流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、客户端进程"><span class="nav-text">二、客户端进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-CL-bindService"><span class="nav-text">2.1 CL.bindService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-CL-bindServiceCommon"><span class="nav-text">2.2 CL.bindServiceCommon</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-getServiceDispatcher"><span class="nav-text">2.2.1 getServiceDispatcher</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-ServiceDispatcher"><span class="nav-text">2.2.2 ServiceDispatcher</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-AM-getService"><span class="nav-text">2.2.3 AM.getService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-asInterface"><span class="nav-text">2.2.4 asInterface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-创建Proxy"><span class="nav-text">2.2.5 创建Proxy</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、system-server进程"><span class="nav-text">三、system_server进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-onZygoteInit"><span class="nav-text">3.1 onZygoteInit()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-startThreadPool"><span class="nav-text">3.1.1  startThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-spawnPooledThread"><span class="nav-text">3.1.2  spawnPooledThread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-new-PoolThread"><span class="nav-text">3.1.3  new PoolThread</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-joinThreadPool"><span class="nav-text">3.2 joinThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-IPC-getAndExecuteCommand"><span class="nav-text">3.3 IPC.getAndExecuteCommand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-IPC-executeCommand"><span class="nav-text">3.4 IPC.executeCommand</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-ipcSetDataReference"><span class="nav-text">3.4.1 ipcSetDataReference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-freeDataNoInit"><span class="nav-text">3.4.2 freeDataNoInit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-releaseObjects"><span class="nav-text">3.4.3 releaseObjects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-release-object"><span class="nav-text">3.4.4 release_object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-Parcel"><span class="nav-text">3.4.5 ~Parcel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-freeBuffer"><span class="nav-text">3.4.6  freeBuffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-BBbinder-transact"><span class="nav-text">3.5 BBbinder.transact</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-onTransact"><span class="nav-text">3.5.1 onTransact</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-execTransact"><span class="nav-text">3.5.2 execTransact</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-IActivityManager-onTransact"><span class="nav-text">3.6 IActivityManager.onTransact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-onTransact-bindService"><span class="nav-text">3.7 onTransact$bindService$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-AMS-bindService"><span class="nav-text">3.8 AMS.bindService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-AS-bindServiceLocked"><span class="nav-text">3.9 AS.bindServiceLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-AS-bringUpServiceLocked"><span class="nav-text">3.10 AS.bringUpServiceLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-AS-realStartServiceLocked"><span class="nav-text">3.11 AS.realStartServiceLocked</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、服务端进程"><span class="nav-text">四、服务端进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-AT-scheduleCreateService"><span class="nav-text">4.1 AT.scheduleCreateService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-AT-handleMessage"><span class="nav-text">4.2 AT.handleMessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-AT-handleCreateService"><span class="nav-text">4.3 AT.handleCreateService</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、system-server进程"><span class="nav-text">五、system_server进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-AS-requestServiceBindingsLocked"><span class="nav-text">5.1 AS.requestServiceBindingsLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-AS-requestServiceBindingLocked"><span class="nav-text">5.2 AS.requestServiceBindingLocked</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、服务端进程"><span class="nav-text">六、服务端进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-AT-scheduleBindService"><span class="nav-text">6.1 AT.scheduleBindService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-AT-handleMessage"><span class="nav-text">6.2 AT.handleMessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-AT-handleBindService"><span class="nav-text">6.3 AT.handleBindService</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、system-server进程"><span class="nav-text">七、system_server进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-AMS-publishService"><span class="nav-text">7.1 AMS.publishService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-AMS-publishServiceLocked"><span class="nav-text">7.2 AMS.publishServiceLocked</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、客户端进程"><span class="nav-text">八、客户端进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-InnerConnection-connected"><span class="nav-text">8.1  InnerConnection.connected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-SD-connected"><span class="nav-text">8.2  SD.connected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-new-RunConnection"><span class="nav-text">8.3  new RunConnection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-doConnected"><span class="nav-text">8.4 doConnected</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、总结"><span class="nav-text">九、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-通信流程"><span class="nav-text">9.1 通信流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-通信协议"><span class="nav-text">9.2 通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-数据流"><span class="nav-text">9.3 数据流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2020/深入理解Binder机制4-bindService过程分析/';
      var disqus_title = "深入理解Binder机制4-bindService过程分析";
      var disqus_url = 'http://zproo.github.io/2020/深入理解Binder机制4-bindService过程分析/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
