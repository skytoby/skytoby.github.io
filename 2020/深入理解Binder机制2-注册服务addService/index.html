<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Binder机制,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="一、概述本文将分析系统服务的注册流程，如注册ActivityManagerService时，通过ServiceManager中的静态方法addService注册具体的服务。ServiceManger是Binder IPC通信过程中的守护进程，是一个具体的服务，其功能主要是查询和注册服务。 二、ServiceManager启动ServiceManager是由init进程通过servicemanage">
<meta name="keywords" content="Binder机制">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Binder机制2-注册服务addService">
<meta property="og:url" content="http://zproo.github.io/2020/深入理解Binder机制2-注册服务addService/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="一、概述本文将分析系统服务的注册流程，如注册ActivityManagerService时，通过ServiceManager中的静态方法addService注册具体的服务。ServiceManger是Binder IPC通信过程中的守护进程，是一个具体的服务，其功能主要是查询和注册服务。 二、ServiceManager启动ServiceManager是由init进程通过servicemanage">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2020/深入理解Binder机制2-注册服务addService/binder_addservice.PNG">
<meta property="og:updated_time" content="2020-05-11T04:06:38.384Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Binder机制2-注册服务addService">
<meta name="twitter:description" content="一、概述本文将分析系统服务的注册流程，如注册ActivityManagerService时，通过ServiceManager中的静态方法addService注册具体的服务。ServiceManger是Binder IPC通信过程中的守护进程，是一个具体的服务，其功能主要是查询和注册服务。 二、ServiceManager启动ServiceManager是由init进程通过servicemanage">
<meta name="twitter:image" content="http://zproo.github.io/2020/深入理解Binder机制2-注册服务addService/binder_addservice.PNG">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2020/深入理解Binder机制2-注册服务addService/">

  <title> 深入理解Binder机制2-注册服务addService | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/Binder机制/" rel="tag" title="Binder机制">Binder机制</a>
      
      </div>
      <h1>深入理解Binder机制2-注册服务addService</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2020-01-10T22:28:28+08:00" content="2020-01-10" title="2020-01-10 22:28:28">
          2020-01-10
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解Binder机制2-注册服务addService
              
            
          </h1>
        

        <div class="post-meta">
		  

          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-01-10T22:28:28+08:00" content="2020-01-10">
              2020-01-10
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/深入理解Binder机制2-注册服务addService/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/深入理解Binder机制2-注册服务addService/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>本文将分析系统服务的注册流程，如注册ActivityManagerService时，通过ServiceManager中的静态方法addService注册具体的服务。ServiceManger是Binder IPC通信过程中的守护进程，是一个具体的服务，其功能主要是查询和注册服务。</p>
<h2 id="二、ServiceManager启动"><a href="#二、ServiceManager启动" class="headerlink" title="二、ServiceManager启动"></a>二、ServiceManager启动</h2><p>ServiceManager是由init进程通过servicemanager.rc文件而创建，其所在的可执行文件在system/bin/servicemanager，对应的源文件是service_manager.c。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    class core animation</span><br><span class="line">    user system</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>
<p>启动ServiceManager的入口时文件中的main方法.</p>
<h3 id="2-1-mian"><a href="#2-1-mian" class="headerlink" title="2.1 mian"></a>2.1 mian</h3><p>[-&gt;service_manager.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_state *bs;</span><br><span class="line">    union selinux_callback cb;</span><br><span class="line">    char *driver;</span><br><span class="line"></span><br><span class="line">    if (argc &gt; 1) &#123;</span><br><span class="line">        driver = argv[1];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        driver = &quot;/dev/binder&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //见2.2节，打开binder驱动，申请128K字节大小的内存空间</span><br><span class="line">    bs = binder_open(driver, 128*1024);</span><br><span class="line">    if (!bs) &#123;</span><br><span class="line">#ifdef VENDORSERVICEMANAGER</span><br><span class="line">        ALOGW(&quot;failed to open binder driver %s/n&quot;, driver);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            sleep(UINT_MAX);</span><br><span class="line">        &#125;</span><br><span class="line">#else</span><br><span class="line">        ALOGE(&quot;failed to open binder driver %s/n&quot;, driver);</span><br><span class="line">#endif</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //见2.3节，成为上下文管理者</span><br><span class="line">    if (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(&quot;cannot become context manager (%s)/n&quot;, strerror(errno));</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb.func_audit = audit_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line">    cb.func_log = selinux_log_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line">#ifdef VENDORSERVICEMANAGER</span><br><span class="line">    sehandle = selinux_android_vendor_service_context_handle();</span><br><span class="line">#else</span><br><span class="line">    sehandle = selinux_android_service_context_handle();</span><br><span class="line">#endif</span><br><span class="line">    selinux_status_open(true);</span><br><span class="line"></span><br><span class="line">    if (sehandle == NULL) &#123;</span><br><span class="line">        ALOGE(&quot;SELinux: Failed to acquire sehandle. Aborting./n&quot;);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (getcon(&amp;service_manager_context) != 0) &#123;</span><br><span class="line">        ALOGE(&quot;SELinux: Failed to acquire service_manager context. Aborting./n&quot;);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //见2.4节，进入无限循环，处理client发送过来的消息</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-binder-open"><a href="#2-2-binder-open" class="headerlink" title="2.2 binder_open"></a>2.2 binder_open</h3><p>[-&gt;servicemanager/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">struct binder_state *binder_open(const char* driver, size_t mapsize)</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_state *bs;</span><br><span class="line">    struct binder_version vers;</span><br><span class="line"></span><br><span class="line">    bs = malloc(sizeof(*bs));</span><br><span class="line">    if (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过系统调用陷入内核，打开Binder设备驱动</span><br><span class="line">    bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (bs-&gt;fd &lt; 0) &#123;</span><br><span class="line">        fprintf(stderr,&quot;binder: cannot open %s (%s)/n&quot;,</span><br><span class="line">                driver, strerror(errno));</span><br><span class="line">        goto fail_open;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过系统调用，ioctl获取binder版本信息</span><br><span class="line">    if ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) == -1) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123;</span><br><span class="line">        fprintf(stderr,</span><br><span class="line">                &quot;binder: kernel driver version (%d) differs from user space version (%d)/n&quot;,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        goto fail_open; //内核空间与用户空间的binder版本不是同一个版本</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    //通过系统调用，mmap内存映射，必须是page的整数倍</span><br><span class="line">    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);</span><br><span class="line">    if (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        fprintf(stderr,&quot;binder: cannot map device (%s)/n&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        goto fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    free(bs);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>调用open打开binder驱动设备，open方法经过系统调用，进入binder驱动，然后调用binder_open方法，该方法会在binder驱动层创建一个binder_proc对象，再将binder_proc对象赋值给fd-&gt;private_data，同时放入全局链表binder_procs。</p>
</li>
<li><p>再通过ioctl检查当前binder版本与binder驱动层的版本是否一致。</p>
</li>
<li><p>调用mmap进行内存映射，通过系统调用，对应于binder驱动层的binder_mmap方法，该方法会在binder驱动层创建Binder_buffer对象，并放入当前的binder_proc的proc-&gt;buffers链表。</p>
</li>
</ul>
<h3 id="2-3-binder-become-context-manager"><a href="#2-3-binder-become-context-manager" class="headerlink" title="2.3 binder_become_context_manager"></a>2.3 binder_become_context_manager</h3><p>[-&gt;servicemanager/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int binder_become_context_manager(struct binder_state *bs)</span><br><span class="line">&#123;</span><br><span class="line">    return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成为上下文管理者，整个系统只有一个这样的管理者，经过系统调用binder驱动层的binder_ioctl方法。</p>
<h3 id="2-4-binder-loop"><a href="#2-4-binder-loop" class="headerlink" title="2.4 binder_loop"></a>2.4 binder_loop</h3><p>[-&gt;servicemanager/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void binder_loop(struct binder_state *bs, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    int res;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line">    uint32_t readbuf[32];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = 0;</span><br><span class="line">    bwr.write_consumed = 0;</span><br><span class="line">    bwr.write_buffer = 0;</span><br><span class="line"></span><br><span class="line">    readbuf[0] = BC_ENTER_LOOPER;</span><br><span class="line">    //将BC_ENTER_LOOPER，发送给binder驱动，让ServiceManger进入循环</span><br><span class="line">    binder_write(bs, readbuf, sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        bwr.read_size = sizeof(readbuf);</span><br><span class="line">        bwr.read_consumed = 0;</span><br><span class="line">        bwr.read_buffer = (uintptr_t) readbuf;</span><br><span class="line">        //进入循环，不断的binder读写</span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: ioctl failed (%s)/n&quot;, strerror(errno));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        //解析binder信息</span><br><span class="line">        res = binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func);</span><br><span class="line">        if (res == 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: unexpected reply?!/n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: io error %d %s/n&quot;, res, strerror(errno));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入循环读写操作，main方法传递过来的参数fun指向svcmgr_handler。</p>
<h2 id="三、注册服务"><a href="#三、注册服务" class="headerlink" title="三、注册服务"></a>三、注册服务</h2><p>ServiceManager.addService(String name, IBinder service)过程</p>
<h3 id="3-1-SM-addService"><a href="#3-1-SM-addService" class="headerlink" title="3.1 SM.addService"></a>3.1 SM.addService</h3><p>[-&gt;ServiceManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void addService(String name, IBinder service) &#123;</span><br><span class="line">    addService(name, service, false, IServiceManager.DUMP_FLAG_PRIORITY_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void addService(String name, IBinder service, boolean allowIsolated,</span><br><span class="line">        int dumpPriority) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        getIServiceManager().addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-getIServiceManager"><a href="#3-2-getIServiceManager" class="headerlink" title="3.2  getIServiceManager"></a>3.2  getIServiceManager</h3><p>[-&gt;ServiceManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">       if (sServiceManager != null) &#123;</span><br><span class="line">           return sServiceManager;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Find the service manager</span><br><span class="line">       sServiceManager = ServiceManagerNative</span><br><span class="line">               .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</span><br><span class="line">       return sServiceManager;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    public static final native IBinder getContextObject();</span><br></pre></td></tr></table></figure>
<p>getContextObject通过Native方式调用。</p>
<h4 id="3-2-1-Binder-allowBlocking"><a href="#3-2-1-Binder-allowBlocking" class="headerlink" title="3.2.1 Binder.allowBlocking"></a>3.2.1 Binder.allowBlocking</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static IBinder allowBlocking(IBinder binder) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           //是BinderProxy类</span><br><span class="line">           if (binder instanceof BinderProxy) &#123;</span><br><span class="line">               ((BinderProxy) binder).mWarnOnBlocking = false;</span><br><span class="line">           &#125; else if (binder != null &amp;&amp; binder.getInterfaceDescriptor() != null</span><br><span class="line">                   &amp;&amp; binder.queryLocalInterface(binder.getInterfaceDescriptor()) == null) &#123;</span><br><span class="line">               Log.w(TAG, &quot;Unable to allow blocking on interface &quot; + binder);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (RemoteException ignored) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">       return binder;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法用来判断IBinder类，根据不同情况添加标志，具体可见3.7节</p>
<h4 id="3-2-2-getContextObject"><a href="#3-2-2-getContextObject" class="headerlink" title="3.2.2 getContextObject"></a>3.2.2 getContextObject</h4><p>[-&gt;android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    return javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-1-ProcessState-self"><a href="#3-2-2-1-ProcessState-self" class="headerlink" title="3.2.2.1 ProcessState::self"></a>3.2.2.1 ProcessState::self</h5><p>[-&gt;ProcessState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    if (gProcess != NULL) &#123;</span><br><span class="line">        return gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建ProcessState对象</span><br><span class="line">    gProcess = new ProcessState(&quot;/dev/binder&quot;);</span><br><span class="line">    return gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式创建ProcessState对象，其初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState(const char *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver)) //打开驱动</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(0)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(0)</span><br><span class="line">    , mManagesContexts(false)</span><br><span class="line">    , mBinderContextCheckFunc(NULL)</span><br><span class="line">    , mBinderContextUserData(NULL)</span><br><span class="line">    , mThreadPoolStarted(false)</span><br><span class="line">    , mThreadPoolSeq(1)</span><br><span class="line">&#123;</span><br><span class="line">    if (mDriverFD &gt;= 0) &#123;</span><br><span class="line">        // mmap the binder, providing a chunk of virtual address space to receive transactions.</span><br><span class="line">        // 采用内存映射函数，给binder分配一块虚拟内存空间，用来接收事务</span><br><span class="line">        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);</span><br><span class="line">        if (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            // *sigh*</span><br><span class="line">            ALOGE(&quot;Using %s failed: unable to mmap transaction memory./n&quot;, mDriverName.c_str());</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD = -1;</span><br><span class="line">            mDriverName.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, &quot;Binder driver could not be opened.  Terminating.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessState一个进程只打开一个binder设置一次，其中mDriverFD，记录binder驱动的fd，用于访问binder设置；</p>
<p>BINDER_VM_SIZE = 1 <em> 1024 </em> 1024 - 4096 * 2)，binder分配的内存大小为1M-8K；</p>
<p>DEFAULT_MAX_BINDER_THREADS =15，binder默认最大可并发访问的线程数为16。</p>
<p>打开驱动的过程如下，这里就只介绍到这里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static int open_driver(const char *driver)</span><br><span class="line">&#123;</span><br><span class="line">    //打开/dev/binder设置</span><br><span class="line">    int fd = open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (fd &gt;= 0) &#123;</span><br><span class="line">        int vers = 0;</span><br><span class="line">        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            ALOGE(&quot;Binder ioctl to obtain version failed: %s&quot;, strerror(errno));</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          ALOGE(&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //设定最大的binder支持的最大线程数</span><br><span class="line">        size_t maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        //通过ioctl设置binder驱动</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            ALOGE(&quot;Binder ioctl to set max threads failed: %s&quot;, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGW(&quot;Opening &apos;%s&apos; failed: %s/n&quot;, driver, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-2-PS-getContextObject"><a href="#3-2-2-2-PS-getContextObject" class="headerlink" title="3.2.2.2  PS.getContextObject"></a>3.2.2.2  PS.getContextObject</h5><p>[-&gt;ProcessState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)</span><br><span class="line">&#123;</span><br><span class="line">    return getStrongProxyForHandle(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-3-PS-getStrongProxyForHandle"><a href="#3-2-2-3-PS-getStrongProxyForHandle" class="headerlink" title="3.2.2.3 PS.getStrongProxyForHandle"></a>3.2.2.3 PS.getStrongProxyForHandle</h5><p>[-&gt;ProcessState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    //查找handle对应的资源项</span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e != NULL) &#123;</span><br><span class="line">        // We need to create a new BpBinder if there isn&apos;t currently one, OR we</span><br><span class="line">        // are unable to acquire a weak reference on this current one.  See comment</span><br><span class="line">        // in getWeakProxyForHandle() for more info about this.</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            if (handle == 0) &#123;</span><br><span class="line">                // Special case for context manager...</span><br><span class="line">                // The context manager is the only object for which we create</span><br><span class="line">                // a BpBinder proxy without already holding a reference.</span><br><span class="line">                // Perform a dummy transaction to ensure the context manager</span><br><span class="line">                // is registered before we create the first local reference</span><br><span class="line">                // to it (which will occur when creating the BpBinder).</span><br><span class="line">                // If a local reference is created for the BpBinder when the</span><br><span class="line">                // context manager is not present, the driver will fail to</span><br><span class="line">                // provide a reference to the context manager, but the</span><br><span class="line">                // driver API does not return status.</span><br><span class="line">                //</span><br><span class="line">                // Note that this is not race-free if the context manager</span><br><span class="line">                // dies while this code runs.</span><br><span class="line">                //</span><br><span class="line">                // TODO: add a driver API to wait for context manager, or</span><br><span class="line">                // stop special casing handle 0 for context manager and add</span><br><span class="line">                // a driver API to get a handle to the context manager with</span><br><span class="line">                // proper reference counting.</span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        0, IBinder::PING_TRANSACTION, data, NULL, 0);</span><br><span class="line">                if (status == DEAD_OBJECT)</span><br><span class="line">                   return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            //创建BpBinder</span><br><span class="line">            b = BpBinder::create(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            if (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // This little bit of nastyness is to allow us to add a primary</span><br><span class="line">            // reference to the remote proxy when this team doesn&apos;t have one</span><br><span class="line">            // but another team is sending the handle to us.</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当handler值所对应的Binder不存在或弱引用无效时会创建BpBinder，否则直接获取。对应handler等于0的情况，通过PING_TRANSACTION来判断是否准备就绪。如果context manager还未生效前，一个BpBinder的本地已经被创建，那么驱动将无法提供context manager的引用。</p>
<h4 id="3-2-3-javaObjectForIBinder"><a href="#3-2-3-javaObjectForIBinder" class="headerlink" title="3.2.3 javaObjectForIBinder"></a>3.2.3 javaObjectForIBinder</h4><p>[-&gt;android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    if (val == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        // It&apos;s a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span><br><span class="line">        jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        LOGDEATH(&quot;objectForBinder %p: it&apos;s our own %p!/n&quot;, val.get(), object);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // For the rest of the function we will hold this lock, to serialize</span><br><span class="line">    // looking/creation/destruction of Java proxies for native Binder proxies.</span><br><span class="line">    AutoMutex _l(gProxyLock);</span><br><span class="line"></span><br><span class="line">    BinderProxyNativeData* nativeData = gNativeDataCache;</span><br><span class="line">    if (nativeData == nullptr) &#123;</span><br><span class="line">        nativeData = new BinderProxyNativeData();</span><br><span class="line">    &#125;</span><br><span class="line">    // gNativeDataCache is now logically empty.</span><br><span class="line">    //创建BinderProxy对象</span><br><span class="line">    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());</span><br><span class="line">    if (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        // In the exception case, getInstance still took ownership of nativeData.</span><br><span class="line">        gNativeDataCache = nullptr;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);</span><br><span class="line">    if (actualNativeData == nativeData) &#123;</span><br><span class="line">        // New BinderProxy; we still have exclusive access.</span><br><span class="line">        nativeData-&gt;mOrgue = new DeathRecipientList;</span><br><span class="line">        nativeData-&gt;mObject = val;</span><br><span class="line">        gNativeDataCache = nullptr;</span><br><span class="line">        ++gNumProxies;</span><br><span class="line">        if (gNumProxies &gt;= gProxiesWarned + PROXY_WARN_INTERVAL) &#123;</span><br><span class="line">            ALOGW(&quot;Unexpectedly many live BinderProxies: %d/n&quot;, gNumProxies);</span><br><span class="line">            gProxiesWarned = gNumProxies;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // nativeData wasn&apos;t used. Reuse it the next time.</span><br><span class="line">        gNativeDataCache = nativeData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据BpBinder（C++）创建BinderProxy（java）对象，主要工作是创建BinderProxy对象。</p>
<p>ServiceManagerNative.asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));相当于</p>
<p>ServiceManagerNative.asInterface(new BinderProxy())</p>
<h3 id="3-3-SMN-asInterface"><a href="#3-3-SMN-asInterface" class="headerlink" title="3.3 SMN.asInterface"></a>3.3 SMN.asInterface</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">   &#123;</span><br><span class="line">       if (obj == null) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       //由于obj为</span><br><span class="line">       IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">       if (in != null) &#123;</span><br><span class="line">           return in;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return new ServiceManagerProxy(obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>由3.2节可知ServiceManagerNative.asInterface(new BinderProxy()),等价于</p>
<p>new ServiceManagerProxy(new BinderProxy());</p>
<h4 id="3-3-1-ServiceManagerProxy"><a href="#3-3-1-ServiceManagerProxy" class="headerlink" title="3.3.1 ServiceManagerProxy"></a>3.3.1 ServiceManagerProxy</h4><p>[-&gt;ServiceManagerNative::ServiceManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mRemote为BinderProxy对象</strong>，该对象对应于BpBinder(0)，作为binder代理类，执行native层ServiceManager</p>
<p> getIServiceManager()等价于new ServiceManagerProxy(new BinderProxy());</p>
<p> getIServiceManager().addService等价于ServiceManagerProxy.addService</p>
<p>framework层的ServiceManager的调用实际交给了ServiceManagerProxy成员变量BinderProxy，而BinderProxy通过JNI方式，最终调用的BpBinder对象，可以看出binder架构的核心功能依赖于native架构的服务来完成。</p>
<h3 id="3-4-SMP-addService"><a href="#3-4-SMP-addService" class="headerlink" title="3.4 SMP.addService"></a>3.4 SMP.addService</h3><p>[-&gt;ServiceManagerNative::ServiceManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority)</span><br><span class="line">        throws RemoteException &#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">    data.writeString(name);</span><br><span class="line">    //见3.5节</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    data.writeInt(allowIsolated ? 1 : 0);</span><br><span class="line">    data.writeInt(dumpPriority);</span><br><span class="line">    //见3.7节</span><br><span class="line">    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-writeStrongBinder-Java"><a href="#3-5-writeStrongBinder-Java" class="headerlink" title="3.5 writeStrongBinder(Java)"></a>3.5 writeStrongBinder(Java)</h3><p>[-&gt;Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void writeStrongBinder(IBinder val) &#123;</span><br><span class="line">    //native调用</span><br><span class="line">    nativeWriteStrongBinder(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-1-android-os-Parcel-writeStrongBinder"><a href="#3-5-1-android-os-Parcel-writeStrongBinder" class="headerlink" title="3.5.1 android_os_Parcel_writeStrongBinder"></a>3.5.1 android_os_Parcel_writeStrongBinder</h4><p>[-&gt;android_os_Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span><br><span class="line">&#123;</span><br><span class="line">    //将java层的Parce转换为native层的Parcel</span><br><span class="line">    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    if (parcel != NULL) &#123;</span><br><span class="line">        const status_t err = parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object));</span><br><span class="line">        if (err != NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nativePtr为native层创建Parcel对象后返回的指针地址。</p>
<h4 id="3-5-2-ibinderForJavaObject"><a href="#3-5-2-ibinderForJavaObject" class="headerlink" title="3.5.2 ibinderForJavaObject"></a>3.5.2 ibinderForJavaObject</h4><p>[-&gt;android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    // Instance of Binder?</span><br><span class="line">    // java层Binder对象？</span><br><span class="line">    if (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;GetLongField(obj, gBinderOffsets.mObject);</span><br><span class="line">        return jbh-&gt;get(env, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Instance of BinderProxy?</span><br><span class="line">    //java层的BinderProxy对象</span><br><span class="line">    if (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        return getBPNativeData(env, obj)-&gt;mObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGW(&quot;ibinderForJavaObject: %p is not a Binder object&quot;, obj);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据Binder(Java)生成JavaBBinderHolder(C++)对象，并把JavaBBinderHolder对象地址保存到Binder.mObject成员变量</p>
<p>如果是BinderProxy(Java)返回的是Binder Native代理BpBinder。</p>
<h4 id="3-5-3-JavaBBinderHolder"><a href="#3-5-3-JavaBBinderHolder" class="headerlink" title="3.5.3 JavaBBinderHolder"></a>3.5.3 JavaBBinderHolder</h4><p>[-&gt;android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class JavaBBinderHolder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    sp&lt;JavaBBinder&gt; get(JNIEnv* env, jobject obj)</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        sp&lt;JavaBBinder&gt; b = mBinder.promote();</span><br><span class="line">        if (b == NULL) &#123;</span><br><span class="line">            //创建JavaBBinder对象</span><br><span class="line">            b = new JavaBBinder(env, obj);</span><br><span class="line">            mBinder = b;</span><br><span class="line">            ALOGV(&quot;Creating JavaBinder %p (refs %p) for Object %p, weakCount=%&quot; PRId32 &quot;/n&quot;,</span><br><span class="line">                 b.get(), b-&gt;getWeakRefs(), obj, b-&gt;getWeakRefs()-&gt;getWeakCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;JavaBBinder&gt; getExisting()</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        return mBinder.promote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Mutex           mLock;</span><br><span class="line">    wp&lt;JavaBBinder&gt; mBinder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-4-new-JavaBBinder"><a href="#3-5-4-new-JavaBBinder" class="headerlink" title="3.5.4 new JavaBBinder"></a>3.5.4 new JavaBBinder</h4><p>[-&gt;android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class JavaBBinder : public BBinder</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">    JavaBBinder(JNIEnv* env, jobject /* Java Binder */ object)</span><br><span class="line">        : mVM(jnienv_to_javavm(env)), mObject(env-&gt;NewGlobalRef(object))</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGV(&quot;Creating JavaBBinder %p/n&quot;, this);</span><br><span class="line">        gNumLocalRefsCreated.fetch_add(1, std::memory_order_relaxed);</span><br><span class="line">        gcIfManyNewRefs(env);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool    checkSubclass(const void* subclassID) const</span><br><span class="line">    &#123;</span><br><span class="line">        return subclassID == &amp;gBinderOffsets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobject object() const</span><br><span class="line">    &#123;</span><br><span class="line">        return mObject;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>创建JavaBBinder，该类继承于BBinder， data.writeStrongBinder(service);等价于parcel-&gt;writeStrongBinder(new JavaBBinder(env, obj))</p>
<h3 id="3-6-writeStrongBinder-C"><a href="#3-6-writeStrongBinder-C" class="headerlink" title="3.6 writeStrongBinder(C++)"></a>3.6 writeStrongBinder(C++)</h3><p>[-&gt;Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    return flatten_binder(ProcessState::self(), val, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-1-flatten-binder"><a href="#3-6-1-flatten-binder" class="headerlink" title="3.6.1 flatten_binder"></a>3.6.1 flatten_binder</h4><p>[-&gt;Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; /*proc*/,</span><br><span class="line">    const sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    if (IPCThreadState::self()-&gt;backgroundSchedulingDisabled()) &#123;</span><br><span class="line">        /* minimum priority for all nodes is nice 0 */</span><br><span class="line">        obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* minimum priority for all nodes is MAX_NICE(19) */</span><br><span class="line">        obj.flags = 0x13 | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (binder != NULL) &#123;</span><br><span class="line">        IBinder *local = binder-&gt;localBinder();</span><br><span class="line">        if (!local) &#123; //远程Binder</span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            if (proxy == NULL) &#123;</span><br><span class="line">                ALOGE(&quot;null proxy&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            const int32_t handle = proxy ? proxy-&gt;handle() : 0;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = 0; /* Don&apos;t pass uninitialized stack data to a remote process */</span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = 0;</span><br><span class="line">        &#125; else &#123;  //本地Binder</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie = reinterpret_cast&lt;uintptr_t&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = 0;</span><br><span class="line">        obj.cookie = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是将Binder对象扁平化，转换成flat_binder_object。</p>
<p>对于Binder实体，cookie记录Binder实体的指针</p>
<p>对于Binder代理，则用handle记录Binder代理的句柄。</p>
<h4 id="3-6-2-finish-flatten-binder"><a href="#3-6-2-finish-flatten-binder" class="headerlink" title="3.6.2 finish_flatten_binder"></a>3.6.2 finish_flatten_binder</h4><p>[-&gt;Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline static status_t finish_flatten_binder(</span><br><span class="line">    const sp&lt;IBinder&gt;&amp; /*binder*/, const flat_binder_object&amp; flat, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    return out-&gt;writeObject(flat, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到3.4的addService过程，则进入transact过程</p>
<h3 id="3-7-BP-transact"><a href="#3-7-BP-transact" class="headerlink" title="3.7 BP.transact"></a>3.7 BP.transact</h3><p>[-&gt;BinderProxy.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">       Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line"></span><br><span class="line">       if (mWarnOnBlocking &amp;&amp; ((flags &amp; FLAG_ONEWAY) == 0)) &#123;</span><br><span class="line">           // For now, avoid spamming the log by disabling after we&apos;ve logged</span><br><span class="line">           // about this interface at least once</span><br><span class="line">           mWarnOnBlocking = false;</span><br><span class="line">           Log.w(Binder.TAG, &quot;Outgoing transactions from this process must be FLAG_ONEWAY&quot;,</span><br><span class="line">                   new Throwable());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final boolean tracingEnabled = Binder.isTracingEnabled();</span><br><span class="line">       if (tracingEnabled) &#123;</span><br><span class="line">           final Throwable tr = new Throwable();</span><br><span class="line">           Binder.getTransactionTracker().addTrace(tr);</span><br><span class="line">           StackTraceElement stackTraceElement = tr.getStackTrace()[1];</span><br><span class="line">           Trace.traceBegin(Trace.TRACE_TAG_ALWAYS,</span><br><span class="line">                   stackTraceElement.getClassName() + &quot;.&quot; + stackTraceElement.getMethodName());</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           //native层调用</span><br><span class="line">           return transactNative(code, data, reply, flags);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (tracingEnabled) &#123;</span><br><span class="line">               Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-android-os-BinderProxy-transact"><a href="#3-8-android-os-BinderProxy-transact" class="headerlink" title="3.8  android_os_BinderProxy_transact"></a>3.8  android_os_BinderProxy_transact</h3><p>[-&gt;android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,</span><br><span class="line">        jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    if (dataObj == NULL) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, NULL);</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //将java parcel转换为native parcel</span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj);</span><br><span class="line">    if (data == NULL) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj);</span><br><span class="line">    if (reply == NULL &amp;&amp; replyObj != NULL) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //获取binder native代理</span><br><span class="line">    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get();</span><br><span class="line">    if (target == NULL) &#123;</span><br><span class="line">        jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Binder has been finalized!&quot;);</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;Java code calling transact on %p in Java object %p with code %&quot; PRId32 &quot;/n&quot;,</span><br><span class="line">            target, obj, code);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool time_binder_calls;</span><br><span class="line">    int64_t start_millis;</span><br><span class="line">    if (kEnableBinderSample) &#123;</span><br><span class="line">        // Only log the binder call duration for things on the Java-level main thread.</span><br><span class="line">        // But if we don&apos;t</span><br><span class="line">        time_binder_calls = should_time_binder_calls();</span><br><span class="line"></span><br><span class="line">        if (time_binder_calls) &#123;</span><br><span class="line">            start_millis = uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //printf(&quot;Transact from Java code to %p sending: &quot;, target); data-&gt;print();</span><br><span class="line">    //相当于BpBinder.transact</span><br><span class="line">    status_t err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    //if (reply) printf(&quot;Transact from Java code to %p received: &quot;, target); reply-&gt;print();</span><br><span class="line"></span><br><span class="line">    if (kEnableBinderSample) &#123;</span><br><span class="line">        if (time_binder_calls) &#123;</span><br><span class="line">            conditionally_log_binder_call(start_millis, target, code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        return JNI_TRUE;</span><br><span class="line">    &#125; else if (err == UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-&gt;dataSize());</span><br><span class="line">    return JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-BpBinder-transact"><a href="#3-9-BpBinder-transact" class="headerlink" title="3.9 BpBinder::transact"></a>3.9 BpBinder::transact</h3><p>[-&gt;BpBinder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // Once a binder has died, it will never come back to life.</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        //见3.10节</span><br><span class="line">        status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status == DEAD_OBJECT) mAlive = 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-9-1-BpBinder-transact"><a href="#3-9-1-BpBinder-transact" class="headerlink" title="3.9.1 BpBinder::transact"></a>3.9.1 BpBinder::transact</h4><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    if (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        const pthread_key_t k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        if (st) return st;</span><br><span class="line">        return new IPCThreadState; //创建IPCThreadState，见3.9.2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (gShutdown) &#123;</span><br><span class="line">        ALOGW(&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash./n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加锁</span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    if (!gHaveTLS) &#123;</span><br><span class="line">        //创建线程TLS</span><br><span class="line">        int key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        if (key_create_value != 0) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s/n&quot;,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //释放锁</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    goto restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TLS(Thread local storage),线程本地存储空间，每个线程都有自己私有的TLS,线程之间不能共享。</p>
<p>pthread_setspecific/pthread_getspecific可以设置和获取这些空间中的内容。</p>
<h4 id="3-9-2-new-IPCThreadState"><a href="#3-9-2-new-IPCThreadState" class="headerlink" title="3.9.2 new IPCThreadState"></a>3.9.2 new IPCThreadState</h4><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(0),</span><br><span class="line">      mLastTransactionBinderFlags(0)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, this);</span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(256);</span><br><span class="line">    mOut.setDataCapacity(256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个线程都有一个IPCThreadState，每个IPCThreadState都有一个mIn，mOut，成员变量mProcess保存了ProcessState变量，每个进程只有一个。</p>
<p>mInt用来接收来自Binder设备的数据，默认大小事256</p>
<p>mOut用来存储发往Binder设备的数据，默认大小事256</p>
<h3 id="3-10-IPC-transact"><a href="#3-10-IPC-transact" class="headerlink" title="3.10 IPC::transact"></a>3.10 IPC::transact</h3><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, const Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        alog &lt;&lt; &quot;BC_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / hand &quot;</span><br><span class="line">            &lt;&lt; handle &lt;&lt; &quot; / code &quot; &lt;&lt; TypeCode(code) &lt;&lt; &quot;: &quot;</span><br><span class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),</span><br><span class="line">        (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);</span><br><span class="line">    //传输数据，见3.11    </span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span><br><span class="line"></span><br><span class="line">    if (err != NO_ERROR) &#123;</span><br><span class="line">        //错误则返回</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        return (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; TF_ONE_WAY) == 0) &#123;</span><br><span class="line">        #if 0</span><br><span class="line">        if (code == 4) &#123; // relayout</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            //等待回应</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        #if 0</span><br><span class="line">        if (code == 4) &#123; // relayout</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; &quot;BR_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / hand &quot;</span><br><span class="line">                &lt;&lt; handle &lt;&lt; &quot;: &quot;;</span><br><span class="line">            if (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            else alog &lt;&lt; &quot;(none requested)&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //oneway，不需要等待reply的场景</span><br><span class="line">        err = waitForResponse(NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transact主要工作：</p>
<ul>
<li><p>errorCheck错误检查</p>
</li>
<li><p>writeTransactionData传输数据</p>
</li>
<li><p>waitForResponse等待响应</p>
</li>
</ul>
<h3 id="3-11-IPC-writeTransactionData"><a href="#3-11-IPC-writeTransactionData" class="headerlink" title="3.11  IPC::writeTransactionData"></a>3.11  IPC::writeTransactionData</h3><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</span><br><span class="line">    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = 0; /* Don&apos;t pass uninitialized stack data to a remote process */</span><br><span class="line">    tr.target.handle = handle;  //handle = 0</span><br><span class="line">    tr.code = code;             //code = ADD_SERVICE_TRANSACTION</span><br><span class="line">    tr.flags = binderFlags;     // binderFlags = 0</span><br><span class="line">    tr.cookie = 0;</span><br><span class="line">    tr.sender_pid = 0;</span><br><span class="line">    tr.sender_euid = 0;</span><br><span class="line"></span><br><span class="line">    //data记录服务的Parcel对象</span><br><span class="line">    const status_t err = data.errorCheck();</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; else if (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = sizeof(status_t);</span><br><span class="line">        tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = 0;</span><br><span class="line">        tr.data.ptr.offsets = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, sizeof(tr));</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handler对象用来标记目的端，注册服务的目的端为ServiceManager,这里handle = 0所对应的是binder实体对象。</p>
<p>binder_transaction_data是binder驱动通信的数据结构，该过程吧Binder请求码BC_TRANSACTION和binder_transaction_data结构体写入mOut，写完后执行waitForResponse方法。</p>
<p>binder_transaction_data中重要的成员变量</p>
<ul>
<li><p>data_size，binder_transaction的数据大小</p>
</li>
<li><p>data.ptr.buffer，binder_transaction数据的起始地址</p>
</li>
<li><p>offsets_size，记录flat_binder_object结构体的个数</p>
</li>
<li><p>data.ptr.offsets，记录flat_binder_object结构体的数据偏移量</p>
</li>
</ul>
<h3 id="3-12-IPC-waitForResponse"><a href="#3-12-IPC-waitForResponse" class="headerlink" title="3.12 IPC::waitForResponse"></a>3.12 IPC::waitForResponse</h3><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        //见3.13小节</span><br><span class="line">        if ((err=talkWithDriver()) &lt; NO_ERROR) break;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        if (err &lt; NO_ERROR) break;</span><br><span class="line">        if (mIn.dataAvail() == 0) continue;</span><br><span class="line"></span><br><span class="line">        cmd = (uint32_t)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Processing waitForResponse Command: &quot;</span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            if (!reply &amp;&amp; !acquireResult) goto finish;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_FAILED_REPLY:</span><br><span class="line">            err = FAILED_TRANSACTION;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_ACQUIRE_RESULT:</span><br><span class="line">            &#123;</span><br><span class="line">                ALOG_ASSERT(acquireResult != NULL, &quot;Unexpected brACQUIRE_RESULT&quot;);</span><br><span class="line">                const int32_t result = mIn.readInt32();</span><br><span class="line">                if (!acquireResult) continue;</span><br><span class="line">                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;);</span><br><span class="line">                if (err != NO_ERROR) goto finish;</span><br><span class="line"></span><br><span class="line">                if (reply) &#123;</span><br><span class="line">                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/sizeof(binder_size_t),</span><br><span class="line">                            freeBuffer, this);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(NULL,</span><br><span class="line">                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/sizeof(binder_size_t), this);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    freeBuffer(NULL,</span><br><span class="line">                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/sizeof(binder_size_t), this);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            if (err != NO_ERROR) goto finish;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    if (err != NO_ERROR) &#123;</span><br><span class="line">        if (acquireResult) *acquireResult = err;</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>talkWithDriver过程是和binder驱动通信过程，Binder驱动收到BC_TRANSACTION后，会回应BR_TRANSACTION_COMPLETE,然后等待目标进程的BR_REPLY.</p>
<h3 id="3-13-IPC-talkWithDriver"><a href="#3-13-IPC-talkWithDriver" class="headerlink" title="3.13 IPC::talkWithDriver"></a>3.13 IPC::talkWithDriver</h3><p>[-&gt;IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::talkWithDriver(bool doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    if (mProcess-&gt;mDriverFD &lt;= 0) &#123;</span><br><span class="line">        return -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    // Is the read buffer empty?</span><br><span class="line">    // 读缓冲是否为空</span><br><span class="line">    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    // We don&apos;t want to write anything if we are still reading</span><br><span class="line">    // from data left in the input buffer and the caller</span><br><span class="line">    // has requested to read the next data.</span><br><span class="line">    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (uintptr_t)mOut.data();</span><br><span class="line"></span><br><span class="line">    // This is what we&apos;ll read.</span><br><span class="line">    if (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        //接收数据缓冲区信息，如果收到数据，就直接填在mInt中</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (uintptr_t)mIn.data();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        bwr.read_size = 0;</span><br><span class="line">        bwr.read_buffer = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IF_LOG_COMMANDS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        if (outAvail != 0) &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Sending commands to driver: &quot; &lt;&lt; indent;</span><br><span class="line">            const void* cmds = (const void*)bwr.write_buffer;</span><br><span class="line">            const void* end = ((const uint8_t*)cmds)+bwr.write_size;</span><br><span class="line">            alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;</span><br><span class="line">            while (cmds &lt; end) cmds = printCommand(alog, cmds);</span><br><span class="line">            alog &lt;&lt; dedent;</span><br><span class="line">        &#125;</span><br><span class="line">        alog &lt;&lt; &quot;Size of receive buffer: &quot; &lt;&lt; bwr.read_size</span><br><span class="line">            &lt;&lt; &quot;, needRead: &quot; &lt;&lt; needRead &lt;&lt; &quot;, doReceive: &quot; &lt;&lt; doReceive &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Return immediately if there is nothing to do.</span><br><span class="line">    //读缓冲和写缓冲为空，直接返回</span><br><span class="line">    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;</span><br><span class="line"></span><br><span class="line">    //先清零</span><br><span class="line">    bwr.write_consumed = 0;</span><br><span class="line">    bwr.read_consumed = 0;</span><br><span class="line">    status_t err;</span><br><span class="line">    do &#123;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;About to read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">#if defined(__ANDROID__)</span><br><span class="line">        //通过ioctl和Binder Driver进行通信，进行读写操作</span><br><span class="line">        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        else</span><br><span class="line">            err = -errno;</span><br><span class="line">#else</span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line">#endif</span><br><span class="line">        if (mProcess-&gt;mDriverFD &lt;= 0) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Finished read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (err == -EINTR); //当被中断，则继续执行</span><br><span class="line"></span><br><span class="line">    IF_LOG_COMMANDS() &#123;</span><br><span class="line">        alog &lt;&lt; &quot;Our err: &quot; &lt;&lt; (void*)(intptr_t)err &lt;&lt; &quot;, write consumed: &quot;</span><br><span class="line">            &lt;&lt; bwr.write_consumed &lt;&lt; &quot; (of &quot; &lt;&lt; mOut.dataSize()</span><br><span class="line">                        &lt;&lt; &quot;), read consumed: &quot; &lt;&lt; bwr.read_consumed &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        if (bwr.write_consumed &gt; 0) &#123;</span><br><span class="line">            //写的数据大于0</span><br><span class="line">            if (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                mOut.remove(0, bwr.write_consumed);</span><br><span class="line">            else &#123;</span><br><span class="line">                mOut.setDataSize(0);</span><br><span class="line">                //清除引用</span><br><span class="line">                processPostWriteDerefs();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bwr.read_consumed &gt; 0) &#123;</span><br><span class="line">            //读取的数据大于0，设置mIn数据大小和将指针位置置为开始位置</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; &quot;Remaining data size: &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;</span><br><span class="line">            alog &lt;&lt; &quot;Received commands from driver: &quot; &lt;&lt; indent;</span><br><span class="line">            const void* cmds = mIn.data();</span><br><span class="line">            const void* end = mIn.data() + mIn.dataSize();</span><br><span class="line">            alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;</span><br><span class="line">            while (cmds &lt; end) cmds = printReturnCommand(alog, cmds);</span><br><span class="line">            alog &lt;&lt; dedent;</span><br><span class="line">        &#125;</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder_write_read结构体用来与Binder驱动进行数据交换，通过ioctl与mDriverFD通信，主要操作的是mInt和mOut.</p>
<p>ioctl通过系统调用进入到Binder Driver。</p>
<h2 id="四、Binder-Driver"><a href="#四、Binder-Driver" class="headerlink" title="四、Binder Driver"></a>四、Binder Driver</h2><p>用户态的程序调用Kernel层驱动需陷入内核态，进行系统调用（syscall），其定义在kernel/include/linux/syscalls.h文件中</p>
<p>打开Binder驱动方法调用流程：ioctl-&gt;__ioctl-&gt;binder_ioctl，ioctl为用户空间的方法，</p>
<p>__ioctl是系统调用中相应的处理方法，通过查找找到内核binder驱动的binder_ioctl的方法。</p>
<p>上面传过来的是BINDER_WRITE_READ命令</p>
<h3 id="4-1-binder-ioctl"><a href="#4-1-binder-ioctl" class="headerlink" title="4.1 binder_ioctl"></a>4.1 binder_ioctl</h3><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;  //binder进程</span><br><span class="line">	struct binder_thread *thread;      //binder线程</span><br><span class="line">	unsigned int size = _IOC_SIZE(cmd);</span><br><span class="line">	void __user *ubuf = (void __user *)arg;</span><br><span class="line"></span><br><span class="line">	/*pr_info(&quot;binder_ioctl: %d:%d %x %lx/n&quot;,</span><br><span class="line">			proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span><br><span class="line"></span><br><span class="line">	binder_selftest_alloc(&amp;proc-&gt;alloc);</span><br><span class="line"></span><br><span class="line">	trace_binder_ioctl(cmd, arg);</span><br><span class="line">    //进入休眠状态，直到中断唤醒</span><br><span class="line">	ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto err_unlocked;</span><br><span class="line">    //获取binder_thread，见4.1.1节</span><br><span class="line">	thread = binder_get_thread(proc);</span><br><span class="line">	if (thread == NULL) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	case BINDER_WRITE_READ:  //binder读写操作</span><br><span class="line">	    //见4.2节</span><br><span class="line">		ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">		if (ret)</span><br><span class="line">			goto err;</span><br><span class="line">		break;</span><br><span class="line">	case BINDER_SET_MAX_THREADS: &#123; //Binder线程最大个数</span><br><span class="line">		int max_threads;</span><br><span class="line"></span><br><span class="line">		if (copy_from_user(&amp;max_threads, ubuf,</span><br><span class="line">				   sizeof(max_threads))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			goto err;</span><br><span class="line">		&#125;</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		proc-&gt;max_threads = max_threads;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		break;</span><br><span class="line">	&#125; </span><br><span class="line">	case BINDER_SET_CONTEXT_MGR:  //binder上下文管理者，ServiceManager成为守护进程</span><br><span class="line">		ret = binder_ioctl_set_ctx_mgr(filp);</span><br><span class="line">		if (ret)</span><br><span class="line">			goto err;</span><br><span class="line">		break; </span><br><span class="line">	case BINDER_THREAD_EXIT:  //退出，释放Binder线程</span><br><span class="line">		binder_debug(BINDER_DEBUG_THREADS, &quot;%d:%d exit/n&quot;,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		binder_thread_release(proc, thread);</span><br><span class="line">		thread = NULL;</span><br><span class="line">		break;</span><br><span class="line">	case BINDER_VERSION: &#123;  //Binder版本信息</span><br><span class="line">		struct binder_version __user *ver = ubuf;</span><br><span class="line"></span><br><span class="line">		if (size != sizeof(struct binder_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			goto err;</span><br><span class="line">		&#125;</span><br><span class="line">		if (put_user(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">			     &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			goto err;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case BINDER_GET_NODE_DEBUG_INFO: &#123;  //binder debug信息</span><br><span class="line">		struct binder_node_debug_info info;</span><br><span class="line"></span><br><span class="line">		if (copy_from_user(&amp;info, ubuf, sizeof(info))) &#123;</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			goto err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = binder_ioctl_get_node_debug_info(proc, &amp;info);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto err;</span><br><span class="line"></span><br><span class="line">		if (copy_to_user(ubuf, &amp;info, sizeof(info))) &#123;</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			goto err;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	default:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		goto err;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = 0;</span><br><span class="line">err:</span><br><span class="line">	if (thread)</span><br><span class="line">		thread-&gt;looper_need_return = false;</span><br><span class="line">	wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">	if (ret &amp;&amp; ret != -ERESTARTSYS)</span><br><span class="line">		pr_info(&quot;%d:%d ioctl %x %lx returned %d/n&quot;, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line">	trace_binder_ioctl_done(ret);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> binder_ioctl负责两个进程间收发IPC数据和IPC reply数据</p>
<blockquote>
<p> binder_ioctl(文件描述符，ioctl命令，数据类型)</p>
</blockquote>
<p>文件描述符，是通过binder_open方法打开Binder Driver后的返回值</p>
<p>ioctl命令和数据类型是一体的，不同的命令对应不同的数据类型</p>
<table>
<thead>
<tr>
<th>ioctl命令</th>
<th>数据类型</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>BINDER_WRITE_READ</td>
<td>struct binder_write_read</td>
<td>收发Binder IPC数据</td>
</tr>
<tr>
<td>BINDER_SET_MAX_THREADS</td>
<td>__u32</td>
<td>Binder线程最大个数</td>
</tr>
<tr>
<td>BINDER_SET_CONTEXT_MGR</td>
<td>__s32</td>
<td>Service Manager节点</td>
</tr>
<tr>
<td>BINDER_THREAD_EXIT</td>
<td>__s32</td>
<td>释放Binder线程</td>
</tr>
<tr>
<td>BINDER_VERSION</td>
<td>struct binder_version</td>
<td>Binder版本信息</td>
</tr>
<tr>
<td>BINDER_GET_NODE_DEBUG_INFO</td>
<td>struct binder_node_debug_info</td>
<td>binder debug信息</td>
</tr>
</tbody>
</table>
<h4 id="4-1-1-binder-get-thread"><a href="#4-1-1-binder-get-thread" class="headerlink" title="4.1.1 binder_get_thread"></a>4.1.1 binder_get_thread</h4><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static struct binder_thread *binder_get_thread(struct binder_proc *proc)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_thread *thread;</span><br><span class="line">	struct binder_thread *new_thread;</span><br><span class="line">    //获取锁</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	//见4.1.2节,获取binder线程</span><br><span class="line">	thread = binder_get_thread_ilocked(proc, NULL);</span><br><span class="line">	//释放锁</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">	//未获取到线程</span><br><span class="line">	if (!thread) &#123;</span><br><span class="line">	    //新建binder_thread结构体</span><br><span class="line">		new_thread = kzalloc(sizeof(*thread), GFP_KERNEL);</span><br><span class="line">		if (new_thread == NULL)</span><br><span class="line">			return NULL;</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		thread = binder_get_thread_ilocked(proc, new_thread);</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		if (thread != new_thread)</span><br><span class="line">			kfree(new_thread);</span><br><span class="line">	&#125;</span><br><span class="line">	return thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-binder-get-thread-ilocked"><a href="#4-1-2-binder-get-thread-ilocked" class="headerlink" title="4.1.2 binder_get_thread_ilocked"></a>4.1.2 binder_get_thread_ilocked</h4><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static struct binder_thread *binder_get_thread_ilocked(</span><br><span class="line">		struct binder_proc *proc, struct binder_thread *new_thread)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_thread *thread = NULL;</span><br><span class="line">	//红黑树数据结构存储结点</span><br><span class="line">	struct rb_node *parent = NULL;</span><br><span class="line">	struct rb_node **p = &amp;proc-&gt;threads.rb_node;</span><br><span class="line">    //根据当前线程的pid,从binder_proc中查找相应的binder_thread</span><br><span class="line">	while (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		thread = rb_entry(parent, struct binder_thread, rb_node);</span><br><span class="line"></span><br><span class="line">		if (current-&gt;pid &lt; thread-&gt;pid)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		else if (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		else</span><br><span class="line">			return thread;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!new_thread)</span><br><span class="line">		return NULL;</span><br><span class="line">	thread = new_thread;</span><br><span class="line">	binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">	thread-&gt;proc = proc;</span><br><span class="line">	thread-&gt;pid = current-&gt;pid; //保存当前线程的pid</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	thread-&gt;task = current;</span><br><span class="line">	atomic_set(&amp;thread-&gt;tmp_ref, 0);</span><br><span class="line">	init_waitqueue_head(&amp;thread-&gt;wait);</span><br><span class="line">	INIT_LIST_HEAD(&amp;thread-&gt;todo);</span><br><span class="line">	rb_link_node(&amp;thread-&gt;rb_node, parent, p);</span><br><span class="line">	rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line">	thread-&gt;looper_need_return = true;</span><br><span class="line">	thread-&gt;return_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">	thread-&gt;return_error.cmd = BR_OK;</span><br><span class="line">	thread-&gt;reply_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">	thread-&gt;reply_error.cmd = BR_OK;</span><br><span class="line">	INIT_LIST_HEAD(&amp;new_thread-&gt;waiting_thread_node);</span><br><span class="line">	return thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从binder_proc中查找binder_thread,如果当前线程已经加入到proc的线程队列则直接返回，如果不存在则创建binder_thread，并将当前线程添加到当期的proc。</p>
<h3 id="4-2-binder-ioctl-write-read"><a href="#4-2-binder-ioctl-write-read" class="headerlink" title="4.2 binder_ioctl_write_read"></a>4.2 binder_ioctl_write_read</h3><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">static int binder_ioctl_write_read(struct file *filp,</span><br><span class="line">				unsigned int cmd, unsigned long arg,</span><br><span class="line">				struct binder_thread *thread)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	unsigned int size = _IOC_SIZE(cmd);</span><br><span class="line">	//用户空间binder_write_read</span><br><span class="line">	void __user *ubuf = (void __user *)arg;</span><br><span class="line">	struct binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">	if (size != sizeof(struct binder_write_read)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	//拷贝用户空间的binder_write_read拷贝到内核</span><br><span class="line">	if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_debug(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">		     &quot;%d:%d write %lld at %016llx, read %lld at %016llx/n&quot;,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">		     (u64)bwr.write_size, (u64)bwr.write_buffer,</span><br><span class="line">		     (u64)bwr.read_size, (u64)bwr.read_buffer);</span><br><span class="line"></span><br><span class="line">	if (bwr.write_size &gt; 0) &#123;</span><br><span class="line">	    //将数据放入目标进程</span><br><span class="line">		ret = binder_thread_write(proc, thread,</span><br><span class="line">					  bwr.write_buffer,</span><br><span class="line">					  bwr.write_size,</span><br><span class="line">					  &amp;bwr.write_consumed);</span><br><span class="line">		trace_binder_write_done(ret);</span><br><span class="line">		if (ret &lt; 0) &#123;</span><br><span class="line">			bwr.read_consumed = 0;</span><br><span class="line">			if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (bwr.read_size &gt; 0) &#123;</span><br><span class="line">	    //读取自己队列数据</span><br><span class="line">		ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">					 bwr.read_size,</span><br><span class="line">					 &amp;bwr.read_consumed,</span><br><span class="line">					 filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">		trace_binder_read_done(ret);</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))</span><br><span class="line">			binder_wakeup_proc_ilocked(proc);</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		if (ret &lt; 0) &#123;</span><br><span class="line">			if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_debug(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">		     &quot;%d:%d wrote %lld of %lld, read return %lld of %lld/n&quot;,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">		     (u64)bwr.write_consumed, (u64)bwr.write_size,</span><br><span class="line">		     (u64)bwr.read_consumed, (u64)bwr.read_size);</span><br><span class="line">	//将内核空间的bwr结构体，拷贝到用户空间     </span><br><span class="line">	if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-binder-thread-write"><a href="#4-3-binder-thread-write" class="headerlink" title="4.3  binder_thread_write"></a>4.3  binder_thread_write</h3><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_write(struct binder_proc *proc,</span><br><span class="line">			struct binder_thread *thread,</span><br><span class="line">			binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">			binder_size_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t cmd;</span><br><span class="line">	struct binder_context *context = proc-&gt;context;</span><br><span class="line">	void __user *buffer = (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">	void __user *ptr = buffer + *consumed;</span><br><span class="line">	void __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	while (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;</span><br><span class="line">		int ret;</span><br><span class="line">         //获取用户空间的cmd命令，此时为BC_TRANSACTION</span><br><span class="line">		if (get_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		ptr += sizeof(uint32_t);</span><br><span class="line">		trace_binder_command(cmd);</span><br><span class="line">		if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">			atomic_inc(&amp;binder_stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">			atomic_inc(&amp;proc-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">			atomic_inc(&amp;thread-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">		&#125;</span><br><span class="line">		switch (cmd) &#123;</span><br><span class="line">		    ...</span><br><span class="line">		    case BC_TRANSACTION:</span><br><span class="line">		    case BC_REPLY: &#123;</span><br><span class="line">			    struct binder_transaction_data tr;</span><br><span class="line">                  //从用户空间获取binder_transaction_data</span><br><span class="line">			    if (copy_from_user(&amp;tr, ptr, sizeof(tr)))</span><br><span class="line">				   return -EFAULT;</span><br><span class="line">			    ptr += sizeof(tr);</span><br><span class="line">			    //见4.3节</span><br><span class="line">			    binder_transaction(proc, thread, &amp;tr,</span><br><span class="line">					   cmd == BC_REPLY, 0);</span><br><span class="line">			    break;</span><br><span class="line">		    &#125;</span><br><span class="line">		    ...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-binder-transaction"><a href="#4-4-binder-transaction" class="headerlink" title="4.4 binder_transaction"></a>4.4 binder_transaction</h3><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line">static void binder_transaction(struct binder_proc *proc,</span><br><span class="line">			       struct binder_thread *thread,</span><br><span class="line">			       struct binder_transaction_data *tr, int reply,</span><br><span class="line">			       binder_size_t extra_buffers_size)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct binder_transaction *t;</span><br><span class="line">	struct binder_work *tcomplete;</span><br><span class="line">	binder_size_t *offp, *off_end, *off_start;</span><br><span class="line">	binder_size_t off_min;</span><br><span class="line">	u8 *sg_bufp, *sg_buf_end;</span><br><span class="line">	struct binder_proc *target_proc = NULL;</span><br><span class="line">	struct binder_thread *target_thread = NULL;</span><br><span class="line">	struct binder_node *target_node = NULL;</span><br><span class="line">	struct binder_transaction *in_reply_to = NULL;</span><br><span class="line">	struct binder_transaction_log_entry *e;</span><br><span class="line">	uint32_t return_error = 0;</span><br><span class="line">	uint32_t return_error_param = 0;</span><br><span class="line">	uint32_t return_error_line = 0;</span><br><span class="line">	struct binder_buffer_object *last_fixup_obj = NULL;</span><br><span class="line">	binder_size_t last_fixup_min_off = 0;</span><br><span class="line">	struct binder_context *context = proc-&gt;context;</span><br><span class="line">	int t_debug_id = atomic_inc_return(&amp;binder_last_id);</span><br><span class="line"></span><br><span class="line">	e = binder_transaction_log_add(&amp;binder_transaction_log);</span><br><span class="line">	e-&gt;debug_id = t_debug_id;</span><br><span class="line">	e-&gt;call_type = reply ? 2 : !!(tr-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">	e-&gt;from_proc = proc-&gt;pid;</span><br><span class="line">	e-&gt;from_thread = thread-&gt;pid;</span><br><span class="line">	e-&gt;target_handle = tr-&gt;target.handle;</span><br><span class="line">	e-&gt;data_size = tr-&gt;data_size;</span><br><span class="line">	e-&gt;offsets_size = tr-&gt;offsets_size;</span><br><span class="line">	e-&gt;context_name = proc-&gt;context-&gt;name;</span><br><span class="line">     //此处上面传过来reply为false</span><br><span class="line">	if (reply) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	    //上面传过来的handle是0</span><br><span class="line">		if (tr-&gt;target.handle) &#123;</span><br><span class="line">		   ...</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">			//handle为0，找到servicemanager实体</span><br><span class="line">			target_node = context-&gt;binder_context_mgr_node;</span><br><span class="line">			if (target_node)</span><br><span class="line">				target_node = binder_get_node_refs_for_txn(</span><br><span class="line">						target_node, &amp;target_proc,</span><br><span class="line">						&amp;return_error);</span><br><span class="line">			else</span><br><span class="line">				return_error = BR_DEAD_REPLY;</span><br><span class="line">			mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">			if (target_node &amp;&amp; target_proc == proc) &#123;</span><br><span class="line">				binder_user_error(&quot;%d:%d got transaction to context manager from process owning it/n&quot;,</span><br><span class="line">						  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = -EINVAL;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				goto err_invalid_target_handle;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//target_node为空转到err_dead_binder</span><br><span class="line">		if (!target_node) &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * return_error is set above</span><br><span class="line">			 */</span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			goto err_dead_binder;</span><br><span class="line">		&#125;</span><br><span class="line">		e-&gt;to_node = target_node-&gt;debug_id;</span><br><span class="line">		if (security_binder_transaction(proc-&gt;tsk,</span><br><span class="line">						target_proc-&gt;tsk) &lt; 0) &#123;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EPERM;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			goto err_invalid_target_handle;</span><br><span class="line">		&#125;</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		if (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">			struct binder_transaction *tmp;</span><br><span class="line"></span><br><span class="line">			tmp = thread-&gt;transaction_stack;</span><br><span class="line">			if (tmp-&gt;to_thread != thread) &#123;</span><br><span class="line">				spin_lock(&amp;tmp-&gt;lock);</span><br><span class="line">				binder_user_error(&quot;%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d/n&quot;,</span><br><span class="line">					proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,</span><br><span class="line">					tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : 0,</span><br><span class="line">					tmp-&gt;to_thread ?</span><br><span class="line">					tmp-&gt;to_thread-&gt;pid : 0);</span><br><span class="line">				spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">				binder_inner_proc_unlock(proc);</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = -EPROTO;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				goto err_bad_call_stack;</span><br><span class="line">			&#125;</span><br><span class="line">			while (tmp) &#123;</span><br><span class="line">				struct binder_thread *from;</span><br><span class="line"></span><br><span class="line">				spin_lock(&amp;tmp-&gt;lock);</span><br><span class="line">				from = tmp-&gt;from;</span><br><span class="line">				if (from &amp;&amp; from-&gt;proc == target_proc) &#123;</span><br><span class="line">					atomic_inc(&amp;from-&gt;tmp_ref);</span><br><span class="line">					target_thread = from;</span><br><span class="line">					spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">				tmp = tmp-&gt;from_parent;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">	&#125;</span><br><span class="line">	if (target_thread)</span><br><span class="line">		e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">	e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">	/* TODO: reuse incoming transaction for reply */</span><br><span class="line">	t = kzalloc(sizeof(*t), GFP_KERNEL);</span><br><span class="line">	if (t == NULL) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -ENOMEM;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_alloc_t_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_stats_created(BINDER_STAT_TRANSACTION);</span><br><span class="line">	spin_lock_init(&amp;t-&gt;lock);</span><br><span class="line"></span><br><span class="line">	tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);</span><br><span class="line">	if (tcomplete == NULL) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -ENOMEM;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_alloc_tcomplete_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">	t-&gt;debug_id = t_debug_id;</span><br><span class="line">	...</span><br><span class="line">	//非oneway通信方式，把当前thread保存到transaction的from字段</span><br><span class="line">	if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">		t-&gt;from = thread;</span><br><span class="line">	else</span><br><span class="line">		t-&gt;from = NULL;</span><br><span class="line">	t-&gt;sender_euid = task_euid(proc-&gt;tsk);</span><br><span class="line">	t-&gt;to_proc = target_proc;//此次通信目标进程为servicemanager进程</span><br><span class="line">	t-&gt;to_thread = target_thread; //此次通信的目标线程为servicemanager线程</span><br><span class="line">	t-&gt;code = tr-&gt;code; //此次通信code=ADD_SERVICE_TRANSACTION</span><br><span class="line">	t-&gt;flags = tr-&gt;flags; //此次flag = 0</span><br><span class="line">	if (!(t-&gt;flags &amp; TF_ONE_WAY) &amp;&amp;</span><br><span class="line">	    binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">		/* Inherit supported policies for synchronous transactions */</span><br><span class="line">		t-&gt;priority.sched_policy = current-&gt;policy;</span><br><span class="line">		t-&gt;priority.prio = current-&gt;normal_prio;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/* Otherwise, fall back to the default priority */</span><br><span class="line">		t-&gt;priority = target_proc-&gt;default_priority;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_binder_transaction(reply, t, target_node);</span><br><span class="line">    //从servicemanage进程中分配buffer</span><br><span class="line">	t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size,</span><br><span class="line">		tr-&gt;offsets_size, extra_buffers_size,</span><br><span class="line">		!reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">	if (IS_ERR(t-&gt;buffer)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * -ESRCH indicates VMA cleared. The target is dying.</span><br><span class="line">		 */</span><br><span class="line">		return_error_param = PTR_ERR(t-&gt;buffer);</span><br><span class="line">		return_error = return_error_param == -ESRCH ?</span><br><span class="line">			BR_DEAD_REPLY : BR_FAILED_REPLY;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		t-&gt;buffer = NULL;</span><br><span class="line">		goto err_binder_alloc_buf_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;buffer-&gt;allow_user_free = 0;</span><br><span class="line">	t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">	t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">	t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">	trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">	off_start = (binder_size_t *)(t-&gt;buffer-&gt;data +</span><br><span class="line">				      ALIGN(tr-&gt;data_size, sizeof(void *)));</span><br><span class="line">	offp = off_start;</span><br><span class="line">    //分别拷贝用户空间的binder_transaction_data中的ptr.buffer和ptr.offsets</span><br><span class="line">	if (copy_from_user(t-&gt;buffer-&gt;data, (const void __user *)(uintptr_t)</span><br><span class="line">			   tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">		binder_user_error(&quot;%d:%d got transaction with invalid data ptr/n&quot;,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EFAULT;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	if (copy_from_user(offp, (const void __user *)(uintptr_t)</span><br><span class="line">			   tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">		binder_user_error(&quot;%d:%d got transaction with invalid offsets ptr/n&quot;,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EFAULT;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!IS_ALIGNED(tr-&gt;offsets_size, sizeof(binder_size_t))) &#123;</span><br><span class="line">		binder_user_error(&quot;%d:%d got transaction with invalid offsets size, %lld/n&quot;,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid, (u64)tr-&gt;offsets_size);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EINVAL;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_bad_offset;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!IS_ALIGNED(extra_buffers_size, sizeof(u64))) &#123;</span><br><span class="line">		binder_user_error(&quot;%d:%d got transaction with unaligned buffers size, %lld/n&quot;,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">				  (u64)extra_buffers_size);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EINVAL;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_bad_offset;</span><br><span class="line">	&#125;</span><br><span class="line">	off_end = (void *)off_start + tr-&gt;offsets_size;</span><br><span class="line">	sg_bufp = (u8 *)(PTR_ALIGN(off_end, sizeof(void *)));</span><br><span class="line">	sg_buf_end = sg_bufp + extra_buffers_size;</span><br><span class="line">	off_min = 0;</span><br><span class="line">	for (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">		struct binder_object_header *hdr;</span><br><span class="line">		size_t object_size = binder_validate_object(t-&gt;buffer, *offp);</span><br><span class="line"></span><br><span class="line">		if (object_size == 0 || *offp &lt; off_min) &#123;</span><br><span class="line">			binder_user_error(&quot;%d:%d got transaction with invalid offset (%lld, min %lld max %lld) or object./n&quot;,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid, (u64)*offp,</span><br><span class="line">					  (u64)off_min,</span><br><span class="line">					  (u64)t-&gt;buffer-&gt;data_size);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			goto err_bad_offset;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		hdr = (struct binder_object_header *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">		off_min = *offp + object_size;</span><br><span class="line">		switch (hdr-&gt;type) &#123;</span><br><span class="line">		case BINDER_TYPE_BINDER:</span><br><span class="line">		case BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">			struct flat_binder_object *fp;</span><br><span class="line">			fp = to_flat_binder_object(hdr);</span><br><span class="line">			//见4.4.1节</span><br><span class="line">			ret = binder_translate_binder(fp, t, thread);</span><br><span class="line">			if (ret &lt; 0) &#123;</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = ret;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				goto err_translate_failed;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; break;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	//将当前线程的type为BINDER_WORK_TRANSACTION_COMPLETE</span><br><span class="line">	tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">	//设置目标线程type为BINDER_WORK_TRANSACTION</span><br><span class="line">	t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line"></span><br><span class="line">	if (reply) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">	    //BC_TRANSACTION且oneway，则设置事务栈信息</span><br><span class="line">		BUG_ON(t-&gt;buffer-&gt;async_transaction != 0);</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		/*</span><br><span class="line">		 * Defer the TRANSACTION_COMPLETE, so we don&apos;t return to</span><br><span class="line">		 * userspace immediately; this allows the target process to</span><br><span class="line">		 * immediately start processing this transaction, reducing</span><br><span class="line">		 * latency. We will then return the TRANSACTION_COMPLETE when</span><br><span class="line">		 * the target replies (or there is an error).</span><br><span class="line">		 */</span><br><span class="line">		 //BINDER_WORK_TRANSACTION_COMPLETE加入到当前线程todo队列</span><br><span class="line">		binder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);</span><br><span class="line">		t-&gt;need_reply = 1;</span><br><span class="line">		t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">		thread-&gt;transaction_stack = t;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		//见4.4.2节，BINDER_WORK_TRANSACTION加入到目标线程todo队列</span><br><span class="line">		if (!binder_proc_transaction(t, target_proc, target_thread)) &#123;</span><br><span class="line">			binder_inner_proc_lock(proc);</span><br><span class="line">			binder_pop_transaction_ilocked(thread, t);</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			goto err_dead_proc_or_thread;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	if (target_thread)</span><br><span class="line">		binder_thread_dec_tmpref(target_thread);</span><br><span class="line">	binder_proc_dec_tmpref(target_proc);</span><br><span class="line">	if (target_node)</span><br><span class="line">		binder_dec_node_tmpref(target_node);</span><br><span class="line">	/*</span><br><span class="line">	 * write barrier to synchronize with initialization</span><br><span class="line">	 * of log entry</span><br><span class="line">	 */</span><br><span class="line">	smp_wmb();</span><br><span class="line">	WRITE_ONCE(e-&gt;debug_id_done, t_debug_id);</span><br><span class="line">	return;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder_transaction主要的工作如下</p>
<ul>
<li><p>注册服务的过程，传递的是BBinder对象，所以hdr-&gt;type为BINDER_TYPE_BINDER；</p>
</li>
<li><p>服务注册过程中是在服务所在的进程创建binder_node，在Servicemanager进程创建binder_ref,对应一个binder_node，每个进程只会创建一个binder_ref对象；</p>
</li>
<li><p>向当前线程的binder_proc-&gt;todo添加BINDER_WORK_TRANSACTION_COMPLETE事务，回复服务注册进程收到BC_TRANSACTION；</p>
</li>
<li><p>向servicemanager的binder_proc-&gt;todo添加BINDER_WORK_TRANSACTION事务，接下来进入到servicemanager进程中。</p>
</li>
</ul>
<h4 id="4-4-1-binder-translate-binder"><a href="#4-4-1-binder-translate-binder" class="headerlink" title="4.4.1  binder_translate_binder"></a>4.4.1  binder_translate_binder</h4><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">static int binder_translate_binder(struct flat_binder_object *fp,</span><br><span class="line">				   struct binder_transaction *t,</span><br><span class="line">				   struct binder_thread *thread)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_node *node;</span><br><span class="line">	struct binder_proc *proc = thread-&gt;proc;</span><br><span class="line">	struct binder_proc *target_proc = t-&gt;to_proc;</span><br><span class="line">	struct binder_ref_data rdata;</span><br><span class="line">	int ret = 0;</span><br><span class="line">    //获取binder实体</span><br><span class="line">	node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">	if (!node) &#123;</span><br><span class="line">	    //创建binder实体</span><br><span class="line">		node = binder_new_node(proc, fp);</span><br><span class="line">		if (!node)</span><br><span class="line">			return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	if (fp-&gt;cookie != node-&gt;cookie) &#123;</span><br><span class="line">		binder_user_error(&quot;%d:%d sending u%016llx node %d, cookie mismatch %016llx != %016llx/n&quot;,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid, (u64)fp-&gt;binder,</span><br><span class="line">				  node-&gt;debug_id, (u64)fp-&gt;cookie,</span><br><span class="line">				  (u64)node-&gt;cookie);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		goto done;</span><br><span class="line">	&#125;</span><br><span class="line">	if (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">		ret = -EPERM;</span><br><span class="line">		goto done;</span><br><span class="line">	&#125;</span><br><span class="line">    //servicemanager进程的binder_ref</span><br><span class="line">	ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">			fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">			&amp;thread-&gt;todo, &amp;rdata);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto done;</span><br><span class="line">     //调整type为HANDLE类型</span><br><span class="line">	if (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">		fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">	else</span><br><span class="line">		fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">	fp-&gt;binder = 0;</span><br><span class="line">	fp-&gt;handle = rdata.desc;  //设置handler值</span><br><span class="line">	fp-&gt;cookie = 0;</span><br><span class="line"></span><br><span class="line">	trace_binder_transaction_node_to_ref(t, node, &amp;rdata);</span><br><span class="line">	binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">		     &quot;        node %d u%016llx -&gt; ref %d desc %d/n&quot;,</span><br><span class="line">		     node-&gt;debug_id, (u64)node-&gt;ptr,</span><br><span class="line">		     rdata.debug_id, rdata.desc);</span><br><span class="line">done:</span><br><span class="line">	binder_put_node(node);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-binder-proc-transaction"><a href="#4-4-2-binder-proc-transaction" class="headerlink" title="4.4.2  binder_proc_transaction"></a>4.4.2  binder_proc_transaction</h4><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static bool binder_proc_transaction(struct binder_transaction *t,</span><br><span class="line">				    struct binder_proc *proc,</span><br><span class="line">				    struct binder_thread *thread)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_node *node = t-&gt;buffer-&gt;target_node;</span><br><span class="line">	struct binder_priority node_prio;</span><br><span class="line">	bool oneway = !!(t-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">	bool pending_async = false;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!node);</span><br><span class="line">	binder_node_lock(node);</span><br><span class="line">	node_prio.prio = node-&gt;min_priority;</span><br><span class="line">	node_prio.sched_policy = node-&gt;sched_policy;</span><br><span class="line"></span><br><span class="line">	if (oneway) &#123;</span><br><span class="line">		BUG_ON(thread);</span><br><span class="line">		if (node-&gt;has_async_transaction) &#123;</span><br><span class="line">			pending_async = true;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			node-&gt;has_async_transaction = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line"></span><br><span class="line">	if (proc-&gt;is_dead || (thread &amp;&amp; thread-&gt;is_dead)) &#123;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		binder_node_unlock(node);</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!thread &amp;&amp; !pending_async)</span><br><span class="line">		thread = binder_select_thread_ilocked(proc);</span><br><span class="line"></span><br><span class="line">	if (thread) &#123;</span><br><span class="line">		binder_transaction_priority(thread-&gt;task, t, node_prio,</span><br><span class="line">					    node-&gt;inherit_rt);</span><br><span class="line">		//BINDER_WORK_TRANSACTION加入到目标线程todo队列</span><br><span class="line">		binder_enqueue_thread_work_ilocked(thread, &amp;t-&gt;work);</span><br><span class="line">	&#125; else if (!pending_async) &#123;</span><br><span class="line">		binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;proc-&gt;todo);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;node-&gt;async_todo);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!pending_async)</span><br><span class="line">	    //唤醒等待队列，本次通信的目标队列为target_proc-&gt;wait</span><br><span class="line">		binder_wakeup_thread_ilocked(proc, thread, !oneway /* sync */);</span><br><span class="line"></span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">	binder_node_unlock(node);</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.2节中执行完binder_thread_write，再执行binder_thread_read操作,见4.5节</p>
<h4 id="4-4-3-binder-inc-ref-for-node"><a href="#4-4-3-binder-inc-ref-for-node" class="headerlink" title="4.4.3 binder_inc_ref_for_node"></a>4.4.3 binder_inc_ref_for_node</h4><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static int binder_inc_ref_for_node(struct binder_proc *proc,</span><br><span class="line">			struct binder_node *node,</span><br><span class="line">			bool strong,</span><br><span class="line">			struct list_head *target_list,</span><br><span class="line">			struct binder_ref_data *rdata)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_ref *ref;</span><br><span class="line">	struct binder_ref *new_ref = NULL;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	binder_proc_lock(proc);</span><br><span class="line">	//获取binder_ref,见4.4.4节</span><br><span class="line">	ref = binder_get_ref_for_node_olocked(proc, node, NULL);</span><br><span class="line">	if (!ref) &#123;</span><br><span class="line">		binder_proc_unlock(proc);</span><br><span class="line">		new_ref = kzalloc(sizeof(*ref), GFP_KERNEL);</span><br><span class="line">		if (!new_ref)</span><br><span class="line">			return -ENOMEM;</span><br><span class="line">		binder_proc_lock(proc);</span><br><span class="line">		ref = binder_get_ref_for_node_olocked(proc, node, new_ref);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = binder_inc_ref_olocked(ref, strong, target_list);</span><br><span class="line">	*rdata = ref-&gt;data;</span><br><span class="line">	binder_proc_unlock(proc);</span><br><span class="line">	if (new_ref &amp;&amp; ref != new_ref)</span><br><span class="line">		/*</span><br><span class="line">		 * Another thread created the ref first so</span><br><span class="line">		 * free the one we allocated</span><br><span class="line">		 */</span><br><span class="line">		kfree(new_ref);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-4-binder-get-ref-for-node-olocked"><a href="#4-4-4-binder-get-ref-for-node-olocked" class="headerlink" title="4.4.4 binder_get_ref_for_node_olocked"></a>4.4.4 binder_get_ref_for_node_olocked</h4><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static struct binder_ref *binder_get_ref_for_node_olocked(</span><br><span class="line">					struct binder_proc *proc,</span><br><span class="line">					struct binder_node *node,</span><br><span class="line">					struct binder_ref *new_ref)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_context *context = proc-&gt;context;</span><br><span class="line">	struct rb_node **p = &amp;proc-&gt;refs_by_node.rb_node;</span><br><span class="line">	struct rb_node *parent = NULL;</span><br><span class="line">	struct binder_ref *ref;</span><br><span class="line">	struct rb_node *n;</span><br><span class="line">    //从refs_by_node红黑树，找到binder_ref则直接返回</span><br><span class="line">	while (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		ref = rb_entry(parent, struct binder_ref, rb_node_node);</span><br><span class="line"></span><br><span class="line">		if (node &lt; ref-&gt;node)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		else if (node &gt; ref-&gt;node)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		else</span><br><span class="line">			return ref;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!new_ref)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_REF);</span><br><span class="line">	new_ref-&gt;data.debug_id = atomic_inc_return(&amp;binder_last_id);</span><br><span class="line">	new_ref-&gt;proc = proc;</span><br><span class="line">	new_ref-&gt;node = node;</span><br><span class="line">	rb_link_node(&amp;new_ref-&gt;rb_node_node, parent, p);</span><br><span class="line">	rb_insert_color(&amp;new_ref-&gt;rb_node_node, &amp;proc-&gt;refs_by_node);</span><br><span class="line">    </span><br><span class="line">    //计算binder引用的handle值</span><br><span class="line">	new_ref-&gt;data.desc = (node == context-&gt;binder_context_mgr_node) ? 0 : 1;</span><br><span class="line">	//从红黑树最左边的handle对比，依次递增，直到红黑树结束或者找到更大的handle结束</span><br><span class="line">	for (n = rb_first(&amp;proc-&gt;refs_by_desc); n != NULL; n = rb_next(n)) &#123;</span><br><span class="line">	//根据binder_ref的成员变量rb_node_desc地址指针，来获取binder_ref首地址</span><br><span class="line">		ref = rb_entry(n, struct binder_ref, rb_node_desc);</span><br><span class="line">		if (ref-&gt;data.desc &gt; new_ref-&gt;data.desc)</span><br><span class="line">			break;</span><br><span class="line">		new_ref-&gt;data.desc = ref-&gt;data.desc + 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p = &amp;proc-&gt;refs_by_desc.rb_node;</span><br><span class="line">	while (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		ref = rb_entry(parent, struct binder_ref, rb_node_desc);</span><br><span class="line"></span><br><span class="line">		if (new_ref-&gt;data.desc &lt; ref-&gt;data.desc)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		else if (new_ref-&gt;data.desc &gt; ref-&gt;data.desc)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		else</span><br><span class="line">			BUG();</span><br><span class="line">	&#125;</span><br><span class="line">	rb_link_node(&amp;new_ref-&gt;rb_node_desc, parent, p);</span><br><span class="line">	rb_insert_color(&amp;new_ref-&gt;rb_node_desc, &amp;proc-&gt;refs_by_desc);</span><br><span class="line"></span><br><span class="line">	binder_node_lock(node);</span><br><span class="line">	hlist_add_head(&amp;new_ref-&gt;node_entry, &amp;node-&gt;refs);</span><br><span class="line"></span><br><span class="line">	binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">		     &quot;%d new ref %d desc %d for node %d/n&quot;,</span><br><span class="line">		      proc-&gt;pid, new_ref-&gt;data.debug_id, new_ref-&gt;data.desc,</span><br><span class="line">		      node-&gt;debug_id);</span><br><span class="line">	binder_node_unlock(node);</span><br><span class="line">	return new_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handle值计算方法规律：</p>
<ul>
<li>每个进程binder_proc记录的binder_ref的handle值是从1开始递增的</li>
<li>所有进程的binder_proc所记录的handler=0的binder_ref都指向service manage</li>
<li>同一个服务的binder_node在不同进程的binder_ref的handle值可以不同</li>
</ul>
<h3 id="4-5-binder-thread-read"><a href="#4-5-binder-thread-read" class="headerlink" title="4.5 binder_thread_read"></a>4.5 binder_thread_read</h3><p>[-&gt;android/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_read(struct binder_proc *proc,</span><br><span class="line">			      struct binder_thread *thread,</span><br><span class="line">			      binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">			      binder_size_t *consumed, int non_block)</span><br><span class="line">&#123;</span><br><span class="line">	void __user *buffer = (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">	void __user *ptr = buffer + *consumed;</span><br><span class="line">	void __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	int ret = 0;</span><br><span class="line">	int wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">	if (*consumed == 0) &#123;</span><br><span class="line">		if (put_user(BR_NOOP, (uint32_t __user *)ptr))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		ptr += sizeof(uint32_t);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	wait_for_proc_work = binder_available_for_proc_work_ilocked(thread);</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">	thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">	trace_binder_wait_for_work(wait_for_proc_work,</span><br><span class="line">				   !!thread-&gt;transaction_stack,</span><br><span class="line">				   !binder_worklist_empty(proc, &amp;thread-&gt;todo));</span><br><span class="line">	if (wait_for_proc_work) &#123;</span><br><span class="line">		if (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">					BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">			binder_user_error(&quot;%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)/n&quot;,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</span><br><span class="line">			wait_event_interruptible(binder_user_error_wait,</span><br><span class="line">						 binder_stop_on_user_error &lt; 2);</span><br><span class="line">		&#125;</span><br><span class="line">		binder_restore_priority(current, proc-&gt;default_priority);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (non_block) &#123;</span><br><span class="line">		if (!binder_has_work(thread, wait_for_proc_work))</span><br><span class="line">			ret = -EAGAIN;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ret = binder_wait_for_work(thread, wait_for_proc_work);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	while (1) &#123;</span><br><span class="line">		uint32_t cmd;</span><br><span class="line">		struct binder_transaction_data tr;</span><br><span class="line">		struct binder_work *w = NULL;</span><br><span class="line">		struct list_head *list = NULL;</span><br><span class="line">		struct binder_transaction *t = NULL;</span><br><span class="line">		struct binder_thread *t_from;</span><br><span class="line"></span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		if (!binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">			list = &amp;thread-&gt;todo;</span><br><span class="line">		else if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo) &amp;&amp;</span><br><span class="line">			   wait_for_proc_work)</span><br><span class="line">			list = &amp;proc-&gt;todo;</span><br><span class="line">		else &#123;</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">			/* no data added */</span><br><span class="line">			if (ptr - buffer == 4 &amp;&amp; !thread-&gt;looper_need_return)</span><br><span class="line">				goto retry;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (end - ptr &lt; sizeof(tr) + 4) &#123;</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		//上面binder_transaction中将BINDER_WORK_TRANSACTION_COMPLETE事务添加到了todo队列</span><br><span class="line">		w = binder_dequeue_work_head_ilocked(list);</span><br><span class="line">		if (binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">			thread-&gt;process_todo = false;</span><br><span class="line">         //这里是BINDER_WORK_TRANSACTION_COMPLETE</span><br><span class="line">		switch (w-&gt;type) &#123;</span><br><span class="line">		...</span><br><span class="line">		case BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			//cmd赋值，回复客服端</span><br><span class="line">			cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">			//将cmd和数据写回用户空间</span><br><span class="line">			if (put_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">				return -EFAULT;</span><br><span class="line">			ptr += sizeof(uint32_t);</span><br><span class="line"></span><br><span class="line">			binder_stat_br(proc, thread, cmd);</span><br><span class="line">			binder_debug(BINDER_DEBUG_TRANSACTION_COMPLETE,</span><br><span class="line">				     &quot;%d:%d BR_TRANSACTION_COMPLETE/n&quot;,</span><br><span class="line">				     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			kfree(w);</span><br><span class="line">			binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">		&#125; break;</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">         //binder_transaction为空继续</span><br><span class="line">		if (!t)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		BUG_ON(t-&gt;buffer == NULL);</span><br><span class="line">		if (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">		     //获取目标node</span><br><span class="line">			struct binder_node *target_node = t-&gt;buffer-&gt;target_node;</span><br><span class="line">			struct binder_priority node_prio;</span><br><span class="line"></span><br><span class="line">			tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">			tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">			node_prio.sched_policy = target_node-&gt;sched_policy;</span><br><span class="line">			node_prio.prio = target_node-&gt;min_priority;</span><br><span class="line">			binder_transaction_priority(current, t, node_prio,</span><br><span class="line">						    target_node-&gt;inherit_rt);</span><br><span class="line">			cmd = BR_TRANSACTION; //设置目标cmd为BR_TRANSACTION</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			tr.target.ptr = 0;</span><br><span class="line">			tr.cookie = 0;</span><br><span class="line">			cmd = BR_REPLY; //设置目标cmd为BR_REPLY</span><br><span class="line">		&#125;</span><br><span class="line">		tr.code = t-&gt;code;</span><br><span class="line">		tr.flags = t-&gt;flags;</span><br><span class="line">		tr.sender_euid = from_kuid(current_user_ns(), t-&gt;sender_euid);</span><br><span class="line"></span><br><span class="line">		t_from = binder_get_txn_from(t);</span><br><span class="line">		if (t_from) &#123;</span><br><span class="line">			struct task_struct *sender = t_from-&gt;proc-&gt;tsk;</span><br><span class="line"></span><br><span class="line">			tr.sender_pid = task_tgid_nr_ns(sender,</span><br><span class="line">							task_active_pid_ns(current));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			tr.sender_pid = 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">		tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">		tr.data.ptr.buffer = (binder_uintptr_t)</span><br><span class="line">			((uintptr_t)t-&gt;buffer-&gt;data +</span><br><span class="line">			binder_alloc_get_user_buffer_offset(&amp;proc-&gt;alloc));</span><br><span class="line">		tr.data.ptr.offsets = tr.data.ptr.buffer +</span><br><span class="line">					ALIGN(t-&gt;buffer-&gt;data_size,</span><br><span class="line">					    sizeof(void *));</span><br><span class="line"></span><br><span class="line">         //将cmd和数据写回用户空间</span><br><span class="line">		if (put_user(cmd, (uint32_t __user *)ptr)) &#123;</span><br><span class="line">			if (t_from)</span><br><span class="line">				binder_thread_dec_tmpref(t_from);</span><br><span class="line"></span><br><span class="line">			binder_cleanup_transaction(t, &quot;put_user failed&quot;,</span><br><span class="line">						   BR_FAILED_REPLY);</span><br><span class="line"></span><br><span class="line">			return -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		ptr += sizeof(uint32_t);</span><br><span class="line">		//将内核空间的binder_transaction_data，拷贝到用户空间   </span><br><span class="line">		if (copy_to_user(ptr, &amp;tr, sizeof(tr))) &#123;</span><br><span class="line">			if (t_from)</span><br><span class="line">				binder_thread_dec_tmpref(t_from);</span><br><span class="line"></span><br><span class="line">			binder_cleanup_transaction(t, &quot;copy_to_user failed&quot;,</span><br><span class="line">						   BR_FAILED_REPLY);</span><br><span class="line"></span><br><span class="line">			return -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		ptr += sizeof(tr);</span><br><span class="line"></span><br><span class="line">		trace_binder_transaction_received(t);</span><br><span class="line">		binder_stat_br(proc, thread, cmd);</span><br><span class="line">		binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">			     &quot;%d:%d %s %d %d:%d, cmd %d size %zd-%zd ptr %016llx-%016llx/n&quot;,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">			     (cmd == BR_TRANSACTION) ? &quot;BR_TRANSACTION&quot; :</span><br><span class="line">			     &quot;BR_REPLY&quot;,</span><br><span class="line">			     t-&gt;debug_id, t_from ? t_from-&gt;proc-&gt;pid : 0,</span><br><span class="line">			     t_from ? t_from-&gt;pid : 0, cmd,</span><br><span class="line">			     t-&gt;buffer-&gt;data_size, t-&gt;buffer-&gt;offsets_size,</span><br><span class="line">			     (u64)tr.data.ptr.buffer, (u64)tr.data.ptr.offsets);</span><br><span class="line"></span><br><span class="line">		if (t_from)</span><br><span class="line">			binder_thread_dec_tmpref(t_from);</span><br><span class="line">		t-&gt;buffer-&gt;allow_user_free = 1;</span><br><span class="line">		if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">			binder_inner_proc_lock(thread-&gt;proc);</span><br><span class="line">			t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">			t-&gt;to_thread = thread;</span><br><span class="line">			thread-&gt;transaction_stack = t;</span><br><span class="line">			binder_inner_proc_unlock(thread-&gt;proc);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			binder_free_transaction(t);</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">	*consumed = ptr - buffer;</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	if (proc-&gt;requested_threads == 0 &amp;&amp;</span><br><span class="line">	    list_empty(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp;</span><br><span class="line">	    proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">	    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">	     BINDER_LOOPER_STATE_ENTERED)) /* the user-space code fails to */</span><br><span class="line">	     /*spawn a new thread if we leave this out */) &#123;</span><br><span class="line">		proc-&gt;requested_threads++;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		binder_debug(BINDER_DEBUG_THREADS,</span><br><span class="line">			     &quot;%d:%d BR_SPAWN_LOOPER/n&quot;,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		if (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		binder_stat_br(proc, thread, BR_SPAWN_LOOPER);</span><br><span class="line">	&#125; elseB</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里binder_thread_read主要是读取队列中的事务，将BR_TRANSACTION_COMPLETE命令写回客户端的用户空间，并且将BR_TRANSACTION命令写回服务端的用户空间。</p>
<p>下面看下服务端进程servicemanager。</p>
<h2 id="五、ServiceManager进程"><a href="#五、ServiceManager进程" class="headerlink" title="五、ServiceManager进程"></a>五、ServiceManager进程</h2><p>从第二大节中可以看到servicemanager启动后，循环再binder_loop过程，会调用binder_parse方法</p>
<h3 id="5-1-binder-parse"><a href="#5-1-binder-parse" class="headerlink" title="5.1 binder_parse"></a>5.1 binder_parse</h3><p>[-&gt;servicemanager/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int binder_parse(struct binder_state *bs, struct binder_io *bio,</span><br><span class="line">                 uintptr_t ptr, size_t size, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    int r = 1;</span><br><span class="line">    uintptr_t end = ptr + (uintptr_t) size;</span><br><span class="line"></span><br><span class="line">    while (ptr &lt; end) &#123;</span><br><span class="line">        uint32_t cmd = *(uint32_t *) ptr;</span><br><span class="line">        ptr += sizeof(uint32_t);</span><br><span class="line">#if TRACE</span><br><span class="line">        fprintf(stderr,&quot;%s:/n&quot;, cmd_name(cmd));</span><br><span class="line">#endif</span><br><span class="line">        switch(cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        //从上面传过来的是BR_TRANSACTION</span><br><span class="line">        case BR_TRANSACTION: &#123;</span><br><span class="line">            struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;</span><br><span class="line">            if ((end - ptr) &lt; sizeof(*txn)) &#123;</span><br><span class="line">                ALOGE(&quot;parse: txn too small!/n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            if (func) &#123;</span><br><span class="line">                unsigned rdata[256/4];</span><br><span class="line">                struct binder_io msg;</span><br><span class="line">                struct binder_io reply;</span><br><span class="line">                int res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, sizeof(rdata), 4);</span><br><span class="line">                //从txn解析出binder_io信息</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                //收到Binder事务</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                //这里走的是非oneway</span><br><span class="line">                if (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    binder_free_buffer(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //发送reply事件</span><br><span class="line">                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += sizeof(*txn);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-svcmgr-handler"><a href="#5-2-svcmgr-handler" class="headerlink" title="5.2 svcmgr_handler"></a>5.2 svcmgr_handler</h3><p>[-&gt;service_manager.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">int svcmgr_handler(struct binder_state *bs,</span><br><span class="line">                   struct binder_transaction_data *txn,</span><br><span class="line">                   struct binder_io *msg,</span><br><span class="line">                   struct binder_io *reply)</span><br><span class="line">&#123;</span><br><span class="line">    struct svcinfo *si;</span><br><span class="line">    uint16_t *s;</span><br><span class="line">    size_t len;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    uint32_t strict_policy;</span><br><span class="line">    int allow_isolated;</span><br><span class="line">    uint32_t dumpsys_priority;</span><br><span class="line"></span><br><span class="line">    //ALOGI(&quot;target=%p code=%d pid=%d uid=%d/n&quot;,</span><br><span class="line">    //      (void*) txn-&gt;target.ptr, txn-&gt;code, txn-&gt;sender_pid, txn-&gt;sender_euid);</span><br><span class="line"></span><br><span class="line">    if (txn-&gt;target.ptr != BINDER_SERVICE_MANAGER)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    if (txn-&gt;code == PING_TRANSACTION)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    // Equivalent to Parcel::enforceInterface(), reading the RPC</span><br><span class="line">    // header with the strict mode policy mask and the interface name.</span><br><span class="line">    // Note that we ignore the strict_policy and don&apos;t propagate it</span><br><span class="line">    // further (since we do no outbound RPCs anyway).</span><br><span class="line">    strict_policy = bio_get_uint32(msg);</span><br><span class="line">    s = bio_get_string16(msg, &amp;len);</span><br><span class="line">    if (s == NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((len != (sizeof(svcmgr_id) / 2)) ||</span><br><span class="line">        memcmp(svcmgr_id, s, sizeof(svcmgr_id))) &#123;</span><br><span class="line">        fprintf(stderr,&quot;invalid id %s/n&quot;, str8(s, len));</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sehandle &amp;&amp; selinux_status_updated() &gt; 0) &#123;</span><br><span class="line">#ifdef VENDORSERVICEMANAGER</span><br><span class="line">        struct selabel_handle *tmp_sehandle = selinux_android_vendor_service_context_handle();</span><br><span class="line">#else</span><br><span class="line">        struct selabel_handle *tmp_sehandle = selinux_android_service_context_handle();</span><br><span class="line">#endif</span><br><span class="line">        if (tmp_sehandle) &#123;</span><br><span class="line">            selabel_close(sehandle);</span><br><span class="line">            sehandle = tmp_sehandle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch(txn-&gt;code) &#123;</span><br><span class="line">    ...</span><br><span class="line">    //这里是addservice</span><br><span class="line">    case SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        if (s == NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取handle</span><br><span class="line">        handle = bio_get_ref(msg);</span><br><span class="line">        allow_isolated = bio_get_uint32(msg) ? 1 : 0;</span><br><span class="line">        dumpsys_priority = bio_get_uint32(msg);</span><br><span class="line">        //注册服务，见5.3节</span><br><span class="line">        if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,</span><br><span class="line">                           txn-&gt;sender_pid))</span><br><span class="line">            return -1;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio_put_uint32(reply, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-do-add-service"><a href="#5-3-do-add-service" class="headerlink" title="5.3 do_add_service"></a>5.3 do_add_service</h3><p>[-&gt;service_manager.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">int do_add_service(struct binder_state *bs, const uint16_t *s, size_t len, uint32_t handle,</span><br><span class="line">                   uid_t uid, int allow_isolated, uint32_t dumpsys_priority, pid_t spid) &#123;</span><br><span class="line">    struct svcinfo *si;</span><br><span class="line"></span><br><span class="line">    //ALOGI(&quot;add_service(&apos;%s&apos;,%x,%s) uid=%d/n&quot;, str8(s, len), handle,</span><br><span class="line">    //        allow_isolated ? &quot;allow_isolated&quot; : &quot;!allow_isolated&quot;, uid);</span><br><span class="line"></span><br><span class="line">    if (!handle || (len == 0) || (len &gt; 127))</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    //权限检查</span><br><span class="line">    if (!svc_can_register(s, len, spid, uid)) &#123;</span><br><span class="line">        ALOGE(&quot;add_service(&apos;%s&apos;,%x) uid=%d - PERMISSION DENIED/n&quot;,</span><br><span class="line">             str8(s, len), handle, uid);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //服务检索</span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    if (si) &#123;</span><br><span class="line">        if (si-&gt;handle) &#123;</span><br><span class="line">            ALOGE(&quot;add_service(&apos;%s&apos;,%x) uid=%d - ALREADY REGISTERED, OVERRIDE/n&quot;,</span><br><span class="line">                 str8(s, len), handle, uid);</span><br><span class="line">            svcinfo_death(bs, si);//服务已经注册时，释放相应的服务</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t));</span><br><span class="line">        if (!si) &#123; //内存不足，无法分配足够内存</span><br><span class="line">            ALOGE(&quot;add_service(&apos;%s&apos;,%x) uid=%d - OUT OF MEMORY/n&quot;,</span><br><span class="line">                 str8(s, len), handle, uid);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        //拷贝内存服务信息</span><br><span class="line">        memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t));</span><br><span class="line">        si-&gt;name[len] = &apos;/0&apos;;</span><br><span class="line">        si-&gt;death.func = (void*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;dumpsys_priority = dumpsys_priority;</span><br><span class="line">        si-&gt;next = svclist; //svclist保存所有已经注册的服务</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line">    //BC_ACQUIRE为命令，handle为目标的信息通过ioct发送给binder驱动</span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    //BC_REQUEST_DEATH_NOTIFICATION为命令的信息通过ioct发送给binder驱动</span><br><span class="line">    //主要用于清理内存等收尾工作</span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-binder-send-reply"><a href="#5-4-binder-send-reply" class="headerlink" title="5.4 binder_send_reply"></a>5.4 binder_send_reply</h3><p>[-&gt;servicemanager/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void binder_send_reply(struct binder_state *bs,</span><br><span class="line">                       struct binder_io *reply,</span><br><span class="line">                       binder_uintptr_t buffer_to_free,</span><br><span class="line">                       int status)</span><br><span class="line">&#123;</span><br><span class="line">    struct &#123;</span><br><span class="line">        uint32_t cmd_free;</span><br><span class="line">        binder_uintptr_t buffer;</span><br><span class="line">        uint32_t cmd_reply;</span><br><span class="line">        struct binder_transaction_data txn;</span><br><span class="line">    &#125; __attribute__((packed)) data;</span><br><span class="line"></span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER;</span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY;</span><br><span class="line">    data.txn.target.ptr = 0;</span><br><span class="line">    data.txn.cookie = 0;</span><br><span class="line">    data.txn.code = 0;</span><br><span class="line">    if (status) &#123;</span><br><span class="line">        data.txn.flags = TF_STATUS_CODE;</span><br><span class="line">        data.txn.data_size = sizeof(int);</span><br><span class="line">        data.txn.offsets_size = 0;</span><br><span class="line">        data.txn.data.ptr.buffer = (uintptr_t)&amp;status;</span><br><span class="line">        data.txn.data.ptr.offsets = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        data.txn.flags = 0;</span><br><span class="line">        data.txn.data_size = reply-&gt;data - reply-&gt;data0;</span><br><span class="line">        data.txn.offsets_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0);</span><br><span class="line">        data.txn.data.ptr.buffer = (uintptr_t)reply-&gt;data0;</span><br><span class="line">        data.txn.data.ptr.offsets = (uintptr_t)reply-&gt;offs0;</span><br><span class="line">    &#125;</span><br><span class="line">    //向Binder驱动写数据，见5.5</span><br><span class="line">    binder_write(bs, &amp;data, sizeof(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将BC_FREE_BUFFER和BC_REPLY发送给binder驱动，向client发送reply。</p>
<h3 id="5-5-binder-write"><a href="#5-5-binder-write" class="headerlink" title="5.5 binder_write"></a>5.5 binder_write</h3><p>[-&gt;servicemanager/binder.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int binder_write(struct binder_state *bs, void *data, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line">    int res;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = 0;</span><br><span class="line">    bwr.write_buffer = (uintptr_t) data;</span><br><span class="line">    bwr.read_size = 0;</span><br><span class="line">    bwr.read_consumed = 0;</span><br><span class="line">    bwr.read_buffer = 0;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    if (res &lt; 0) &#123;</span><br><span class="line">        fprintf(stderr,&quot;binder_write: ioctl failed (%s)/n&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里ioctl操作又回到驱动层，见第四节，流程和上面的一样，这里不再详细分析。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><h3 id="6-1-servicemanager启动流程"><a href="#6-1-servicemanager启动流程" class="headerlink" title="6.1 servicemanager启动流程"></a>6.1 servicemanager启动流程</h3><p>1.打开Binder启动，调用mmap方法分配128K的内存映射空间：binder_open</p>
<p>2.通知binder驱动，使其成为上下文管理者，整个系统只有一个：binder_become_context_manager</p>
<p>3.进入循环等待，等待Client请求：binder_loop</p>
<h3 id="6-2-addService核心过程"><a href="#6-2-addService核心过程" class="headerlink" title="6.2 addService核心过程"></a>6.2 addService核心过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void addService(String name, IBinder service) &#123;</span><br><span class="line">      //此处需要将Java层Parcel转换为Native层的Parcel</span><br><span class="line">      Parcel data = Parcel.obtain();</span><br><span class="line">      Parcel reply = Parcel.obtain();</span><br><span class="line">      data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">      data.writeString(name);</span><br><span class="line">      //见3.5节</span><br><span class="line">      data.writeStrongBinder(new JavaBBinder(env, obj));</span><br><span class="line">      data.writeInt(allowIsolated ? 1 : 0);</span><br><span class="line">      data.writeInt(dumpPriority);</span><br><span class="line">      //见3.7节</span><br><span class="line">      mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">      reply.recycle();</span><br><span class="line">      data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过创建JavaBBinder对象，将服务添加到ServiceManager中，和binder驱动的交互通过BpBinder.transact发送ADD_SERVICE_TRANSACTION实现添加，svclist保存所有已经注册的服务（包括服务名和handle信息）</p>
<h3 id="6-3-通信流程"><a href="#6-3-通信流程" class="headerlink" title="6.3 通信流程"></a>6.3 通信流程</h3><p>1.发起端进程向Binder Driver发送binder_ioct请求后，采用不断的循环talkWithDriver，此时线程处于阻塞状态，直到收到BR_TRANSACTION_COMPLETE命令才会结束该流程；</p>
<p>2.waitForResponse收到BR_TRANSACTION_COMPLETE命令后，则直接退出循环，不会再执行executeCommand方法，除六种其他命令外会执行该方法；</p>
<p>3.由于ServiceManager进程已经启动，并且有binder_loop一直在循环查询命令，当收到BR_TRANSACTION命令后，就开始处理addService过程。</p>
<p><img src="/2020/深入理解Binder机制2-注册服务addService/binder_addservice.PNG" alt="binder_addservice"></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>源码路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/ServiceManager.java</span><br><span class="line">frameworks/base/core/java/android/os/ServiceManagerNative.java</span><br><span class="line">frameworks/base/core/java/android/os/Parcel.java</span><br><span class="line">frameworks/base/core/java/android/os/BinderProxy.java</span><br><span class="line"></span><br><span class="line">frameworks/base/core/jni/android_os_Parcel.cpp</span><br><span class="line">frameworks/base/core/jni/android_util_Binder.cpp</span><br><span class="line">native/libs/binder/Parcel.cpp</span><br><span class="line">native/libs/binder/ProcessState.cpp</span><br><span class="line">native/libs/binder/BpBinder.cpp</span><br><span class="line">native/libs/binder/IPCThreadState.cpp</span><br><span class="line">native/cmds/servicemanager/binder.c</span><br><span class="line">native/cmds/servicemanager/service_manager.c</span><br><span class="line">native/cmds/servicemanager/servicemanager.rc</span><br><span class="line"></span><br><span class="line">kernel/include/linux/syscalls.h</span><br><span class="line">kernel/drivers/android/binder.c</span><br></pre></td></tr></table></figure>
      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Binder机制/" rel="tag">#Binder机制</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/深入理解Binder机制1-AIDL原理/" rel="next" title="深入理解Binder机制1-AIDL原理">
                <i class="fa fa-chevron-left"></i> 深入理解Binder机制1-AIDL原理
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/深入理解Binder机制3-获取服务getService/" rel="prev" title="深入理解Binder机制3-获取服务getService">
                深入理解Binder机制3-获取服务getService <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、ServiceManager启动"><span class="nav-text">二、ServiceManager启动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-mian"><span class="nav-text">2.1 mian</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-binder-open"><span class="nav-text">2.2 binder_open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-binder-become-context-manager"><span class="nav-text">2.3 binder_become_context_manager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-binder-loop"><span class="nav-text">2.4 binder_loop</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、注册服务"><span class="nav-text">三、注册服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-SM-addService"><span class="nav-text">3.1 SM.addService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-getIServiceManager"><span class="nav-text">3.2  getIServiceManager</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-Binder-allowBlocking"><span class="nav-text">3.2.1 Binder.allowBlocking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-getContextObject"><span class="nav-text">3.2.2 getContextObject</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-1-ProcessState-self"><span class="nav-text">3.2.2.1 ProcessState::self</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-2-PS-getContextObject"><span class="nav-text">3.2.2.2  PS.getContextObject</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-3-PS-getStrongProxyForHandle"><span class="nav-text">3.2.2.3 PS.getStrongProxyForHandle</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-javaObjectForIBinder"><span class="nav-text">3.2.3 javaObjectForIBinder</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-SMN-asInterface"><span class="nav-text">3.3 SMN.asInterface</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-ServiceManagerProxy"><span class="nav-text">3.3.1 ServiceManagerProxy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-SMP-addService"><span class="nav-text">3.4 SMP.addService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-writeStrongBinder-Java"><span class="nav-text">3.5 writeStrongBinder(Java)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-android-os-Parcel-writeStrongBinder"><span class="nav-text">3.5.1 android_os_Parcel_writeStrongBinder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-ibinderForJavaObject"><span class="nav-text">3.5.2 ibinderForJavaObject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-JavaBBinderHolder"><span class="nav-text">3.5.3 JavaBBinderHolder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-new-JavaBBinder"><span class="nav-text">3.5.4 new JavaBBinder</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-writeStrongBinder-C"><span class="nav-text">3.6 writeStrongBinder(C++)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-flatten-binder"><span class="nav-text">3.6.1 flatten_binder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-finish-flatten-binder"><span class="nav-text">3.6.2 finish_flatten_binder</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-BP-transact"><span class="nav-text">3.7 BP.transact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-android-os-BinderProxy-transact"><span class="nav-text">3.8  android_os_BinderProxy_transact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-BpBinder-transact"><span class="nav-text">3.9 BpBinder::transact</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-1-BpBinder-transact"><span class="nav-text">3.9.1 BpBinder::transact</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-2-new-IPCThreadState"><span class="nav-text">3.9.2 new IPCThreadState</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-IPC-transact"><span class="nav-text">3.10 IPC::transact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-IPC-writeTransactionData"><span class="nav-text">3.11  IPC::writeTransactionData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-12-IPC-waitForResponse"><span class="nav-text">3.12 IPC::waitForResponse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-13-IPC-talkWithDriver"><span class="nav-text">3.13 IPC::talkWithDriver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Binder-Driver"><span class="nav-text">四、Binder Driver</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-binder-ioctl"><span class="nav-text">4.1 binder_ioctl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-binder-get-thread"><span class="nav-text">4.1.1 binder_get_thread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-binder-get-thread-ilocked"><span class="nav-text">4.1.2 binder_get_thread_ilocked</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-binder-ioctl-write-read"><span class="nav-text">4.2 binder_ioctl_write_read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-binder-thread-write"><span class="nav-text">4.3  binder_thread_write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-binder-transaction"><span class="nav-text">4.4 binder_transaction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-binder-translate-binder"><span class="nav-text">4.4.1  binder_translate_binder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-binder-proc-transaction"><span class="nav-text">4.4.2  binder_proc_transaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-binder-inc-ref-for-node"><span class="nav-text">4.4.3 binder_inc_ref_for_node</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-binder-get-ref-for-node-olocked"><span class="nav-text">4.4.4 binder_get_ref_for_node_olocked</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-binder-thread-read"><span class="nav-text">4.5 binder_thread_read</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、ServiceManager进程"><span class="nav-text">五、ServiceManager进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-binder-parse"><span class="nav-text">5.1 binder_parse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-svcmgr-handler"><span class="nav-text">5.2 svcmgr_handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-do-add-service"><span class="nav-text">5.3 do_add_service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-binder-send-reply"><span class="nav-text">5.4 binder_send_reply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-binder-write"><span class="nav-text">5.5 binder_write</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、总结"><span class="nav-text">六、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-servicemanager启动流程"><span class="nav-text">6.1 servicemanager启动流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-addService核心过程"><span class="nav-text">6.2 addService核心过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-通信流程"><span class="nav-text">6.3 通信流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2020/深入理解Binder机制2-注册服务addService/';
      var disqus_title = "深入理解Binder机制2-注册服务addService";
      var disqus_url = 'http://zproo.github.io/2020/深入理解Binder机制2-注册服务addService/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
