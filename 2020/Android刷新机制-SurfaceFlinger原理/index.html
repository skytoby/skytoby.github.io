<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="SurfaceFlinger,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="一、概述SurfaceFlinger作为负责绘制应用UI的核心，Android平台所创建的Window都是由surface所支持，所有可见的surface渲染到显示设备都是通过SurfaceFlinger来完成的。 SurfaceFlinger进程是由init进程创建，运行在独立的SurfaceFlinger进程。Android应用进程必须和SurfaceFlinger进程交互，才能完成应用UI绘">
<meta name="keywords" content="SurfaceFlinger">
<meta property="og:type" content="article">
<meta property="og:title" content="Android刷新机制-SurfaceFlinger原理">
<meta property="og:url" content="http://zproo.github.io/2020/Android刷新机制-SurfaceFlinger原理/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="一、概述SurfaceFlinger作为负责绘制应用UI的核心，Android平台所创建的Window都是由surface所支持，所有可见的surface渲染到显示设备都是通过SurfaceFlinger来完成的。 SurfaceFlinger进程是由init进程创建，运行在独立的SurfaceFlinger进程。Android应用进程必须和SurfaceFlinger进程交互，才能完成应用UI绘">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-07-29T08:31:49.287Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android刷新机制-SurfaceFlinger原理">
<meta name="twitter:description" content="一、概述SurfaceFlinger作为负责绘制应用UI的核心，Android平台所创建的Window都是由surface所支持，所有可见的surface渲染到显示设备都是通过SurfaceFlinger来完成的。 SurfaceFlinger进程是由init进程创建，运行在独立的SurfaceFlinger进程。Android应用进程必须和SurfaceFlinger进程交互，才能完成应用UI绘">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2020/Android刷新机制-SurfaceFlinger原理/">

  <title> Android刷新机制-SurfaceFlinger原理 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/SurfaceFlinger/" rel="tag" title="SurfaceFlinger">SurfaceFlinger</a>
      
      </div>
      <h1>Android刷新机制-SurfaceFlinger原理</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2020-07-15T20:24:11+08:00" content="2020-07-15" title="2020-07-15 20:24:11">
          2020-07-15
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android刷新机制-SurfaceFlinger原理
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-07-15T20:24:11+08:00" content="2020-07-15">
              2020-07-15
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/Android刷新机制-SurfaceFlinger原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/Android刷新机制-SurfaceFlinger原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>SurfaceFlinger作为负责绘制应用UI的核心，Android平台所创建的Window都是由surface所支持，所有可见的surface渲染到显示设备都是通过SurfaceFlinger来完成的。</p>
<p>SurfaceFlinger进程是由init进程创建，运行在独立的SurfaceFlinger进程。Android应用进程必须和SurfaceFlinger进程交互，才能完成应用UI绘制到frameBuffer(帧缓冲区)，这里是通过IPC的方式进行通信的。</p>
<p>SurfaceComposerClient对象是一个比较重要的类，WMS通过该类中的mClient、mParent和SurfaceFlinger进行交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceComposerClient&gt;  mClient;</span><br><span class="line">wp&lt;IGraphicBufferProducer&gt;  mParent;</span><br></pre></td></tr></table></figure>
<p>每一个应用在SurfaceFlinger中都有一个client与之相对应，当应用执行onResume方法时流程如下：</p>
<p>1.WMS会请求SurfaceFlinger来绘制Surface；</p>
<p>2.SurfaceFlinger创建Layer；</p>
<p>3.一个生产者的Binder对象通过WMS传递给应用，因此应用可以直接向SurfaceFlinger发送帧消息。</p>
<h3 id="二、启动过程"><a href="#二、启动过程" class="headerlink" title="二、启动过程"></a>二、启动过程</h3><p>SurfaceFlinger启动是通过surfaceflinger.rc启动</p>
<p>[-&gt;native/services/surfaceflinger/surfaceflinger.rc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    class core animation</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc readproc</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/stune/foreground/tasks</span><br><span class="line">    socket pdx/system/vr/display/client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0</span><br><span class="line">    socket pdx/system/vr/display/manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0</span><br><span class="line">    socket pdx/system/vr/display/vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0</span><br></pre></td></tr></table></figure>
<p>SurfaceFlinger属于核心类，当SurfaceFlinger重启时会触发zygote重启，SurfaceFlinger服务启动是在其main函数中</p>
<h4 id="2-1-main"><a href="#2-1-main" class="headerlink" title="2.1 main"></a>2.1 main</h4><p>[-&gt;native/services/surfaceflinger/main_surfaceflinger.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">int main(int, char**) &#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">   </span><br><span class="line">    hardware::configureRpcThreadpool(1 /* maxThreads */,</span><br><span class="line">            false /* callerWillJoin */);</span><br><span class="line"></span><br><span class="line">    //启动图形处理服务</span><br><span class="line">    startGraphicsAllocatorService();</span><br><span class="line"></span><br><span class="line">    // When SF is launched in its own process, limit the number of</span><br><span class="line">    // binder threads to 4.</span><br><span class="line">    //最大binder线程池数的个数为4</span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);</span><br><span class="line"></span><br><span class="line">    // start the thread pool</span><br><span class="line">    // 开启线程池</span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    // instantiate surfaceflinger</span><br><span class="line">    // 创建SurfaceFlinger</span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = DisplayUtils::getInstance()-&gt;getSFInstance();</span><br><span class="line">     </span><br><span class="line">    setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    set_sched_policy(0, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    // Put most SurfaceFlinger threads in the system-background cpuset</span><br><span class="line">    // Keeps us from unnecessarily using big cores</span><br><span class="line">    // Do this after the binder thread pool init</span><br><span class="line">    if (cpusets_enabled()) set_cpuset_policy(0, SP_SYSTEM);</span><br><span class="line"></span><br><span class="line">    // initialize before clients can connect</span><br><span class="line">    //初始化</span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    // publish surface flinger</span><br><span class="line">    // 发布surface flinger</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false,</span><br><span class="line">                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);</span><br><span class="line"></span><br><span class="line">    // publish GpuService</span><br><span class="line">    // 发布Gpu服务</span><br><span class="line">    sp&lt;GpuService&gt; gpuservice = new GpuService();</span><br><span class="line">    sm-&gt;addService(String16(GpuService::SERVICE_NAME), gpuservice, false);</span><br><span class="line">    </span><br><span class="line">    //开始显示服务</span><br><span class="line">    startDisplayService(); // dependency on SF getting registered above</span><br><span class="line"></span><br><span class="line">    struct sched_param param = &#123;0&#125;;</span><br><span class="line">    param.sched_priority = 2;</span><br><span class="line">    if (sched_setscheduler(0, SCHED_FIFO, &amp;param) != 0) &#123;</span><br><span class="line">        ALOGE(&quot;Couldn&apos;t set SCHED_FIFO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // run surface flinger in this thread</span><br><span class="line">    // 运行在当前线程</span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的工作如下：</p>
<p>1.启动图形处理服务</p>
<p>2.开启线程池，最大binder线程池数的个数为4</p>
<p>3.设置surfacefinger进程为高优先级以及后台调度策略</p>
<p>4.创建SurfaceFlinger，并初始化</p>
<p>5.注册SurfaceFlinger服务和GpuService</p>
<p>6.开启显示服务，最后执行surfacefinger的run方法</p>
<h4 id="2-2-创建SurfaceFlinger"><a href="#2-2-创建SurfaceFlinger" class="headerlink" title="2.2 创建SurfaceFlinger"></a>2.2 创建SurfaceFlinger</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger* DisplayUtils::getSFInstance() &#123;</span><br><span class="line">    if (sUseExtendedImpls) &#123;</span><br><span class="line">        return new ExSurfaceFlinger();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return new SurfaceFlinger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[-&gt;G:/AOSP/native/services/surfaceflinger/SurfaceFlinger.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::SurfaceFlinger(SurfaceFlinger::SkipInitializationTag)</span><br><span class="line">      : BnSurfaceComposer(),</span><br><span class="line">        mTransactionFlags(0),</span><br><span class="line">        mTransactionPending(false),</span><br><span class="line">        mAnimTransactionPending(false),</span><br><span class="line">        mLayersRemoved(false),</span><br><span class="line">        mLayersAdded(false),</span><br><span class="line">        mRepaintEverything(0),</span><br><span class="line">        mBootTime(systemTime()),</span><br><span class="line">        mBuiltinDisplays(),</span><br><span class="line">        mVisibleRegionsDirty(false),</span><br><span class="line">        mGeometryInvalid(false),</span><br><span class="line">        mAnimCompositionPending(false),</span><br><span class="line">        mBootStage(BootStage::BOOTLOADER),</span><br><span class="line">        mActiveDisplays(0),</span><br><span class="line">        mBuiltInBitmask(0),</span><br><span class="line">        mPluggableBitmask(0),</span><br><span class="line">        mDebugRegion(0),</span><br><span class="line">        mDebugDDMS(0),</span><br><span class="line">        mDebugDisableHWC(0),</span><br><span class="line">        mDebugDisableTransformHint(0),</span><br><span class="line">        mDebugInSwapBuffers(0),</span><br><span class="line">        mLastSwapBufferTime(0),</span><br><span class="line">        mDebugInTransaction(0),</span><br><span class="line">        mLastTransactionTime(0),</span><br><span class="line">        mForceFullDamage(false),</span><br><span class="line">        mPrimaryDispSync(&quot;PrimaryDispSync&quot;),</span><br><span class="line">        mPrimaryHWVsyncEnabled(false),</span><br><span class="line">        mHWVsyncAvailable(false),</span><br><span class="line">        mHasPoweredOff(false),</span><br><span class="line">        mNumLayers(0),</span><br><span class="line">        mVrFlingerRequestsDisplay(false),</span><br><span class="line">        mMainThreadId(std::this_thread::get_id()),</span><br><span class="line">        mCreateBufferQueue(&amp;BufferQueue::createBufferQueue),</span><br><span class="line">        mCreateNativeWindowSurface(&amp;impl::NativeWindowSurface::create) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>SurfaceFlinger继承于BnSurfaceComposer，flinger的数据类型为sp强指针类型，当首次被强指针引用时会执行onFirstRef方法。</p>
<h5 id="2-2-1-onFirstRef"><a href="#2-2-1-onFirstRef" class="headerlink" title="2.2.1 onFirstRef"></a>2.2.1 onFirstRef</h5><p>[-&gt;G:/AOSP/native/services/surfaceflinger/SurfaceFlinger.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    mEventQueue-&gt;init(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-2-MQ-init"><a href="#2-2-2-MQ-init" class="headerlink" title="2.2.2  MQ.init"></a>2.2.2  MQ.init</h5><p>[-&gt;G:/AOSP/native/services/surfaceflinger/MessageQueue.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger) &#123;</span><br><span class="line">    mFlinger = flinger;</span><br><span class="line">    mLooper = new Looper(true);</span><br><span class="line">    mHandler = new Handler(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handler是MessageQueue的内部类，native层的handler机制和java层的一样</p>
<h4 id="2-3-SF-init"><a href="#2-3-SF-init" class="headerlink" title="2.3 SF.init"></a>2.3 SF.init</h4><p>[-&gt;native/services/surfaceflinger/SurfaceFlinger.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">// Do not call property_set on main thread which will be blocked by init</span><br><span class="line">// Use StartPropertySetThread instead.</span><br><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ALOGI(  &quot;SurfaceFlinger&apos;s main thread ready to run. &quot;</span><br><span class="line">            &quot;Initializing graphics H/W...&quot;);</span><br><span class="line"></span><br><span class="line">    ALOGI(&quot;Phase offest NS: %&quot; PRId64 &quot;&quot;, vsyncPhaseOffsetNs);</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    // start the EventThread</span><br><span class="line">    // 启动app和sf的两个EventThread线程</span><br><span class="line">    mEventThreadSource =</span><br><span class="line">            std::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs,</span><br><span class="line">                                             true, &quot;app&quot;);</span><br><span class="line">    mEventThread = std::make_unique&lt;impl::EventThread&gt;(mEventThreadSource.get(),</span><br><span class="line">                                                       [this]() &#123; resyncWithRateLimit(); &#125;,</span><br><span class="line">                                                       impl::EventThread::InterceptVSyncsCallback(),</span><br><span class="line">                                                       &quot;appEventThread&quot;);</span><br><span class="line">    mSfEventThreadSource =</span><br><span class="line">            std::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync,</span><br><span class="line">                                             SurfaceFlinger::sfVsyncPhaseOffsetNs, true, &quot;sf&quot;);</span><br><span class="line"></span><br><span class="line">    mSFEventThread =</span><br><span class="line">            std::make_unique&lt;impl::EventThread&gt;(mSfEventThreadSource.get(),</span><br><span class="line">                                                [this]() &#123; resyncWithRateLimit(); &#125;,</span><br><span class="line">                                                [this](nsecs_t timestamp) &#123;</span><br><span class="line">                                                    mInterceptor-&gt;saveVSyncEvent(timestamp);</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                &quot;sfEventThread&quot;);</span><br><span class="line">    mEventQueue-&gt;setEventThread(mSFEventThread.get());</span><br><span class="line">    mVsyncModulator.setEventThreads(mSFEventThread.get(), mEventThread.get());</span><br><span class="line"></span><br><span class="line">    // Get a RenderEngine for the given display / config (can&apos;t fail)</span><br><span class="line">    // 获取渲染引擎</span><br><span class="line">    getBE().mRenderEngine =</span><br><span class="line">            RE::impl::RenderEngine::create(HAL_PIXEL_FORMAT_RGBA_8888,</span><br><span class="line">                                           hasWideColorDisplay</span><br><span class="line">                                                   ? RE::RenderEngine::WIDE_COLOR_SUPPORT</span><br><span class="line">                                                   : 0);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(getBE().mRenderEngine == nullptr, &quot;couldn&apos;t create RenderEngine&quot;);</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mVrFlingerRequestsDisplay,</span><br><span class="line">            &quot;Starting with vr flinger active is not currently supported.&quot;);</span><br><span class="line">    //创建HWComposer</span><br><span class="line">    getBE().mHwc.reset(</span><br><span class="line">            new HWComposer(std::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName)));</span><br><span class="line">    //注册回调</span><br><span class="line">    getBE().mHwc-&gt;registerCallback(this, getBE().mComposerSequenceId);</span><br><span class="line">    // Process any initial hotplug and resulting display changes.</span><br><span class="line">    //处理热插拔的显示设备</span><br><span class="line">    processDisplayHotplugEventsLocked();</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!getBE().mHwc-&gt;isConnected(HWC_DISPLAY_PRIMARY),</span><br><span class="line">            &quot;Registered composer callback but didn&apos;t create the default primary display&quot;);</span><br><span class="line"></span><br><span class="line">    // make the default display GLContext current so that we can create textures</span><br><span class="line">    // when creating Layers (which may happens before we render something)</span><br><span class="line">    getDefaultDisplayDeviceLocked()-&gt;makeCurrent();</span><br><span class="line"></span><br><span class="line">    if (useVrFlinger) &#123;</span><br><span class="line">        auto vrFlingerRequestDisplayCallback = [this] (bool requestDisplay) &#123;</span><br><span class="line">            // This callback is called from the vr flinger dispatch thread. We</span><br><span class="line">            // need to call signalTransaction(), which requires holding</span><br><span class="line">            // mStateLock when we&apos;re not on the main thread. Acquiring</span><br><span class="line">            // mStateLock from the vr flinger dispatch thread might trigger a</span><br><span class="line">            // deadlock in surface flinger (see b/66916578), so post a message</span><br><span class="line">            // to be handled on the main thread instead.</span><br><span class="line">            sp&lt;LambdaMessage&gt; message = new LambdaMessage([=]() &#123;</span><br><span class="line">                ALOGI(&quot;VR request display mode: requestDisplay=%d&quot;, requestDisplay);</span><br><span class="line">                mVrFlingerRequestsDisplay = requestDisplay;</span><br><span class="line">                signalTransaction();</span><br><span class="line">            &#125;);</span><br><span class="line">            postMessageAsync(message);</span><br><span class="line">        &#125;;</span><br><span class="line">        mVrFlinger = dvr::VrFlinger::Create(getBE().mHwc-&gt;getComposer(),</span><br><span class="line">                getBE().mHwc-&gt;getHwcDisplayId(HWC_DISPLAY_PRIMARY).value_or(0),</span><br><span class="line">                vrFlingerRequestDisplayCallback);</span><br><span class="line">        if (!mVrFlinger) &#123;</span><br><span class="line">            ALOGE(&quot;Failed to start vrflinger&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //EventControl线程</span><br><span class="line">    mEventControlThread = std::make_unique&lt;impl::EventControlThread&gt;(</span><br><span class="line">            [this](bool enabled) &#123; setVsyncEnabled(HWC_DISPLAY_PRIMARY, enabled); &#125;);</span><br><span class="line"></span><br><span class="line">    // initialize our drawing state</span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    // set initial conditions (e.g. unblank default device)</span><br><span class="line">    //初始化显示设备</span><br><span class="line">    initializeDisplays();</span><br><span class="line"></span><br><span class="line">    getBE().mRenderEngine-&gt;primeCache();</span><br><span class="line"></span><br><span class="line">    // Inform native graphics APIs whether the present timestamp is supported:</span><br><span class="line">    if (getHwComposer().hasCapability(</span><br><span class="line">            HWC2::Capability::PresentFenceIsNotReliable)) &#123;</span><br><span class="line">        mStartPropertySetThread = new StartPropertySetThread(false);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mStartPropertySetThread = new StartPropertySetThread(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mStartPropertySetThread-&gt;Start() != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(&quot;Run StartPropertySetThread failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // This is a hack. Per definition of getDataspaceSaturationMatrix, the returned matrix</span><br><span class="line">    // is used to saturate legacy sRGB content. However, to make sure the same color under</span><br><span class="line">    // Display P3 will be saturated to the same color, we intentionally break the API spec</span><br><span class="line">    // and apply this saturation matrix on Display P3 content. Unless the risk of applying</span><br><span class="line">    // such saturation matrix on Display P3 is understood fully, the API should always return</span><br><span class="line">    // identify matrix.</span><br><span class="line">    mEnhancedSaturationMatrix = getBE().mHwc-&gt;getDataspaceSaturationMatrix(HWC_DISPLAY_PRIMARY,</span><br><span class="line">            Dataspace::SRGB_LINEAR);</span><br><span class="line"></span><br><span class="line">    // we will apply this on Display P3.</span><br><span class="line">    if (mEnhancedSaturationMatrix != mat4()) &#123;</span><br><span class="line">        ColorSpace srgb(ColorSpace::sRGB());</span><br><span class="line">        ColorSpace displayP3(ColorSpace::DisplayP3());</span><br><span class="line">        mat4 srgbToP3 = mat4(ColorSpaceConnector(srgb, displayP3).getTransform());</span><br><span class="line">        mat4 p3ToSrgb = mat4(ColorSpaceConnector(displayP3, srgb).getTransform());</span><br><span class="line">        mEnhancedSaturationMatrix = srgbToP3 * mEnhancedSaturationMatrix * p3ToSrgb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBuiltInBitmask.set(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    for (int disp = HWC_DISPLAY_BUILTIN_2; disp &lt;= HWC_DISPLAY_BUILTIN_4; disp++) &#123;</span><br><span class="line">      mBuiltInBitmask.set(disp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPluggableBitmask.set(HWC_DISPLAY_EXTERNAL);</span><br><span class="line">    for (int disp = HWC_DISPLAY_EXTERNAL_2; disp &lt;= HWC_DISPLAY_EXTERNAL_4; disp++) &#123;</span><br><span class="line">      mPluggableBitmask.set(disp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;Done initializing&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-1-创建HWComposer"><a href="#2-3-1-创建HWComposer" class="headerlink" title="2.3.1 创建HWComposer"></a>2.3.1 创建HWComposer</h5><p>[-&gt;native/services/surfaceflinger/DisplayHardware/HWComposer.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(std::unique_ptr&lt;android::Hwc2::Composer&gt; composer)</span><br><span class="line">      : mHwcDevice(std::make_unique&lt;HWC2::Device&gt;(std::move(composer))) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-2-processDisplayHotplugEventsLocked"><a href="#2-3-2-processDisplayHotplugEventsLocked" class="headerlink" title="2.3.2 processDisplayHotplugEventsLocked"></a>2.3.2 processDisplayHotplugEventsLocked</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::processDisplayHotplugEventsLocked() &#123;</span><br><span class="line">    //遍历连接的设置</span><br><span class="line">    for (const auto&amp; event : mPendingHotplugEvents) &#123;</span><br><span class="line">        auto displayType = determineDisplayType(event.display, event.connection);</span><br><span class="line">        if (displayType == DisplayDevice::DISPLAY_ID_INVALID) &#123;</span><br><span class="line">            ALOGW(&quot;Unable to determine the display type for display %&quot; PRIu64, event.display);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (getBE().mHwc-&gt;isUsingVrComposer() &amp;&amp; displayType == DisplayDevice::DISPLAY_EXTERNAL) &#123;</span><br><span class="line">            ALOGE(&quot;External displays are not supported by the vr hardware composer.&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!getBE().mHwc-&gt;onHotplug(event.display, displayType, event.connection)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (event.connection == HWC2::Connection::Connected) &#123;</span><br><span class="line">            if (!mBuiltinDisplays[displayType].get()) &#123;</span><br><span class="line">                ALOGV(&quot;Creating built in display %d&quot;, displayType);</span><br><span class="line">                mBuiltinDisplays[displayType] = new BBinder();</span><br><span class="line">                // All non-virtual displays are currently considered secure.</span><br><span class="line">                DisplayDeviceState info(displayType, true);</span><br><span class="line">                info.displayName = displayType == DisplayDevice::DISPLAY_PRIMARY ?</span><br><span class="line">                        &quot;Built-in Screen&quot; : &quot;External Screen&quot;;</span><br><span class="line">                mCurrentState.displays.add(mBuiltinDisplays[displayType], info);</span><br><span class="line">                mInterceptor-&gt;saveDisplayCreation(info);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGV(&quot;Removing built in display %d&quot;, displayType);</span><br><span class="line"></span><br><span class="line">            ssize_t idx = mCurrentState.displays.indexOfKey(mBuiltinDisplays[displayType]);</span><br><span class="line">            if (idx &gt;= 0) &#123;</span><br><span class="line">                const DisplayDeviceState&amp; info(mCurrentState.displays.valueAt(idx));</span><br><span class="line">                mInterceptor-&gt;saveDisplayDeletion(info.displayId);</span><br><span class="line">                mCurrentState.displays.removeItemsAt(idx);</span><br><span class="line">            &#125;</span><br><span class="line">            mBuiltinDisplays[displayType].clear();</span><br><span class="line">            if ((event.display &gt;= 0) &amp;&amp;</span><br><span class="line">                (event.display &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES)) &#123;</span><br><span class="line">                // Display no longer exists.</span><br><span class="line">                mActiveDisplays.reset(event.display);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        processDisplayChangesLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPendingHotplugEvents.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里遍历连接的显示设备，这里的显示设置主要分成3类：主设备，拓展设备，虚拟设备，具体的处理操作在processDisplayChangesLocked函数中，见2.4.3节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum DisplayType &#123;</span><br><span class="line">       DISPLAY_ID_INVALID = -1,</span><br><span class="line">       DISPLAY_PRIMARY     = HWC_DISPLAY_PRIMARY,</span><br><span class="line">       DISPLAY_EXTERNAL    = HWC_DISPLAY_EXTERNAL,</span><br><span class="line">       DISPLAY_VIRTUAL     = HWC_DISPLAY_VIRTUAL,</span><br><span class="line">       NUM_BUILTIN_DISPLAY_TYPES = HWC_NUM_PHYSICAL_DISPLAY_TYPES,</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-3-processDisplayChangesLocked"><a href="#2-3-3-processDisplayChangesLocked" class="headerlink" title="2.3.3 processDisplayChangesLocked"></a>2.3.3 processDisplayChangesLocked</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::processDisplayChangesLocked() &#123;</span><br><span class="line">    // here we take advantage of Vector&apos;s copy-on-write semantics to</span><br><span class="line">    // improve performance by skipping the transaction entirely when</span><br><span class="line">    // know that the lists are identical</span><br><span class="line">    const KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays);</span><br><span class="line">    const KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays);</span><br><span class="line">    if (!curr.isIdenticalTo(draw)) &#123;</span><br><span class="line">        mVisibleRegionsDirty = true;</span><br><span class="line">        const size_t cc = curr.size();</span><br><span class="line">        size_t dc = draw.size();</span><br><span class="line"></span><br><span class="line">        // find the displays that were removed</span><br><span class="line">        // (ie: in drawing state but not in current state)</span><br><span class="line">        // also handle displays that changed</span><br><span class="line">        // (ie: displays that are in both lists)</span><br><span class="line">        for (size_t i = 0; i &lt; dc;) &#123;</span><br><span class="line">            const ssize_t j = curr.indexOfKey(draw.keyAt(i));</span><br><span class="line">            if (j &lt; 0) &#123;</span><br><span class="line">                // in drawing state but not in current state</span><br><span class="line">                // Call makeCurrent() on the primary display so we can</span><br><span class="line">                // be sure that nothing associated with this display</span><br><span class="line">                // is current.</span><br><span class="line">                const sp&lt;const DisplayDevice&gt; defaultDisplay(getDefaultDisplayDeviceLocked());</span><br><span class="line">                if (defaultDisplay != nullptr) defaultDisplay-&gt;makeCurrent();</span><br><span class="line">                sp&lt;DisplayDevice&gt; hw(getDisplayDeviceLocked(draw.keyAt(i)));</span><br><span class="line">                if (hw != nullptr) hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                if (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES)</span><br><span class="line">                    mEventThread-&gt;onHotplugReceived(draw[i].type, false);</span><br><span class="line">                mDisplays.removeItem(draw.keyAt(i));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // this display is in both lists. see if something changed.</span><br><span class="line">                const DisplayDeviceState&amp; state(curr[j]);</span><br><span class="line">                const wp&lt;IBinder&gt;&amp; display(curr.keyAt(j));</span><br><span class="line">                const sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface);</span><br><span class="line">                const sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface);</span><br><span class="line">                if (state_binder != draw_binder) &#123;</span><br><span class="line">                    // changing the surface is like destroying and</span><br><span class="line">                    // recreating the DisplayDevice, so we just remove it</span><br><span class="line">                    // from the drawing state, so that it get re-added</span><br><span class="line">                    // below.</span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw(getDisplayDeviceLocked(display));</span><br><span class="line">                    if (hw != nullptr) hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    mDisplays.removeItem(display);</span><br><span class="line">                    mDrawingState.displays.removeItemsAt(i);</span><br><span class="line">                    dc--;</span><br><span class="line">                    // at this point we must loop to the next item</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const sp&lt;DisplayDevice&gt; disp(getDisplayDeviceLocked(display));</span><br><span class="line">                if (disp != nullptr) &#123;</span><br><span class="line">                    if (state.layerStack != draw[i].layerStack) &#123;</span><br><span class="line">                        disp-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if ((state.orientation != draw[i].orientation) ||</span><br><span class="line">                        (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) &#123;</span><br><span class="line">                        disp-&gt;setProjection(state.orientation, state.viewport, state.frame);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (state.width != draw[i].width || state.height != draw[i].height) &#123;</span><br><span class="line">                        disp-&gt;setDisplaySize(state.width, state.height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // find displays that were added</span><br><span class="line">        // (ie: in current state but not in drawing state)</span><br><span class="line">        for (size_t i = 0; i &lt; cc; i++) &#123;</span><br><span class="line">            if (draw.indexOfKey(curr.keyAt(i)) &lt; 0) &#123;</span><br><span class="line">                const DisplayDeviceState&amp; state(curr[i]);</span><br><span class="line"></span><br><span class="line">                sp&lt;DisplaySurface&gt; dispSurface;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; bqProducer;</span><br><span class="line">                sp&lt;IGraphicBufferConsumer&gt; bqConsumer;</span><br><span class="line">                //创建BufferQueue的生产者和消费者</span><br><span class="line">                mCreateBufferQueue(&amp;bqProducer, &amp;bqConsumer, false);</span><br><span class="line"></span><br><span class="line">                int32_t hwcId = -1;</span><br><span class="line">                if (state.isVirtualDisplay()) &#123;</span><br><span class="line">                    // Virtual displays without a surface are dormant:</span><br><span class="line">                    // they have external state (layer stack, projection,</span><br><span class="line">                    // etc.) but no internal state (i.e. a DisplayDevice).</span><br><span class="line">                    if (state.surface != nullptr) &#123;</span><br><span class="line">                        // Allow VR composer to use virtual displays.</span><br><span class="line">                        if (mUseHwcVirtualDisplays || getBE().mHwc-&gt;isUsingVrComposer()) &#123;</span><br><span class="line">                            DisplayUtils *displayUtils = DisplayUtils::getInstance();</span><br><span class="line">                            int width = 0;</span><br><span class="line">                            int status = state.surface-&gt;query(NATIVE_WINDOW_WIDTH, &amp;width);</span><br><span class="line">                            ALOGE_IF(status != NO_ERROR, &quot;Unable to query width (%d)&quot;, status);</span><br><span class="line">                            int height = 0;</span><br><span class="line">                            status = state.surface-&gt;query(NATIVE_WINDOW_HEIGHT, &amp;height);</span><br><span class="line">                            ALOGE_IF(status != NO_ERROR, &quot;Unable to query height (%d)&quot;, status);</span><br><span class="line">                            int intFormat = 0;</span><br><span class="line">                            status = state.surface-&gt;query(NATIVE_WINDOW_FORMAT, &amp;intFormat);</span><br><span class="line">                            ALOGE_IF(status != NO_ERROR, &quot;Unable to query format (%d)&quot;, status);</span><br><span class="line">                            auto format = static_cast&lt;ui::PixelFormat&gt;(intFormat);</span><br><span class="line"></span><br><span class="line">                            if (maxVirtualDisplaySize == 0 ||</span><br><span class="line">                                 ( (uint64_t)width &lt;= maxVirtualDisplaySize &amp;&amp;</span><br><span class="line">                                 (uint64_t)height &lt;= maxVirtualDisplaySize)) &#123;</span><br><span class="line">                                uint64_t usage = 0;</span><br><span class="line">                                // Replace with native_window_get_consumer_usage ?</span><br><span class="line">                                status = state.surface-&gt;getConsumerUsage(&amp;usage);</span><br><span class="line">                                ALOGW_IF(status != NO_ERROR, &quot;Unable to query usage (%d)&quot;, status);</span><br><span class="line">                                if ( (status == NO_ERROR) &amp;&amp;</span><br><span class="line">                                     displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123;</span><br><span class="line">                                    getBE().mHwc-&gt;allocateVirtualDisplay(</span><br><span class="line">                                            width, height, &amp;format, &amp;hwcId);</span><br><span class="line">                                 &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // TODO: Plumb requested format back up to consumer</span><br><span class="line">                        DisplayUtils::getInstance()-&gt;initVDSInstance(*getBE().mHwc,</span><br><span class="line">                                                        hwcId, state.surface,</span><br><span class="line">                                                        dispSurface, producer,</span><br><span class="line">                                                        bqProducer, bqConsumer,</span><br><span class="line">                                                        state.displayName, state.isSecure);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ALOGE_IF(state.surface != nullptr,</span><br><span class="line">                             &quot;adding a supported display, but rendering &quot;</span><br><span class="line">                             &quot;surface is provided (%p), ignoring it&quot;,</span><br><span class="line">                             state.surface.get());</span><br><span class="line"></span><br><span class="line">                    hwcId = state.type;</span><br><span class="line">                    dispSurface = new FramebufferSurface(*getBE().mHwc, hwcId, bqConsumer);</span><br><span class="line">                    producer = bqProducer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const wp&lt;IBinder&gt;&amp; display(curr.keyAt(i));</span><br><span class="line">                if (dispSurface != nullptr) &#123;</span><br><span class="line">                    mDisplays.add(display,</span><br><span class="line">                                  setupNewDisplayDeviceInternal(display, hwcId, state, dispSurface,</span><br><span class="line">                                                                producer));</span><br><span class="line">                    if (!state.isVirtualDisplay()) &#123;</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(state.type, true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.displays = mCurrentState.displays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-4-initializeDisplays"><a href="#2-3-4-initializeDisplays" class="headerlink" title="2.3.4 initializeDisplays"></a>2.3.4 initializeDisplays</h5><p>[-&gt;native/services/surfaceflinger/SurfaceFlinger.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::initializeDisplays() &#123;</span><br><span class="line">    class MessageScreenInitialized : public MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">    public:</span><br><span class="line">        explicit MessageScreenInitialized(SurfaceFlinger* flinger) : flinger(flinger) &#123; &#125;</span><br><span class="line">        virtual bool handler() &#123;</span><br><span class="line">            flinger-&gt;onInitializeDisplays();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    sp&lt;MessageBase&gt; msg = new MessageScreenInitialized(this);</span><br><span class="line">    postMessageAsync(msg);  // we may be called from main thread, use async message</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::onInitializeDisplays() &#123;</span><br><span class="line">    // reset screen orientation and use primary layer stack</span><br><span class="line">    Vector&lt;ComposerState&gt; state;</span><br><span class="line">    Vector&lt;DisplayState&gt; displays;</span><br><span class="line">    DisplayState d;</span><br><span class="line">    d.what = DisplayState::eDisplayProjectionChanged |</span><br><span class="line">             DisplayState::eLayerStackChanged;</span><br><span class="line">    d.token = mBuiltinDisplays[DisplayDevice::DISPLAY_PRIMARY];</span><br><span class="line">    d.layerStack = 0;</span><br><span class="line">    d.orientation = DisplayState::eOrientationDefault;</span><br><span class="line">    d.frame.makeInvalid();</span><br><span class="line">    d.viewport.makeInvalid();</span><br><span class="line">    d.width = 0;</span><br><span class="line">    d.height = 0;</span><br><span class="line">    displays.add(d);</span><br><span class="line">    setTransactionState(state, displays, 0);</span><br><span class="line">    setPowerModeInternal(getDisplayDevice(d.token), HWC_POWER_MODE_NORMAL,</span><br><span class="line">                         /*stateLockHeld*/ false);</span><br><span class="line"></span><br><span class="line">    const auto&amp; activeConfig = getBE().mHwc-&gt;getActiveConfig(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    const nsecs_t period = activeConfig-&gt;getVsyncPeriod();</span><br><span class="line">    mAnimFrameTracker.setDisplayRefreshPeriod(period);</span><br><span class="line"></span><br><span class="line">    // Use phase of 0 since phase is not known.</span><br><span class="line">    // Use latency of 0, which will snap to the ideal latency.</span><br><span class="line">    setCompositorTimingSnapped(0, period, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过handler发送消息，进行显示设备的初始化操作。</p>
<h4 id="2-4-EventThread线程"><a href="#2-4-EventThread线程" class="headerlink" title="2.4 EventThread线程"></a>2.4 EventThread线程</h4><p>[-&gt;native/services/surfaceflinger/EventThread.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">EventThread::EventThread(VSyncSource* src, ResyncWithRateLimitCallback resyncWithRateLimitCallback,</span><br><span class="line">                         InterceptVSyncsCallback interceptVSyncsCallback, const char* threadName)</span><br><span class="line">      : mVSyncSource(src),</span><br><span class="line">        mResyncWithRateLimitCallback(resyncWithRateLimitCallback),</span><br><span class="line">        mInterceptVSyncsCallback(interceptVSyncsCallback) &#123;</span><br><span class="line">    for (auto&amp; event : mVSyncEvent) &#123;</span><br><span class="line">        event.header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        event.header.id = 0;</span><br><span class="line">        event.header.timestamp = 0;</span><br><span class="line">        event.vsync.count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mThread = std::thread(&amp;EventThread::threadMain, this);</span><br><span class="line"></span><br><span class="line">    pthread_setname_np(mThread.native_handle(), threadName);</span><br><span class="line"></span><br><span class="line">    pid_t tid = pthread_gettid_np(mThread.native_handle());</span><br><span class="line"></span><br><span class="line">    // Use SCHED_FIFO to minimize jitter</span><br><span class="line">    constexpr int EVENT_THREAD_PRIORITY = 2;</span><br><span class="line">    struct sched_param param = &#123;0&#125;;</span><br><span class="line">    param.sched_priority = EVENT_THREAD_PRIORITY;</span><br><span class="line">    if (pthread_setschedparam(mThread.native_handle(), SCHED_FIFO, &amp;param) != 0) &#123;</span><br><span class="line">        ALOGE(&quot;Couldn&apos;t set SCHED_FIFO for EventThread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_sched_policy(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventThread继承于VSyncSource::Callback</p>
<h5 id="2-4-1-onFirstRef"><a href="#2-4-1-onFirstRef" class="headerlink" title="2.4.1 onFirstRef"></a>2.4.1 onFirstRef</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void EventThread::Connection::onFirstRef() &#123;</span><br><span class="line">    // NOTE: mEventThread doesn&apos;t hold a strong reference on us</span><br><span class="line">    mEventThread-&gt;registerDisplayEventConnection(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册显示设备事件</p>
<h5 id="2-4-2-threadMain"><a href="#2-4-2-threadMain" class="headerlink" title="2.4.2 threadMain"></a>2.4.2 threadMain</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void EventThread::threadMain() NO_THREAD_SAFETY_ANALYSIS &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock(mMutex);</span><br><span class="line">    while (mKeepRunning) &#123;</span><br><span class="line">        DisplayEventReceiver::Event event;</span><br><span class="line">        Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">        //见2.4.3节</span><br><span class="line">        signalConnections = waitForEventLocked(&amp;lock, &amp;event);</span><br><span class="line"></span><br><span class="line">        // dispatch events to listeners...</span><br><span class="line">        const size_t count = signalConnections.size();</span><br><span class="line">        for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            const sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">            // now see if we still need to report this event</span><br><span class="line">            //分发事件</span><br><span class="line">            status_t err = conn-&gt;</span><br><span class="line">            postEvent(event);</span><br><span class="line">            if (err == -EAGAIN || err == -EWOULDBLOCK) &#123;</span><br><span class="line">                // The destination doesn&apos;t accept events anymore, it&apos;s probably</span><br><span class="line">                // full. For now, we just drop the events on the floor.</span><br><span class="line">                // FIXME: Note that some events cannot be dropped and would have</span><br><span class="line">                // to be re-sent later.</span><br><span class="line">                // Right-now we don&apos;t have the ability to do this.</span><br><span class="line">                ALOGW(&quot;EventThread: dropping event (%08x) for connection %p&quot;, event.header.type,</span><br><span class="line">                      conn.get());</span><br><span class="line">            &#125; else if (err &lt; 0) &#123;</span><br><span class="line">                // handle any other error on the pipe as fatal. the only</span><br><span class="line">                // reasonable thing to do is to clean-up this connection.</span><br><span class="line">                // The most common error we&apos;ll get here is -EPIPE.</span><br><span class="line">                //清除连接</span><br><span class="line">                removeDisplayEventConnectionLocked(signalConnections[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-4-3-waitForEventLocked"><a href="#2-4-3-waitForEventLocked" class="headerlink" title="2.4.3 waitForEventLocked"></a>2.4.3 waitForEventLocked</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">// This will return when (1) a vsync event has been received, and (2) there was</span><br><span class="line">// at least one connection interested in receiving it when we started waiting.</span><br><span class="line">Vector&lt;sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEventLocked(</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt;* lock, DisplayEventReceiver::Event* event) &#123;</span><br><span class="line">    Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    while (signalConnections.isEmpty() &amp;&amp; mKeepRunning) &#123;</span><br><span class="line">        bool eventPending = false;</span><br><span class="line">        bool waitForVSync = false;</span><br><span class="line"></span><br><span class="line">        size_t vsyncCount = 0;</span><br><span class="line">        nsecs_t timestamp = 0;</span><br><span class="line">        for (int32_t i = 0; i &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES; i++) &#123;</span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line">            if (timestamp) &#123;</span><br><span class="line">                // we have a vsync event to dispatch</span><br><span class="line">                if (mInterceptVSyncsCallback) &#123;</span><br><span class="line">                    mInterceptVSyncsCallback(timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                *event = mVSyncEvent[i];</span><br><span class="line">                mVSyncEvent[i].header.timestamp = 0;</span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // find out connections waiting for events</span><br><span class="line">        size_t count = mDisplayEventConnections.size();</span><br><span class="line">        if (!timestamp &amp;&amp; count) &#123;</span><br><span class="line">            // no vsync event, see if there are some other event</span><br><span class="line">            // 没有vsync事件查看其他事件</span><br><span class="line">            eventPending = !mPendingEvents.isEmpty();</span><br><span class="line">            if (eventPending) &#123;</span><br><span class="line">                // we have some other event to dispatch</span><br><span class="line">                *event = mPendingEvents[0];</span><br><span class="line">                mPendingEvents.removeAt(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (size_t i = 0; i &lt; count;) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection(mDisplayEventConnections[i].promote());</span><br><span class="line">            if (connection != nullptr) &#123;</span><br><span class="line">                bool added = false;</span><br><span class="line">                if (connection-&gt;count &gt;= 0) &#123;</span><br><span class="line">                    // we need vsync events because at least</span><br><span class="line">                    // one connection is waiting for it</span><br><span class="line">                    //需要vysnc事件，因为至少需要一个连接正在等待vsync</span><br><span class="line">                    waitForVSync = true;</span><br><span class="line">                    if (timestamp) &#123;</span><br><span class="line">                        // we consume the event only if it&apos;s time</span><br><span class="line">                        // (ie: we received a vsync event)</span><br><span class="line">                        if (connection-&gt;count == 0) &#123;</span><br><span class="line">                            // fired this time around</span><br><span class="line">                            connection-&gt;count = -1;</span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added = true;</span><br><span class="line">                        &#125; else if (connection-&gt;count == 1 ||</span><br><span class="line">                                   (vsyncCount % connection-&gt;count) == 0) &#123;</span><br><span class="line">                            // continuous event, and time to report it</span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    // we don&apos;t have a vsync event to process</span><br><span class="line">                    // (timestamp==0), but we have some pending</span><br><span class="line">                    // messages.</span><br><span class="line">                    signalConnections.add(connection);</span><br><span class="line">                &#125;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // we couldn&apos;t promote this reference, the connection has</span><br><span class="line">                // died, so clean-up!</span><br><span class="line">                mDisplayEventConnections.removeAt(i);</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Here we figure out if we need to enable or disable vsyncs</span><br><span class="line">        if (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line">            // we received a VSYNC but we have no clients</span><br><span class="line">            // don&apos;t report it, and disable VSYNC events</span><br><span class="line">            //接收Vsync，但没有client需要它，则直接关闭VYSNC</span><br><span class="line">            disableVSyncLocked();</span><br><span class="line">        &#125; else if (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            // we have at least one client, so we want vsync enabled</span><br><span class="line">            // (TODO: this function is called right after we finish</span><br><span class="line">            // notifying clients of a vsync, so this call will be made</span><br><span class="line">            // at the vsync rate, e.g. 60fps.  If we can accurately</span><br><span class="line">            // track the current state we could avoid making this call</span><br><span class="line">            // so often.)</span><br><span class="line">            //至少存在一个Client，则需要使能VSYNC</span><br><span class="line">            enableVSyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // note: !timestamp implies signalConnections.isEmpty(), because we</span><br><span class="line">        // don&apos;t populate signalConnections if there&apos;s no vsync pending</span><br><span class="line">        if (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            // wait for something to happen</span><br><span class="line">            if (waitForVSync) &#123;</span><br><span class="line">                // This is where we spend most of our time, waiting</span><br><span class="line">                // for vsync events and new client registrations.</span><br><span class="line">                //</span><br><span class="line">                // If the screen is off, we can&apos;t use h/w vsync, so we</span><br><span class="line">                // use a 16ms timeout instead.  It doesn&apos;t need to be</span><br><span class="line">                // precise, we just need to keep feeding our clients.</span><br><span class="line">                //</span><br><span class="line">                // We don&apos;t want to stall if there&apos;s a driver bug, so we</span><br><span class="line">                // use a (long) timeout when waiting for h/w vsync, and</span><br><span class="line">                // generate fake events when necessary.</span><br><span class="line">                bool softwareSync = mUseSoftwareVSync;</span><br><span class="line">                auto timeout = softwareSync ? 16ms : 1000ms;</span><br><span class="line">                if (mCondition.wait_for(*lock, timeout) == std::cv_status::timeout) &#123;</span><br><span class="line">                    if (!softwareSync) &#123;</span><br><span class="line">                        ALOGW(&quot;Timed out waiting for hw vsync; faking it&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // FIXME: how do we decide which display id the fake</span><br><span class="line">                    // vsync came from ?</span><br><span class="line">                    mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[0].header.id = DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[0].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[0].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Nobody is interested in vsync, so we just want to sleep.</span><br><span class="line">                // h/w vsync should be disabled, so this will wait until we</span><br><span class="line">                // get a new connection, or an existing connection becomes</span><br><span class="line">                // interested in receiving vsync again.</span><br><span class="line">                //不存在对vsync感兴趣的连接，则进入休眠</span><br><span class="line">                mCondition.wait(*lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // here we&apos;re guaranteed to have a timestamp and some connections to signal</span><br><span class="line">    // (The connections might have dropped out of mDisplayEventConnections</span><br><span class="line">    // while we were asleep, but we&apos;ll still have strong references to them.)</span><br><span class="line">    return signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventThread线程进入mCondition的wait方法，等待唤醒</p>
<h4 id="2-5-setEventThread"><a href="#2-5-setEventThread" class="headerlink" title="2.5 setEventThread"></a>2.5 setEventThread</h4><p>[-&gt;native/services/surfaceflinger/MessageQueue.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void MessageQueue::setEventThread(android::EventThread* eventThread) &#123;</span><br><span class="line">    if (mEventThread == eventThread) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mEventTube.getFd() &gt;= 0) &#123;</span><br><span class="line">        mLooper-&gt;removeFd(mEventTube.getFd());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();</span><br><span class="line">    mEvents-&gt;stealReceiveChannel(&amp;mEventTube);</span><br><span class="line">    mLooper-&gt;addFd(mEventTube.getFd(), 0, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是监听EventTube（类型为BitTube），当有数据来的时候，调用cb_eventReceiver方法</p>
<h4 id="2-6-SF-run"><a href="#2-6-SF-run" class="headerlink" title="2.6 SF.run"></a>2.6 SF.run</h4><p>[-&gt;native/services/surfaceflinger/SurfaceFlinger.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::run() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        waitForEvent();</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::waitForEvent() &#123;</span><br><span class="line">    mEventQueue-&gt;waitMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MessageQueue::waitMessage() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">        int32_t ret = mLooper-&gt;pollOnce(-1);</span><br><span class="line">        switch (ret) &#123;</span><br><span class="line">            case Looper::POLL_WAKE:</span><br><span class="line">            case Looper::POLL_CALLBACK:</span><br><span class="line">                continue;</span><br><span class="line">            case Looper::POLL_ERROR:</span><br><span class="line">                ALOGE(&quot;Looper::POLL_ERROR&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            case Looper::POLL_TIMEOUT:</span><br><span class="line">                // timeout (should not happen)</span><br><span class="line">                continue;</span><br><span class="line">            default:</span><br><span class="line">                // should not happen</span><br><span class="line">                ALOGE(&quot;Looper::pollOnce() returned unknown status %d&quot;, ret);</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是一个while循环，一直在等待消息，如果有消息就进行处理。</p>
<h3 id="三、Vsync信号"><a href="#三、Vsync信号" class="headerlink" title="三、Vsync信号"></a>三、Vsync信号</h3><p>前面2.4.1创建HWComposer过程中，会注册一些回调方法。</p>
<h4 id="3-1-registerCallback"><a href="#3-1-registerCallback" class="headerlink" title="3.1 registerCallback"></a>3.1 registerCallback</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建HWComposer</span><br><span class="line">getBE().mHwc.reset(</span><br><span class="line">        new HWComposer(std::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName)));</span><br><span class="line">//注册回调</span><br><span class="line">getBE().mHwc-&gt;registerCallback(this, getBE().mComposerSequenceId); //注册回调</span><br><span class="line">getBE().mHwc-&gt;registerCallback(this, getBE().mComposerSequenceId);</span><br></pre></td></tr></table></figure>
<p>当硬件产生Vsync信号时，则会回调onVsyncReceived方法，SurfaceFlinger继承ComposerCallback。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ComposerCallback &#123;</span><br><span class="line"> public:</span><br><span class="line">    virtual void onHotplugReceived(int32_t sequenceId, hwc2_display_t display,</span><br><span class="line">                                   Connection connection) = 0;</span><br><span class="line">    virtual void onRefreshReceived(int32_t sequenceId,</span><br><span class="line">                                   hwc2_display_t display) = 0;</span><br><span class="line">    virtual void onVsyncReceived(int32_t sequenceId, hwc2_display_t display,</span><br><span class="line">                                 int64_t timestamp) = 0;</span><br><span class="line">    virtual ~ComposerCallback() = default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-onVsyncReceived"><a href="#3-2-onVsyncReceived" class="headerlink" title="3.2 onVsyncReceived"></a>3.2 onVsyncReceived</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::onVsyncReceived(int32_t sequenceId,</span><br><span class="line">        hwc2_display_t displayId, int64_t timestamp) &#123;</span><br><span class="line">    Mutex::Autolock lock(mStateLock);</span><br><span class="line">    // Ignore any vsyncs from a previous hardware composer.</span><br><span class="line">    if (sequenceId != getBE().mComposerSequenceId) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t type;</span><br><span class="line">    if (!getBE().mHwc-&gt;onVsync(displayId, timestamp, &amp;type)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool needsHwVsync = false;</span><br><span class="line"></span><br><span class="line">    &#123; // Scope for the lock</span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        if (type == DisplayDevice::DISPLAY_PRIMARY &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (needsHwVsync) &#123;</span><br><span class="line">        enableHardwareVsync();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        disableHardwareVsync(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-addResyncSample"><a href="#3-3-addResyncSample" class="headerlink" title="3.3 addResyncSample"></a>3.3 addResyncSample</h4><p>[-&gt;native/services/surfaceflinger/DispSync.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">bool DispSync::addResyncSample(nsecs_t timestamp) &#123;</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;[%s] addResyncSample(%&quot; PRId64 &quot;)&quot;, mName, ns2us(timestamp));</span><br><span class="line"></span><br><span class="line">    size_t idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    mResyncSamples[idx] = timestamp;</span><br><span class="line">    if (mNumResyncSamples == 0) &#123;</span><br><span class="line">        mPhase = 0;</span><br><span class="line">        mReferenceTime = timestamp;</span><br><span class="line">        ALOGV(&quot;[%s] First resync sample: mPeriod = %&quot; PRId64 &quot;, mPhase = 0, &quot;</span><br><span class="line">              &quot;mReferenceTime = %&quot; PRId64,</span><br><span class="line">              mName, ns2us(mPeriod), ns2us(mReferenceTime));</span><br><span class="line">        mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;</span><br><span class="line">        mNumResyncSamples++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mFirstResyncSample = (mFirstResyncSample + 1) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    &#125;</span><br><span class="line">    //见3.4节</span><br><span class="line">    updateModelLocked();</span><br><span class="line"></span><br><span class="line">    if (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123;</span><br><span class="line">        resetErrorLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mIgnorePresentFences) &#123;</span><br><span class="line">        // If we don&apos;t have the sync framework we will never have</span><br><span class="line">        // addPresentFence called.  This means we have no way to know whether</span><br><span class="line">        // or not we&apos;re synchronized with the HW vsyncs, so we just request</span><br><span class="line">        // that the HW vsync events be turned on whenever we need to generate</span><br><span class="line">        // SW vsync events.</span><br><span class="line">        return mThread-&gt;hasAnyEventListeners();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check against kErrorThreshold / 2 to add some hysteresis before having to</span><br><span class="line">    // resync again</span><br><span class="line">    bool modelLocked = mModelUpdated &amp;&amp; mError &lt; (kErrorThreshold / 2);</span><br><span class="line">    ALOGV(&quot;[%s] addResyncSample returning %s&quot;, mName, modelLocked ? &quot;locked&quot; : &quot;unlocked&quot;);</span><br><span class="line">    return !modelLocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-1-DispSync初始化"><a href="#3-3-1-DispSync初始化" class="headerlink" title="3.3.1 DispSync初始化"></a>3.3.1 DispSync初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void DispSync::init(bool hasSyncFramework, int64_t dispSyncPresentTimeOffset) &#123;</span><br><span class="line">    mIgnorePresentFences = !hasSyncFramework;</span><br><span class="line">    mPresentTimeOffset = dispSyncPresentTimeOffset;</span><br><span class="line">    mThread-&gt;run(&quot;DispSync&quot;, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    // set DispSync to SCHED_FIFO to minimize jitter</span><br><span class="line">    struct sched_param param = &#123;0&#125;;</span><br><span class="line">    param.sched_priority = 2;</span><br><span class="line">    if (sched_setscheduler(mThread-&gt;getTid(), SCHED_FIFO, &amp;param) != 0) &#123;</span><br><span class="line">        ALOGE(&quot;Couldn&apos;t set SCHED_FIFO for DispSyncThread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reset();</span><br><span class="line">    beginResync();</span><br><span class="line"></span><br><span class="line">    if (kTraceDetailedInfo) &#123;</span><br><span class="line">        // If we&apos;re not getting present fences then the ZeroPhaseTracer</span><br><span class="line">        // would prevent HW vsync event from ever being turned off.</span><br><span class="line">        // Even if we&apos;re just ignoring the fences, the zero-phase tracing is</span><br><span class="line">        // not needed because any time there is an event registered we will</span><br><span class="line">        // turn on the HW vsync events.</span><br><span class="line">        if (!mIgnorePresentFences &amp;&amp; kEnableZeroPhaseTracer) &#123;</span><br><span class="line">            mZeroPhaseTracer = std::make_unique&lt;ZeroPhaseTracer&gt;();</span><br><span class="line">            addEventListener(&quot;ZeroPhaseTracer&quot;, 0, mZeroPhaseTracer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-DispSyncThread-run"><a href="#3-3-2-DispSyncThread-run" class="headerlink" title="3.3.2 DispSyncThread.run"></a>3.3.2 DispSyncThread.run</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">virtual bool threadLoop() &#123;</span><br><span class="line">       status_t err;</span><br><span class="line">       nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">       while (true) &#123;</span><br><span class="line">           Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">           nsecs_t targetTime = 0;</span><br><span class="line"></span><br><span class="line">           &#123; // Scope for lock</span><br><span class="line">               Mutex::Autolock lock(mMutex);</span><br><span class="line"></span><br><span class="line">               if (kTraceDetailedInfo) &#123;</span><br><span class="line">                   ATRACE_INT64(&quot;DispSync:Frame&quot;, mFrameNumber);</span><br><span class="line">               &#125;</span><br><span class="line">               ALOGV(&quot;[%s] Frame %&quot; PRId64, mName, mFrameNumber);</span><br><span class="line">               ++mFrameNumber;</span><br><span class="line"></span><br><span class="line">               if (mStop) &#123;</span><br><span class="line">                   return false;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (mPeriod == 0) &#123;</span><br><span class="line">                   err = mCond.wait(mMutex);</span><br><span class="line">                   if (err != NO_ERROR) &#123;</span><br><span class="line">                       ALOGE(&quot;error waiting for new events: %s (%d)&quot;, strerror(-err), err);</span><br><span class="line">                       return false;</span><br><span class="line">                   &#125;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               targetTime = computeNextEventTimeLocked(now);</span><br><span class="line"></span><br><span class="line">               bool isWakeup = false;</span><br><span class="line"></span><br><span class="line">               if (now &lt; targetTime) &#123;</span><br><span class="line">                   if (kTraceDetailedInfo) ATRACE_NAME(&quot;DispSync waiting&quot;);</span><br><span class="line"></span><br><span class="line">                   if (targetTime == INT64_MAX) &#123;</span><br><span class="line">                       ALOGV(&quot;[%s] Waiting forever&quot;, mName);</span><br><span class="line">                       err = mCond.wait(mMutex);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       ALOGV(&quot;[%s] Waiting until %&quot; PRId64, mName, ns2us(targetTime));</span><br><span class="line">                       err = mCond.waitRelative(mMutex, targetTime - now);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   if (err == TIMED_OUT) &#123;</span><br><span class="line">                       isWakeup = true;</span><br><span class="line">                   &#125; else if (err != NO_ERROR) &#123;</span><br><span class="line">                       ALOGE(&quot;error waiting for next event: %s (%d)&quot;, strerror(-err), err);</span><br><span class="line">                       return false;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">               // Don&apos;t correct by more than 1.5 ms</span><br><span class="line">               static const nsecs_t kMaxWakeupLatency = us2ns(1500);</span><br><span class="line"></span><br><span class="line">               if (isWakeup) &#123;</span><br><span class="line">                   mWakeupLatency = ((mWakeupLatency * 63) + (now - targetTime)) / 64;</span><br><span class="line">                   mWakeupLatency = min(mWakeupLatency, kMaxWakeupLatency);</span><br><span class="line">                   if (kTraceDetailedInfo) &#123;</span><br><span class="line">                       ATRACE_INT64(&quot;DispSync:WakeupLat&quot;, now - targetTime);</span><br><span class="line">                       ATRACE_INT64(&quot;DispSync:AvgWakeupLat&quot;, mWakeupLatency);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               callbackInvocations = gatherCallbackInvocationsLocked(now);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (callbackInvocations.size() &gt; 0) &#123;</span><br><span class="line">               fireCallbackInvocations(callbackInvocations);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-DS-updateModelLocked"><a href="#3-4-DS-updateModelLocked" class="headerlink" title="3.4 DS.updateModelLocked"></a>3.4 DS.updateModelLocked</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void DispSync::updateModelLocked() &#123;</span><br><span class="line">    ALOGV(&quot;[%s] updateModelLocked %zu&quot;, mName, mNumResyncSamples);</span><br><span class="line">    if (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;</span><br><span class="line">        ALOGV(&quot;[%s] Computing...&quot;, mName);</span><br><span class="line">        nsecs_t durationSum = 0;</span><br><span class="line">        nsecs_t minDuration = INT64_MAX;</span><br><span class="line">        nsecs_t maxDuration = 0;</span><br><span class="line">        for (size_t i = 1; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            size_t prev = (idx + MAX_RESYNC_SAMPLES - 1) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            nsecs_t duration = mResyncSamples[idx] - mResyncSamples[prev];</span><br><span class="line">            durationSum += duration;</span><br><span class="line">            minDuration = min(minDuration, duration);</span><br><span class="line">            maxDuration = max(maxDuration, duration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Exclude the min and max from the average</span><br><span class="line">        durationSum -= minDuration + maxDuration;</span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - 3);</span><br><span class="line"></span><br><span class="line">        ALOGV(&quot;[%s] mPeriod = %&quot; PRId64, mName, ns2us(mPeriod));</span><br><span class="line"></span><br><span class="line">        double sampleAvgX = 0;</span><br><span class="line">        double sampleAvgY = 0;</span><br><span class="line">        double scale = 2.0 * M_PI / double(mPeriod);</span><br><span class="line">        // Intentionally skip the first sample</span><br><span class="line">        for (size_t i = 1; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            nsecs_t sample = mResyncSamples[idx] - mReferenceTime;</span><br><span class="line">            double samplePhase = double(sample % mPeriod) * scale;</span><br><span class="line">            sampleAvgX += cos(samplePhase);</span><br><span class="line">            sampleAvgY += sin(samplePhase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sampleAvgX /= double(mNumResyncSamples - 1);</span><br><span class="line">        sampleAvgY /= double(mNumResyncSamples - 1);</span><br><span class="line"></span><br><span class="line">        mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale);</span><br><span class="line"></span><br><span class="line">        ALOGV(&quot;[%s] mPhase = %&quot; PRId64, mName, ns2us(mPhase));</span><br><span class="line"></span><br><span class="line">        if (mPhase &lt; -(mPeriod / 2)) &#123;</span><br><span class="line">            mPhase += mPeriod;</span><br><span class="line">            ALOGV(&quot;[%s] Adjusting mPhase -&gt; %&quot; PRId64, mName, ns2us(mPhase));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (kTraceDetailedInfo) &#123;</span><br><span class="line">            ATRACE_INT64(&quot;DispSync:Period&quot;, mPeriod);</span><br><span class="line">            ATRACE_INT64(&quot;DispSync:Phase&quot;, mPhase + mPeriod / 2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Artificially inflate the period if requested.</span><br><span class="line">        mPeriod += mPeriod * mRefreshSkipCount;</span><br><span class="line">        //见3.5节</span><br><span class="line">        mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">        mModelUpdated = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-DST-updateModel"><a href="#3-5-DST-updateModel" class="headerlink" title="3.5 DST.updateModel"></a>3.5 DST.updateModel</h4><p>[-&gt;native/services/surfaceflinger/DispSync.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void updateModel(nsecs_t period, nsecs_t phase, nsecs_t referenceTime) &#123;</span><br><span class="line">        if (kTraceDetailedInfo) ATRACE_CALL();</span><br><span class="line">        Mutex::Autolock lock(mMutex);</span><br><span class="line">        mPeriod = period;</span><br><span class="line">        mPhase = phase;</span><br><span class="line">        mReferenceTime = referenceTime;</span><br><span class="line">        ALOGV(&quot;[%s] updateModel: mPeriod = %&quot; PRId64 &quot;, mPhase = %&quot; PRId64</span><br><span class="line">              &quot; mReferenceTime = %&quot; PRId64,</span><br><span class="line">              mName, ns2us(mPeriod), ns2us(mPhase), ns2us(mReferenceTime));</span><br><span class="line">        //唤醒目标线程</span><br><span class="line">        mCond.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>后面进入到DispSyncThread线程，线程里面具体的执行方法在3.3.2中有详细介绍，这里主要看下 fireCallbackInvocations方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void fireCallbackInvocations(const Vector&lt;CallbackInvocation&gt;&amp; callbacks) &#123;</span><br><span class="line">       if (kTraceDetailedInfo) ATRACE_CALL();</span><br><span class="line">       for (size_t i = 0; i &lt; callbacks.size(); i++) &#123;</span><br><span class="line">           callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在SurfaceFlinger里面有调用init方法，其中创建了DispSyncSource对象，这里是调用了DispSyncSource的onDispSyncEvent方法。</p>
<h4 id="3-6-DSS-onDispSyncEvent"><a href="#3-6-DSS-onDispSyncEvent" class="headerlink" title="3.6 DSS.onDispSyncEvent"></a>3.6 DSS.onDispSyncEvent</h4><p>[-&gt;native/services/surfaceflinger/SurfaceFlinger.cpp::DispSyncSource]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">virtual void onDispSyncEvent(nsecs_t when) &#123;</span><br><span class="line">    VSyncSource::Callback* callback;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock lock(mCallbackMutex);</span><br><span class="line">        callback = mCallback;</span><br><span class="line"></span><br><span class="line">        if (mTraceVsync) &#123;</span><br><span class="line">            mValue = (mValue + 1) % 2;</span><br><span class="line">            ATRACE_INT(mVsyncEventLabel.string(), mValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callback != nullptr) &#123;</span><br><span class="line">        callback-&gt;onVSyncEvent(when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-7-onVSyncEvent"><a href="#3-7-onVSyncEvent" class="headerlink" title="3.7 onVSyncEvent"></a>3.7 onVSyncEvent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void EventThread::onVSyncEvent(nsecs_t timestamp) &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(mMutex);</span><br><span class="line">    mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">    mVSyncEvent[0].header.id = 0;</span><br><span class="line">    mVSyncEvent[0].header.timestamp = timestamp;</span><br><span class="line">    mVSyncEvent[0].vsync.count++;</span><br><span class="line">    mCondition.notify_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> mCondition.notify_all能够唤醒处理waitForEventLocked的EventThread（2.4.2）,并执行postEvent</p>
<h4 id="3-8-ET-postEvent"><a href="#3-8-ET-postEvent" class="headerlink" title="3.8 ET.postEvent"></a>3.8 ET.postEvent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t EventThread::Connection::postEvent(const DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    ssize_t size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, 1);</span><br><span class="line">    return size &lt; 0 ? status_t(size) : status_t(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-9-DER-sendEvents"><a href="#3-9-DER-sendEvents" class="headerlink" title="3.9 DER.sendEvents"></a>3.9 DER.sendEvents</h4><p>[-&gt;native\libs\gui\DisplayEventReceiver.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t DisplayEventReceiver::sendEvents(gui::BitTube* dataChannel,</span><br><span class="line">        Event const* events, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    return gui::BitTube::sendObjects(dataChannel, events, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在2.5节中有监听BitTube，此处调用sendObjects，当收到数据时，则调用回调方法。</p>
<h5 id="3-9-1-MQ-cb-eventReceiver"><a href="#3-9-1-MQ-cb-eventReceiver" class="headerlink" title="3.9.1 MQ.cb_eventReceiver"></a>3.9.1 MQ.cb_eventReceiver</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123;</span><br><span class="line">    MessageQueue* queue = reinterpret_cast&lt;MessageQueue*&gt;(data);</span><br><span class="line">    return queue-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-9-2-MQ-eventReceiver"><a href="#3-9-2-MQ-eventReceiver" class="headerlink" title="3.9.2  MQ.eventReceiver"></a>3.9.2  MQ.eventReceiver</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int MessageQueue::eventReceiver(int /*fd*/, int /*events*/) &#123;</span><br><span class="line">    ssize_t n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[8];</span><br><span class="line">    while ((n = DisplayEventReceiver::getEvents(&amp;mEventTube, buffer, 8)) &gt; 0) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                mHandler-&gt;dispatchInvalidate();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-10-MQ-dispatchInvalidate"><a href="#3-10-MQ-dispatchInvalidate" class="headerlink" title="3.10 MQ.dispatchInvalidate"></a>3.10 MQ.dispatchInvalidate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void MessageQueue::Handler::dispatchInvalidate() &#123;</span><br><span class="line">    if ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == 0) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-11-MQ-handleMessage"><a href="#3-11-MQ-handleMessage" class="headerlink" title="3.11 MQ.handleMessage"></a>3.11 MQ.handleMessage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123;</span><br><span class="line">    switch (message.what) &#123;</span><br><span class="line">        case INVALIDATE:</span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            break;</span><br><span class="line">        case REFRESH:</span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-12-SF-onMessageReceived"><a href="#3-12-SF-onMessageReceived" class="headerlink" title="3.12 SF.onMessageReceived"></a>3.12 SF.onMessageReceived</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::onMessageReceived(int32_t what) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    switch (what) &#123;</span><br><span class="line">        case MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            bool frameMissed = !mHadClientComposition &amp;&amp;</span><br><span class="line">                    mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;</span><br><span class="line">                    (mPreviousPresentFence-&gt;getSignalTime() ==</span><br><span class="line">                            Fence::SIGNAL_TIME_PENDING);</span><br><span class="line">            ATRACE_INT(&quot;FrameMissed&quot;, static_cast&lt;int&gt;(frameMissed));</span><br><span class="line">            if (frameMissed) &#123;</span><br><span class="line">                mTimeStats.incrementMissedFrames();</span><br><span class="line">                if (mPropagateBackpressure) &#123;</span><br><span class="line">                    signalLayerUpdate();</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mDolphinFuncsEnabled) &#123;</span><br><span class="line">                int maxQueuedFrames = 0;</span><br><span class="line">                mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">                    if (layer-&gt;hasQueuedFrame() &amp;&amp;</span><br><span class="line">                            layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123;</span><br><span class="line">                        int layerQueuedFrames = layer-&gt;getQueuedFrameCount();</span><br><span class="line">                        if (maxQueuedFrames &lt; layerQueuedFrames &amp;&amp;</span><br><span class="line">                                !layer-&gt;visibleNonTransparentRegion.isEmpty()) &#123;</span><br><span class="line">                            maxQueuedFrames = layerQueuedFrames;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                if(mDolphinMonitor(maxQueuedFrames)) &#123;</span><br><span class="line">                    signalLayerUpdate();</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Now that we&apos;re going to make it to the handleMessageTransaction()</span><br><span class="line">            // call below it&apos;s safe to call updateVrFlinger(), which will</span><br><span class="line">            // potentially trigger a display handoff.</span><br><span class="line">            updateVrFlinger();</span><br><span class="line"></span><br><span class="line">            bool refreshNeeded = handleMessageTransaction();</span><br><span class="line">            refreshNeeded |= handleMessageInvalidate();</span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line">            //如果需要刷新</span><br><span class="line">            if (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                // Signal a refresh if a transaction modified the window state,</span><br><span class="line">                // a new buffer was latched, or if HWC has requested a full</span><br><span class="line">                // repaint</span><br><span class="line">                if (mDolphinFuncsEnabled) &#123;</span><br><span class="line">                    mDolphinRefresh();</span><br><span class="line">                &#125;</span><br><span class="line">                signalRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、图像输出"><a href="#四、图像输出" class="headerlink" title="四、图像输出"></a>四、图像输出</h3><p>上面经过Vsync信号后，经过层层调用到onMessageReceived方法，如果屏幕刷新，则会调用到handleMessageRefresh方法流程，具体如下：</p>
<h4 id="4-1-SF-handleMessageRefresh"><a href="#4-1-SF-handleMessageRefresh" class="headerlink" title="4.1 SF.handleMessageRefresh"></a>4.1 SF.handleMessageRefresh</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = false;</span><br><span class="line"></span><br><span class="line">    nsecs_t refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    //主要是这个5步操作</span><br><span class="line">    preComposition(refreshStartTime);</span><br><span class="line">    rebuildLayerStacks();</span><br><span class="line">    setUpHWComposer();</span><br><span class="line">    doDebugFlashRegions();</span><br><span class="line">    doTracing(&quot;handleRefresh&quot;);</span><br><span class="line">    logLayerStats();</span><br><span class="line">    doComposition();</span><br><span class="line">    postComposition(refreshStartTime);</span><br><span class="line"></span><br><span class="line">    int id = getVsyncSource();</span><br><span class="line">    mPreviousPresentFence = (id != -1) ? getBE().mHwc-&gt;getPresentFence(id) : Fence::NO_FENCE;</span><br><span class="line">    ALOGV(&quot;Checking for backpressure against %d retire fence&quot;, id);</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = false;</span><br><span class="line">    for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">        const sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">        mHadClientComposition = mHadClientComposition ||</span><br><span class="line">                getBE().mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">    &#125;</span><br><span class="line">    mVsyncModulator.onRefreshed(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-SF-preComposition"><a href="#4-2-SF-preComposition" class="headerlink" title="4.2 SF.preComposition"></a>4.2 SF.preComposition</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::preComposition(nsecs_t refreshStartTime)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;preComposition&quot;);</span><br><span class="line"></span><br><span class="line">    bool needExtraInvalidate = false;</span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        //回调每一个图层的onPreComposition方法</span><br><span class="line">        if (layer-&gt;onPreComposition(refreshStartTime)) &#123;</span><br><span class="line">            needExtraInvalidate = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //当图层信息</span><br><span class="line">    if (needExtraInvalidate) &#123;</span><br><span class="line">        signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-SF-rebuildLayerStacks"><a href="#4-3-SF-rebuildLayerStacks" class="headerlink" title="4.3 SF.rebuildLayerStacks"></a>4.3 SF.rebuildLayerStacks</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::rebuildLayerStacks() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;rebuildLayerStacks&quot;);</span><br><span class="line">    Mutex::Autolock lock(mDolphinStateLock);</span><br><span class="line"></span><br><span class="line">    // rebuild the visible layer list per screen</span><br><span class="line">    // 重建每个显示屏中可见的图层列表</span><br><span class="line">    if (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        ATRACE_NAME(&quot;rebuildLayerStacks VR Dirty&quot;);</span><br><span class="line">        mVisibleRegionsDirty = false;</span><br><span class="line">        invalidateHwcGeometry();</span><br><span class="line"></span><br><span class="line">        for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            Region opaqueRegion;</span><br><span class="line">            Region dirtyRegion;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences;</span><br><span class="line">            const sp&lt;DisplayDevice&gt;&amp; displayDevice(mDisplays[dpy]);</span><br><span class="line">            const Transform&amp; tr(displayDevice-&gt;getTransform());</span><br><span class="line">            const Rect bounds(displayDevice-&gt;getBounds());</span><br><span class="line">            if (displayDevice-&gt;isDisplayOn()) &#123;</span><br><span class="line">                //计算每个layer的可见区域</span><br><span class="line">                computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">                mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">                    bool hwcLayerDestroyed = false;</span><br><span class="line">                    //LayerStack一样</span><br><span class="line">                    if (layer-&gt;belongsToDisplay(displayDevice-&gt;getLayerStack(),</span><br><span class="line">                                displayDevice-&gt;isPrimary())) &#123;</span><br><span class="line">                        Region drawRegion(tr.transform(</span><br><span class="line">                                layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                        drawRegion.andSelf(bounds);</span><br><span class="line">                        if (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                            layersSortedByZ.add(layer);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            // Clear out the HWC layer if this layer was</span><br><span class="line">                            // previously visible, but no longer is</span><br><span class="line">                            hwcLayerDestroyed = layer-&gt;destroyHwcLayer(</span><br><span class="line">                                    displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // WM changes displayDevice-&gt;layerStack upon sleep/awake.</span><br><span class="line">                        // Here we make sure we delete the HWC layers even if</span><br><span class="line">                        // WM changed their layer stack.</span><br><span class="line">                        hwcLayerDestroyed = layer-&gt;destroyHwcLayer(</span><br><span class="line">                                displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // If a layer is not going to get a release fence because</span><br><span class="line">                    // it is invisible, but it is also going to release its</span><br><span class="line">                    // old buffer, add it to the list of layers needing</span><br><span class="line">                    // fences.</span><br><span class="line">                    if (hwcLayerDestroyed) &#123;</span><br><span class="line">                        auto found = std::find(mLayersWithQueuedFrames.cbegin(),</span><br><span class="line">                                mLayersWithQueuedFrames.cend(), layer);</span><br><span class="line">                        if (found != mLayersWithQueuedFrames.cend()) &#123;</span><br><span class="line">                            layersNeedingFences.add(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            displayDevice-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;setLayersNeedingFences(layersNeedingFences);</span><br><span class="line">            displayDevice-&gt;undefinedRegion.set(bounds);</span><br><span class="line">            displayDevice-&gt;undefinedRegion.subtractSelf(</span><br><span class="line">                    tr.transform(opaqueRegion));</span><br><span class="line">            displayDevice-&gt;dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-SF-setUpHWComposer"><a href="#4-4-SF-setUpHWComposer" class="headerlink" title="4.4 SF.setUpHWComposer"></a>4.4 SF.setUpHWComposer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::setUpHWComposer() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;setUpHWComposer&quot;);</span><br><span class="line"></span><br><span class="line">    for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        bool dirty = !mDisplays[dpy]-&gt;getDirtyRegion(mRepaintEverything).isEmpty();</span><br><span class="line">        bool empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == 0;</span><br><span class="line">        bool wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">        // If nothing has changed (!dirty), don&apos;t recompose.</span><br><span class="line">        // If something changed, but we don&apos;t currently have any visible layers,</span><br><span class="line">        //   and didn&apos;t when we last did a composition, then skip it this time.</span><br><span class="line">        // The second rule does two things:</span><br><span class="line">        // - When all layers are removed from a display, we&apos;ll emit one black</span><br><span class="line">        //   frame, then nothing more until we get new layers.</span><br><span class="line">        // - When a display is created with a private layer stack, we won&apos;t</span><br><span class="line">        //   emit any black frames until a layer is added to the layer stack.</span><br><span class="line">        bool mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">        ALOGV_IF(mDisplays[dpy]-&gt;getDisplayType() == DisplayDevice::DISPLAY_VIRTUAL,</span><br><span class="line">                &quot;dpy[%zu]: %s composition (%sdirty %sempty %swasEmpty)&quot;, dpy,</span><br><span class="line">                mustRecompose ? &quot;doing&quot; : &quot;skipping&quot;,</span><br><span class="line">                dirty ? &quot;+&quot; : &quot;-&quot;,</span><br><span class="line">                empty ? &quot;+&quot; : &quot;-&quot;,</span><br><span class="line">                wasEmpty ? &quot;+&quot; : &quot;-&quot;);</span><br><span class="line"></span><br><span class="line">        mDisplays[dpy]-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">        if (mustRecompose) &#123;</span><br><span class="line">            mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // build the h/w work list</span><br><span class="line">    if (CC_UNLIKELY(mGeometryInvalid)) &#123;</span><br><span class="line">        mGeometryInvalid = false;</span><br><span class="line">        for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            sp&lt;const DisplayDevice&gt; displayDevice(mDisplays[dpy]);</span><br><span class="line">            const auto hwcId = displayDevice-&gt;getHwcDisplayId();</span><br><span class="line">            if (hwcId &gt;= 0) &#123;</span><br><span class="line">                const Vector&lt;sp&lt;Layer&gt;&gt;&amp; currentLayers(</span><br><span class="line">                        displayDevice-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">                setDisplayAnimating(displayDevice);</span><br><span class="line">                for (size_t i = 0; i &lt; currentLayers.size(); i++) &#123;</span><br><span class="line">                    const auto&amp; layer = currentLayers[i];</span><br><span class="line">                    if (!layer-&gt;hasHwcLayer(hwcId)) &#123;</span><br><span class="line">                        if (!layer-&gt;createHwcLayer(getBE().mHwc.get(), hwcId)) &#123;</span><br><span class="line">                            layer-&gt;forceClientComposition(hwcId);</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (layer-&gt;isPrimaryDisplayOnly()) &#123;</span><br><span class="line">                            setLayerAsMask(hwcId, layer-&gt;getLayerId());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layer-&gt;setGeometry(displayDevice, i);</span><br><span class="line">                    if (mDebugDisableHWC || mDebugRegion) &#123;</span><br><span class="line">                        layer-&gt;forceClientComposition(hwcId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Set the per-frame data</span><br><span class="line">    // 设置每一帧的数据</span><br><span class="line">    for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">        auto&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">        const auto hwcId = displayDevice-&gt;getHwcDisplayId();</span><br><span class="line"></span><br><span class="line">        if (hwcId &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mDrawingState.colorMatrixChanged) &#123;</span><br><span class="line">            displayDevice-&gt;setColorTransform(mDrawingState.colorMatrix);</span><br><span class="line">            status_t result = getBE().mHwc-&gt;setColorTransform(hwcId, mDrawingState.colorMatrix);</span><br><span class="line">            ALOGE_IF(result != NO_ERROR, &quot;Failed to set color transform on &quot;</span><br><span class="line">                    &quot;display %zd: %d&quot;, displayId, result);</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            if (layer-&gt;isHdrY410()) &#123;</span><br><span class="line">                layer-&gt;forceClientComposition(hwcId);</span><br><span class="line">            &#125; else if ((layer-&gt;getDataSpace() == Dataspace::BT2020_PQ ||</span><br><span class="line">                        layer-&gt;getDataSpace() == Dataspace::BT2020_ITU_PQ) &amp;&amp;</span><br><span class="line">                    !displayDevice-&gt;hasHDR10Support()) &#123;</span><br><span class="line">                layer-&gt;forceClientComposition(hwcId);</span><br><span class="line">            &#125; else if ((layer-&gt;getDataSpace() == Dataspace::BT2020_HLG ||</span><br><span class="line">                        layer-&gt;getDataSpace() == Dataspace::BT2020_ITU_HLG) &amp;&amp;</span><br><span class="line">                    !displayDevice-&gt;hasHLGSupport()) &#123;</span><br><span class="line">                layer-&gt;forceClientComposition(hwcId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (layer-&gt;getForceClientComposition(hwcId)) &#123;</span><br><span class="line">                ALOGV(&quot;[%s] Requesting Client composition&quot;, layer-&gt;getName().string());</span><br><span class="line">                layer-&gt;setCompositionType(hwcId, HWC2::Composition::Client);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            layer-&gt;setPerFrameData(displayDevice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (hasWideColorDisplay) &#123;</span><br><span class="line">            ColorMode colorMode;</span><br><span class="line">            Dataspace dataSpace;</span><br><span class="line">            RenderIntent renderIntent;</span><br><span class="line">            pickColorMode(displayDevice, &amp;colorMode, &amp;dataSpace, &amp;renderIntent);</span><br><span class="line">            setActiveColorModeInternal(displayDevice, colorMode, dataSpace, renderIntent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.colorMatrixChanged = false;</span><br><span class="line"></span><br><span class="line">    dumpDrawCycle(true);</span><br><span class="line"></span><br><span class="line">    for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">        auto&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">        if (!displayDevice-&gt;isDisplayOn()) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        status_t result = displayDevice-&gt;prepareFrame(*getBE().mHwc);</span><br><span class="line">        ALOGE_IF(result != NO_ERROR, &quot;prepareFrame for display %zd failed:&quot;</span><br><span class="line">                &quot; %d (%s)&quot;, displayId, result, strerror(-result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-SF-doComposition"><a href="#4-5-SF-doComposition" class="headerlink" title="4.5 SF.doComposition"></a>4.5 SF.doComposition</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::doComposition() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;doComposition&quot;);</span><br><span class="line"></span><br><span class="line">    const bool repaintEverything = android_atomic_and(0, &amp;mRepaintEverything);</span><br><span class="line">    for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">        if (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            // transform the dirty region into this screen&apos;s coordinate space</span><br><span class="line">            // 将脏区域转换为此屏幕的坐标空间</span><br><span class="line">            const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything));</span><br><span class="line"></span><br><span class="line">            // repaint the framebuffer (if needed)</span><br><span class="line">            // 如果需要，重绘framebuffer</span><br><span class="line">            doDisplayComposition(hw, dirtyRegion);</span><br><span class="line"></span><br><span class="line">            hw-&gt;dirtyRegion.clear();</span><br><span class="line">            hw-&gt;flip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-5-1-doDisplayComposition"><a href="#4-5-1-doDisplayComposition" class="headerlink" title="4.5.1 doDisplayComposition"></a>4.5.1 doDisplayComposition</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::doDisplayComposition(</span><br><span class="line">        const sp&lt;const DisplayDevice&gt;&amp; displayDevice,</span><br><span class="line">        const Region&amp; inDirtyRegion)</span><br><span class="line">&#123;</span><br><span class="line">    // We only need to actually compose the display if:</span><br><span class="line">    // 1) It is being handled by hardware composer, which may need this to</span><br><span class="line">    //    keep its virtual display state machine in sync, or</span><br><span class="line">    // 2) There is work to be done (the dirty region isn&apos;t empty)</span><br><span class="line">    bool isHwcDisplay = displayDevice-&gt;getHwcDisplayId() &gt;= 0;</span><br><span class="line">    if (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">        ALOGV(&quot;Skipping display composition&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;doDisplayComposition&quot;);</span><br><span class="line">    if (!doComposeSurfaces(displayDevice)) return;</span><br><span class="line"></span><br><span class="line">    // swap buffers (presentation)</span><br><span class="line">    // 交换buffer,输出图像</span><br><span class="line">    displayDevice-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-5-2-doComposeSurfaces"><a href="#4-5-2-doComposeSurfaces" class="headerlink" title="4.5.2 doComposeSurfaces"></a>4.5.2 doComposeSurfaces</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">bool SurfaceFlinger::doComposeSurfaces(const sp&lt;const DisplayDevice&gt;&amp; displayDevice)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;doComposeSurfaces&quot;);</span><br><span class="line"></span><br><span class="line">    const Region bounds(displayDevice-&gt;bounds());</span><br><span class="line">    const DisplayRenderArea renderArea(displayDevice);</span><br><span class="line">    const auto hwcId = displayDevice-&gt;getHwcDisplayId();</span><br><span class="line">    const bool hasClientComposition = getBE().mHwc-&gt;hasClientComposition(hwcId);</span><br><span class="line">    ATRACE_INT(&quot;hasClientComposition&quot;, hasClientComposition);</span><br><span class="line"></span><br><span class="line">    bool applyColorMatrix = false;</span><br><span class="line">    bool needsEnhancedColorMatrix = false;</span><br><span class="line"></span><br><span class="line">    if (hasClientComposition) &#123;</span><br><span class="line">        ALOGV(&quot;hasClientComposition&quot;);</span><br><span class="line"></span><br><span class="line">        Dataspace outputDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        if (displayDevice-&gt;hasWideColorGamut()) &#123;</span><br><span class="line">            outputDataspace = displayDevice-&gt;getCompositionDataSpace();</span><br><span class="line">        &#125;</span><br><span class="line">        getBE().mRenderEngine-&gt;setOutputDataSpace(outputDataspace);</span><br><span class="line">        getBE().mRenderEngine-&gt;setDisplayMaxLuminance(</span><br><span class="line">                displayDevice-&gt;getHdrCapabilities().getDesiredMaxLuminance());</span><br><span class="line"></span><br><span class="line">        const bool hasDeviceComposition = getBE().mHwc-&gt;hasDeviceComposition(hwcId);</span><br><span class="line">        const bool skipClientColorTransform = getBE().mHwc-&gt;hasCapability(</span><br><span class="line">            HWC2::Capability::SkipClientColorTransform);</span><br><span class="line"></span><br><span class="line">        mat4 colorMatrix;</span><br><span class="line">        applyColorMatrix = !hasDeviceComposition &amp;&amp; !skipClientColorTransform;</span><br><span class="line">        if (applyColorMatrix) &#123;</span><br><span class="line">            colorMatrix = mDrawingState.colorMatrix;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // The current enhanced saturation matrix is designed to enhance Display P3,</span><br><span class="line">        // thus we only apply this matrix when the render intent is not colorimetric</span><br><span class="line">        // and the output color space is Display P3.</span><br><span class="line">        needsEnhancedColorMatrix =</span><br><span class="line">            (displayDevice-&gt;getActiveRenderIntent() &gt;= RenderIntent::ENHANCE &amp;&amp;</span><br><span class="line">             outputDataspace == Dataspace::DISPLAY_P3);</span><br><span class="line">        if (needsEnhancedColorMatrix) &#123;</span><br><span class="line">            colorMatrix *= mEnhancedSaturationMatrix;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getRenderEngine().setupColorTransform(colorMatrix);</span><br><span class="line"></span><br><span class="line">        if (!displayDevice-&gt;makeCurrent()) &#123;</span><br><span class="line">            ALOGW(&quot;DisplayDevice::makeCurrent failed. Aborting surface composition for display %s&quot;,</span><br><span class="line">                  displayDevice-&gt;getDisplayName().string());</span><br><span class="line">            getRenderEngine().resetCurrentSurface();</span><br><span class="line"></span><br><span class="line">            // |mStateLock| not needed as we are on the main thread</span><br><span class="line">            if(!getDefaultDisplayDeviceLocked()-&gt;makeCurrent()) &#123;</span><br><span class="line">              ALOGE(&quot;DisplayDevice::makeCurrent on default display failed. Aborting.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Never touch the framebuffer if we don&apos;t have any framebuffer layers</span><br><span class="line">        // 如果没有framebuffer的layer层，则不需要改变framebuffer</span><br><span class="line">        if (hasDeviceComposition) &#123;</span><br><span class="line">            // when using overlays, we assume a fully transparent framebuffer</span><br><span class="line">            // NOTE: we could reduce how much we need to clear, for instance</span><br><span class="line">            // remove where there are opaque FB layers. however, on some</span><br><span class="line">            // GPUs doing a &quot;clean slate&quot; clear might be more efficient.</span><br><span class="line">            // We&apos;ll revisit later if needed.</span><br><span class="line">            getBE().mRenderEngine-&gt;clearWithColor(0, 0, 0, 0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // we start with the whole screen area and remove the scissor part</span><br><span class="line">            // we&apos;re left with the letterbox region</span><br><span class="line">            // (common case is that letterbox ends-up being empty)</span><br><span class="line">            const Region letterbox(bounds.subtract(displayDevice-&gt;getScissor()));</span><br><span class="line"></span><br><span class="line">            // compute the area to clear</span><br><span class="line">            Region region(displayDevice-&gt;undefinedRegion.merge(letterbox));</span><br><span class="line"></span><br><span class="line">            // screen is already cleared here</span><br><span class="line">            if (!region.isEmpty()) &#123;</span><br><span class="line">                // can happen with SurfaceView</span><br><span class="line">                drawWormhole(displayDevice, region);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const Rect&amp; bounds(displayDevice-&gt;getBounds());</span><br><span class="line">        const Rect&amp; scissor(displayDevice-&gt;getScissor());</span><br><span class="line">        if (scissor != bounds) &#123;</span><br><span class="line">            // scissor doesn&apos;t match the screen&apos;s dimensions, so we</span><br><span class="line">            // need to clear everything outside of it and enable</span><br><span class="line">            // the GL scissor so we don&apos;t draw anything where we shouldn&apos;t</span><br><span class="line"></span><br><span class="line">            // enable scissor for this frame</span><br><span class="line">            const uint32_t height = displayDevice-&gt;getHeight();</span><br><span class="line">            getBE().mRenderEngine-&gt;setScissor(scissor.left, height - scissor.bottom,</span><br><span class="line">                                              scissor.getWidth(), scissor.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * and then, render the layers targeted at the framebuffer</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;Rendering client layers&quot;);</span><br><span class="line">    const Transform&amp; displayTransform = displayDevice-&gt;getTransform();</span><br><span class="line">    bool firstLayer = true;</span><br><span class="line">    for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">        const Region clip(bounds.intersect(</span><br><span class="line">                displayTransform.transform(layer-&gt;visibleRegion)));</span><br><span class="line">        ALOGV(&quot;Layer: %s&quot;, layer-&gt;getName().string());</span><br><span class="line">        ALOGV(&quot;  Composition type: %s&quot;,</span><br><span class="line">                to_string(layer-&gt;getCompositionType(hwcId)).c_str());</span><br><span class="line">        if (!clip.isEmpty()) &#123;</span><br><span class="line">            switch (layer-&gt;getCompositionType(hwcId)) &#123;</span><br><span class="line">                case HWC2::Composition::Cursor:</span><br><span class="line">                case HWC2::Composition::Device:</span><br><span class="line">                case HWC2::Composition::Sideband:</span><br><span class="line">                case HWC2::Composition::SolidColor: &#123;</span><br><span class="line">                    const Layer::State&amp; state(layer-&gt;getDrawingState());</span><br><span class="line">                    if (layer-&gt;getClearClientTarget(hwcId) &amp;&amp; !firstLayer &amp;&amp;</span><br><span class="line">                            layer-&gt;isOpaque(state) &amp;&amp; (layer-&gt;getAlpha() == 1.0f)</span><br><span class="line">                            &amp;&amp; hasClientComposition) &#123;</span><br><span class="line">                        // never clear the very first layer since we&apos;re</span><br><span class="line">                        // guaranteed the FB is already cleared</span><br><span class="line">                        layer-&gt;clearWithOpenGL(renderArea);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case HWC2::Composition::Client: &#123;</span><br><span class="line">                    if ((hwcId &lt; 0) &amp;&amp;</span><br><span class="line">                        (DisplayUtils::getInstance()-&gt;skipColorLayer(layer-&gt;getTypeId()))) &#123;</span><br><span class="line">                        // We are not using h/w composer.</span><br><span class="line">                        // Skip color (dim) layer for WFD direct streaming.</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    layer-&gt;draw(renderArea, clip);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGV(&quot;  Skipping for empty clip&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        firstLayer = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (applyColorMatrix || needsEnhancedColorMatrix) &#123;</span><br><span class="line">        getRenderEngine().setupColorTransform(mat4());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // disable scissor at the end of the frame</span><br><span class="line">    getBE().mRenderEngine-&gt;disableScissor();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-5-3-postFramebuffer"><a href="#4-5-3-postFramebuffer" class="headerlink" title="4.5.3 postFramebuffer"></a>4.5.3 postFramebuffer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::postFramebuffer()</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;postFramebuffer&quot;);</span><br><span class="line"></span><br><span class="line">    const nsecs_t now = systemTime();</span><br><span class="line">    mDebugInSwapBuffers = now;</span><br><span class="line"></span><br><span class="line">    for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">        auto&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">        if (!displayDevice-&gt;isDisplayOn()) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        const auto hwcId = displayDevice-&gt;getHwcDisplayId();</span><br><span class="line">        if (hwcId &gt;= 0) &#123;</span><br><span class="line">            getBE().mHwc-&gt;presentAndGetReleaseFences(hwcId);</span><br><span class="line">        &#125;</span><br><span class="line">        displayDevice-&gt;onSwapBuffersCompleted();</span><br><span class="line">        displayDevice-&gt;makeCurrent();</span><br><span class="line">        for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            sp&lt;Fence&gt; releaseFence = Fence::NO_FENCE;</span><br><span class="line"></span><br><span class="line">            // The layer buffer from the previous frame (if any) is released</span><br><span class="line">            // by HWC only when the release fence from this frame (if any) is</span><br><span class="line">            // signaled.  Always get the release fence from HWC first.</span><br><span class="line">            auto hwcLayer = layer-&gt;getHwcLayer(hwcId);</span><br><span class="line">            if (hwcId &gt;= 0) &#123;</span><br><span class="line">                releaseFence = getBE().mHwc-&gt;getLayerReleaseFence(hwcId, hwcLayer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If the layer was client composited in the previous frame, we</span><br><span class="line">            // need to merge with the previous client target acquire fence.</span><br><span class="line">            // Since we do not track that, always merge with the current</span><br><span class="line">            // client target acquire fence when it is available, even though</span><br><span class="line">            // this is suboptimal.</span><br><span class="line">            if (layer-&gt;getCompositionType(hwcId) == HWC2::Composition::Client) &#123;</span><br><span class="line">                //合成</span><br><span class="line">                releaseFence = Fence::merge(&quot;LayerRelease&quot;, releaseFence,</span><br><span class="line">                        displayDevice-&gt;getClientTargetAcquireFence());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            layer-&gt;onLayerDisplayed(releaseFence);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We&apos;ve got a list of layers needing fences, that are disjoint with</span><br><span class="line">        // displayDevice-&gt;getVisibleLayersSortedByZ.  The best we can do is to</span><br><span class="line">        // supply them with the present fence.</span><br><span class="line">        if (!displayDevice-&gt;getLayersNeedingFences().isEmpty()) &#123;</span><br><span class="line">            sp&lt;Fence&gt; presentFence = getBE().mHwc-&gt;getPresentFence(hwcId);</span><br><span class="line">            for (auto&amp; layer : displayDevice-&gt;getLayersNeedingFences()) &#123;</span><br><span class="line">                layer-&gt;onLayerDisplayed(presentFence);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (hwcId &gt;= 0) &#123;</span><br><span class="line">            getBE().mHwc-&gt;clearReleaseFences(hwcId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastSwapBufferTime = systemTime() - now;</span><br><span class="line">    mDebugInSwapBuffers = 0;</span><br><span class="line"></span><br><span class="line">    // |mStateLock| not needed as we are on the main thread</span><br><span class="line">    if (getBE().mHwc-&gt;isConnected(HWC_DISPLAY_PRIMARY)) &#123;</span><br><span class="line">        uint32_t flipCount = getDefaultDisplayDeviceLocked()-&gt;getPageFlipCount();</span><br><span class="line">        if (flipCount % LOG_FRAME_STATS_PERIOD == 0) &#123;</span><br><span class="line">            logFrameStats();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-SF-postComposition"><a href="#4-6-SF-postComposition" class="headerlink" title="4.6 SF.postComposition"></a>4.6 SF.postComposition</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::postComposition(nsecs_t refreshStartTime)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;postComposition&quot;);</span><br><span class="line"></span><br><span class="line">    // Release any buffers which were replaced this frame</span><br><span class="line">    nsecs_t dequeueReadyTime = systemTime();</span><br><span class="line">    for (auto&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">        layer-&gt;releasePendingBuffer(dequeueReadyTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // |mStateLock| not needed as we are on the main thread</span><br><span class="line">    const sp&lt;const DisplayDevice&gt; hw(getDefaultDisplayDeviceLocked());</span><br><span class="line"></span><br><span class="line">    getBE().mGlCompositionDoneTimeline.updateSignalTimes();</span><br><span class="line">    std::shared_ptr&lt;FenceTime&gt; glCompositionDoneFenceTime;</span><br><span class="line">    if (hw &amp;&amp; getBE().mHwc-&gt;hasClientComposition(HWC_DISPLAY_PRIMARY)) &#123;</span><br><span class="line">        glCompositionDoneFenceTime =</span><br><span class="line">                std::make_shared&lt;FenceTime&gt;(hw-&gt;getClientTargetAcquireFence());</span><br><span class="line">        getBE().mGlCompositionDoneTimeline.push(glCompositionDoneFenceTime);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        glCompositionDoneFenceTime = FenceTime::NO_FENCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getBE().mDisplayTimeline.updateSignalTimes();</span><br><span class="line"></span><br><span class="line">    int disp = getVsyncSource();</span><br><span class="line">    sp&lt;Fence&gt; presentFence = (disp != -1) ? getBE().mHwc-&gt;getPresentFence(disp) : Fence::NO_FENCE;</span><br><span class="line">    auto presentFenceTime = std::make_shared&lt;FenceTime&gt;(presentFence);</span><br><span class="line">    getBE().mDisplayTimeline.push(presentFenceTime);</span><br><span class="line"></span><br><span class="line">    nsecs_t vsyncPhase = mPrimaryDispSync.computeNextRefresh(0);</span><br><span class="line">    nsecs_t vsyncInterval = mPrimaryDispSync.getPeriod();</span><br><span class="line"></span><br><span class="line">    // We use the refreshStartTime which might be sampled a little later than</span><br><span class="line">    // when we started doing work for this frame, but that should be okay</span><br><span class="line">    // since updateCompositorTiming has snapping logic.</span><br><span class="line">    updateCompositorTiming(</span><br><span class="line">        vsyncPhase, vsyncInterval, refreshStartTime, presentFenceTime);</span><br><span class="line">    CompositorTiming compositorTiming;</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(getBE().mCompositorTimingLock);</span><br><span class="line">        compositorTiming = getBE().mCompositorTiming;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        bool frameLatched = layer-&gt;onPostComposition(glCompositionDoneFenceTime,</span><br><span class="line">                presentFenceTime, compositorTiming);</span><br><span class="line">        if (frameLatched) &#123;</span><br><span class="line">            recordBufferingStats(layer-&gt;getName().string(),</span><br><span class="line">                    layer-&gt;getOccupancyHistory(false));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if (presentFenceTime-&gt;isValid()) &#123;</span><br><span class="line">        if (mPrimaryDispSync.addPresentFence(presentFenceTime)) &#123;</span><br><span class="line">            enableHardwareVsync();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disableHardwareVsync(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forceResyncModel();</span><br><span class="line">    if (!hasSyncFramework) &#123;</span><br><span class="line">        if (getBE().mHwc-&gt;isConnected(HWC_DISPLAY_PRIMARY) &amp;&amp; hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            enableHardwareVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mAnimCompositionPending) &#123;</span><br><span class="line">        mAnimCompositionPending = false;</span><br><span class="line"></span><br><span class="line">        if (presentFenceTime-&gt;isValid()) &#123;</span><br><span class="line">            mAnimFrameTracker.setActualPresentFence(</span><br><span class="line">                    std::move(presentFenceTime));</span><br><span class="line">        &#125; else if (getBE().mHwc-&gt;isConnected(HWC_DISPLAY_PRIMARY)) &#123;</span><br><span class="line">            // The HWC doesn&apos;t support present fences, so use the refresh</span><br><span class="line">            // timestamp instead.</span><br><span class="line">            nsecs_t presentTime =</span><br><span class="line">                    getBE().mHwc-&gt;getRefreshTimestamp(HWC_DISPLAY_PRIMARY);</span><br><span class="line">            mAnimFrameTracker.setActualPresentTime(presentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        mAnimFrameTracker.advanceFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dumpDrawCycle(false);</span><br><span class="line"></span><br><span class="line">    mTimeStats.incrementTotalFrames();</span><br><span class="line">    if (mHadClientComposition) &#123;</span><br><span class="line">        mTimeStats.incrementClientCompositionFrames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (getBE().mHwc-&gt;isConnected(HWC_DISPLAY_PRIMARY) &amp;&amp;</span><br><span class="line">            hw-&gt;getPowerMode() == HWC_POWER_MODE_OFF) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nsecs_t currentTime = systemTime();</span><br><span class="line">    if (mHasPoweredOff) &#123;</span><br><span class="line">        mHasPoweredOff = false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        nsecs_t elapsedTime = currentTime - getBE().mLastSwapTime;</span><br><span class="line">        size_t numPeriods = static_cast&lt;size_t&gt;(elapsedTime / vsyncInterval);</span><br><span class="line">        if (numPeriods &lt; SurfaceFlingerBE::NUM_BUCKETS - 1) &#123;</span><br><span class="line">            getBE().mFrameBuckets[numPeriods] += elapsedTime;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            getBE().mFrameBuckets[SurfaceFlingerBE::NUM_BUCKETS - 1] += elapsedTime;</span><br><span class="line">        &#125;</span><br><span class="line">        getBE().mTotalTime += elapsedTime;</span><br><span class="line">    &#125;</span><br><span class="line">    getBE().mLastSwapTime = currentTime;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard lock(mTexturePoolMutex);</span><br><span class="line">        const size_t refillCount = mTexturePoolSize - mTexturePool.size();</span><br><span class="line">        if (refillCount &gt; 0) &#123;</span><br><span class="line">            const size_t offset = mTexturePool.size();</span><br><span class="line">            mTexturePool.resize(mTexturePoolSize);</span><br><span class="line">            getRenderEngine().genTextures(refillCount, mTexturePool.data() + offset);</span><br><span class="line">            ATRACE_INT(&quot;TexturePoolSize&quot;, mTexturePool.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>本文主要介绍了SurfaceFlinger和绘制相关的流程，首先介绍了SurfcaeFlinger的启动过程，后面分析Vsync信号如何进行通知屏幕的绘制，最后分析了屏幕的绘制图像输出流程。</p>
<p>这三个过程主要的线程如下：</p>
<ul>
<li>主线程“/system/bin/surfaceflinger”: 主线程</li>
<li>线程“EventThread”：EventThread</li>
<li>线程“EventControl”： EventControlThread</li>
<li>线程“DispSync”：DispSyncThread</li>
</ul>
<p><strong>SurfcaeFlinger的启动过程</strong></p>
<p>1.启动图形处理服务</p>
<p>2.开启线程池，最大binder线程池数的个数为4</p>
<p>3.设置SurfaceFlinger进程为高优先级以及后台调度策略</p>
<p>4.创建SurfaceFlinger，并初始化，启动app和sf的两个EventThread线程</p>
<p>5.注册SurfaceFlinger服务和GpuService</p>
<p>6.启动显示服务，最后执行surfacefinger的run方法</p>
<p><strong>Vsync信号处理</strong></p>
<p>1.如果要接收Vsync信号，则必须先注册，当Vsync信号来时会调用onVsyncReceived方法</p>
<p>2.通过调用DispSyncThread.updateModel中的mCond.signal() 来唤醒DispSyncThread线程；</p>
<p>3.执行EventThread::onVSyncEvent()方法中调用 mCondition.notify_all() 唤醒EventThread线程；</p>
<p>4.在DisplayEventReceiver.sendEvents调用BitTube::sendObjects，当收到数据时会执行MQ.cb_eventReceiver，然后通过handler消息机制进入到SurfaceFlinger主线程，调用SF.onMessageReceived方法</p>
<p><strong>图形输出</strong></p>
<p>1.根据上次绘制的图层是否有更新，来判断是否执行invalidate过程</p>
<p>2.重新每个显示屏所有可见点Layer列表</p>
<p>3.更新HWComposer图层</p>
<p>4.合成所有Layer的图像</p>
<p>5.回调每个Layer的onPostComposition</p>

      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SurfaceFlinger/" rel="tag">#SurfaceFlinger</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/Android刷新机制-Choreographer原理/" rel="next" title="Android刷新机制-Choreographer原理">
                <i class="fa fa-chevron-left"></i> Android刷新机制-Choreographer原理
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">33</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、启动过程"><span class="nav-text">二、启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-main"><span class="nav-text">2.1 main</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-创建SurfaceFlinger"><span class="nav-text">2.2 创建SurfaceFlinger</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-onFirstRef"><span class="nav-text">2.2.1 onFirstRef</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-MQ-init"><span class="nav-text">2.2.2  MQ.init</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-SF-init"><span class="nav-text">2.3 SF.init</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-创建HWComposer"><span class="nav-text">2.3.1 创建HWComposer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-processDisplayHotplugEventsLocked"><span class="nav-text">2.3.2 processDisplayHotplugEventsLocked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-processDisplayChangesLocked"><span class="nav-text">2.3.3 processDisplayChangesLocked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-initializeDisplays"><span class="nav-text">2.3.4 initializeDisplays</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-EventThread线程"><span class="nav-text">2.4 EventThread线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-1-onFirstRef"><span class="nav-text">2.4.1 onFirstRef</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-threadMain"><span class="nav-text">2.4.2 threadMain</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-3-waitForEventLocked"><span class="nav-text">2.4.3 waitForEventLocked</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-setEventThread"><span class="nav-text">2.5 setEventThread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-SF-run"><span class="nav-text">2.6 SF.run</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、Vsync信号"><span class="nav-text">三、Vsync信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-registerCallback"><span class="nav-text">3.1 registerCallback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-onVsyncReceived"><span class="nav-text">3.2 onVsyncReceived</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-addResyncSample"><span class="nav-text">3.3 addResyncSample</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-DispSync初始化"><span class="nav-text">3.3.1 DispSync初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-DispSyncThread-run"><span class="nav-text">3.3.2 DispSyncThread.run</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-DS-updateModelLocked"><span class="nav-text">3.4 DS.updateModelLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-DST-updateModel"><span class="nav-text">3.5 DST.updateModel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-DSS-onDispSyncEvent"><span class="nav-text">3.6 DSS.onDispSyncEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-onVSyncEvent"><span class="nav-text">3.7 onVSyncEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-ET-postEvent"><span class="nav-text">3.8 ET.postEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-DER-sendEvents"><span class="nav-text">3.9 DER.sendEvents</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9-1-MQ-cb-eventReceiver"><span class="nav-text">3.9.1 MQ.cb_eventReceiver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9-2-MQ-eventReceiver"><span class="nav-text">3.9.2  MQ.eventReceiver</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-10-MQ-dispatchInvalidate"><span class="nav-text">3.10 MQ.dispatchInvalidate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-11-MQ-handleMessage"><span class="nav-text">3.11 MQ.handleMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-12-SF-onMessageReceived"><span class="nav-text">3.12 SF.onMessageReceived</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、图像输出"><span class="nav-text">四、图像输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-SF-handleMessageRefresh"><span class="nav-text">4.1 SF.handleMessageRefresh</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-SF-preComposition"><span class="nav-text">4.2 SF.preComposition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-SF-rebuildLayerStacks"><span class="nav-text">4.3 SF.rebuildLayerStacks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-SF-setUpHWComposer"><span class="nav-text">4.4 SF.setUpHWComposer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-SF-doComposition"><span class="nav-text">4.5 SF.doComposition</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-1-doDisplayComposition"><span class="nav-text">4.5.1 doDisplayComposition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-2-doComposeSurfaces"><span class="nav-text">4.5.2 doComposeSurfaces</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-3-postFramebuffer"><span class="nav-text">4.5.3 postFramebuffer</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-SF-postComposition"><span class="nav-text">4.6 SF.postComposition</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、总结"><span class="nav-text">五、总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2020/Android刷新机制-SurfaceFlinger原理/';
      var disqus_title = "Android刷新机制-SurfaceFlinger原理";
      var disqus_url = 'http://zproo.github.io/2020/Android刷新机制-SurfaceFlinger原理/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
