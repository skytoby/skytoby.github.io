<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Android进程,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="基于Android10.0，分析进程的创建过程  一、概述每个app在启动前都必须创建一个进程，这个进程是由zygote fork而来，进程具有独立的资源空间，用于app上运行的各种Activity、Service等组件。大多数情况下一个应用运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或者通过Native代码fork进程。相对于线程，线">
<meta name="keywords" content="Android进程">
<meta property="og:type" content="article">
<meta property="og:title" content="Android进程创建流程分析">
<meta property="og:url" content="http://zproo.github.io/2019/Android进程创建流程分析/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="基于Android10.0，分析进程的创建过程  一、概述每个app在启动前都必须创建一个进程，这个进程是由zygote fork而来，进程具有独立的资源空间，用于app上运行的各种Activity、Service等组件。大多数情况下一个应用运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或者通过Native代码fork进程。相对于线程，线">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2019/Android进程创建流程分析/process_create.jpg">
<meta property="og:image" content="http://zproo.github.io/2019/Android进程创建流程分析/zygote.PNG">
<meta property="og:updated_time" content="2020-05-08T02:03:17.529Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android进程创建流程分析">
<meta name="twitter:description" content="基于Android10.0，分析进程的创建过程  一、概述每个app在启动前都必须创建一个进程，这个进程是由zygote fork而来，进程具有独立的资源空间，用于app上运行的各种Activity、Service等组件。大多数情况下一个应用运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或者通过Native代码fork进程。相对于线程，线">
<meta name="twitter:image" content="http://zproo.github.io/2019/Android进程创建流程分析/process_create.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2019/Android进程创建流程分析/">

  <title> Android进程创建流程分析 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/Android进程/" rel="tag" title="Android进程">Android进程</a>
      
      </div>
      <h1>Android进程创建流程分析</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2019-10-20T21:50:23+08:00" content="2019-10-20" title="2019-10-20 21:50:23">
          2019-10-20
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android进程创建流程分析
              
            
          </h1>
        

        <div class="post-meta">
		  

          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-10-20T21:50:23+08:00" content="2019-10-20">
              2019-10-20
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/Android进程创建流程分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/Android进程创建流程分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>基于Android10.0，分析进程的创建过程</p>
</blockquote>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>每个app在启动前都必须创建一个进程，这个进程是由zygote fork而来，进程具有独立的资源空间，用于app上运行的各种Activity、Service等组件。大多数情况下一个应用运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或者通过Native代码fork进程。相对于线程，线程没有独立的地址空间，与其所在进程之间资源共享。</p>
<p>Android系统根据进程的重要性主要分为前台进程、可见进程、服务进程、后台进程、空进程。为了回收系统资源，系统会根据重要性高低来清除进程。</p>
<p>下图是进程的创建过程</p>
<p><img src="/2019/Android进程创建流程分析/process_create.jpg" alt=""></p>
<p>1.APP发起进程：当从桌面启动应用，则发起进程是Launcher所在进程；当从某App内启动远程进程，则发送进程是该app所在的进程。发送进程通过binder发送消息给systemserver进程。</p>
<p>2.systemserver进程:调用Process.start方法，通过socket向zygote进程发送创建新进程的请求。</p>
<p>3.zygote进程：执行ZygoteInit.main进入runSelectLoop循环体内，当有客户端连接时，便会执行ZygoteConnection.processOneCommand方法，经过层层调用fork新的应用进程。</p>
<p>4.新进程：执行handleChildProc方法，最后调用ActivityThread.main方法。</p>
<p>下面将从进程的角度分析进程创建的过程。</p>
<h2 id="二、systemserver发起请求"><a href="#二、systemserver发起请求" class="headerlink" title="二、systemserver发起请求"></a>二、systemserver发起请求</h2><h3 id="1-Process-start"><a href="#1-Process-start" class="headerlink" title="1.  Process.start"></a>1.  Process.start</h3><p>[-&gt;Process.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                                 final String niceName,</span><br><span class="line">                                 int uid, int gid, int[] gids,</span><br><span class="line">                                 int runtimeFlags, int mountExternal,</span><br><span class="line">                                 int targetSdkVersion,</span><br><span class="line">                                 String seInfo,</span><br><span class="line">                                 String abi,</span><br><span class="line">                                 String instructionSet,</span><br><span class="line">                                 String appDataDir,</span><br><span class="line">                                 String invokeWith,</span><br><span class="line">                                 String[] zygoteArgs) &#123;</span><br><span class="line">       return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                   runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                   abi, instructionSet, appDataDir, invokeWith,</span><br><span class="line">                   /*useBlastulaPool=*/ true, zygoteArgs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final Process.ProcessStartResult start(final String processClass,</span><br><span class="line">                                                 final String niceName,</span><br><span class="line">                                                 int uid, int gid, int[] gids,</span><br><span class="line">                                                 int runtimeFlags, int mountExternal,</span><br><span class="line">                                                 int targetSdkVersion,</span><br><span class="line">                                                 String seInfo,</span><br><span class="line">                                                 String abi,</span><br><span class="line">                                                 String instructionSet,</span><br><span class="line">                                                 String appDataDir,</span><br><span class="line">                                                 String invokeWith,</span><br><span class="line">                                                 boolean useBlastulaPool,</span><br><span class="line">                                                 String[] zygoteArgs) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                   runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                   abi, instructionSet, appDataDir, invokeWith,</span><br><span class="line">                   /*startChildZygote=*/false,</span><br><span class="line">                   useBlastulaPool, zygoteArgs);</span><br><span class="line">       &#125; catch (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">           Log.e(LOG_TAG,</span><br><span class="line">                   &quot;Starting VM process through Zygote failed&quot;);</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">                   &quot;Starting VM process through Zygote failed&quot;, ex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Process-startViaZygote"><a href="#2-Process-startViaZygote" class="headerlink" title="2.  Process.startViaZygote"></a>2.  Process.startViaZygote</h3><p>[-&gt;ZygoteProcess.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">private Process.ProcessStartResult startViaZygote(final String processClass,</span><br><span class="line">                                                     final String niceName,</span><br><span class="line">                                                     final int uid, final int gid,</span><br><span class="line">                                                     final int[] gids,</span><br><span class="line">                                                     int runtimeFlags, int mountExternal,</span><br><span class="line">                                                     int targetSdkVersion,</span><br><span class="line">                                                     String seInfo,</span><br><span class="line">                                                     String abi,</span><br><span class="line">                                                     String instructionSet,</span><br><span class="line">                                                     String appDataDir,</span><br><span class="line">                                                     String invokeWith,</span><br><span class="line">                                                     boolean startChildZygote,</span><br><span class="line">                                                     boolean useBlastulaPool,</span><br><span class="line">                                                     String[] extraArgs)</span><br><span class="line">                                                     throws ZygoteStartFailedEx &#123;</span><br><span class="line">       ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">       // --runtime-args, --setuid=, --setgid=,</span><br><span class="line">       // and --setgroups= must go first</span><br><span class="line">       argsForZygote.add(&quot;--runtime-args&quot;);</span><br><span class="line">       argsForZygote.add(&quot;--setuid=&quot; + uid);</span><br><span class="line">       argsForZygote.add(&quot;--setgid=&quot; + gid);</span><br><span class="line">       argsForZygote.add(&quot;--runtime-flags=&quot; + runtimeFlags);</span><br><span class="line">       if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">           argsForZygote.add(&quot;--mount-external-default&quot;);</span><br><span class="line">       &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">           argsForZygote.add(&quot;--mount-external-read&quot;);</span><br><span class="line">       &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">           argsForZygote.add(&quot;--mount-external-write&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">       // --setgroups is a comma-separated list</span><br><span class="line">       if (gids != null &amp;&amp; gids.length &gt; 0) &#123;</span><br><span class="line">           StringBuilder sb = new StringBuilder();</span><br><span class="line">           sb.append(&quot;--setgroups=&quot;);</span><br><span class="line"></span><br><span class="line">           int sz = gids.length;</span><br><span class="line">           for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">               if (i != 0) &#123;</span><br><span class="line">                   sb.append(&apos;,&apos;);</span><br><span class="line">               &#125;</span><br><span class="line">               sb.append(gids[i]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           argsForZygote.add(sb.toString());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (niceName != null) &#123;</span><br><span class="line">           argsForZygote.add(&quot;--nice-name=&quot; + niceName);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (seInfo != null) &#123;</span><br><span class="line">           argsForZygote.add(&quot;--seinfo=&quot; + seInfo);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (instructionSet != null) &#123;</span><br><span class="line">           argsForZygote.add(&quot;--instruction-set=&quot; + instructionSet);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (appDataDir != null) &#123;</span><br><span class="line">           argsForZygote.add(&quot;--app-data-dir=&quot; + appDataDir);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (invokeWith != null) &#123;</span><br><span class="line">           argsForZygote.add(&quot;--invoke-with&quot;);</span><br><span class="line">           argsForZygote.add(invokeWith);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (startChildZygote) &#123;</span><br><span class="line">           argsForZygote.add(&quot;--start-child-zygote&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">       if (extraArgs != null) &#123;</span><br><span class="line">           for (String arg : extraArgs) &#123;</span><br><span class="line">               argsForZygote.add(arg);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized(mLock) &#123;</span><br><span class="line">           //见第3节</span><br><span class="line">           return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),</span><br><span class="line">                                             useBlastulaPool,</span><br><span class="line">                                             argsForZygote);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该过程主要是配置argsForZygote列表信息，列表信息保存了uid,gid,targetSdkVersion，appDataDir等信息。</p>
<h3 id="3-zygoteSendArgsAndGetResult"><a href="#3-zygoteSendArgsAndGetResult" class="headerlink" title="3.  zygoteSendArgsAndGetResult"></a>3.  zygoteSendArgsAndGetResult</h3><p>[-&gt;ZygoteProcess.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">private static Process.ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">            ZygoteState zygoteState, boolean useBlastulaPool, ArrayList&lt;String&gt; args)</span><br><span class="line">            throws ZygoteStartFailedEx &#123;</span><br><span class="line">        // Throw early if any of the arguments are malformed. This means we can</span><br><span class="line">        // avoid writing a partial response to the zygote.</span><br><span class="line">        for (String arg : args) &#123;</span><br><span class="line">            if (arg.indexOf(&apos;/n&apos;) &gt;= 0) &#123;</span><br><span class="line">                throw new ZygoteStartFailedEx(&quot;embedded newlines not allowed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * See com.android.internal.os.ZygoteArguments.parseArgs()</span><br><span class="line">         * Presently the wire format to the zygote process is:</span><br><span class="line">         * a) a count of arguments (argc, in essence)</span><br><span class="line">         * b) a number of newline-separated argument strings equal to count</span><br><span class="line">         *</span><br><span class="line">         * After the zygote process reads these it will write the pid of</span><br><span class="line">         * the child or -1 on failure, followed by boolean to</span><br><span class="line">         * indicate whether a wrapper process was used.</span><br><span class="line">         */</span><br><span class="line">        String msgStr = Integer.toString(args.size()) + &quot;/n&quot;</span><br><span class="line">                        + String.join(&quot;/n&quot;, args) + &quot;/n&quot;;</span><br><span class="line"></span><br><span class="line">        // Should there be a timeout on this?</span><br><span class="line">        //这里等待创建进程返回是否加timeout？</span><br><span class="line">        Process.ProcessStartResult result = new Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        // TODO (chriswailes): Move branch body into separate function.</span><br><span class="line">        if (useBlastulaPool &amp;&amp; Zygote.BLASTULA_POOL_ENABLED &amp;&amp; isValidBlastulaCommand(args)) &#123;</span><br><span class="line">            LocalSocket blastulaSessionSocket = null;</span><br><span class="line">           //blastulaSessionSocket进入这个分支</span><br><span class="line">            try &#123;</span><br><span class="line">                blastulaSessionSocket = zygoteState.getBlastulaSessionSocket();</span><br><span class="line"></span><br><span class="line">                final BufferedWriter blastulaWriter =</span><br><span class="line">                        new BufferedWriter(</span><br><span class="line">                                new OutputStreamWriter(blastulaSessionSocket.getOutputStream()),</span><br><span class="line">                                Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line">                final DataInputStream blastulaReader =</span><br><span class="line">                        new DataInputStream(blastulaSessionSocket.getInputStream());</span><br><span class="line"></span><br><span class="line">                blastulaWriter.write(msgStr);</span><br><span class="line">                blastulaWriter.flush();</span><br><span class="line"></span><br><span class="line">                //等待socket服务端返回新创建的进程pid</span><br><span class="line">                result.pid = blastulaReader.readInt();</span><br><span class="line">                // Blastulas can&apos;t be used to spawn processes that need wrappers.</span><br><span class="line">                result.usingWrapper = false;</span><br><span class="line"></span><br><span class="line">                if (result.pid &lt; 0) &#123;</span><br><span class="line">                    throw new ZygoteStartFailedEx(&quot;Blastula specialization failed&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return result;</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">                // If there was an IOException using the blastula pool we will log the error and</span><br><span class="line">                // attempt to start the process through the Zygote.</span><br><span class="line">                Log.e(LOG_TAG, &quot;IO Exception while communicating with blastula pool - &quot;</span><br><span class="line">                               + ex.toString());</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    blastulaSessionSocket.close();</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    Log.e(LOG_TAG, &quot;Failed to close blastula session socket: &quot; + ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">            final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line"></span><br><span class="line">            zygoteWriter.write(msgStr);</span><br><span class="line">            zygoteWriter.flush();</span><br><span class="line"></span><br><span class="line">            // Always read the entire result from the input stream to avoid leaving</span><br><span class="line">            // bytes in the stream for future process starts to accidentally stumble</span><br><span class="line">            // upon.</span><br><span class="line">            //等待socket服务端返回新创建的进程pid</span><br><span class="line">            result.pid = zygoteInputStream.readInt();</span><br><span class="line">            result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            zygoteState.close();</span><br><span class="line">            Log.e(LOG_TAG, &quot;IO Exception while communicating with Zygote - &quot;</span><br><span class="line">                    + ex.toString());</span><br><span class="line">            throw new ZygoteStartFailedEx(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (result.pid &lt; 0) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是通过socket通道向zygote进程发送一个参数列表信息，然后进入阻塞等待状态，直到远端的socket服务端发送回来新创建的进程pid才返回。</p>
<h4 id="3-1-openZygoteSocketIfNeeded"><a href="#3-1-openZygoteSocketIfNeeded" class="headerlink" title="3.1 openZygoteSocketIfNeeded"></a>3.1 openZygoteSocketIfNeeded</h4><p>[-&gt;ZygoteProcess.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private ZygoteState openZygoteSocketIfNeeded(String abi)</span><br><span class="line">           throws ZygoteStartFailedEx &#123;</span><br><span class="line"></span><br><span class="line">       Preconditions.checkState(Thread.holdsLock(mLock), &quot;ZygoteProcess lock not held&quot;);</span><br><span class="line"></span><br><span class="line">       if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">              //向主zygote发起connect操作</span><br><span class="line">               primaryZygoteState =</span><br><span class="line">                   ZygoteState.connect(mZygoteSocketAddress, mBlastulaPoolSocketAddress);</span><br><span class="line">           &#125; catch (IOException ioe) &#123;</span><br><span class="line">               throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           maybeSetApiBlacklistExemptions(primaryZygoteState, false);</span><br><span class="line">           maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">           return primaryZygoteState;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // The primary zygote didn&apos;t match. Try the secondary.</span><br><span class="line">       if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">              //当主zygote不匹配，则采用第二个zygote发起connect连接</span><br><span class="line">               secondaryZygoteState =</span><br><span class="line">                   ZygoteState.connect(mZygoteSecondarySocketAddress,</span><br><span class="line">                                       mBlastulaPoolSecondarySocketAddress);</span><br><span class="line">           &#125; catch (IOException ioe) &#123;</span><br><span class="line">               throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           maybeSetApiBlacklistExemptions(secondaryZygoteState, false);</span><br><span class="line">           maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">           return secondaryZygoteState;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是根据abi来选择与zygote还是zygote64来进行通信。</p>
<p>在systemserver进程的zygoteSendArgsAndGetResult方法通过socket向zygote发送消息，这时会唤醒Zygote进程，来响应systemserver客户端的请求，下面是zygote来创建进程。</p>
<h2 id="三、zygote创建进程"><a href="#三、zygote创建进程" class="headerlink" title="三、zygote创建进程"></a>三、zygote创建进程</h2><p>在systemserver启动过程上中有介绍zygote进程启动，它是由init进程创建，进程启动之后调用ZygoteInit.main方法，经过socket管道，预加载资源后，进入runSelectLoop方法。</p>
<h3 id="4-ZygoteInit-main"><a href="#4-ZygoteInit-main" class="headerlink" title="4.ZygoteInit.main"></a>4.ZygoteInit.main</h3><p>[-&gt;ZygoteInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">       ZygoteServer zygoteServer = new ZygoteServer();</span><br><span class="line"></span><br><span class="line">       // Mark zygote start. This ensures that thread creation will throw</span><br><span class="line">       // an error.</span><br><span class="line">       ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">       // Zygote goes into its own process group.</span><br><span class="line">       try &#123;</span><br><span class="line">           Os.setpgid(0, 0);</span><br><span class="line">       &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">           throw new RuntimeException(&quot;Failed to setpgid(0,0)&quot;, ex);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Runnable caller;</span><br><span class="line">       try &#123;</span><br><span class="line">           // Report Zygote start time to tron unless it is a runtime restart</span><br><span class="line">           if (!&quot;1&quot;.equals(SystemProperties.get(&quot;sys.boot_completed&quot;))) &#123;</span><br><span class="line">               MetricsLogger.histogram(null, &quot;boot_zygote_init&quot;,</span><br><span class="line">                       (int) SystemClock.elapsedRealtime());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           String bootTimeTag = Process.is64Bit() ? &quot;Zygote64Timing&quot; : &quot;Zygote32Timing&quot;;</span><br><span class="line">           TimingsTraceLog bootTimingsTraceLog = new TimingsTraceLog(bootTimeTag,</span><br><span class="line">                   Trace.TRACE_TAG_DALVIK);</span><br><span class="line">           bootTimingsTraceLog.traceBegin(&quot;ZygoteInit&quot;);</span><br><span class="line">           RuntimeInit.enableDdms();</span><br><span class="line"></span><br><span class="line">           boolean startSystemServer = false;</span><br><span class="line">           String socketName = &quot;zygote&quot;;</span><br><span class="line">           String abiList = null;</span><br><span class="line">           boolean enableLazyPreload = false;</span><br><span class="line">           for (int i = 1; i &lt; argv.length; i++) &#123;</span><br><span class="line">               if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</span><br><span class="line">                   startSystemServer = true;</span><br><span class="line">               &#125; else if (&quot;--enable-lazy-preload&quot;.equals(argv[i])) &#123;</span><br><span class="line">                   enableLazyPreload = true;</span><br><span class="line">               &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                   abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">               &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                   socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (abiList == null) &#123;</span><br><span class="line">               throw new RuntimeException(&quot;No ABI list supplied.&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // TODO (chriswailes): Wrap these three calls in a helper function?</span><br><span class="line">           final String blastulaSocketName =</span><br><span class="line">                   socketName.equals(ZygoteProcess.ZYGOTE_SOCKET_NAME)</span><br><span class="line">                           ? ZygoteProcess.BLASTULA_POOL_SOCKET_NAME</span><br><span class="line">                           : ZygoteProcess.BLASTULA_POOL_SECONDARY_SOCKET_NAME;</span><br><span class="line">           //为zygote注册socket</span><br><span class="line">           zygoteServer.createZygoteSocket(socketName);</span><br><span class="line">           Zygote.createBlastulaSocket(blastulaSocketName);</span><br><span class="line"></span><br><span class="line">           Zygote.getSocketFDs(socketName.equals(ZygoteProcess.ZYGOTE_SOCKET_NAME));</span><br><span class="line"></span><br><span class="line">           // In some configurations, we avoid preloading resources and classes eagerly.</span><br><span class="line">           // In such cases, we will preload things prior to our first fork.</span><br><span class="line">           if (!enableLazyPreload) &#123;</span><br><span class="line">               bootTimingsTraceLog.traceBegin(&quot;ZygotePreload&quot;);</span><br><span class="line">               EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">                       SystemClock.uptimeMillis());</span><br><span class="line">               //预加载资源</span><br><span class="line">               preload(bootTimingsTraceLog);</span><br><span class="line">               EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class="line">                       SystemClock.uptimeMillis());</span><br><span class="line">               bootTimingsTraceLog.traceEnd(); // ZygotePreload</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               Zygote.resetNicePriority();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Do an initial gc to clean up after startup</span><br><span class="line">           bootTimingsTraceLog.traceBegin(&quot;PostZygoteInitGC&quot;);</span><br><span class="line">           gcAndFinalize();</span><br><span class="line">           bootTimingsTraceLog.traceEnd(); // PostZygoteInitGC</span><br><span class="line"></span><br><span class="line">           bootTimingsTraceLog.traceEnd(); // ZygoteInit</span><br><span class="line">           // Disable tracing so that forked processes do not inherit stale tracing tags from</span><br><span class="line">           // Zygote.</span><br><span class="line">           Trace.setTracingEnabled(false, 0);</span><br><span class="line"></span><br><span class="line">           Zygote.nativeSecurityInit();</span><br><span class="line"></span><br><span class="line">           // Zygote process unmounts root storage spaces.</span><br><span class="line">           Zygote.nativeUnmountStorageOnInit();</span><br><span class="line"></span><br><span class="line">           ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">           if (startSystemServer) &#123;</span><br><span class="line">               //启动systemserver进程</span><br><span class="line">               Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">               // &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span><br><span class="line">               // child (system_server) process.</span><br><span class="line">               if (r != null) &#123;</span><br><span class="line">                   r.run();</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // If the return value is null then this is the zygote process</span><br><span class="line">           // returning to the normal control flow.  If it returns a Runnable</span><br><span class="line">           // object then this is a blastula that has finished specializing.</span><br><span class="line">           // 初始化胚胎池</span><br><span class="line">           caller = Zygote.initBlastulaPool();</span><br><span class="line"></span><br><span class="line">           if (caller == null) &#123;</span><br><span class="line">               Log.i(TAG, &quot;Accepting command socket connections&quot;);</span><br><span class="line">               // 当接收到创建进程的请求时唤醒并执行相应工作</span><br><span class="line">               // The select loop returns early in the child process after a fork and</span><br><span class="line">               // loops forever in the zygote.</span><br><span class="line">               caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Throwable ex) &#123;</span><br><span class="line">           Log.e(TAG, &quot;System zygote died with exception&quot;, ex);</span><br><span class="line">           throw ex;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           zygoteServer.closeServerSocket();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // We&apos;re in the child process and have exited the select loop. Proceed to execute the</span><br><span class="line">       // command.</span><br><span class="line">       if (caller != null) &#123;</span><br><span class="line">           caller.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-ZS-runSelectLoop"><a href="#5-ZS-runSelectLoop" class="headerlink" title="5.ZS.runSelectLoop"></a>5.ZS.runSelectLoop</h3><p>[-&gt;ZygoteServer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Runs the zygote process&apos;s select loop. Accepts new connections as</span><br><span class="line">   * they happen, and reads commands from connections one spawn-request&apos;s</span><br><span class="line">   * worth at a time.</span><br><span class="line">   */</span><br><span class="line">  Runnable runSelectLoop(String abiList) &#123;</span><br><span class="line">      ArrayList&lt;FileDescriptor&gt; socketFDs = new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">      ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">      //mZygoteSocket是socket通信中的服务端即zygote进程，保存在fds[0]中</span><br><span class="line">      socketFDs.add(mZygoteSocket.getFileDescriptor());</span><br><span class="line">      peers.add(null);</span><br><span class="line"></span><br><span class="line">      while (true) &#123;</span><br><span class="line">          int[] blastulaPipeFDs = Zygote.getBlastulaPipeFDs();</span><br><span class="line">          </span><br><span class="line">          // Space for all of the socket FDs, the Blastula Pool Event FD, and</span><br><span class="line">          // all of the open blastula read pipe FDs.</span><br><span class="line">          //pollFDs包括socket、Blastula Pool Event 和open blastula read pipe FDs</span><br><span class="line">          StructPollfd[] pollFDs =</span><br><span class="line">              new StructPollfd[socketFDs.size() + 1 + blastulaPipeFDs.length];</span><br><span class="line"></span><br><span class="line">          int pollIndex = 0;</span><br><span class="line">          for (FileDescriptor socketFD : socketFDs) &#123;</span><br><span class="line">              pollFDs[pollIndex] = new StructPollfd();</span><br><span class="line">              pollFDs[pollIndex].fd = socketFD;</span><br><span class="line">              pollFDs[pollIndex].events = (short) POLLIN;</span><br><span class="line">              ++pollIndex;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final int blastulaPoolEventFDIndex = pollIndex;</span><br><span class="line">          pollFDs[pollIndex] = new StructPollfd();</span><br><span class="line">          pollFDs[pollIndex].fd = Zygote.sBlastulaPoolEventFD;</span><br><span class="line">          pollFDs[pollIndex].events = (short) POLLIN;</span><br><span class="line">          ++pollIndex;</span><br><span class="line"></span><br><span class="line">          for (int blastulaPipeFD : blastulaPipeFDs) &#123;</span><br><span class="line">              FileDescriptor managedFd = new FileDescriptor();</span><br><span class="line">              managedFd.setInt$(blastulaPipeFD);</span><br><span class="line"></span><br><span class="line">              pollFDs[pollIndex] = new StructPollfd();</span><br><span class="line">              pollFDs[pollIndex].fd = managedFd;</span><br><span class="line">              pollFDs[pollIndex].events = (short) POLLIN;</span><br><span class="line">              ++pollIndex;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              //处理轮询状态，当pollFDs有事件到来则往下执行，否则阻塞在这里</span><br><span class="line">              Os.poll(pollFDs, -1);</span><br><span class="line">          &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">              throw new RuntimeException(&quot;poll failed&quot;, ex);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          while (--pollIndex &gt;= 0) &#123;</span><br><span class="line">              //采用I/O多路复用机制，当接收到客户端发出的连接请求时或者数据处理请求到来</span><br><span class="line">              //则往下执行，否则continue，本次循环结束</span><br><span class="line">              if ((pollFDs[pollIndex].revents &amp; POLLIN) == 0) &#123;</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              if (pollIndex == 0) &#123;</span><br><span class="line">                  // Zygote server socket</span><br><span class="line">                  //代表mZygoteSocket即fds[0]</span><br><span class="line">                  //有客户连接请求，创建ZygoteConnection对象并添加到socketFDs</span><br><span class="line">                  ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                  peers.add(newPeer);</span><br><span class="line">                  socketFDs.add(newPeer.getFileDescriptor());</span><br><span class="line"></span><br><span class="line">              &#125; else if (pollIndex &lt; blastulaPoolEventFDIndex) &#123;</span><br><span class="line">                  // Session socket accepted from the Zygote server socket</span><br><span class="line">                  // 从zygote server中的socket</span><br><span class="line">                  try &#123;</span><br><span class="line">                      ZygoteConnection connection = peers.get(pollIndex);</span><br><span class="line">                      final Runnable command = connection.processOneCommand(this);</span><br><span class="line"></span><br><span class="line">                      if (mIsForkChild) &#123;</span><br><span class="line">                          // We&apos;re in the child. We should always have a command to run at this</span><br><span class="line">                          // stage if processOneCommand hasn&apos;t called &quot;exec&quot;.</span><br><span class="line">                          if (command == null) &#123;</span><br><span class="line">                              throw new IllegalStateException(&quot;command == null&quot;);</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          return command;</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          // We&apos;re in the server - we should never have any commands to run.</span><br><span class="line">                          if (command != null) &#123;</span><br><span class="line">                              throw new IllegalStateException(&quot;command != null&quot;);</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          // We don&apos;t know whether the remote side of the socket was closed or</span><br><span class="line">                          // not until we attempt to read from it from processOneCommand. This</span><br><span class="line">                          // shows up as a regular POLLIN event in our regular processing loop.</span><br><span class="line">                          if (connection.isClosedByPeer()) &#123;</span><br><span class="line">                              connection.closeSocket();</span><br><span class="line">                              peers.remove(pollIndex);</span><br><span class="line">                              socketFDs.remove(pollIndex);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                      if (!mIsForkChild) &#123;</span><br><span class="line">                          // We&apos;re in the server so any exception here is one that has taken place</span><br><span class="line">                          // pre-fork while processing commands or reading / writing from the</span><br><span class="line">                          // control socket. Make a loud noise about any such exceptions so that</span><br><span class="line">                          // we know exactly what failed and why.</span><br><span class="line"></span><br><span class="line">                          Slog.e(TAG, &quot;Exception executing zygote command: &quot;, e);</span><br><span class="line"></span><br><span class="line">                          // Make sure the socket is closed so that the other end knows</span><br><span class="line">                          // immediately that something has gone wrong and doesn&apos;t time out</span><br><span class="line">                          // waiting for a response.</span><br><span class="line">                          ZygoteConnection conn = peers.remove(pollIndex);</span><br><span class="line">                          conn.closeSocket();</span><br><span class="line"></span><br><span class="line">                          socketFDs.remove(pollIndex);</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          // We&apos;re in the child so any exception caught here has happened post</span><br><span class="line">                          // fork and before we execute ActivityThread.main (or any other main()</span><br><span class="line">                          // method). Log the details of the exception and bring down the process.</span><br><span class="line">                          Log.e(TAG, &quot;Caught post-fork exception in child process.&quot;, e);</span><br><span class="line">                          throw e;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; finally &#123;</span><br><span class="line">                      // Reset the child flag, in the event that the child process is a child-</span><br><span class="line">                      // zygote. The flag will not be consulted this loop pass after the Runnable</span><br><span class="line">                      // is returned.</span><br><span class="line">                      mIsForkChild = false;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  // Either the blastula pool event FD or a blastula reporting pipe.</span><br><span class="line">                  //  blastula pool event FD或者blastula reporting pipe</span><br><span class="line">                  // If this is the event FD the payload will be the number of blastulas removed.</span><br><span class="line">                  // If this is a reporting pipe FD the payload will be the PID of the blastula</span><br><span class="line">                  // that was just specialized.</span><br><span class="line">                  long messagePayload = -1;</span><br><span class="line"></span><br><span class="line">                  try &#123;</span><br><span class="line">                  </span><br><span class="line">                  /**</span><br><span class="line">                  *   Number of bytes sent to the Zygote over blastula pipes or the pool event FD </span><br><span class="line">                  *   public static final int BLASTULA_MANAGEMENT_MESSAGE_BYTES = 8;</span><br><span class="line">                  */</span><br><span class="line">                      byte[] buffer = new byte[Zygote.BLASTULA_MANAGEMENT_MESSAGE_BYTES];</span><br><span class="line">                      int readBytes = Os.read(pollFDs[pollIndex].fd, buffer, 0, buffer.length);</span><br><span class="line"></span><br><span class="line">                      if (readBytes == Zygote.BLASTULA_MANAGEMENT_MESSAGE_BYTES) &#123;</span><br><span class="line">                          DataInputStream inputStream =</span><br><span class="line">                                  new DataInputStream(new ByteArrayInputStream(buffer));</span><br><span class="line"></span><br><span class="line">                          messagePayload = inputStream.readLong();</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          Log.e(TAG, &quot;Incomplete read from blastula management FD of size &quot;</span><br><span class="line">                                  + readBytes);</span><br><span class="line">                          continue;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; catch (Exception ex) &#123;</span><br><span class="line">                      if (pollIndex == blastulaPoolEventFDIndex) &#123;</span><br><span class="line">                          Log.e(TAG, &quot;Failed to read from blastula pool event FD: &quot;</span><br><span class="line">                                  + ex.getMessage());</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          Log.e(TAG, &quot;Failed to read from blastula reporting pipe: &quot;</span><br><span class="line">                                  + ex.getMessage());</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      continue;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  if (pollIndex &gt; blastulaPoolEventFDIndex) &#123;</span><br><span class="line">                      Zygote.removeBlastulaTableEntry((int) messagePayload);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  int[] sessionSocketRawFDs =</span><br><span class="line">                          socketFDs.subList(1, socketFDs.size())</span><br><span class="line">                                  .stream()</span><br><span class="line">                                  .mapToInt(fd -&gt; fd.getInt$())</span><br><span class="line">                                  .toArray();</span><br><span class="line"></span><br><span class="line">                  final Runnable command = Zygote.fillBlastulaPool(sessionSocketRawFDs);</span><br><span class="line"></span><br><span class="line">                  if (command != null) &#123;</span><br><span class="line">                      return command;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第三小节zygoteSendArgsAndGetResult发送请求来建立连接，根据不同的请求做相应的处理：</p>
<ul>
<li><p>pollIndex小于blastulaPoolEventFDIndex为来自Zygote server socket的请求；</p>
<p>执行acceptCommandPeer，创建ZygoteConnection对象，并添加socketFDs数值，建立连接后，可以和客户端进行通信，进入processOneCommand方法接受客户端数据，并执行进程创建工作。</p>
</li>
<li><p>pollIndex大于等于blastulaPoolEventFDIndex为胚胎池事件FD或者胚胎上报管道；</p>
<p>读取管道信息，调用fillBlastulaPool方法，创建胚胎（blastula）进程。</p>
</li>
</ul>
<h4 id="5-1-ZC-acceptCommandPeer"><a href="#5-1-ZC-acceptCommandPeer" class="headerlink" title="5.1 ZC.acceptCommandPeer"></a>5.1 ZC.acceptCommandPeer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Waits for and accepts a single command connection. Throws</span><br><span class="line">    * RuntimeException on failure.</span><br><span class="line">    */</span><br><span class="line">   private ZygoteConnection acceptCommandPeer(String abiList) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           return createNewConnection(mZygoteSocket.accept(), abiList);</span><br><span class="line">       &#125; catch (IOException ex) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">                   &quot;IOException during accept()&quot;, ex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   protected ZygoteConnection createNewConnection(LocalSocket socket, String abiList)</span><br><span class="line">           throws IOException &#123;</span><br><span class="line">       return new ZygoteConnection(socket, abiList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>客户端发送过来的connect操作，服务端zygote执行accept操作，然后客户端写数据，zygote服务端读数据。</p>
<p>在没有连接的情况下会进入休眠状态，当有新创建的进程发送连接请求时，唤醒zygote进程，创建socket通道，然后执行processOneCommand方法。</p>
<h3 id="6-ZC-processOneCommand"><a href="#6-ZC-processOneCommand" class="headerlink" title="6. ZC.processOneCommand"></a>6. ZC.processOneCommand</h3><p>[-&gt;ZygoteConnection.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Reads one start command from the command socket. If successful, a child is forked and a</span><br><span class="line">    * &#123;@code Runnable&#125; that calls the childs main method (or equivalent) is returned in the child</span><br><span class="line">    * process. &#123;@code null&#125; is always returned in the parent process (the zygote).</span><br><span class="line">    *</span><br><span class="line">    * If the client closes the socket, an &#123;@code EOF&#125; condition is set, which callers can test</span><br><span class="line">    * for by calling &#123;@code ZygoteConnection.isClosedByPeer&#125;.</span><br><span class="line">    */</span><br><span class="line">   Runnable processOneCommand(ZygoteServer zygoteServer) &#123;</span><br><span class="line">       String args[];</span><br><span class="line">       ZygoteArguments parsedArgs = null;</span><br><span class="line">       FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           //读取客户端发送过来参数列表</span><br><span class="line">           args = Zygote.readArgumentList(mSocketReader);</span><br><span class="line"></span><br><span class="line">           // TODO (chriswailes): Remove this and add an assert.</span><br><span class="line">           descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">       &#125; catch (IOException ex) &#123;</span><br><span class="line">           throw new IllegalStateException(&quot;IOException on command socket&quot;, ex);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // readArgumentList returns null only when it has reached EOF with no available</span><br><span class="line">       // data to read. This will only happen when the remote socket has disconnected.</span><br><span class="line">       if (args == null) &#123;</span><br><span class="line">           isEof = true;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int pid = -1;</span><br><span class="line">       FileDescriptor childPipeFd = null;</span><br><span class="line">       FileDescriptor serverPipeFd = null;</span><br><span class="line">       //将客户端传递过来的参数，解析成ZygoteArguments对象格式</span><br><span class="line">       parsedArgs = new ZygoteArguments(args);</span><br><span class="line"></span><br><span class="line">       //进行一序列参数判断</span><br><span class="line">       if (parsedArgs.mAbiListQuery) &#123;</span><br><span class="line">           handleAbiListQuery();</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (parsedArgs.mPidQuery) &#123;</span><br><span class="line">           handlePidQuery();</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (parsedArgs.mPreloadDefault) &#123;</span><br><span class="line">           handlePreload();</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (parsedArgs.mPreloadPackage != null) &#123;</span><br><span class="line">           handlePreloadPackage(parsedArgs.mPreloadPackage, parsedArgs.mPreloadPackageLibs,</span><br><span class="line">                   parsedArgs.mPreloadPackageLibFileName, parsedArgs.mPreloadPackageCacheKey);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (parsedArgs.mApiBlacklistExemptions != null) &#123;</span><br><span class="line">           handleApiBlacklistExemptions(parsedArgs.mApiBlacklistExemptions);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (parsedArgs.mHiddenApiAccessLogSampleRate != -1) &#123;</span><br><span class="line">           handleHiddenApiAccessLogSampleRate(parsedArgs.mHiddenApiAccessLogSampleRate);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (parsedArgs.mPermittedCapabilities != 0 || parsedArgs.mEffectiveCapabilities != 0) &#123;</span><br><span class="line">           throw new ZygoteSecurityException(&quot;Client may not specify capabilities: &quot;</span><br><span class="line">                   + &quot;permitted=0x&quot; + Long.toHexString(parsedArgs.mPermittedCapabilities)</span><br><span class="line">                   + &quot;, effective=0x&quot; + Long.toHexString(parsedArgs.mEffectiveCapabilities));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Zygote.applyUidSecurityPolicy(parsedArgs, peer);</span><br><span class="line">       Zygote.applyInvokeWithSecurityPolicy(parsedArgs, peer);</span><br><span class="line"></span><br><span class="line">       Zygote.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">       Zygote.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">       int[][] rlimits = null;</span><br><span class="line"></span><br><span class="line">       if (parsedArgs.mRLimits != null) &#123;</span><br><span class="line">           rlimits = parsedArgs.mRLimits.toArray(Zygote.INT_ARRAY_2D);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int[] fdsToIgnore = null;</span><br><span class="line"></span><br><span class="line">       if (parsedArgs.mInvokeWith != null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</span><br><span class="line">               childPipeFd = pipeFds[1];</span><br><span class="line">               serverPipeFd = pipeFds[0];</span><br><span class="line">               Os.fcntlInt(childPipeFd, F_SETFD, 0);</span><br><span class="line">               fdsToIgnore = new int[]&#123;childPipeFd.getInt$(), serverPipeFd.getInt$()&#125;;</span><br><span class="line">           &#125; catch (ErrnoException errnoEx) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Unable to set up pipe for invoke-with&quot;, errnoEx);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * In order to avoid leaking descriptors to the Zygote child,</span><br><span class="line">        * the native code must close the two Zygote socket descriptors</span><br><span class="line">        * in the child process before it switches from Zygote-root to</span><br><span class="line">        * the UID and privileges of the application being launched.</span><br><span class="line">        *</span><br><span class="line">        * In order to avoid &quot;bad file descriptor&quot; errors when the</span><br><span class="line">        * two LocalSocket objects are closed, the Posix file</span><br><span class="line">        * descriptors are released via a dup2() call which closes</span><br><span class="line">        * the socket and substitutes an open descriptor to /dev/null.</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">       int [] fdsToClose = &#123; -1, -1 &#125;;</span><br><span class="line"></span><br><span class="line">       FileDescriptor fd = mSocket.getFileDescriptor();</span><br><span class="line"></span><br><span class="line">       if (fd != null) &#123;</span><br><span class="line">           fdsToClose[0] = fd.getInt$();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       fd = zygoteServer.getZygoteSocketFileDescriptor();</span><br><span class="line"></span><br><span class="line">       if (fd != null) &#123;</span><br><span class="line">           fdsToClose[1] = fd.getInt$();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       fd = null;</span><br><span class="line"></span><br><span class="line">       pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids,</span><br><span class="line">               parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo,</span><br><span class="line">               parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,</span><br><span class="line">               parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mTargetSdkVersion);</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           if (pid == 0) &#123;</span><br><span class="line">               // in child</span><br><span class="line">               //子进程执行</span><br><span class="line">               zygoteServer.setForkChild();</span><br><span class="line"></span><br><span class="line">               zygoteServer.closeServerSocket();</span><br><span class="line">               IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">               serverPipeFd = null;</span><br><span class="line">               //见第四大节</span><br><span class="line">               return handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class="line">                       parsedArgs.mStartChildZygote);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // 父进程执行</span><br><span class="line">               // In the parent. A pid &lt; 0 indicates a failure and will be handled in</span><br><span class="line">               // handleParentProc.</span><br><span class="line">               IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">               childPipeFd = null;</span><br><span class="line">               handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">           IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是处理客户端返回过来的参数，并调用forkAndSpecialize方法创建进程，返回pid</p>
<h3 id="7-Zygote-forkAndSpecialize"><a href="#7-Zygote-forkAndSpecialize" class="headerlink" title="7.Zygote.forkAndSpecialize"></a>7.Zygote.forkAndSpecialize</h3><p>[-&gt;Zygote.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @return 0 if this is the child, pid of the child</span><br><span class="line">  * if this is the parent, or -1 on error.</span><br><span class="line"> */</span><br><span class="line">public static int forkAndSpecialize(int uid, int gid, int[] gids, int runtimeFlags,</span><br><span class="line">            int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</span><br><span class="line">            int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir,</span><br><span class="line">            int targetSdkVersion) &#123;</span><br><span class="line">        //见小节8</span><br><span class="line">        ZygoteHooks.preFork();</span><br><span class="line">        // Resets nice priority for zygote process.</span><br><span class="line">        resetNicePriority();</span><br><span class="line">        //见小节9</span><br><span class="line">        int pid = nativeForkAndSpecialize(</span><br><span class="line">                uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">                fdsToIgnore, startChildZygote, instructionSet, appDataDir);</span><br><span class="line">        // Enable tracing as soon as possible for the child process.</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            Zygote.disableExecuteOnly(targetSdkVersion);</span><br><span class="line">            Trace.setTracingEnabled(true, runtimeFlags);</span><br><span class="line"></span><br><span class="line">            // Note that this event ends at the end of handleChildProc,</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       //见小节12</span><br><span class="line">        ZygoteHooks.postForkCommon();</span><br><span class="line">        return pid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/Android进程创建流程分析/zygote.PNG" alt=""></p>
<p>Zygote进程有4个子线程分别为ReferenceQueueD、FinalizerDaemon、FinalizerWatchd、HeapTaskDaemon，图中的线程名显示并不完整，是由于底层的进程结构体task_struct是由长度16的char型数组保存。</p>
<h3 id="8-ZygoteHooks-preFork"><a href="#8-ZygoteHooks-preFork" class="headerlink" title="8. ZygoteHooks.preFork"></a>8. ZygoteHooks.preFork</h3><p>[-&gt;ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void preFork() &#123;</span><br><span class="line">       Daemons.stop();  //停止4个Daemons子进程</span><br><span class="line">       waitUntilAllThreadsStopped(); //等待所有子线程结束</span><br><span class="line">       token = nativePreFork(); //完成gc堆得初始化</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-1-Daemons-stop"><a href="#8-1-Daemons-stop" class="headerlink" title="8.1 Daemons.stop"></a>8.1 Daemons.stop</h4><p>[-&gt;Daemons.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void stop() &#123;</span><br><span class="line">       HeapTaskDaemon.INSTANCE.stop(); //Java堆整理线程</span><br><span class="line">       ReferenceQueueDaemon.INSTANCE.stop(); //引用队列线程</span><br><span class="line">       FinalizerDaemon.INSTANCE.stop(); //析构线程</span><br><span class="line">       FinalizerWatchdogDaemon.INSTANCE.stop();//析构监控线程</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>此守护线程stop方式是先调用目标线程的interrupt方法，然后再调用目标线程join方法，等待线程执行完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">       * Waits for the runtime thread to stop. This interrupts the thread</span><br><span class="line">       * currently running the runnable and then waits for it to exit.</span><br><span class="line">       */</span><br><span class="line">      public void stop() &#123;</span><br><span class="line">          Thread threadToStop;</span><br><span class="line">          synchronized (this) &#123;</span><br><span class="line">              threadToStop = thread;</span><br><span class="line">              thread = null;</span><br><span class="line">          &#125;</span><br><span class="line">          if (threadToStop == null) &#123;</span><br><span class="line">              throw new IllegalStateException(&quot;not running&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          interrupt(threadToStop);</span><br><span class="line">          while (true) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  threadToStop.join();</span><br><span class="line">                  return;</span><br><span class="line">              &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">              &#125; catch (OutOfMemoryError ignored) &#123;</span><br><span class="line">                  // An OOME may be thrown if allocating the InterruptedException failed.</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-2-waitUntilAllThreadsStopped"><a href="#8-2-waitUntilAllThreadsStopped" class="headerlink" title="8.2  waitUntilAllThreadsStopped"></a>8.2  waitUntilAllThreadsStopped</h4><p>[-&gt;ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void waitUntilAllThreadsStopped() &#123;</span><br><span class="line">       File tasks = new File(&quot;/proc/self/task&quot;);</span><br><span class="line">       // All Java daemons are stopped already. We&apos;re just waiting for their OS counterparts to</span><br><span class="line">       // finish as well. This shouldn&apos;t take much time so spinning is ok here.</span><br><span class="line">       // 当/proc中线程数大于1，就让出线程数大于1，才退出循环</span><br><span class="line">       while (tasks.list().length &gt; 1) &#123;</span><br><span class="line">         Thread.yield();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-nativePreFork"><a href="#8-3-nativePreFork" class="headerlink" title="8.3 nativePreFork"></a>8.3 nativePreFork</h4><p>[-&gt;dalvik_system_ZygoteHooks.cc]</p>
<p>nativePreFork通过JNI最终调用如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</span><br><span class="line">  Runtime* runtime = Runtime::Current();</span><br><span class="line">  CHECK(runtime-&gt;IsZygote()) &lt;&lt; &quot;runtime instance not started with -Xzygote&quot;;</span><br><span class="line"></span><br><span class="line">  runtime-&gt;PreZygoteFork();</span><br><span class="line"></span><br><span class="line">  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</span><br><span class="line">    // Tracing active, pause it.</span><br><span class="line">    Trace::Pause();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.</span><br><span class="line">  //将线程转换为long类型并保存到token，该过程是非安全的</span><br><span class="line">  return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Runtime::PreZygoteFork() &#123;</span><br><span class="line"> //堆的初始化，具体到art虚拟机</span><br><span class="line">  heap_-&gt;PreZygoteFork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ZygoteHooks.preFork主要功能是停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是单线程（用于fork效率）,并等待这些线程的停止，初始化gc堆得工作，并将线程转换为long型并保存到token。</p>
<h3 id="9-nativeForkAndSpecialize"><a href="#9-nativeForkAndSpecialize" class="headerlink" title="9. nativeForkAndSpecialize"></a>9. nativeForkAndSpecialize</h3><p>[-&gt;com_android_internal_os_Zygote.cpp]</p>
<p>nativeForkAndSpecialize通过JNC调用如下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(</span><br><span class="line">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span><br><span class="line">        jint runtime_flags, jobjectArray rlimits,</span><br><span class="line">        jint mount_external, jstring se_info, jstring nice_name,</span><br><span class="line">        jintArray managed_fds_to_close, jintArray managed_fds_to_ignore, jboolean is_child_zygote,</span><br><span class="line">        jstring instruction_set, jstring app_data_dir) &#123;</span><br><span class="line">    jlong capabilities = CalculateCapabilities(env, uid, gid, gids, is_child_zygote);</span><br><span class="line"></span><br><span class="line">    if (UNLIKELY(managed_fds_to_close == nullptr)) &#123;</span><br><span class="line">      ZygoteFailure(env, &quot;zygote&quot;, nice_name, &quot;Zygote received a null fds_to_close vector.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;int&gt; fds_to_close =</span><br><span class="line">        ExtractJIntArray(env, &quot;zygote&quot;, nice_name, managed_fds_to_close).value();</span><br><span class="line">    std::vector&lt;int&gt; fds_to_ignore =</span><br><span class="line">        ExtractJIntArray(env, &quot;zygote&quot;, nice_name, managed_fds_to_ignore)</span><br><span class="line">            .value_or(std::vector&lt;int&gt;());</span><br><span class="line"></span><br><span class="line">    std::vector&lt;int&gt; blastula_pipes = MakeBlastulaPipeReadFDVector();</span><br><span class="line"></span><br><span class="line">    fds_to_close.insert(fds_to_close.end(), blastula_pipes.begin(), blastula_pipes.end());</span><br><span class="line">    fds_to_ignore.insert(fds_to_ignore.end(), blastula_pipes.begin(), blastula_pipes.end());</span><br><span class="line"></span><br><span class="line">    fds_to_close.push_back(gBlastulaPoolSocketFD);</span><br><span class="line"></span><br><span class="line">    if (gBlastulaPoolEventFD != -1) &#123;</span><br><span class="line">      fds_to_close.push_back(gBlastulaPoolEventFD);</span><br><span class="line">      fds_to_ignore.push_back(gBlastulaPoolEventFD);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //见10小节</span><br><span class="line">    pid_t pid = ForkCommon(env, false, fds_to_close, fds_to_ignore);</span><br><span class="line"></span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">      //见11小节</span><br><span class="line">      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,</span><br><span class="line">                       capabilities, capabilities,</span><br><span class="line">                       mount_external, se_info, nice_name, false,</span><br><span class="line">                       is_child_zygote == JNI_TRUE, instruction_set, app_data_dir);</span><br><span class="line">    &#125;</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-ForkCommon"><a href="#10-ForkCommon" class="headerlink" title="10. ForkCommon"></a>10. ForkCommon</h3><p>[-&gt;com_android_internal_os_Zygote.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// Utility routine to fork a process from the zygote.</span><br><span class="line">static pid_t ForkCommon(JNIEnv* env, bool is_system_server,</span><br><span class="line">                        const std::vector&lt;int&gt;&amp; fds_to_close,</span><br><span class="line">                        const std::vector&lt;int&gt;&amp; fds_to_ignore) &#123;</span><br><span class="line">  //设置子进程的signal信号处理函数                      </span><br><span class="line">  SetSignalHandlers();</span><br><span class="line"></span><br><span class="line">  // Curry a failure function.</span><br><span class="line">  auto fail_fn = std::bind(ZygoteFailure, env, is_system_server ? &quot;system_server&quot; : &quot;zygote&quot;,</span><br><span class="line">                           nullptr, _1);</span><br><span class="line"></span><br><span class="line">  // Temporarily block SIGCHLD during forks. The SIGCHLD handler might</span><br><span class="line">  // log, which would result in the logging FDs we close being reopened.</span><br><span class="line">  // This would cause failures because the FDs are not whitelisted.</span><br><span class="line">  //</span><br><span class="line">  // Note that the zygote process is single threaded at this point.</span><br><span class="line">  BlockSignal(SIGCHLD, fail_fn);</span><br><span class="line"></span><br><span class="line">  // Close any logging related FDs before we start evaluating the list of</span><br><span class="line">  // file descriptors.</span><br><span class="line">  __android_log_close();</span><br><span class="line">  stats_log_close();</span><br><span class="line"></span><br><span class="line">  // If this is the first fork for this zygote, create the open FD table.  If</span><br><span class="line">  // it isn&apos;t, we just need to check whether the list of open files has changed</span><br><span class="line">  // (and it shouldn&apos;t in the normal case).</span><br><span class="line">  if (gOpenFdTable == nullptr) &#123;</span><br><span class="line">    gOpenFdTable = FileDescriptorTable::Create(fds_to_ignore, fail_fn);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    gOpenFdTable-&gt;Restat(fds_to_ignore, fail_fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  android_fdsan_error_level fdsan_error_level = android_fdsan_get_error_level();</span><br><span class="line">  //fork子进程</span><br><span class="line">  pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">  if (pid == 0) &#123;</span><br><span class="line">    // The child process.</span><br><span class="line">    PreApplicationInit();</span><br><span class="line"></span><br><span class="line">    // Clean up any descriptors which must be closed immediately</span><br><span class="line">    DetachDescriptors(env, fds_to_close, fail_fn);</span><br><span class="line"></span><br><span class="line">    // Re-open all remaining open file descriptors so that they aren&apos;t shared</span><br><span class="line">    // with the zygote across a fork.</span><br><span class="line">    gOpenFdTable-&gt;ReopenOrDetach(fail_fn);</span><br><span class="line"></span><br><span class="line">    // Turn fdsan back on.</span><br><span class="line">    android_fdsan_set_error_level(fdsan_error_level);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ALOGD(&quot;Forked child process %d&quot;, pid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // We blocked SIGCHLD prior to a fork, we unblock it here.</span><br><span class="line">  UnblockSignal(SIGCHLD, fail_fn);</span><br><span class="line"></span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fork采用copy on write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3中类型。</p>
<p>父进程中，fork返回新创建的子进程pid</p>
<p>子进程中，fork返回0</p>
<p>当出现错误（进程数超过上限或者系统内存不足）时，fork返回负数。</p>
<p>fork主要工作是寻找空闲的进程号pid,然后从父进程中拷贝进程信息，例如代码段和数据段，fork后子进程要执行的代码。Zygote进程是所有Android进程的母体，包括systemserver和各个app进程。zygote利用fork方法生成新的进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A.</p>
<p>copy on write过程：当父子进程任何一方修改内存数据时（on-write时机），才发生缺页中断，从而分配新的物理内存（copy操作）。原理：写时拷贝是指子进程与父进程的页表都指向同一物理内存，fork过程只拷贝父进程的页表，并标记这些页表是可读的。父子进程共用同一份物理内存，如果父子进程任一方想要修改这块物理内存，那么就会触发缺页异常，linux收到改中断便会创建新的物理内存，并将这个两个物理内存都设置为可写状态，从而父子进程各自用用独立的物理内存。</p>
<h4 id="10-1-fork"><a href="#10-1-fork" class="headerlink" title="10.1 fork"></a>10.1 fork</h4><p>[-&gt;bionic/fork.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int fork() &#123;</span><br><span class="line">  __bionic_atfork_run_prepare();</span><br><span class="line"> </span><br><span class="line">  pthread_internal_t* self = __get_thread();</span><br><span class="line">  //fork过程，syscall调用</span><br><span class="line">  int result = clone(nullptr,</span><br><span class="line">                     nullptr,</span><br><span class="line">                     (CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD),</span><br><span class="line">                     nullptr,</span><br><span class="line">                     nullptr,</span><br><span class="line">                     nullptr,</span><br><span class="line">                     &amp;(self-&gt;tid));</span><br><span class="line">  if (result == 0) &#123;</span><br><span class="line">    // Update the cached pid, since clone() will not set it directly (as</span><br><span class="line">    // self-&gt;tid is updated by the kernel).</span><br><span class="line">    self-&gt;set_cached_pid(gettid());</span><br><span class="line">    __bionic_atfork_run_child();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    __bionic_atfork_run_parent();</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在执行clone前后都有相应的回调方法</p>
<p>__bionic_atfork_run_prepare()  ： fork完成执行子进程回调方法</p>
<p> __bionic_atfork_run_child() ： fork完成执行子进程回调方法</p>
<p>__bionic_atfork_run_parent() ： fork完成执行父进程回调方法</p>
<p>这个三个方法bionic/pthread_atfork.cpp中，如果有业务需求，可以拓展回调方法</p>
<h3 id="11-SpecializeCommon"><a href="#11-SpecializeCommon" class="headerlink" title="11. SpecializeCommon"></a>11. SpecializeCommon</h3><p>[-&gt;com_android_internal_os_Zygote.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">// Utility routine to specialize a zygote child process.</span><br><span class="line">static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids,</span><br><span class="line">                             jint runtime_flags, jobjectArray rlimits,</span><br><span class="line">                             jlong permitted_capabilities, jlong effective_capabilities,</span><br><span class="line">                             jint mount_external, jstring managed_se_info,</span><br><span class="line">                             jstring managed_nice_name, bool is_system_server,</span><br><span class="line">                             bool is_child_zygote, jstring managed_instruction_set,</span><br><span class="line">                             jstring managed_app_data_dir) &#123;</span><br><span class="line">  const char* process_name = is_system_server ? &quot;system_server&quot; : &quot;zygote&quot;;</span><br><span class="line">  auto fail_fn = std::bind(ZygoteFailure, env, process_name, managed_nice_name, _1);</span><br><span class="line">  auto extract_fn = std::bind(ExtractJString, env, process_name, managed_nice_name, _1);</span><br><span class="line"></span><br><span class="line">  auto se_info = extract_fn(managed_se_info);</span><br><span class="line">  auto nice_name = extract_fn(managed_nice_name);</span><br><span class="line">  auto instruction_set = extract_fn(managed_instruction_set);</span><br><span class="line">  auto app_data_dir = extract_fn(managed_app_data_dir);</span><br><span class="line"></span><br><span class="line">  // Keep capabilities across UID change, unless we&apos;re staying root.</span><br><span class="line">  if (uid != 0) &#123;</span><br><span class="line">    EnableKeepCapabilities(fail_fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SetInheritable(permitted_capabilities, fail_fn);</span><br><span class="line"></span><br><span class="line">  DropCapabilitiesBoundingSet(fail_fn);</span><br><span class="line"></span><br><span class="line">  bool use_native_bridge = !is_system_server &amp;&amp;</span><br><span class="line">                           instruction_set.has_value() &amp;&amp;</span><br><span class="line">                           android::NativeBridgeAvailable() &amp;&amp;</span><br><span class="line">                           android::NeedsNativeBridge(instruction_set.value().c_str());</span><br><span class="line"></span><br><span class="line">  if (use_native_bridge &amp;&amp; !app_data_dir.has_value()) &#123;</span><br><span class="line">    // The app_data_dir variable should never be empty if we need to use a</span><br><span class="line">    // native bridge.  In general, app_data_dir will never be empty for normal</span><br><span class="line">    // applications.  It can only happen in special cases (for isolated</span><br><span class="line">    // processes which are not associated with any app).  These are launched by</span><br><span class="line">    // the framework and should not be emulated anyway.</span><br><span class="line">    use_native_bridge = false;</span><br><span class="line">    ALOGW(&quot;Native bridge will not be used because managed_app_data_dir == nullptr.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MountEmulatedStorage(uid, mount_external, use_native_bridge, fail_fn);</span><br><span class="line"></span><br><span class="line">  // If this zygote isn&apos;t root, it won&apos;t be able to create a process group,</span><br><span class="line">  // since the directory is owned by root.</span><br><span class="line">  //对于非systemserver子进程并且uid==0,则创建进程组</span><br><span class="line">  if (!is_system_server &amp;&amp; getuid() == 0) &#123;</span><br><span class="line">      const int rc = createProcessGroup(uid, getpid());</span><br><span class="line">      if (rc != 0) &#123;</span><br><span class="line">          if (rc == -EROFS) &#123;</span><br><span class="line">              ALOGW(&quot;createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              ALOGE(&quot;createProcessGroup(%d, %d) failed: %s&quot;, uid, 0/*pid*/, strerror(-rc));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SetGids(env, gids, fail_fn);  //设置group</span><br><span class="line">  SetRLimits(env, rlimits, fail_fn);  //设置资源limit</span><br><span class="line"></span><br><span class="line">  if (use_native_bridge) &#123;</span><br><span class="line">    // Due to the logic behind use_native_bridge we know that both app_data_dir</span><br><span class="line">    // and instruction_set contain values.</span><br><span class="line">    android::PreInitializeNativeBridge(app_data_dir.value().c_str(),</span><br><span class="line">                                       instruction_set.value().c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (setresgid(gid, gid, gid) == -1) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(&quot;setresgid(%d) failed: %s&quot;, gid, strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Must be called when the new process still has CAP_SYS_ADMIN, in this case,</span><br><span class="line">  // before changing uid from 0, which clears capabilities.  The other</span><br><span class="line">  // alternative is to call prctl(PR_SET_NO_NEW_PRIVS, 1) afterward, but that</span><br><span class="line">  // breaks SELinux domain transition (see b/71859146).  As the result,</span><br><span class="line">  // privileged syscalls used below still need to be accessible in app process.</span><br><span class="line">  SetUpSeccompFilter(uid);</span><br><span class="line"></span><br><span class="line">  if (setresuid(uid, uid, uid) == -1) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(&quot;setresuid(%d) failed: %s&quot;, uid, strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // The &quot;dumpable&quot; flag of a process, which controls core dump generation, is</span><br><span class="line">  // overwritten by the value in /proc/sys/fs/suid_dumpable when the effective</span><br><span class="line">  // user or group ID changes. See proc(5) for possible values. In most cases,</span><br><span class="line">  // the value is 0, so core dumps are disabled for zygote children. However,</span><br><span class="line">  // when running in a Chrome OS container, the value is already set to 2,</span><br><span class="line">  // which allows the external crash reporter to collect all core dumps. Since</span><br><span class="line">  // only system crashes are interested, core dump is disabled for app</span><br><span class="line">  // processes. This also ensures compliance with CTS.</span><br><span class="line">  int dumpable = prctl(PR_GET_DUMPABLE);</span><br><span class="line">  if (dumpable == -1) &#123;</span><br><span class="line">      ALOGE(&quot;prctl(PR_GET_DUMPABLE) failed: %s&quot;, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, &quot;prctl(PR_GET_DUMPABLE) failed&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (dumpable == 2 &amp;&amp; uid &gt;= AID_APP) &#123;</span><br><span class="line">    if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) == -1) &#123;</span><br><span class="line">      ALOGE(&quot;prctl(PR_SET_DUMPABLE, 0) failed: %s&quot;, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, &quot;prctl(PR_SET_DUMPABLE, 0) failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Set process properties to enable debugging if required.</span><br><span class="line">  if ((runtime_flags &amp; RuntimeFlags::DEBUG_ENABLE_JDWP) != 0) &#123;</span><br><span class="line">    EnableDebugger();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (NeedsNoRandomizeWorkaround()) &#123;</span><br><span class="line">      // Work around ARM kernel ASLR lossage (http://b/5817320).</span><br><span class="line">      int old_personality = personality(0xffffffff);</span><br><span class="line">      int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</span><br><span class="line">      if (new_personality == -1) &#123;</span><br><span class="line">          ALOGW(&quot;personality(%d) failed: %s&quot;, new_personality, strerror(errno));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SetCapabilities(permitted_capabilities, effective_capabilities, permitted_capabilities, fail_fn);</span><br><span class="line">  //设置调度策略</span><br><span class="line">  SetSchedulerPolicy(fail_fn);</span><br><span class="line"></span><br><span class="line">  const char* se_info_ptr = se_info.has_value() ? se_info.value().c_str() : nullptr;</span><br><span class="line">  const char* nice_name_ptr = nice_name.has_value() ? nice_name.value().c_str() : nullptr;</span><br><span class="line"></span><br><span class="line">  if (selinux_android_setcontext(uid, is_system_server, se_info_ptr, nice_name_ptr) == -1) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(&quot;selinux_android_setcontext(%d, %d, /&quot;%s/&quot;, /&quot;%s/&quot;) failed&quot;,</span><br><span class="line">                         uid, is_system_server, se_info_ptr, nice_name_ptr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Make it easier to debug audit logs by setting the main thread&apos;s name to the</span><br><span class="line">  // nice name rather than &quot;app_process&quot;.</span><br><span class="line">  if (nice_name.has_value()) &#123;</span><br><span class="line">    SetThreadName(nice_name.value());</span><br><span class="line">  &#125; else if (is_system_server) &#123;</span><br><span class="line">    SetThreadName(&quot;system_server&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Unset the SIGCHLD handler, but keep ignoring SIGHUP (rationale in SetSignalHandlers).</span><br><span class="line">  //在子进程中，设置信号SIGHUP的处理器恢复默认行为</span><br><span class="line">  UnsetChldSignalHandler();</span><br><span class="line"></span><br><span class="line">  if (is_system_server) &#123;</span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkSystemServerHooks);</span><br><span class="line">    if (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">      fail_fn(&quot;Error calling post fork system server hooks.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prefetch the classloader for the system server. This is done early to</span><br><span class="line">    // allow a tie-down of the proper system server selinux domain.</span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteInitClass, gCreateSystemServerClassLoader);</span><br><span class="line">    if (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">      // Be robust here. The Java code will attempt to create the classloader</span><br><span class="line">      // at a later point (but may not have rights to use AoT artifacts).</span><br><span class="line">      env-&gt;ExceptionClear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // TODO(oth): Remove hardcoded label here (b/117874058).</span><br><span class="line">    static const char* kSystemServerLabel = &quot;u:r:system_server:s0&quot;;</span><br><span class="line">    //selinux上下文</span><br><span class="line">    if (selinux_android_setcon(kSystemServerLabel) != 0) &#123;</span><br><span class="line">      fail_fn(CREATE_ERROR(&quot;selinux_android_setcon(%s)&quot;, kSystemServerLabel));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   //JNI，调用java方法，调用zygote.callPostForkChildHooks[见11.1]</span><br><span class="line">  env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                            is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line"></span><br><span class="line">  if (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">    fail_fn(&quot;Error calling post fork hooks.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-1-callPostForkChildHooks"><a href="#11-1-callPostForkChildHooks" class="headerlink" title="11.1 callPostForkChildHooks"></a>11.1 callPostForkChildHooks</h4><p>[-&gt;Zygote.java]</p>
<pre><code>private static void callPostForkChildHooks(int runtimeFlags, boolean isSystemServer,
        boolean isZygote, String instructionSet) {
    ZygoteHooks.postForkChild(runtimeFlags, isSystemServer, isZygote, instructionSet);
}
</code></pre><h4 id="11-2-postForkChild"><a href="#11-2-postForkChild" class="headerlink" title="11.2 postForkChild"></a>11.2 postForkChild</h4><p>[-&gt;ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void postForkChild(int runtimeFlags, boolean isSystemServer, boolean isZygote,</span><br><span class="line">           String instructionSet) &#123;</span><br><span class="line">       nativePostForkChild(token, runtimeFlags, isSystemServer, isZygote, instructionSet);</span><br><span class="line">       Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-nativePostForkChild"><a href="#11-3-nativePostForkChild" class="headerlink" title="11.3 nativePostForkChild"></a>11.3 nativePostForkChild</h4><p>[-&gt;dalvik_system_ZygoteHooks.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">static void ZygoteHooks_nativePostForkChild(JNIEnv* env,</span><br><span class="line">                                            jclass,</span><br><span class="line">                                            jlong token,</span><br><span class="line">                                            jint runtime_flags,</span><br><span class="line">                                            jboolean is_system_server,</span><br><span class="line">                                            jboolean is_zygote,</span><br><span class="line">                                            jstring instruction_set) &#123;</span><br><span class="line">  DCHECK(!(is_system_server &amp;&amp; is_zygote));</span><br><span class="line">  //此token由8.3创建，记录着当前线程</span><br><span class="line">  Thread* thread = reinterpret_cast&lt;Thread*&gt;(token);</span><br><span class="line">  // Our system thread ID, etc, has changed so reset Thread state.</span><br><span class="line">  // 设置新进程的主线程id</span><br><span class="line">  thread-&gt;InitAfterFork();</span><br><span class="line">  runtime_flags = EnableDebugFeatures(runtime_flags);</span><br><span class="line">  hiddenapi::EnforcementPolicy api_enforcement_policy = hiddenapi::EnforcementPolicy::kNoChecks;</span><br><span class="line">  bool dedupe_hidden_api_warnings = true;</span><br><span class="line"></span><br><span class="line">  if ((runtime_flags &amp; DISABLE_VERIFIER) != 0) &#123;</span><br><span class="line">    Runtime::Current()-&gt;DisableVerifier();</span><br><span class="line">    runtime_flags &amp;= ~DISABLE_VERIFIER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if ((runtime_flags &amp; ONLY_USE_SYSTEM_OAT_FILES) != 0) &#123;</span><br><span class="line">    Runtime::Current()-&gt;GetOatFileManager().SetOnlyUseSystemOatFiles();</span><br><span class="line">    runtime_flags &amp;= ~ONLY_USE_SYSTEM_OAT_FILES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  api_enforcement_policy = hiddenapi::EnforcementPolicyFromInt(</span><br><span class="line">      (runtime_flags &amp; HIDDEN_API_ENFORCEMENT_POLICY_MASK) &gt;&gt; API_ENFORCEMENT_POLICY_SHIFT);</span><br><span class="line">  runtime_flags &amp;= ~HIDDEN_API_ENFORCEMENT_POLICY_MASK;</span><br><span class="line"></span><br><span class="line">  bool profile_system_server = (runtime_flags &amp; PROFILE_SYSTEM_SERVER) == PROFILE_SYSTEM_SERVER;</span><br><span class="line">  runtime_flags &amp;= ~PROFILE_SYSTEM_SERVER;</span><br><span class="line"></span><br><span class="line">  if (runtime_flags != 0) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; StringPrintf(&quot;Unknown bits set in runtime_flags: %#x&quot;, runtime_flags);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Update tracing.</span><br><span class="line">  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</span><br><span class="line">    Trace::TraceOutputMode output_mode = Trace::GetOutputMode();</span><br><span class="line">    Trace::TraceMode trace_mode = Trace::GetMode();</span><br><span class="line">    size_t buffer_size = Trace::GetBufferSize();</span><br><span class="line"></span><br><span class="line">    // Just drop it.</span><br><span class="line">    Trace::Abort();</span><br><span class="line"></span><br><span class="line">    // Only restart if it was streaming mode.</span><br><span class="line">    // TODO: Expose buffer size, so we can also do file mode.</span><br><span class="line">    if (output_mode == Trace::TraceOutputMode::kStreaming) &#123;</span><br><span class="line">      static constexpr size_t kMaxProcessNameLength = 100;</span><br><span class="line">      char name_buf[kMaxProcessNameLength] = &#123;&#125;;</span><br><span class="line">      int rc = pthread_getname_np(pthread_self(), name_buf, kMaxProcessNameLength);</span><br><span class="line">      std::string proc_name;</span><br><span class="line"></span><br><span class="line">      if (rc == 0) &#123;</span><br><span class="line">          // On success use the pthread name.</span><br><span class="line">          proc_name = name_buf;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (proc_name.empty() || proc_name == &quot;zygote&quot; || proc_name == &quot;zygote64&quot;) &#123;</span><br><span class="line">        // Either no process name, or the name hasn&apos;t been changed, yet. Just use pid.</span><br><span class="line">        pid_t pid = getpid();</span><br><span class="line">        proc_name = StringPrintf(&quot;%u&quot;, static_cast&lt;uint32_t&gt;(pid));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      std::string trace_file = StringPrintf(&quot;/data/misc/trace/%s.trace.bin&quot;, proc_name.c_str());</span><br><span class="line">      Trace::Start(trace_file.c_str(),</span><br><span class="line">                   -1,</span><br><span class="line">                   buffer_size,</span><br><span class="line">                   0,   // TODO: Expose flags.</span><br><span class="line">                   output_mode,</span><br><span class="line">                   trace_mode,</span><br><span class="line">                   0);  // TODO: Expose interval.</span><br><span class="line">      if (thread-&gt;IsExceptionPending()) &#123;</span><br><span class="line">        ScopedObjectAccess soa(env);</span><br><span class="line">        thread-&gt;ClearException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool do_hidden_api_checks = api_enforcement_policy != hiddenapi::EnforcementPolicy::kNoChecks;</span><br><span class="line">  DCHECK(!(is_system_server &amp;&amp; do_hidden_api_checks))</span><br><span class="line">      &lt;&lt; &quot;SystemServer should be forked with EnforcementPolicy::kDisable&quot;;</span><br><span class="line">  DCHECK(!(is_zygote &amp;&amp; do_hidden_api_checks))</span><br><span class="line">      &lt;&lt; &quot;Child zygote processes should be forked with EnforcementPolicy::kDisable&quot;;</span><br><span class="line">  Runtime::Current()-&gt;SetHiddenApiEnforcementPolicy(api_enforcement_policy);</span><br><span class="line">  Runtime::Current()-&gt;SetDedupeHiddenApiWarnings(dedupe_hidden_api_warnings);</span><br><span class="line">  if (api_enforcement_policy != hiddenapi::EnforcementPolicy::kNoChecks &amp;&amp;</span><br><span class="line">      Runtime::Current()-&gt;GetHiddenApiEventLogSampleRate() != 0) &#123;</span><br><span class="line">    // Hidden API checks are enabled, and we are sampling access for the event log. Initialize the</span><br><span class="line">    // random seed, to ensure the sampling is actually random. We do this post-fork, as doing it</span><br><span class="line">    // pre-fork would result in the same sequence for every forked process.</span><br><span class="line">    std::srand(static_cast&lt;uint32_t&gt;(NanoTime()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Clear the hidden API warning flag, in case it was set.</span><br><span class="line">  Runtime::Current()-&gt;SetPendingHiddenApiWarning(false);</span><br><span class="line"></span><br><span class="line">  if (is_zygote) &#123;</span><br><span class="line">    // If creating a child-zygote, do not call into the runtime&apos;s post-fork logic.</span><br><span class="line">    // Doing so would spin up threads for Binder and JDWP. Instead, the Java side</span><br><span class="line">    // of the child process will call a static main in a class specified by the parent.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (instruction_set != nullptr &amp;&amp; !is_system_server) &#123;</span><br><span class="line">    ScopedUtfChars isa_string(env, instruction_set);</span><br><span class="line">    InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">    Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">    if (isa != InstructionSet::kNone &amp;&amp; isa != kRuntimeISA) &#123;</span><br><span class="line">      action = Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">    &#125;</span><br><span class="line">    Runtime::Current()-&gt;InitNonZygoteOrPostFork(</span><br><span class="line">        env, is_system_server, action, isa_string.c_str());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Runtime::Current()-&gt;InitNonZygoteOrPostFork(</span><br><span class="line">        env,</span><br><span class="line">        is_system_server,</span><br><span class="line">        Runtime::NativeBridgeAction::kUnload,</span><br><span class="line">        /*isa*/ nullptr,</span><br><span class="line">        profile_system_server);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-4-InitNonZygoteOrPostFork"><a href="#11-4-InitNonZygoteOrPostFork" class="headerlink" title="11.4 InitNonZygoteOrPostFork"></a>11.4 InitNonZygoteOrPostFork</h4><p>[-&gt;runtime.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void Runtime::InitNonZygoteOrPostFork(</span><br><span class="line">    JNIEnv* env,</span><br><span class="line">    bool is_system_server,</span><br><span class="line">    NativeBridgeAction action,</span><br><span class="line">    const char* isa,</span><br><span class="line">    bool profile_system_server) &#123;</span><br><span class="line">  is_zygote_ = false;</span><br><span class="line"></span><br><span class="line">  if (is_native_bridge_loaded_) &#123;</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">      case NativeBridgeAction::kUnload:</span><br><span class="line">        //卸载用于跨平台的桥连库</span><br><span class="line">        UnloadNativeBridge();</span><br><span class="line">        is_native_bridge_loaded_ = false;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case NativeBridgeAction::kInitialize:</span><br><span class="line">        //初始化用于跨平台的桥连库</span><br><span class="line">        InitializeNativeBridge(env, isa);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Create the thread pools.</span><br><span class="line">  //创建java堆处理的线程池</span><br><span class="line">  heap_-&gt;CreateThreadPool();</span><br><span class="line">  // Reset the gc performance data at zygote fork so that the GCs</span><br><span class="line">  // before fork aren&apos;t attributed to an app.</span><br><span class="line">  //重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上</span><br><span class="line">  heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line"></span><br><span class="line">  // We may want to collect profiling samples for system server, but we never want to JIT there.</span><br><span class="line">  if (is_system_server) &#123;</span><br><span class="line">    jit_options_-&gt;SetUseJitCompilation(false);</span><br><span class="line">    jit_options_-&gt;SetSaveProfilingInfo(profile_system_server);</span><br><span class="line">    if (profile_system_server) &#123;</span><br><span class="line">      jit_options_-&gt;SetWaitForJitNotificationsToSaveProfile(false);</span><br><span class="line">      VLOG(profiler) &lt;&lt; &quot;Enabling system server profiles&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!safe_mode_ &amp;&amp;</span><br><span class="line">      (jit_options_-&gt;UseJitCompilation() || jit_options_-&gt;GetSaveProfilingInfo()) &amp;&amp;</span><br><span class="line">      jit_ == nullptr) &#123;</span><br><span class="line">    // Note that when running ART standalone (not zygote, nor zygote fork),</span><br><span class="line">    // the jit may have already been created.</span><br><span class="line">    //当flag1被设置，并且还没有创建JIT时，则创建JIT</span><br><span class="line">    CreateJit();</span><br><span class="line">  &#125;</span><br><span class="line">  //设置信号处理函数</span><br><span class="line">  StartSignalCatcher();</span><br><span class="line"></span><br><span class="line">  // Start the JDWP thread. If the command-line debugger flags specified &quot;suspend=y&quot;,</span><br><span class="line">  // this will pause the runtime (in the internal debugger implementation), so we probably want</span><br><span class="line">  // this to come last.</span><br><span class="line">  // 启动JDWP线程，当命令debuger的flags指定suspend=y时，则暂停runtime</span><br><span class="line">  ScopedObjectAccess soa(Thread::Current());</span><br><span class="line">  GetRuntimeCallbacks()-&gt;StartDebugger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-postForkCommon"><a href="#12-postForkCommon" class="headerlink" title="12. postForkCommon"></a>12. postForkCommon</h3><p>[-&gt;ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void postForkCommon() &#123;</span><br><span class="line">       Daemons.startPostZygoteFork();</span><br><span class="line">&#125;</span><br><span class="line">public static void startPostZygoteFork() &#123;</span><br><span class="line">       ReferenceQueueDaemon.INSTANCE.startPostZygoteFork();</span><br><span class="line">       FinalizerDaemon.INSTANCE.startPostZygoteFork();</span><br><span class="line">       FinalizerWatchdogDaemon.INSTANCE.startPostZygoteFork();</span><br><span class="line">       HeapTaskDaemon.INSTANCE.startPostZygoteFork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ZygoteHooks的postForkCommon主要功能是fork新进程后，启动zygote的四个Daemon线程，引用队列线程，析构线程，析构监控线程、java堆整理线程。</p>
<h3 id="13-小结"><a href="#13-小结" class="headerlink" title="13. 小结"></a>13. 小结</h3><p>1.ZygoteInit.main方法，经过socket管道，预加载资源后，进入runSelectLoop方法。</p>
<p>2.runSelectLoop执行acceptCommandPeer，创建ZygoteConnection对象，并添加socketFDs数值，建立连接后，可以和客户端进行通信，进入processOneCommand方法接受客户端数据，并调用forkAndSpecialize方法创建进程。</p>
<p>3.forkAndSpecialize主要功能是</p>
<ul>
<li><p>preFork：停止Zygote的4个Daemon线程的运行，初始化gc堆；</p>
</li>
<li><p>nativeForkAndSpecialize：调用fork创建新进程，设置新进程的主线程id，重置gc性能数据，设置信号处理函数等功能、启动JDWP线程。</p>
</li>
<li><p>postForkCommon：启动4个Daemon线程。</p>
</li>
</ul>
<p>到此App进程完成创建的所有工作，执行forkAndSpecialize后，新创建的App进程进入了handleChildProc，后面就是App进程的工作了。</p>
<h2 id="四、新进程运行"><a href="#四、新进程运行" class="headerlink" title="四、新进程运行"></a>四、新进程运行</h2><p>在第6小节中processOneCommand过程中调用forkAndSpecialize创建完新进程后，返回值pid=0即运行在子进程，继续开始执行handleChildProc方法。</p>
<h3 id="14-ZC-handleChildProc"><a href="#14-ZC-handleChildProc" class="headerlink" title="14. ZC.handleChildProc"></a>14. ZC.handleChildProc</h3><p>[-&gt;ZygoteConnection.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private Runnable handleChildProc(ZygoteArguments parsedArgs, FileDescriptor[] descriptors,</span><br><span class="line">           FileDescriptor pipeFd, boolean isZygote) &#123;</span><br><span class="line">       /**</span><br><span class="line">        * By the time we get here, the native code has closed the two actual Zygote</span><br><span class="line">        * socket connections, and substituted /dev/null in their place.  The LocalSocket</span><br><span class="line">        * objects still need to be closed properly.</span><br><span class="line">        */</span><br><span class="line">       //关闭zygote的socket的连接</span><br><span class="line">       closeSocket();</span><br><span class="line">       if (descriptors != null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               Os.dup2(descriptors[0], STDIN_FILENO);</span><br><span class="line">               Os.dup2(descriptors[1], STDOUT_FILENO);</span><br><span class="line">               Os.dup2(descriptors[2], STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">               for (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                   IoUtils.closeQuietly(fd);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">               Log.e(TAG, &quot;Error reopening stdio&quot;, ex);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (parsedArgs.mNiceName != null) &#123;</span><br><span class="line">           //设置进程名</span><br><span class="line">           Process.setArgV0(parsedArgs.mNiceName);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // End of the postFork event.</span><br><span class="line">       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">       if (parsedArgs.mInvokeWith != null) &#123;</span><br><span class="line">           //用于检测进程内存泄露或者溢出时设计</span><br><span class="line">           WrapperInit.execApplication(parsedArgs.mInvokeWith,</span><br><span class="line">                   parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,</span><br><span class="line">                   VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                   pipeFd, parsedArgs.mRemainingArgs);</span><br><span class="line"></span><br><span class="line">           // Should not get here.</span><br><span class="line">           throw new IllegalStateException(&quot;WrapperInit.execApplication unexpectedly returned&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           //不是zygote进程</span><br><span class="line">           if (!isZygote) &#123;</span><br><span class="line">               //执行目标类main方法，见流程15</span><br><span class="line">               return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                       parsedArgs.mRemainingArgs, null /* classLoader */);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return ZygoteInit.childZygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                       parsedArgs.mRemainingArgs, null /* classLoader */);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-ZygoteInit-zygoteInit"><a href="#15-ZygoteInit-zygoteInit" class="headerlink" title="15. ZygoteInit.zygoteInit"></a>15. ZygoteInit.zygoteInit</h3><p>[-&gt;ZygoteInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final Runnable zygoteInit(int targetSdkVersion, String[] argv,</span><br><span class="line">            ClassLoader classLoader) &#123;</span><br><span class="line">        if (RuntimeInit.DEBUG) &#123;</span><br><span class="line">            Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;);</span><br><span class="line">        //重定向log</span><br><span class="line">        RuntimeInit.redirectLogStreams();</span><br><span class="line">        //初始化，见流程15.1</span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">        //zygote初始化，见流程15.2</span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">        //应用初始化</span><br><span class="line">        return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-1-commonInit"><a href="#15-1-commonInit" class="headerlink" title="15.1 commonInit"></a>15.1 commonInit</h4><p>[-&gt; RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">protected static final void commonInit() &#123;</span><br><span class="line">        if (DEBUG) Slog.d(TAG, &quot;Entered RuntimeInit!&quot;);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * set handlers; these apply to all threads in the VM. Apps can replace</span><br><span class="line">         * the default handler, but not the pre handler.</span><br><span class="line">         */</span><br><span class="line">         //设置默认的异常处理方法</span><br><span class="line">        LoggingHandler loggingHandler = new LoggingHandler();</span><br><span class="line">        RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler));</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Install a time zone supplier that uses the Android persistent time zone system property.</span><br><span class="line">         */</span><br><span class="line">         //设置时区</span><br><span class="line">        RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(&quot;persist.sys.timezone&quot;));</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Sets handler for java.util.logging to use Android log facilities.</span><br><span class="line">         * The odd &quot;new instance-and-then-throw-away&quot; is a mirror of how</span><br><span class="line">         * the &quot;java.util.logging.config.class&quot; system property works. We</span><br><span class="line">         * can&apos;t use the system property here since the logger has almost</span><br><span class="line">         * certainly already been initialized.</span><br><span class="line">         */</span><br><span class="line">        //重置log配置 </span><br><span class="line">        LogManager.getLogManager().reset();</span><br><span class="line">        new AndroidConfig();</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Sets the default HTTP User-Agent used by HttpURLConnection.</span><br><span class="line">         */</span><br><span class="line">         //设置默认的HTTP User-Agent ,用于HttpURLConnection</span><br><span class="line">        String userAgent = getDefaultUserAgent();</span><br><span class="line">        System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Wire socket tagging to traffic stats.</span><br><span class="line">         */</span><br><span class="line">         //设置socket的tag,用于流量统计</span><br><span class="line">        NetworkManagementSocketTagger.install();</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * If we&apos;re running in an emulator launched with &quot;-trace&quot;, put the</span><br><span class="line">         * VM into emulator trace profiling mode so that the user can hit</span><br><span class="line">         * F9/F10 at any time to capture traces.  This has performance</span><br><span class="line">         * consequences, so it&apos;s not something you want to do always.</span><br><span class="line">         */</span><br><span class="line">         //配置trace</span><br><span class="line">        String trace = SystemProperties.get(&quot;ro.kernel.android.tracing&quot;);</span><br><span class="line">        if (trace.equals(&quot;1&quot;)) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;NOTE: emulator trace profiling enabled&quot;);</span><br><span class="line">            Debug.enableEmulatorTraceOutput();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initialized = true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-2-nativeZygoteInit"><a href="#15-2-nativeZygoteInit" class="headerlink" title="15.2 nativeZygoteInit"></a>15.2 nativeZygoteInit</h4><p>[-&gt;AndroidRuntime.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    //在AndroidRuntime.cpp中定义</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[-&gt;app_main.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virtual void onZygoteInit()</span><br><span class="line">  &#123;</span><br><span class="line">      sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">      ALOGV(&quot;App process: starting thread pool./n&quot;);</span><br><span class="line">      proc-&gt;startThreadPool(); //启动新的binder线程</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ProcessState::self()主要工作是调用open打开dev/binder驱动设备，再利用mmap映射内核的地址空间，将Binder驱动的fd赋值给ProcessState对象中的mDriverFD，用于交互操作。</p>
<p>startThreadPool用于创建一个binder线程池，不断进行talkWithDriver。</p>
<h4 id="15-3-applicationInit"><a href="#15-3-applicationInit" class="headerlink" title="15.3 applicationInit"></a>15.3 applicationInit</h4><p>[-&gt; RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable applicationInit(int targetSdkVersion, String[] argv,</span><br><span class="line">            ClassLoader classLoader) &#123;</span><br><span class="line">        // If the application calls System.exit(), terminate the process</span><br><span class="line">        // immediately without running any shutdown hooks.  It is not possible to</span><br><span class="line">        // shutdown an Android application gracefully.  Among other things, the</span><br><span class="line">        // Android runtime shutdown hooks close the Binder driver, which can cause</span><br><span class="line">        // leftover running threads to crash before the process actually exits.</span><br><span class="line">        //true代表应用程序退出时不调用AppRuntime.onExit，否则会在退出前退出</span><br><span class="line">        nativeSetExitWithoutCleanup(true);</span><br><span class="line"></span><br><span class="line">        // We want to be fairly aggressive about heap utilization, to avoid</span><br><span class="line">        // holding on to a lot of memory that isn&apos;t needed.</span><br><span class="line">        //设置虚拟机的内存利用率的参数为0.75</span><br><span class="line">        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        final Arguments args = new Arguments(argv);</span><br><span class="line"></span><br><span class="line">        // The end of of the RuntimeInit event (see #zygoteInit).</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">        // Remaining arguments are passed to the start class&apos;s static main</span><br><span class="line">        //调用starClass的static方法，见流程16</span><br><span class="line">        return findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-findStaticMain"><a href="#16-findStaticMain" class="headerlink" title="16. findStaticMain"></a>16. findStaticMain</h3><p>[-&gt; RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable findStaticMain(String className, String[] argv,</span><br><span class="line">          ClassLoader classLoader) &#123;</span><br><span class="line">      Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          cl = Class.forName(className, true, classLoader);</span><br><span class="line">      &#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">          throw new RuntimeException(</span><br><span class="line">                  &quot;Missing class when invoking static main &quot; + className,</span><br><span class="line">                  ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Method m;</span><br><span class="line">      try &#123;</span><br><span class="line">          m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">      &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">          throw new RuntimeException(</span><br><span class="line">                  &quot;Missing static main on &quot; + className, ex);</span><br><span class="line">      &#125; catch (SecurityException ex) &#123;</span><br><span class="line">          throw new RuntimeException(</span><br><span class="line">                  &quot;Problem getting static main on &quot; + className, ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      int modifiers = m.getModifiers();</span><br><span class="line">      if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">          throw new RuntimeException(</span><br><span class="line">                  &quot;Main method is not public and static on &quot; + className);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * This throw gets caught in ZygoteInit.main(), which responds</span><br><span class="line">       * by invoking the exception&apos;s run() method. This arrangement</span><br><span class="line">       * clears up all the stack frames that were required in setting</span><br><span class="line">       * up the process.</span><br><span class="line">       */</span><br><span class="line">      //通过抛出异常，回到zygoteInit.main方法，这样能清空栈帧，提高栈帧利用率，见流程17</span><br><span class="line">      return new MethodAndArgsCaller(m, argv);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>MethodAndArgsCaller方法中的m是指main方法，argv是指ActivityThread，根据流程4可知，下一步进入到 caller.run()方法，也即MethodAndArgsCaller.run。</p>
<h3 id="17-MethodAndArgsCaller"><a href="#17-MethodAndArgsCaller" class="headerlink" title="17. MethodAndArgsCaller"></a>17. MethodAndArgsCaller</h3><p>[-&gt; RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static class MethodAndArgsCaller implements Runnable &#123;</span><br><span class="line">       /** method to call */</span><br><span class="line">       private final Method mMethod;</span><br><span class="line"></span><br><span class="line">       /** argument array */</span><br><span class="line">       private final String[] mArgs;</span><br><span class="line"></span><br><span class="line">       public MethodAndArgsCaller(Method method, String[] args) &#123;</span><br><span class="line">           mMethod = method;</span><br><span class="line">           mArgs = args;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void run() &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               //反射调用ActivityThread.main静态方法，见流程18</span><br><span class="line">               mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">           &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">               throw new RuntimeException(ex);</span><br><span class="line">           &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">               Throwable cause = ex.getCause();</span><br><span class="line">               if (cause instanceof RuntimeException) &#123;</span><br><span class="line">                   throw (RuntimeException) cause;</span><br><span class="line">               &#125; else if (cause instanceof Error) &#123;</span><br><span class="line">                   throw (Error) cause;</span><br><span class="line">               &#125;</span><br><span class="line">               throw new RuntimeException(ex);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最后进入ActivityThread.main方法</p>
<h3 id="18-AT-main"><a href="#18-AT-main" class="headerlink" title="18. AT.main"></a>18. AT.main</h3><p>[-&gt;ActivityThread]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line"></span><br><span class="line">       // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">       // disable it here, but selectively enable it later (via</span><br><span class="line">       // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">       CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">       Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">       // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">       final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">       TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">       Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">       //创建主线程looper</span><br><span class="line">       Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">       // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br><span class="line">       // It will be in the format &quot;seq=114&quot;</span><br><span class="line">       long startSeq = 0;</span><br><span class="line">       if (args != null) &#123;</span><br><span class="line">           for (int i = args.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">               if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                   startSeq = Long.parseLong(</span><br><span class="line">                           args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ActivityThread thread = new ActivityThread();</span><br><span class="line">       thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">       if (sMainThreadHandler == null) &#123;</span><br><span class="line">           sMainThreadHandler = thread.getHandler();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (false) &#123;</span><br><span class="line">           Looper.myLooper().setMessageLogging(new</span><br><span class="line">                   LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // End of event ActivityThreadMain.</span><br><span class="line">       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">       //主线程进入循环状态</span><br><span class="line">       Looper.loop();</span><br><span class="line"></span><br><span class="line">       throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Process.start方法是阻塞操作，直到进程创建完成并返回相应的进程pid时，才完成该方法。</p>
<p>app第一次启动时，其启动所在的进程会通过binder发送消息给Systemserver进程。systemserver进程是从Process.start开始，执行创建进程的操作。</p>
<p>Systemserver进程：通过Process.start方法发起创建新进程请求，会先收集各种新进程uid,gid,nice-name等相关参数，然后通过socket通道发送给zygote进程。</p>
<p>Zygote进程：接收到systemserver进程发送过来的参数后封装成Arguments对象，forAnddSpecialize方法是进程创建过程中最关键的一个过程，具体主要执行下面3个方法。</p>
<ul>
<li><p>preFork：停止Zygote的4个Daemon线程（java堆内存整理线程，引用队列线程、析构线程以及监控线程）的运行，初始化gc堆；</p>
</li>
<li><p>nativeForkAndSpecialize：调用fork创建新进程，设置新进程的主线程id，创建java堆处理的线程池，重置gc性能数据，设置信号处理函数等功能、启动JDWP线程。</p>
</li>
<li><p>postForkCommon：启动之前被停止4个Daemon线程。</p>
</li>
</ul>
<p>新进程：进入handleChildProc方法，设置进程名，打开binder驱动，启动新的binder线程，然后设置虚拟机参数，再通过调用目标类的main方法，即ActivityThread.main.</p>
<p>新进程由于会调用nativeZygoteInit,这个过程会调用startThreadPool创建binder线程池，所以每个进程一定至少包含一个Binder线程。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>源码路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/ZygoteProcess.java</span><br><span class="line">frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line">frameworks/base/core/java/com/android/internal/os/ZygoteServer.java</span><br><span class="line">frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</span><br><span class="line">libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java</span><br><span class="line">art/runtime/native/dalvik_system_ZygoteHooks.cc</span><br><span class="line">art/runtime/native/runtime.cc</span><br><span class="line">frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</span><br><span class="line">frameworks/base/cmds/app_process/app_main.cpp</span><br><span class="line">bionic/libc/bionic/fork.cpp</span><br><span class="line">art/runtime/signal_catcher.cc</span><br><span class="line">frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</span><br><span class="line">frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br></pre></td></tr></table></figure>
      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android进程/" rel="tag">#Android进程</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/开机广播BOOT_COMPLETED发送流程分析/" rel="next" title="开机广播BOOT_COMPLETED发送流程分析">
                <i class="fa fa-chevron-left"></i> 开机广播BOOT_COMPLETED发送流程分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/Android四大组件与进程启动间关系/" rel="prev" title="Android四大组件与进程启动间关系">
                Android四大组件与进程启动间关系 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、systemserver发起请求"><span class="nav-text">二、systemserver发起请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Process-start"><span class="nav-text">1.  Process.start</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Process-startViaZygote"><span class="nav-text">2.  Process.startViaZygote</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-zygoteSendArgsAndGetResult"><span class="nav-text">3.  zygoteSendArgsAndGetResult</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-openZygoteSocketIfNeeded"><span class="nav-text">3.1 openZygoteSocketIfNeeded</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、zygote创建进程"><span class="nav-text">三、zygote创建进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ZygoteInit-main"><span class="nav-text">4.ZygoteInit.main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-ZS-runSelectLoop"><span class="nav-text">5.ZS.runSelectLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-ZC-acceptCommandPeer"><span class="nav-text">5.1 ZC.acceptCommandPeer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-ZC-processOneCommand"><span class="nav-text">6. ZC.processOneCommand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Zygote-forkAndSpecialize"><span class="nav-text">7.Zygote.forkAndSpecialize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-ZygoteHooks-preFork"><span class="nav-text">8. ZygoteHooks.preFork</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-Daemons-stop"><span class="nav-text">8.1 Daemons.stop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-waitUntilAllThreadsStopped"><span class="nav-text">8.2  waitUntilAllThreadsStopped</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-nativePreFork"><span class="nav-text">8.3 nativePreFork</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-nativeForkAndSpecialize"><span class="nav-text">9. nativeForkAndSpecialize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-ForkCommon"><span class="nav-text">10. ForkCommon</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-fork"><span class="nav-text">10.1 fork</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-SpecializeCommon"><span class="nav-text">11. SpecializeCommon</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-callPostForkChildHooks"><span class="nav-text">11.1 callPostForkChildHooks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-postForkChild"><span class="nav-text">11.2 postForkChild</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-nativePostForkChild"><span class="nav-text">11.3 nativePostForkChild</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-InitNonZygoteOrPostFork"><span class="nav-text">11.4 InitNonZygoteOrPostFork</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-postForkCommon"><span class="nav-text">12. postForkCommon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-小结"><span class="nav-text">13. 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、新进程运行"><span class="nav-text">四、新进程运行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-ZC-handleChildProc"><span class="nav-text">14. ZC.handleChildProc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-ZygoteInit-zygoteInit"><span class="nav-text">15. ZygoteInit.zygoteInit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-1-commonInit"><span class="nav-text">15.1 commonInit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-2-nativeZygoteInit"><span class="nav-text">15.2 nativeZygoteInit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-3-applicationInit"><span class="nav-text">15.3 applicationInit</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-findStaticMain"><span class="nav-text">16. findStaticMain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-MethodAndArgsCaller"><span class="nav-text">17. MethodAndArgsCaller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-AT-main"><span class="nav-text">18. AT.main</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、总结"><span class="nav-text">五、总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2019/Android进程创建流程分析/';
      var disqus_title = "Android进程创建流程分析";
      var disqus_url = 'http://zproo.github.io/2019/Android进程创建流程分析/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
