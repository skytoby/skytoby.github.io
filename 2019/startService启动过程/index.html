<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Service,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="基于Android10.0，分析startService的启动过程  一、概述前面已经介绍了详细介绍了管理Android四大剑客Activity、Service、Broadcast、ContentProvider的ActivityManagerService启动的详细流程，这里讲从应用startService的启动过程来分析AMS。 ActivityManagerService相关的类图如下：">
<meta name="keywords" content="Service">
<meta property="og:type" content="article">
<meta property="og:title" content="startServie启动过程">
<meta property="og:url" content="http://zproo.github.io/2019/startService启动过程/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="基于Android10.0，分析startService的启动过程  一、概述前面已经介绍了详细介绍了管理Android四大剑客Activity、Service、Broadcast、ContentProvider的ActivityManagerService启动的详细流程，这里讲从应用startService的启动过程来分析AMS。 ActivityManagerService相关的类图如下：">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2019/startService启动过程/AMS.jpg">
<meta property="og:image" content="http://zproo.github.io/2019/startService启动过程/startService.jpg">
<meta property="og:updated_time" content="2019-12-28T06:15:49.789Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="startServie启动过程">
<meta name="twitter:description" content="基于Android10.0，分析startService的启动过程  一、概述前面已经介绍了详细介绍了管理Android四大剑客Activity、Service、Broadcast、ContentProvider的ActivityManagerService启动的详细流程，这里讲从应用startService的启动过程来分析AMS。 ActivityManagerService相关的类图如下：">
<meta name="twitter:image" content="http://zproo.github.io/2019/startService启动过程/AMS.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2019/startService启动过程/">

  <title> startServie启动过程 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/Service/" rel="tag" title="Service">Service</a>
      
      </div>
      <h1>startServie启动过程</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2019-08-31T00:18:29+08:00" content="2019-08-31" title="2019-08-31 00:18:29">
          2019-08-31
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                startServie启动过程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-08-31T00:18:29+08:00" content="2019-08-31">
              2019-08-31
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/startService启动过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/startService启动过程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>基于Android10.0，分析startService的启动过程</p>
</blockquote>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>前面已经介绍了详细介绍了管理Android四大剑客Activity、Service、Broadcast、ContentProvider的ActivityManagerService启动的详细流程，这里讲从应用startService的启动过程来分析AMS。</p>
<p>ActivityManagerService相关的类图如下：</p>
<p><img src="/2019/startService启动过程/AMS.jpg" alt="AMS"></p>
<p>启动服务通过startServie或者bindService即可，该过程如下：</p>
<p>当应用调用Andorid API方法startServie或者bindService来启动服务的过程，主要是AMS来完成的。</p>
<p>1.AMS通过socket通信方式向zygote进程请求创建用于承载服务进程的ActivityThread。如果启动服务运行在本地服务则不需要再次创建进程。</p>
<p>2.zygote通过fork的方法，将zygote进程复制升级新的进程，并将ActivityThread相关的资源加载到新进程。</p>
<p>3.AMS向新生成的ActivityThread进程，通过Binder方式发送创建服务的请求</p>
<p>4.ActivityThread启动本地运行服务。</p>
<p>启动服务的流程如下：</p>
<p><img src="/2019/startService启动过程/startService.jpg" alt="startService"></p>
<h2 id="二、启动服务进程端"><a href="#二、启动服务进程端" class="headerlink" title="二、启动服务进程端"></a>二、启动服务进程端</h2><p>在app中调用startService，调用的是ContextWrapper中的startService</p>
<h3 id="1-CW-startService"><a href="#1-CW-startService" class="headerlink" title="1. CW.startService"></a>1. CW.startService</h3><p>[-&gt;ContextWrapper.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ComponentName startService(Intent service) &#123;</span><br><span class="line">     //mBase为ContextImpl对象</span><br><span class="line">    return mBase.startService(service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Cl-startService"><a href="#2-Cl-startService" class="headerlink" title="2. Cl.startService"></a>2. Cl.startService</h3><p>[-&gt;ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ComponentName startService(Intent service) &#123;</span><br><span class="line">      //system进程调用此方法时输出warn信息</span><br><span class="line">       warnIfCallingFromSystemProcess();</span><br><span class="line">       return startServiceCommon(service, false, mUser);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-CI-startServiceCommon"><a href="#3-CI-startServiceCommon" class="headerlink" title="3.  CI.startServiceCommon"></a>3.  CI.startServiceCommon</h3><p>[-&gt;ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private ComponentName startServiceCommon(Intent service, boolean requireForeground,</span><br><span class="line">           UserHandle user) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           //校验service，sdk大于等于21时，service中必须带Component和Package</span><br><span class="line">           validateServiceIntent(service);</span><br><span class="line">           service.prepareToLeaveProcess(this);</span><br><span class="line">           //通过binder调用startService,见1.4节</span><br><span class="line">           ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">               mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                           getContentResolver()), requireForeground,</span><br><span class="line">                           getOpPackageName(), user.getIdentifier());</span><br><span class="line">           if (cn != null) &#123;</span><br><span class="line">               if (cn.getPackageName().equals(&quot;!&quot;)) &#123;</span><br><span class="line">                   throw new SecurityException(</span><br><span class="line">                           &quot;Not allowed to start service &quot; + service</span><br><span class="line">                           + &quot; without permission &quot; + cn.getClassName());</span><br><span class="line">               &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123;</span><br><span class="line">                   throw new SecurityException(</span><br><span class="line">                           &quot;Unable to start service &quot; + service</span><br><span class="line">                           + &quot;: &quot; + cn.getClassName());</span><br><span class="line">               &#125; else if (cn.getPackageName().equals(&quot;?&quot;)) &#123;</span><br><span class="line">                   throw new IllegalStateException(</span><br><span class="line">                           &quot;Not allowed to start service &quot; + service + &quot;: &quot; + cn.getClassName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return cn;</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           throw e.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-AM-getService"><a href="#4-AM-getService" class="headerlink" title="4. AM.getService"></a>4. AM.getService</h3><p>这个方法和Android6.0不一样，没有了ActivityManagerNative和ActivityManagerProxy，直接通过IActivityManager.aidl生成的接口获得ActivityManagerService的代理。startService通过Binder机制，调用了服务器端AMS的startService方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static IActivityManager getService() &#123;</span><br><span class="line">    return IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected IActivityManager create() &#123;</span><br><span class="line">                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                //IAcitivityManager.aidl编译会生成相应的代理类和实现类</span><br><span class="line">                final IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                return am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三、SystemServer端"><a href="#三、SystemServer端" class="headerlink" title="三、SystemServer端"></a>三、SystemServer端</h2><h3 id="5-AMS-startService"><a href="#5-AMS-startService" class="headerlink" title="5.  AMS.startService"></a>5.  AMS.startService</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public ComponentName startService(IApplicationThread caller, Intent service,</span><br><span class="line">          String resolvedType, boolean requireForeground, String callingPackage, int userId)</span><br><span class="line">          throws TransactionTooLargeException &#123;</span><br><span class="line">      //当调用进程是孤立进程时抛出异常，孤立进程uid为99000~99999</span><br><span class="line">      enforceNotIsolatedCaller(&quot;startService&quot;);</span><br><span class="line">      // Refuse possible leaked file descriptors</span><br><span class="line">      if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (callingPackage == null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">              &quot;*** startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; fg=&quot; + requireForeground);</span><br><span class="line">      synchronized(this) &#123;</span><br><span class="line">          //调用者pid</span><br><span class="line">          final int callingPid = Binder.getCallingPid();</span><br><span class="line">          //调用者uid</span><br><span class="line">          final int callingUid = Binder.getCallingUid();</span><br><span class="line">          final long origId = Binder.clearCallingIdentity();</span><br><span class="line">          ComponentName res;</span><br><span class="line">          try &#123;</span><br><span class="line">              //mServices为ActiveServices对象</span><br><span class="line">              res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                      resolvedType, callingPid, callingUid,</span><br><span class="line">                      requireForeground, callingPackage, userId);</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              Binder.restoreCallingIdentity(origId);</span><br><span class="line">          &#125;</span><br><span class="line">          return res;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>startServiceLocked方法参数说明：</p>
<p>caller：IApplicationThread类型</p>
<p>service：Intent类型，包含运行的Service信息</p>
<p>resolvedType：String类型</p>
<p>callingPid：调用者pid</p>
<p>callingUid：调用者uid</p>
<p>requireForeground：是否需要前台运行，前面传的是false</p>
<p>callingPackage：调用该方法的包名</p>
<p>userId：用户id</p>
<h3 id="6-AS-startServiceLocked"><a href="#6-AS-startServiceLocked" class="headerlink" title="6.  AS.startServiceLocked"></a>6.  AS.startServiceLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,</span><br><span class="line">          int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)</span><br><span class="line">          throws TransactionTooLargeException &#123;</span><br><span class="line">      if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;startService: &quot; + service</span><br><span class="line">              + &quot; type=&quot; + resolvedType + &quot; args=&quot; + service.getExtras());</span><br><span class="line"></span><br><span class="line">      final boolean callerFg;</span><br><span class="line">      if (caller != null) &#123;</span><br><span class="line">          //进程不存在抛出异常</span><br><span class="line">          final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">          if (callerApp == null) &#123;</span><br><span class="line">              throw new SecurityException(</span><br><span class="line">                      &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                      + &quot; (pid=&quot; + callingPid</span><br><span class="line">                      + &quot;) when starting service &quot; + service);</span><br><span class="line">          &#125;</span><br><span class="line">          callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          callerFg = true;</span><br><span class="line">      &#125;</span><br><span class="line">      //检查服务信息</span><br><span class="line">      ServiceLookupResult res =</span><br><span class="line">          retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                  callingPid, callingUid, userId, true, callerFg, false, false);</span><br><span class="line">      if (res == null) &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (res.record == null) &#123;</span><br><span class="line">          return new ComponentName(&quot;!&quot;, res.permission != null</span><br><span class="line">                  ? res.permission : &quot;private to package&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ServiceRecord r = res.record;</span><br><span class="line">      //检查是否存在启动服务的user</span><br><span class="line">      if (!mAm.mUserController.exists(r.userId)) &#123;</span><br><span class="line">          Slog.w(TAG, &quot;Trying to start service with non-existent user! &quot; + r.userId);</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //是否运行后台启动服务</span><br><span class="line">      // If we&apos;re starting indirectly (e.g. from PendingIntent), figure out whether</span><br><span class="line">      // we&apos;re launching into an app in a background state.  This keys off of the same</span><br><span class="line">      // idleness state tracking as e.g. O+ background service start policy.</span><br><span class="line">      final boolean bgLaunch = !mAm.isUidActiveLocked(r.appInfo.uid);</span><br><span class="line"></span><br><span class="line">      // If the app has strict background restrictions, we treat any bg service</span><br><span class="line">      // start analogously to the legacy-app forced-restrictions case, regardless</span><br><span class="line">      // of its target SDK version.</span><br><span class="line">      boolean forcedStandby = false;</span><br><span class="line">      if (bgLaunch &amp;&amp; appRestrictedAnyInBackground(r.appInfo.uid, r.packageName)) &#123;</span><br><span class="line">          if (DEBUG_FOREGROUND_SERVICE) &#123;</span><br><span class="line">              Slog.d(TAG, &quot;Forcing bg-only service start only for &quot; + r.shortName</span><br><span class="line">                      + &quot; : bgLaunch=&quot; + bgLaunch + &quot; callerFg=&quot; + callerFg);</span><br><span class="line">          &#125;</span><br><span class="line">          forcedStandby = true;</span><br><span class="line">      &#125;</span><br><span class="line">      //如果是要求前台启动，则允许每个应用操作</span><br><span class="line">      // If this is a direct-to-foreground start, make sure it is allowed as per the app op.</span><br><span class="line">      boolean forceSilentAbort = false;</span><br><span class="line">      if (fgRequired) &#123;</span><br><span class="line">          final int mode = mAm.mAppOpsService.checkOperation(</span><br><span class="line">                  AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName);</span><br><span class="line">          switch (mode) &#123;</span><br><span class="line">              case AppOpsManager.MODE_ALLOWED:</span><br><span class="line">              case AppOpsManager.MODE_DEFAULT:</span><br><span class="line">                  // All okay.</span><br><span class="line">                  break;</span><br><span class="line">              case AppOpsManager.MODE_IGNORED:</span><br><span class="line">                  // Not allowed, fall back to normal start service, failing siliently</span><br><span class="line">                  // if background check restricts that.</span><br><span class="line">                  Slog.w(TAG, &quot;startForegroundService not allowed due to app op: service &quot;</span><br><span class="line">                          + service + &quot; to &quot; + r.name.flattenToShortString()</span><br><span class="line">                          + &quot; from pid=&quot; + callingPid + &quot; uid=&quot; + callingUid</span><br><span class="line">                          + &quot; pkg=&quot; + callingPackage);</span><br><span class="line">                  fgRequired = false;</span><br><span class="line">                  forceSilentAbort = true;</span><br><span class="line">                  break;</span><br><span class="line">              default:</span><br><span class="line">                  return new ComponentName(&quot;!!&quot;, &quot;foreground not allowed as per app op&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      //如果不是前台启动，则检查服务是否可以启动</span><br><span class="line">      // If this isn&apos;t a direct-to-foreground start, check our ability to kick off an</span><br><span class="line">      // arbitrary service</span><br><span class="line">      if (forcedStandby || (!r.startRequested &amp;&amp; !fgRequired)) &#123;</span><br><span class="line">          // Before going further -- if this app is not allowed to start services in the</span><br><span class="line">          // background, then at this point we aren&apos;t going to let it period.</span><br><span class="line">          final int allowed = mAm.getAppStartModeLocked(r.appInfo.uid, r.packageName,</span><br><span class="line">                  r.appInfo.targetSdkVersion, callingPid, false, false, forcedStandby);</span><br><span class="line">          if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">              Slog.w(TAG, &quot;Background start not allowed: service &quot;</span><br><span class="line">                      + service + &quot; to &quot; + r.name.flattenToShortString()</span><br><span class="line">                      + &quot; from pid=&quot; + callingPid + &quot; uid=&quot; + callingUid</span><br><span class="line">                      + &quot; pkg=&quot; + callingPackage + &quot; startFg?=&quot; + fgRequired);</span><br><span class="line">              if (allowed == ActivityManager.APP_START_MODE_DELAYED || forceSilentAbort) &#123;</span><br><span class="line">                  // In this case we are silently disabling the app, to disrupt as</span><br><span class="line">                  // little as possible existing apps.</span><br><span class="line">                  return null;</span><br><span class="line">              &#125;</span><br><span class="line">              if (forcedStandby) &#123;</span><br><span class="line">                  // This is an O+ app, but we might be here because the user has placed</span><br><span class="line">                  // it under strict background restrictions.  Don&apos;t punish the app if it&apos;s</span><br><span class="line">                  // trying to do the right thing but we&apos;re denying it for that reason.</span><br><span class="line">                  if (fgRequired) &#123;</span><br><span class="line">                      if (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">                          Slog.v(TAG, &quot;Silently dropping foreground service launch due to FAS&quot;);</span><br><span class="line">                      &#125;</span><br><span class="line">                      return null;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              // This app knows it is in the new model where this operation is not</span><br><span class="line">              // allowed, so tell it what has happened.</span><br><span class="line">              UidRecord uidRec = mAm.mActiveUids.get(r.appInfo.uid);</span><br><span class="line">              return new ComponentName(&quot;?&quot;, &quot;app is in background uid &quot; + uidRec);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      //前台服务判断，小于android10.0 则fgRequired为false</span><br><span class="line">      // At this point we&apos;ve applied allowed-to-start policy based on whether this was</span><br><span class="line">      // an ordinary startService() or a startForegroundService().  Now, only require that</span><br><span class="line">      // the app follow through on the startForegroundService() -&gt; startForeground()</span><br><span class="line">      // contract if it actually targets O+.</span><br><span class="line">      if (r.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O &amp;&amp; fgRequired) &#123;</span><br><span class="line">          if (DEBUG_BACKGROUND_CHECK || DEBUG_FOREGROUND_SERVICE) &#123;</span><br><span class="line">              Slog.i(TAG, &quot;startForegroundService() but host targets &quot;</span><br><span class="line">                      + r.appInfo.targetSdkVersion + &quot; - not requiring startForeground()&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          fgRequired = false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      NeededUriGrants neededGrants = mAm.checkGrantUriPermissionFromIntentLocked(</span><br><span class="line">              callingUid, r.packageName, service, service.getFlags(), null, r.userId);</span><br><span class="line">      //如果权限需要授权，则不启动服务</span><br><span class="line">      // If permissions need a review before any of the app components can run,</span><br><span class="line">      // we do not start the service and launch a review activity if the calling app</span><br><span class="line">      // is in the foreground passing it a pending intent to start the service when</span><br><span class="line">      // review is completed.</span><br><span class="line">      if (mAm.mPermissionReviewRequired) &#123;</span><br><span class="line">          // XXX This is not dealing with fgRequired!</span><br><span class="line">          if (!requestStartTargetPermissionsReviewIfNeededLocked(r, callingPackage,</span><br><span class="line">                  callingUid, service, callerFg, userId)) &#123;</span><br><span class="line">              return null;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (unscheduleServiceRestartLocked(r, callingUid, false)) &#123;</span><br><span class="line">          if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;START SERVICE WHILE RESTART PENDING: &quot; + r);</span><br><span class="line">      &#125;</span><br><span class="line">      r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">      r.startRequested = true;</span><br><span class="line">      r.delayedStop = false;</span><br><span class="line">      r.fgRequired = fgRequired;</span><br><span class="line">      r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">              service, neededGrants, callingUid));</span><br><span class="line"></span><br><span class="line">      if (fgRequired) &#123;</span><br><span class="line">          // We are now effectively running a foreground service.</span><br><span class="line">          mAm.mAppOpsService.startOperation(AppOpsManager.getToken(mAm.mAppOpsService),</span><br><span class="line">                  AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName, true);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final ServiceMap smap = getServiceMapLocked(r.userId);</span><br><span class="line">      boolean addToStarting = false;</span><br><span class="line">      //非前台服务的管理</span><br><span class="line">      if (!callerFg &amp;&amp; !fgRequired &amp;&amp; r.app == null</span><br><span class="line">              &amp;&amp; mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">          ProcessRecord proc = mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, false);</span><br><span class="line">          if (proc == null || proc.curProcState &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">              // If this is not coming from a foreground caller, then we may want</span><br><span class="line">              // to delay the start if there are already other background services</span><br><span class="line">              // that are starting.  This is to avoid process start spam when lots</span><br><span class="line">              // of applications are all handling things like connectivity broadcasts.</span><br><span class="line">              // We only do this for cached processes, because otherwise an application</span><br><span class="line">              // can have assumptions about calling startService() for a service to run</span><br><span class="line">              // in its own process, and for that process to not be killed before the</span><br><span class="line">              // service is started.  This is especially the case for receivers, which</span><br><span class="line">              // may start a service in onReceive() to do some additional work and have</span><br><span class="line">              // initialized some global state as part of that.</span><br><span class="line">              if (DEBUG_DELAYED_SERVICE) Slog.v(TAG_SERVICE, &quot;Potential start delay of &quot;</span><br><span class="line">                      + r + &quot; in &quot; + proc);</span><br><span class="line">              //如果延迟启动</span><br><span class="line">              if (r.delayed) &#123;</span><br><span class="line">                  // This service is already scheduled for a delayed start; just leave</span><br><span class="line">                  // it still waiting.</span><br><span class="line">                  if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;Continuing to delay: &quot; + r);</span><br><span class="line">                  return r.name;</span><br><span class="line">              &#125;</span><br><span class="line">              //如果后台启动的服务数大于同一时间内启动的最大服务数，则加入延迟启动队列</span><br><span class="line">              if (smap.mStartingBackground.size() &gt;= mMaxStartingBackground) &#123;</span><br><span class="line">                  // Something else is starting, delay!</span><br><span class="line">                  Slog.i(TAG_SERVICE, &quot;Delaying start of: &quot; + r);</span><br><span class="line">                  smap.mDelayedStartList.add(r);</span><br><span class="line">                  r.delayed = true;</span><br><span class="line">                  return r.name;</span><br><span class="line">              &#125;</span><br><span class="line">              if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;Not delaying: &quot; + r);</span><br><span class="line">              addToStarting = true;</span><br><span class="line">          &#125; else if (proc.curProcState &gt;= ActivityManager.PROCESS_STATE_SERVICE) &#123;</span><br><span class="line">              // We slightly loosen when we will enqueue this new service as a background</span><br><span class="line">              // starting service we are waiting for, to also include processes that are</span><br><span class="line">              // currently running other services or receivers.</span><br><span class="line">              //将服务加入到后台启动队列</span><br><span class="line">              addToStarting = true;</span><br><span class="line">              if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                      &quot;Not delaying, but counting as bg: &quot; + r);</span><br><span class="line">          &#125; else if (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">              StringBuilder sb = new StringBuilder(128);</span><br><span class="line">              sb.append(&quot;Not potential delay (state=&quot;).append(proc.curProcState)</span><br><span class="line">                      .append(&apos; &apos;).append(proc.adjType);</span><br><span class="line">              String reason = proc.makeAdjReason();</span><br><span class="line">              if (reason != null) &#123;</span><br><span class="line">                  sb.append(&apos; &apos;);</span><br><span class="line">                  sb.append(reason);</span><br><span class="line">              &#125;</span><br><span class="line">              sb.append(&quot;): &quot;);</span><br><span class="line">              sb.append(r.toString());</span><br><span class="line">              Slog.v(TAG_SERVICE, sb.toString());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else if (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">          if (callerFg || fgRequired) &#123;</span><br><span class="line">              Slog.v(TAG_SERVICE, &quot;Not potential delay (callerFg=&quot; + callerFg + &quot; uid=&quot;</span><br><span class="line">                      + callingUid + &quot; pid=&quot; + callingPid + &quot; fgRequired=&quot; + fgRequired + &quot;): &quot; + r);</span><br><span class="line">          &#125; else if (r.app != null) &#123;</span><br><span class="line">              Slog.v(TAG_SERVICE, &quot;Not potential delay (cur app=&quot; + r.app + &quot;): &quot; + r);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              Slog.v(TAG_SERVICE,</span><br><span class="line">                      &quot;Not potential delay (user &quot; + r.userId + &quot; not started): &quot; + r);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">      return cmp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Android10.0对于后台服务的启动，要求更加的严格。如果allowed不等于APP_START_MODE_NORMAL，则后台服务将不允许被启动。</p>
<p>callerFg对用于标记前台还是后台，当发起方进程不等于SCHED_GROUP_BACKGROUND或者发起方为空，则callerFg= true，否则为false。</p>
<h4 id="6-1-AMS-getAppStartModeLocked"><a href="#6-1-AMS-getAppStartModeLocked" class="headerlink" title="6.1 AMS.getAppStartModeLocked"></a>6.1 AMS.getAppStartModeLocked</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int getAppStartModeLocked(int uid, String packageName, int packageTargetSdk,</span><br><span class="line">          int callingPid, boolean alwaysRestrict, boolean disabledOnly, boolean forcedStandby) &#123;</span><br><span class="line">      UidRecord uidRec = mActiveUids.get(uid);</span><br><span class="line">      if (DEBUG_BACKGROUND_CHECK) Slog.d(TAG, &quot;checkAllowBackground: uid=&quot; + uid + &quot; pkg=&quot;</span><br><span class="line">              + packageName + &quot; rec=&quot; + uidRec + &quot; always=&quot; + alwaysRestrict + &quot; idle=&quot;</span><br><span class="line">              + (uidRec != null ? uidRec.idle : false));</span><br><span class="line">      //不进入这里则会被允许启动后台服务，否则将会进入下一步的检查</span><br><span class="line">      if (uidRec == null || alwaysRestrict || forcedStandby || uidRec.idle) &#123;</span><br><span class="line">          boolean ephemeral;</span><br><span class="line">          if (uidRec == null) &#123;</span><br><span class="line">              ephemeral = getPackageManagerInternalLocked().isPackageEphemeral(</span><br><span class="line">                      UserHandle.getUserId(uid), packageName);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              ephemeral = uidRec.ephemeral;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (ephemeral) &#123;</span><br><span class="line">              // We are hard-core about ephemeral apps not running in the background.</span><br><span class="line">              return ActivityManager.APP_START_MODE_DISABLED;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              if (disabledOnly) &#123;</span><br><span class="line">                  // The caller is only interested in whether app starts are completely</span><br><span class="line">                  // disabled for the given package (that is, it is an instant app).  So</span><br><span class="line">                  // we don&apos;t need to go further, which is all just seeing if we should</span><br><span class="line">                  // apply a &quot;delayed&quot; mode for a regular app.</span><br><span class="line">                  return ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">              &#125;</span><br><span class="line">              //alwaysRestrict为上面传过来的callerFg</span><br><span class="line">              final int startMode = (alwaysRestrict)</span><br><span class="line">                      ? appRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk)</span><br><span class="line">                      : appServicesRestrictedInBackgroundLocked(uid, packageName,</span><br><span class="line">                              packageTargetSdk);</span><br><span class="line">              if (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">                  Slog.d(TAG, &quot;checkAllowBackground: uid=&quot; + uid</span><br><span class="line">                          + &quot; pkg=&quot; + packageName + &quot; startMode=&quot; + startMode</span><br><span class="line">                          + &quot; onwhitelist=&quot; + isOnDeviceIdleWhitelistLocked(uid, false)</span><br><span class="line">                          + &quot; onwhitelist(ei)=&quot; + isOnDeviceIdleWhitelistLocked(uid, true));</span><br><span class="line">              &#125;</span><br><span class="line">              //延时模式下如果发起方的进行存在则还是可以启动</span><br><span class="line">              if (startMode == ActivityManager.APP_START_MODE_DELAYED) &#123;</span><br><span class="line">                  // This is an old app that has been forced into a &quot;compatible as possible&quot;</span><br><span class="line">                  // mode of background check.  To increase compatibility, we will allow other</span><br><span class="line">                  // foreground apps to cause its services to start.</span><br><span class="line">                  if (callingPid &gt;= 0) &#123;</span><br><span class="line">                      ProcessRecord proc;</span><br><span class="line">                      synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                          proc = mPidsSelfLocked.get(callingPid);</span><br><span class="line">                      &#125;</span><br><span class="line">                      if (proc != null &amp;&amp;</span><br><span class="line">                              !ActivityManager.isProcStateBackground(proc.curProcState)) &#123;</span><br><span class="line">                          // Whoever is instigating this is in the foreground, so we will allow it</span><br><span class="line">                          // to go through.</span><br><span class="line">                          return ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              return startMode;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>getAppStartModeLocked方法获取是否允许是否后台启动，一般callerFg为false，从而会进行服务再一次判断，普通的服务会进入appServicesRestrictedInBackgroundLocked方法进行判断如下：</p>
<h4 id="6-2-AMS-appServicesRestrictedInBackgroundLocked"><a href="#6-2-AMS-appServicesRestrictedInBackgroundLocked" class="headerlink" title="6.2 AMS.appServicesRestrictedInBackgroundLocked"></a>6.2 AMS.appServicesRestrictedInBackgroundLocked</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Service launch is available to apps with run-in-background exemptions but</span><br><span class="line">// some other background operations are not.  If we&apos;re doing a check</span><br><span class="line">// of service-launch policy, allow those callers to proceed unrestricted.</span><br><span class="line">int appServicesRestrictedInBackgroundLocked(int uid, String packageName, int packageTargetSdk)    &#123;</span><br><span class="line">   // Persistent进程</span><br><span class="line">   // Persistent app?</span><br><span class="line">    if (mPackageManagerInt.isPackagePersistent(packageName)) &#123;</span><br><span class="line">        if (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;App &quot; + uid + &quot;/&quot; + packageName</span><br><span class="line">                    + &quot; is persistent; not restricted in background&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">    //uid白名单</span><br><span class="line">    // Non-persistent but background whitelisted?</span><br><span class="line">    if (uidOnBackgroundWhitelist(uid)) &#123;</span><br><span class="line">        if (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;App &quot; + uid + &quot;/&quot; + packageName</span><br><span class="line">                    + &quot; on background whitelist; not restricted in background&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">    //电池白名单</span><br><span class="line">    // Is this app on the battery whitelist?</span><br><span class="line">    if (isOnDeviceIdleWhitelistLocked(uid, /*allowExceptIdleToo=*/ false)) &#123;</span><br><span class="line">        if (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;App &quot; + uid + &quot;/&quot; + packageName</span><br><span class="line">                    + &quot; on idle whitelist; not restricted in background&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ActivityManager.APP_START_MODE_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // None of the service-policy criteria apply, so we apply the common criteria</span><br><span class="line">    return appRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到对于persistent app、uid后台服务白名单、电池白名单里面都是可以启动后台服务的。</p>
<h3 id="7-AS-startServiceInnerLocked"><a href="#7-AS-startServiceInnerLocked" class="headerlink" title="7. AS.startServiceInnerLocked"></a>7. AS.startServiceInnerLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,</span><br><span class="line">           boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;</span><br><span class="line">       ServiceState stracker = r.getTracker();</span><br><span class="line">       if (stracker != null) &#123;</span><br><span class="line">           stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);</span><br><span class="line">       &#125;</span><br><span class="line">       r.callStart = false;</span><br><span class="line">       synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">           //用于耗电统计，开启允许状态</span><br><span class="line">           r.stats.startRunningLocked();</span><br><span class="line">       &#125;</span><br><span class="line">       String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);</span><br><span class="line">       if (error != null) &#123;</span><br><span class="line">           return new ComponentName(&quot;!!&quot;, error);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (r.startRequested &amp;&amp; addToStarting) &#123;</span><br><span class="line">           boolean first = smap.mStartingBackground.size() == 0;</span><br><span class="line">           smap.mStartingBackground.add(r);</span><br><span class="line">           r.startingBgTimeout = SystemClock.uptimeMillis() + mAm.mConstants.BG_START_TIMEOUT;</span><br><span class="line">           if (DEBUG_DELAYED_SERVICE) &#123;</span><br><span class="line">               RuntimeException here = new RuntimeException(&quot;here&quot;);</span><br><span class="line">               here.fillInStackTrace();</span><br><span class="line">               Slog.v(TAG_SERVICE, &quot;Starting background (first=&quot; + first + &quot;): &quot; + r, here);</span><br><span class="line">           &#125; else if (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">               Slog.v(TAG_SERVICE, &quot;Starting background (first=&quot; + first + &quot;): &quot; + r);</span><br><span class="line">           &#125;</span><br><span class="line">           if (first) &#123;</span><br><span class="line">               smap.rescheduleDelayedStartsLocked();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (callerFg || r.fgRequired) &#123;</span><br><span class="line">           smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return r.name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-AS-bringUpServiceLocked"><a href="#8-AS-bringUpServiceLocked" class="headerlink" title="8.AS.bringUpServiceLocked"></a>8.AS.bringUpServiceLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">           boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">           throws TransactionTooLargeException &#123;</span><br><span class="line">       //Slog.i(TAG, &quot;Bring up service:&quot;);</span><br><span class="line">       //r.dump(&quot;  &quot;);</span><br><span class="line"></span><br><span class="line">       if (r.app != null &amp;&amp; r.app.thread != null) &#123;</span><br><span class="line">           //调用service.onStartCommand过程</span><br><span class="line">           sendServiceArgsLocked(r, execInFg, false);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (!whileRestarting &amp;&amp; mRestartingServices.contains(r)) &#123;</span><br><span class="line">           //等待延迟重启的过程则直接返回</span><br><span class="line">           // If waiting for a restart, then do nothing.</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (DEBUG_SERVICE) &#123;</span><br><span class="line">           Slog.v(TAG_SERVICE, &quot;Bringing up &quot; + r + &quot; &quot; + r.intent + &quot; fg=&quot; + r.fgRequired);</span><br><span class="line">       &#125;</span><br><span class="line">       //启动service前，把service从启动服务队列中移除</span><br><span class="line">       // We are now bringing the service up, so no longer in the</span><br><span class="line">       // restarting state.</span><br><span class="line">       if (mRestartingServices.remove(r)) &#123;</span><br><span class="line">           clearRestartingIfNeededLocked(r);</span><br><span class="line">       &#125;</span><br><span class="line">       //service正在启动，将delayed设置为false</span><br><span class="line">       // Make sure this service is no longer considered delayed, we are starting it now.</span><br><span class="line">       if (r.delayed) &#123;</span><br><span class="line">           if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (bring up): &quot; + r);</span><br><span class="line">           getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">           r.delayed = false;</span><br><span class="line">       &#125;</span><br><span class="line">       //确保拥有服务的user已经启动，否则停止服务</span><br><span class="line">       // Make sure that the user who owns this service is started.  If not,</span><br><span class="line">       // we don&apos;t want to allow it to run.</span><br><span class="line">       if (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">           String msg = &quot;Unable to launch app &quot;</span><br><span class="line">                   + r.appInfo.packageName + &quot;/&quot;</span><br><span class="line">                   + r.appInfo.uid + &quot; for service &quot;</span><br><span class="line">                   + r.intent.getIntent() + &quot;: user &quot; + r.userId + &quot; is stopped&quot;;</span><br><span class="line">           Slog.w(TAG, msg);</span><br><span class="line">           bringDownServiceLocked(r);</span><br><span class="line">           return msg;</span><br><span class="line">       &#125;</span><br><span class="line">       //服务正在启动，设置package停止状态为false</span><br><span class="line">       // Service is now being launched, its package can&apos;t be stopped.</span><br><span class="line">       try &#123;</span><br><span class="line">           AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                   r.packageName, false, r.userId);</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">       &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Failed trying to unstop package &quot;</span><br><span class="line">                   + r.packageName + &quot;: &quot; + e);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;</span><br><span class="line">       final String procName = r.processName;</span><br><span class="line">       String hostingType = &quot;service&quot;;</span><br><span class="line">       ProcessRecord app;</span><br><span class="line">       //如果不是孤立进程</span><br><span class="line">       if (!isolated) &#123;</span><br><span class="line">           //根据uid和pid查询ProcessRecord</span><br><span class="line">           app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);</span><br><span class="line">           if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid</span><br><span class="line">                       + &quot; app=&quot; + app);</span><br><span class="line">           if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);</span><br><span class="line">                   //启动服务</span><br><span class="line">                   realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                   return null;</span><br><span class="line">               &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">                   throw e;</span><br><span class="line">               &#125; catch (RemoteException e) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // If a dead object exception was thrown -- fall through to</span><br><span class="line">               // restart the application.</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // If this service runs in an isolated process, then each time</span><br><span class="line">           // we call startProcessLocked() we will get a new isolated</span><br><span class="line">           // process, starting another process if we are currently waiting</span><br><span class="line">           // for a previous process to come up.  To deal with this, we store</span><br><span class="line">           // in the service any current isolated process it is running in or</span><br><span class="line">           // waiting to have come up.</span><br><span class="line">           app = r.isolatedProc;</span><br><span class="line">           if (WebViewZygote.isMultiprocessEnabled()</span><br><span class="line">                   &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123;</span><br><span class="line">               hostingType = &quot;webview_service&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //对于服务进程没有启动的情况</span><br><span class="line">       // Not running -- get it started, and enqueue this service record</span><br><span class="line">       // to be executed when the app comes up.</span><br><span class="line">       if (app == null &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">           //启动服务所需要的进程</span><br><span class="line">           if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,</span><br><span class="line">                   hostingType, r.name, false, isolated, false)) == null) &#123;</span><br><span class="line">               String msg = &quot;Unable to launch app &quot;</span><br><span class="line">                       + r.appInfo.packageName + &quot;/&quot;</span><br><span class="line">                       + r.appInfo.uid + &quot; for service &quot;</span><br><span class="line">                       + r.intent.getIntent() + &quot;: process is bad&quot;;</span><br><span class="line">               Slog.w(TAG, msg);</span><br><span class="line">               //进程启动失败</span><br><span class="line">               bringDownServiceLocked(r);</span><br><span class="line">               return msg;</span><br><span class="line">           &#125;</span><br><span class="line">           if (isolated) &#123;</span><br><span class="line">               r.isolatedProc = app;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (r.fgRequired) &#123;</span><br><span class="line">           if (DEBUG_FOREGROUND_SERVICE) &#123;</span><br><span class="line">               Slog.v(TAG, &quot;Whitelisting &quot; + UserHandle.formatUid(r.appInfo.uid)</span><br><span class="line">                       + &quot; for fg-service launch&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           mAm.tempWhitelistUidLocked(r.appInfo.uid,</span><br><span class="line">                   SERVICE_START_FOREGROUND_TIMEOUT, &quot;fg-service-launch&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (!mPendingServices.contains(r)) &#123;</span><br><span class="line">           mPendingServices.add(r);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (r.delayedStop) &#123;</span><br><span class="line">           // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">           r.delayedStop = false;</span><br><span class="line">           if (r.startRequested) &#123;</span><br><span class="line">               if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                       &quot;Applying delayed stop (in bring up): &quot; + r);</span><br><span class="line">               //停止服务</span><br><span class="line">               stopServiceLocked(r);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当目标进程已经存在，则直接执行realStartServiceLocked</p>
<p>当目标进程不存在，则先执行startProcessLocked创建进程，经过层层调用最后会调用到AMS.attachApplicationLocked,然后再执行realStartServiceLocked。</p>
<p>对于非前台进程调用而需要启动的服务，如果已经有其他的后台服务正在启动，则可能希望延迟其启动，从而避免同时启动过多的进程（非必须）。</p>
<h4 id="8-1-AMS-attachApplicationLocked"><a href="#8-1-AMS-attachApplicationLocked" class="headerlink" title="8.1 AMS.attachApplicationLocked"></a>8.1 AMS.attachApplicationLocked</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">   private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">           int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">       ...</span><br><span class="line">       thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                       app.instr.mClass,</span><br><span class="line">                       profilerInfo, app.instr.mArguments,</span><br><span class="line">                       app.instr.mWatcher,</span><br><span class="line">                       app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                       mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                       isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                       new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                       getCommonServicesLocked(app.isolated),</span><br><span class="line">                       mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                       buildSerial, isAutofillCompatEnabled);</span><br><span class="line">       </span><br><span class="line">       //寻找所有需要在该进程中运行的服务</span><br><span class="line">       // Find any services that should be running in this process...</span><br><span class="line">       if (!badApp) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">               checkTime(startTime, &quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;);</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);</span><br><span class="line">               badApp = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-2-AS-attachApplicationLocked"><a href="#8-2-AS-attachApplicationLocked" class="headerlink" title="8.2 AS.attachApplicationLocked"></a>8.2 AS.attachApplicationLocked</h4><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord proc, String processName)</span><br><span class="line">          throws RemoteException &#123;</span><br><span class="line">      boolean didSomething = false;</span><br><span class="line">      //启动mPendingServices队列中，等待在该进程启动的服务</span><br><span class="line">      // Collect any services that are waiting for this process to come up.</span><br><span class="line">      if (mPendingServices.size() &gt; 0) &#123;</span><br><span class="line">          ServiceRecord sr = null;</span><br><span class="line">          try &#123;</span><br><span class="line">              for (int i=0; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                  sr = mPendingServices.get(i);</span><br><span class="line">                  if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                          || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                      continue;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  mPendingServices.remove(i);</span><br><span class="line">                  i--;</span><br><span class="line">                  //将当前服务的包信息加入到proc</span><br><span class="line">                  proc.addPackage(sr.appInfo.packageName, sr.appInfo.longVersionCode,</span><br><span class="line">                          mAm.mProcessStats);</span><br><span class="line">                  //启动服务        </span><br><span class="line">                  realStartServiceLocked(sr, proc, sr.createdFromFg);</span><br><span class="line">                  didSomething = true;</span><br><span class="line">                  if (!isServiceNeededLocked(sr, false, false)) &#123;</span><br><span class="line">                      // We were waiting for this service to start, but it is actually no</span><br><span class="line">                      // longer needed.  This could happen because bringDownServiceIfNeeded</span><br><span class="line">                      // won&apos;t bring down a service that is pending...  so now the pending</span><br><span class="line">                      // is done, so let&apos;s drop it.</span><br><span class="line">                      bringDownServiceLocked(sr);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (RemoteException e) &#123;</span><br><span class="line">              Slog.w(TAG, &quot;Exception in new application when starting service &quot;</span><br><span class="line">                      + sr.shortName, e);</span><br><span class="line">              throw e;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //对于正在等待重启并需要运行在该进程中的服务，现在是启动的好时机</span><br><span class="line">      // Also, if there are any services that are waiting to restart and</span><br><span class="line">      // would run in this process, now is a good time to start them.  It would</span><br><span class="line">      // be weird to bring up the process but arbitrarily not let the services</span><br><span class="line">      // run at this point just because their restart time hasn&apos;t come up.</span><br><span class="line">      if (mRestartingServices.size() &gt; 0) &#123;</span><br><span class="line">          ServiceRecord sr;</span><br><span class="line">          for (int i=0; i&lt;mRestartingServices.size(); i++) &#123;</span><br><span class="line">              sr = mRestartingServices.get(i);</span><br><span class="line">              if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                      || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line">              mAm.mHandler.removeCallbacks(sr.restarter);</span><br><span class="line">              mAm.mHandler.post(sr.restarter);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return didSomething;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-AS-realStartServiceLocked"><a href="#9-AS-realStartServiceLocked" class="headerlink" title="9.AS.realStartServiceLocked"></a>9.AS.realStartServiceLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">            ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">        if (app.thread == null) &#123;</span><br><span class="line">            throw new RemoteException();</span><br><span class="line">        &#125;</span><br><span class="line">        if (DEBUG_MU)</span><br><span class="line">            Slog.v(TAG_MU, &quot;realStartServiceLocked, ServiceRecord.uid = &quot; + r.appInfo.uid</span><br><span class="line">                    + &quot;, ProcessRecord.uid = &quot; + app.uid);</span><br><span class="line">        r.app = app;</span><br><span class="line">        r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        final boolean newService = app.services.add(r);</span><br><span class="line">        //发送delay消息</span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);</span><br><span class="line">        mAm.updateLruProcessLocked(app, false, null);</span><br><span class="line">        updateServiceForegroundLocked(r.app, /* oomAdj= */ false);</span><br><span class="line">        mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        boolean created = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">                String nameTerm;</span><br><span class="line">                int lastPeriod = r.shortName.lastIndexOf(&apos;.&apos;);</span><br><span class="line">                nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">                EventLogTags.writeAmCreateService(</span><br><span class="line">                        r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">                r.stats.startLaunchedLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                                 PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">            app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            //服务进入onCreate</span><br><span class="line">            app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                    app.repProcState);</span><br><span class="line">            r.postNotification();</span><br><span class="line">            created = true;</span><br><span class="line">        &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">            //应用死亡处理</span><br><span class="line">            Slog.w(TAG, &quot;Application dead when creating service &quot; + r);</span><br><span class="line">            mAm.appDiedLocked(app);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!created) &#123;</span><br><span class="line">                // Keep the executeNesting count accurate.</span><br><span class="line">                final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">                serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">                // Cleanup.</span><br><span class="line">                if (newService) &#123;</span><br><span class="line">                    app.services.remove(r);</span><br><span class="line">                    r.app = null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Retry.</span><br><span class="line">                if (!inDestroying) &#123;</span><br><span class="line">                    scheduleServiceRestartLocked(r, false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (r.whitelistManager) &#123;</span><br><span class="line">            app.whitelistManager = true;</span><br><span class="line">        &#125;</span><br><span class="line">        requestServiceBindingsLocked(r, execInFg);</span><br><span class="line">        updateServiceClientActivitiesLocked(app, null, true);</span><br><span class="line">        // If the service is in the started state, and there are no</span><br><span class="line">        // pending arguments, then fake up one so its onStartCommand() will</span><br><span class="line">        // be called.</span><br><span class="line">        if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;</span><br><span class="line">            r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                    null, null, 0));</span><br><span class="line">        &#125;</span><br><span class="line">        //服务进入onStartCommand</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line"></span><br><span class="line">        if (r.delayed) &#123;</span><br><span class="line">            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (new proc): &quot; + r);</span><br><span class="line">            getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">            r.delayed = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (r.delayedStop) &#123;</span><br><span class="line">            // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">            r.delayedStop = false;</span><br><span class="line">            if (r.startRequested) &#123;</span><br><span class="line">                //停止服务</span><br><span class="line">                if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                        &quot;Applying delayed stop (from start): &quot; + r);</span><br><span class="line">                stopServiceLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>bumpServiceExecutingLocked会发送一个延迟处理的消息SERVICE_TIMEOUT_MSG。在方法scheduleCreateService执行完成，如果onCreate回调执行完成后，便会remove掉该消息。但如果没有在延时的时间内移除掉消息，则会进入到service timeout流程</p>
<h4 id="9-1-AS-bumpServiceExecutingLocked"><a href="#9-1-AS-bumpServiceExecutingLocked" class="headerlink" title="9.1 AS.bumpServiceExecutingLocked"></a>9.1 AS.bumpServiceExecutingLocked</h4><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private final void bumpServiceExecutingLocked(ServiceRecord r, boolean fg, String why) &#123;</span><br><span class="line">       if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;&gt;&gt;&gt; EXECUTING &quot;</span><br><span class="line">               + why + &quot; of &quot; + r + &quot; in app &quot; + r.app);</span><br><span class="line">       else if (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, &quot;&gt;&gt;&gt; EXECUTING &quot;</span><br><span class="line">               + why + &quot; of &quot; + r.shortName);</span><br><span class="line"></span><br><span class="line">       // For b/34123235: Services within the system server won&apos;t start until SystemServer</span><br><span class="line">       // does Looper.loop(), so we shouldn&apos;t try to start/bind to them too early in the boot</span><br><span class="line">       // process. However, since there&apos;s a little point of showing the ANR dialog in that case,</span><br><span class="line">       // let&apos;s suppress the timeout until PHASE_THIRD_PARTY_APPS_CAN_START.</span><br><span class="line">       //</span><br><span class="line">       // (Note there are multiple services start at PHASE_THIRD_PARTY_APPS_CAN_START too,</span><br><span class="line">       // which technically could also trigger this timeout if there&apos;s a system server</span><br><span class="line">       // that takes a long time to handle PHASE_THIRD_PARTY_APPS_CAN_START, but that shouldn&apos;t</span><br><span class="line">       // happen.)</span><br><span class="line">       boolean timeoutNeeded = true;</span><br><span class="line">       if ((mAm.mBootPhase &lt; SystemService.PHASE_THIRD_PARTY_APPS_CAN_START)</span><br><span class="line">               &amp;&amp; (r.app != null) &amp;&amp; (r.app.pid == android.os.Process.myPid())) &#123;</span><br><span class="line">           //SystemServer还未进入到PHASE_THIRD_PARTY_APPS_CAN_START状态，则不能启动服务</span><br><span class="line">           Slog.w(TAG, &quot;Too early to start/bind service in system_server: Phase=&quot; + mAm.mBootPhase</span><br><span class="line">                   + &quot; &quot; + r.getComponentName());</span><br><span class="line">           timeoutNeeded = false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       long now = SystemClock.uptimeMillis();</span><br><span class="line">       if (r.executeNesting == 0) &#123;</span><br><span class="line">           r.executeFg = fg;</span><br><span class="line">           ServiceState stracker = r.getTracker();</span><br><span class="line">           if (stracker != null) &#123;</span><br><span class="line">               stracker.setExecuting(true, mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">           &#125;</span><br><span class="line">           if (r.app != null) &#123;</span><br><span class="line">               r.app.executingServices.add(r);</span><br><span class="line">               r.app.execServicesFg |= fg;</span><br><span class="line">               if (timeoutNeeded &amp;&amp; r.app.executingServices.size() == 1) &#123;</span><br><span class="line">                   scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (r.app != null &amp;&amp; fg &amp;&amp; !r.app.execServicesFg) &#123;</span><br><span class="line">           r.app.execServicesFg = true;</span><br><span class="line">           if (timeoutNeeded) &#123;</span><br><span class="line">               scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       r.executeFg |= fg;</span><br><span class="line">       r.executeNesting++;</span><br><span class="line">       r.executingStart = now;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-AS-scheduleServiceTimeoutLocked"><a href="#9-2-AS-scheduleServiceTimeoutLocked" class="headerlink" title="9.2 AS.scheduleServiceTimeoutLocked"></a>9.2 AS.scheduleServiceTimeoutLocked</h4><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void scheduleServiceTimeoutLocked(ProcessRecord proc) &#123;</span><br><span class="line">       if (proc.executingServices.size() == 0 || proc.thread == null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">               ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">       msg.obj = proc;</span><br><span class="line">       //超时后还没有移除SERVICE_TIMEOUT_MSG消息，则执行SERVICE_TIMEOUT流程</span><br><span class="line">       mAm.mHandler.sendMessageDelayed(msg,</span><br><span class="line">               proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>发送延迟消息SERVICE_TIMEOUT_MSG：</p>
<ul>
<li><p>对于前台服务，则超时为SERVICE_TIMEOUT=20s</p>
</li>
<li><p>对于后台服务，则超时为SERVICE_BACKGROUND_TIMEOUT=SERVICE_TIMEOUT * 10</p>
</li>
</ul>
<p>app.thread.scheduleCreateService通过Binder机制调用，IApplicationThread.aidl在编译时会生成代理类和实现类。通过IApplicationThread代理，调用到目标进程端的scheduleCreateService具体实现。</p>
<h2 id="四、目标进程端"><a href="#四、目标进程端" class="headerlink" title="四、目标进程端"></a>四、目标进程端</h2><h3 id="10-AT-scheduleCreateService"><a href="#10-AT-scheduleCreateService" class="headerlink" title="10.AT.scheduleCreateService"></a>10.AT.scheduleCreateService</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleCreateService(IBinder token,</span><br><span class="line">              ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">          updateProcessState(processState, false);</span><br><span class="line">          CreateServiceData s = new CreateServiceData();</span><br><span class="line">          s.token = token;</span><br><span class="line">          s.info = info;</span><br><span class="line">          s.compatInfo = compatInfo;</span><br><span class="line">          sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>该方法执行在ActivityThread线程。</p>
<h4 id="10-1-AT-handleMessage"><a href="#10-1-AT-handleMessage" class="headerlink" title="10.1 AT.handleMessage"></a>10.1 AT.handleMessage</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">     ...</span><br><span class="line">              case CREATE_SERVICE:</span><br><span class="line">                    handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                    break;</span><br><span class="line">               case BIND_SERVICE:</span><br><span class="line">                   handleBindService((BindServiceData)msg.obj);</span><br><span class="line">                   break;</span><br><span class="line">               case UNBIND_SERVICE:</span><br><span class="line">                   handleUnbindService((BindServiceData)msg.obj);</span><br><span class="line">                   schedulePurgeIdler();</span><br><span class="line">                   break;</span><br><span class="line">               case SERVICE_ARGS:</span><br><span class="line">                   handleServiceArgs((ServiceArgsData)msg.obj);//onStartCommand</span><br><span class="line">                   break;</span><br><span class="line">               case STOP_SERVICE:</span><br><span class="line">                   handleStopService((IBinder)msg.obj);</span><br><span class="line">                   schedulePurgeIdler();</span><br><span class="line">                   break;</span><br><span class="line">      ...    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-AT-handleCreateService"><a href="#11-AT-handleCreateService" class="headerlink" title="11.AT.handleCreateService"></a>11.AT.handleCreateService</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">    //当应用处于后台即将进行gc,而此时回调到活动状态，则跳过本次gc</span><br><span class="line">    // If we are getting ready to gc after going to the background, well</span><br><span class="line">    // we are back active so skip it.</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = null;</span><br><span class="line">    //通过反射创建目标服务对象</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = packageInfo.getAppFactory()</span><br><span class="line">                .instantiateService(cl, data.info.name, data.intent);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate service &quot; + data.info.name</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</span><br><span class="line">        //创建ContextImpl</span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">       </span><br><span class="line">        //创建Application</span><br><span class="line">        Application app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                ActivityManager.getService());</span><br><span class="line">        //调用服务onCreate方法       </span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        //调用服务创建完成</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to create service &quot; + data.info.name</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-1-Service-onCreate"><a href="#11-1-Service-onCreate" class="headerlink" title="11.1 Service.onCreate"></a>11.1 Service.onCreate</h4><p>[-&gt;Service.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Service extends ContextWrapper implements ComponentCallbacks2 &#123;</span><br><span class="line">   /**</span><br><span class="line">    * Called by the system when the service is first created.  Do not call this method directly.</span><br><span class="line">    */</span><br><span class="line">   public void onCreate() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用到了Service.onCreate方法，对于目标服务一般都是继承Service，并且覆写onCreate方法，到此终于进入到了Service的生命周期。</p>
<h3 id="12-AMS-serviceDoneExecuting"><a href="#12-AMS-serviceDoneExecuting" class="headerlink" title="12.AMS.serviceDoneExecuting"></a>12.AMS.serviceDoneExecuting</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123;</span><br><span class="line">       synchronized(this) &#123;</span><br><span class="line">           if (!(token instanceof ServiceRecord)) &#123;</span><br><span class="line">               Slog.e(TAG, &quot;serviceDoneExecuting: Invalid service token=&quot; + token);</span><br><span class="line">               throw new IllegalArgumentException(&quot;Invalid service token&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>由流程9.1 bumpServiceExecutingLocked方法发送了一个延时消息SERVICE_TIMEOUT_MSG，现在onCreate执行完成，那么就需要移除该消息，否则会报超时。</p>
<h4 id="12-1-AS-serviceDoneExecutingLocked"><a href="#12-1-AS-serviceDoneExecutingLocked" class="headerlink" title="12.1 AS.serviceDoneExecutingLocked"></a>12.1 AS.serviceDoneExecutingLocked</h4><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) &#123;</span><br><span class="line">       boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">       if (r != null) &#123;</span><br><span class="line">           if (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123;</span><br><span class="line">               // This is a call from a service start...  take care of</span><br><span class="line">               // book-keeping.</span><br><span class="line">               r.callStart = true;</span><br><span class="line">               //onStartCommand返回值的处理</span><br><span class="line">               switch (res) &#123;</span><br><span class="line">                   case Service.START_STICKY_COMPATIBILITY:</span><br><span class="line">                   case Service.START_STICKY: &#123;</span><br><span class="line">                       // We are done with the associated start arguments.</span><br><span class="line">                       r.findDeliveredStart(startId, false, true);</span><br><span class="line">                       // Don&apos;t stop if killed.</span><br><span class="line">                       r.stopIfKilled = false;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   case Service.START_NOT_STICKY: &#123;</span><br><span class="line">                       // We are done with the associated start arguments.</span><br><span class="line">                       r.findDeliveredStart(startId, false, true);</span><br><span class="line">                       if (r.getLastStartId() == startId) &#123;</span><br><span class="line">                           // There is no more work, and this service</span><br><span class="line">                           // doesn&apos;t want to hang around if killed.</span><br><span class="line">                           r.stopIfKilled = true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   case Service.START_REDELIVER_INTENT: &#123;</span><br><span class="line">                       // We&apos;ll keep this item until they explicitly</span><br><span class="line">                       // call stop for it, but keep track of the fact</span><br><span class="line">                       // that it was delivered.</span><br><span class="line">                       ServiceRecord.StartItem si = r.findDeliveredStart(startId, false, false);</span><br><span class="line">                       if (si != null) &#123;</span><br><span class="line">                           si.deliveryCount = 0;</span><br><span class="line">                           si.doneExecutingCount++;</span><br><span class="line">                           // Don&apos;t stop if killed.</span><br><span class="line">                           r.stopIfKilled = true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   case Service.START_TASK_REMOVED_COMPLETE: &#123;</span><br><span class="line">                       // Special processing for onTaskRemoved().  Don&apos;t</span><br><span class="line">                       // impact normal onStartCommand() processing.</span><br><span class="line">                       r.findDeliveredStart(startId, true, true);</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   default:</span><br><span class="line">                       throw new IllegalArgumentException(</span><br><span class="line">                               &quot;Unknown service start result: &quot; + res);</span><br><span class="line">               &#125;</span><br><span class="line">               if (res == Service.START_STICKY_COMPATIBILITY) &#123;</span><br><span class="line">                   r.callStart = false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else if (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123;</span><br><span class="line">               // This is the final call from destroying the service...  we should</span><br><span class="line">               // actually be getting rid of the service at this point.  Do some</span><br><span class="line">               // validation of its state, and ensure it will be fully removed.</span><br><span class="line">               if (!inDestroying) &#123;</span><br><span class="line">                   // Not sure what else to do with this...  if it is not actually in the</span><br><span class="line">                   // destroying list, we don&apos;t need to make sure to remove it from it.</span><br><span class="line">                   // If the app is null, then it was probably removed because the process died,</span><br><span class="line">                   // otherwise wtf</span><br><span class="line">                   if (r.app != null) &#123;</span><br><span class="line">                       Slog.w(TAG, &quot;Service done with onDestroy, but not inDestroying: &quot;</span><br><span class="line">                               + r + &quot;, app=&quot; + r.app);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else if (r.executeNesting != 1) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;Service done with onDestroy, but executeNesting=&quot;</span><br><span class="line">                           + r.executeNesting + &quot;: &quot; + r);</span><br><span class="line">                   // Fake it to keep from ANR due to orphaned entry.</span><br><span class="line">                   r.executeNesting = 1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           final long origId = Binder.clearCallingIdentity();</span><br><span class="line">           //如下</span><br><span class="line">           serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Done executing unknown service from pid &quot;</span><br><span class="line">                   + Binder.getCallingPid());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-2-AS-serviceDoneExecutingLocked"><a href="#12-2-AS-serviceDoneExecutingLocked" class="headerlink" title="12.2 AS.serviceDoneExecutingLocked"></a>12.2 AS.serviceDoneExecutingLocked</h4><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying,</span><br><span class="line">           boolean finishing) &#123;</span><br><span class="line">       if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;&lt;&lt;&lt; DONE EXECUTING &quot; + r</span><br><span class="line">               + &quot;: nesting=&quot; + r.executeNesting</span><br><span class="line">               + &quot;, inDestroying=&quot; + inDestroying + &quot;, app=&quot; + r.app);</span><br><span class="line">       else if (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">               &quot;&lt;&lt;&lt; DONE EXECUTING &quot; + r.shortName);</span><br><span class="line">       r.executeNesting--;</span><br><span class="line">       if (r.executeNesting &lt;= 0) &#123;</span><br><span class="line">           if (r.app != null) &#123;</span><br><span class="line">               if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                       &quot;Nesting at 0 of &quot; + r.shortName);</span><br><span class="line">               r.app.execServicesFg = false;</span><br><span class="line">               r.app.executingServices.remove(r);</span><br><span class="line">               if (r.app.executingServices.size() == 0) &#123;</span><br><span class="line">                   //移除SERVICE_TIMEOUT_MSG消息</span><br><span class="line">                   if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                           &quot;No more executingServices of &quot; + r.shortName);</span><br><span class="line">                   mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">               &#125; else if (r.executeFg) &#123;</span><br><span class="line">                   // Need to re-evaluate whether the app still needs to be in the foreground.</span><br><span class="line">                   for (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">                       if (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                           r.app.execServicesFg = true;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (inDestroying) &#123;</span><br><span class="line">                   if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                           &quot;doneExecuting remove destroying &quot; + r);</span><br><span class="line">                   mDestroyingServices.remove(r);</span><br><span class="line">                   r.bindings.clear();</span><br><span class="line">               &#125;</span><br><span class="line">               //更新adj</span><br><span class="line">               mAm.updateOomAdjLocked(r.app, true);</span><br><span class="line">           &#125;</span><br><span class="line">           r.executeFg = false;</span><br><span class="line">           if (r.tracker != null) &#123;</span><br><span class="line">               r.tracker.setExecuting(false, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                       SystemClock.uptimeMillis());</span><br><span class="line">               if (finishing) &#123;</span><br><span class="line">                   r.tracker.clearCurrentOwner(r, false);</span><br><span class="line">                   r.tracker = null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (finishing) &#123;</span><br><span class="line">               if (r.app != null &amp;&amp; !r.app.persistent) &#123;</span><br><span class="line">                   r.app.services.remove(r);</span><br><span class="line">                   if (r.whitelistManager) &#123;</span><br><span class="line">                       updateWhitelistManagerLocked(r.app);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               r.app = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法将会移除SERVICE_TIMEOUT_MSG消息。Service启动过程出现ANR，会发送超时serviceRecord消息，这通常是onCreate的回调方法过长导致。</p>
<p>realStartServiceLocked方法，在完成onCreate操作时，后面进入到了onStartCoomnad方法.</p>
<h3 id="13-AS-sendServiceArgsLocked"><a href="#13-AS-sendServiceArgsLocked" class="headerlink" title="13.AS.sendServiceArgsLocked"></a>13.AS.sendServiceArgsLocked</h3><p>[-&gt;ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,</span><br><span class="line">           boolean oomAdjusted) throws TransactionTooLargeException &#123;</span><br><span class="line">       final int N = r.pendingStarts.size();</span><br><span class="line">       if (N == 0) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       ArrayList&lt;ServiceStartArgs&gt; args = new ArrayList&lt;&gt;();</span><br><span class="line">       while (r.pendingStarts.size() &gt; 0) &#123;</span><br><span class="line">           ServiceRecord.StartItem si = r.pendingStarts.remove(0);</span><br><span class="line">           if (DEBUG_SERVICE) &#123;</span><br><span class="line">               Slog.v(TAG_SERVICE, &quot;Sending arguments to: &quot;</span><br><span class="line">                       + r + &quot; &quot; + r.intent + &quot; args=&quot; + si.intent);</span><br><span class="line">           &#125;</span><br><span class="line">           if (si.intent == null &amp;&amp; N &gt; 1) &#123;</span><br><span class="line">               // If somehow we got a dummy null intent in the middle,</span><br><span class="line">               // then skip it.  DO NOT skip a null intent when it is</span><br><span class="line">               // the only one in the list -- this is to support the</span><br><span class="line">               // onStartCommand(null) case.</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">           r.deliveredStarts.add(si);</span><br><span class="line">           si.deliveryCount++;</span><br><span class="line">           if (si.neededGrants != null) &#123;</span><br><span class="line">               mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants,</span><br><span class="line">                       si.getUriPermissionsLocked());</span><br><span class="line">           &#125;</span><br><span class="line">           mAm.grantEphemeralAccessLocked(r.userId, si.intent,</span><br><span class="line">                   r.appInfo.uid, UserHandle.getAppId(si.callingId));</span><br><span class="line">           //标记启动开始，同上</span><br><span class="line">           bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);</span><br><span class="line">           if (!oomAdjusted) &#123;</span><br><span class="line">               oomAdjusted = true;</span><br><span class="line">               mAm.updateOomAdjLocked(r.app, true);</span><br><span class="line">           &#125;</span><br><span class="line">           if (r.fgRequired &amp;&amp; !r.fgWaiting) &#123;</span><br><span class="line">               if (!r.isForeground) &#123;</span><br><span class="line">                   if (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">                       Slog.i(TAG, &quot;Launched service must call startForeground() within timeout: &quot; + r);</span><br><span class="line">                   &#125;</span><br><span class="line">                   scheduleServiceForegroundTransitionTimeoutLocked(r);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   if (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">                       Slog.i(TAG, &quot;Service already foreground; no new timeout: &quot; + r);</span><br><span class="line">                   &#125;</span><br><span class="line">                   r.fgRequired = false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           int flags = 0;</span><br><span class="line">           if (si.deliveryCount &gt; 1) &#123;</span><br><span class="line">               flags |= Service.START_FLAG_RETRY;</span><br><span class="line">           &#125;</span><br><span class="line">           if (si.doneExecutingCount &gt; 0) &#123;</span><br><span class="line">               flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">           &#125;</span><br><span class="line">           args.add(new ServiceStartArgs(si.taskRemoved, si.id, flags, si.intent));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ParceledListSlice&lt;ServiceStartArgs&gt; slice = new ParceledListSlice&lt;&gt;(args);</span><br><span class="line">       slice.setInlineCountLimit(4);</span><br><span class="line">       Exception caughtException = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           //流程同onCreate，最后回调onStartCommand</span><br><span class="line">           r.app.thread.scheduleServiceArgs(r, slice);</span><br><span class="line">       &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">           if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Transaction too large for &quot; + args.size()</span><br><span class="line">                   + &quot; args, first: &quot; + args.get(0).args);</span><br><span class="line">           Slog.w(TAG, &quot;Failed delivering service starts&quot;, e);</span><br><span class="line">           caughtException = e;</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           // Remote process gone...  we&apos;ll let the normal cleanup take care of this.</span><br><span class="line">           if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while sending args: &quot; + r);</span><br><span class="line">           Slog.w(TAG, &quot;Failed delivering service starts&quot;, e);</span><br><span class="line">           caughtException = e;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Unexpected exception&quot;, e);</span><br><span class="line">           caughtException = e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (caughtException != null) &#123;</span><br><span class="line">           // Keep nesting count correct</span><br><span class="line">           final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">           for (int i = 0; i &lt; args.size(); i++) &#123;</span><br><span class="line">               serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">           &#125;</span><br><span class="line">           if (caughtException instanceof TransactionTooLargeException) &#123;</span><br><span class="line">               throw (TransactionTooLargeException)caughtException;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>realStartServiceLocked先后执行的方法如下：</p>
<p>执行scheduleCreateService方法，通过层层回调到Service.onCreate;</p>
<p>执行scheduleServiceArgs方法，通过层层回调到Service.onStartCommand，流程同onCreate.</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>整个startService过程，从进程角度来看服务启动的过程</p>
<p>process A进程：是指调用startService方法所在的进程，也就是启动服务的发起端进程，如：桌面上点击图标，此处Process A就是Launcher所在的进程。</p>
<p>system_server进程：里面运行着大量的系统服务，如AMS,是运行在system_server不同的线程中，基于Binder接口，binder线程的创建与销毁都是由Binder驱动来决定的，每个进程的binder线程个数上线为16</p>
<p>Zygote进程：是由init进程孵化而来，用于创建java层进程的母体，所有的java层进程都是由Zygote进程孵化而来。</p>
<p>Remote Service进程：远程服务所在的进程，是由zygote进程孵化而来，用于运行Remote服务进程。主线程主要是负责Activity/Service等组件的生命周期以及UI相关的操作；另外，每个app进程至少会有两个binder线程，ApplicationThread和ActivityManagerService的代理。</p>
<p>上面涉及到IPC通信的三种方式，Binder、Socket、Handler。一般来说，同一进程内的线程间通信采用Handler消息队列机制，不同进程间的通信采用Binder机制，另外与Zygote通信采用Socket。</p>
<p>启动流程：</p>
<p>1.Process A进程采用Binder IPC向system_server进程发起startService请求</p>
<p>2.system_server进程接收到请求后，向zygote进程发送创建进程的请求</p>
<p>3.zygote进程fork出新的子进程Remote Service进程</p>
<p>4.RemoteService进程通过Binder IPC向system_server进程发起attachApplication请求</p>
<p>5.system_server进程收到请求后，进行一序列准备工作后，再通过Binder IPC向remote sevice进程发送scheduleCreateService请求</p>
<p>6.Remote Service进程的binder线程收到请求后，通过handler向主线程发送CREATE_SERVICE消息</p>
<p>7.主线程收到消息后，通过反射机制创建目标Service，并回调Service.onCreate方法。</p>
<p>到此，服务就正式启动了。当创建的是本地服务或者服务所属进程已经创建，则无需经过步骤2,3直接创建服务即可。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>源码路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/IActivityManager.aidl</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span><br><span class="line">frameworks/base/core/java/android/app/IApplicationThread.aidl</span><br></pre></td></tr></table></figure>

      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Service/" rel="tag">#Service</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/startActivity启动过程/" rel="next" title="startActivity启动过程">
                <i class="fa fa-chevron-left"></i> startActivity启动过程
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/ContentProvider原理分析/" rel="prev" title="ContentProvider原理分析">
                ContentProvider原理分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description"><br>现居深圳、毕业于电子科技大学 <br> 技术领域：Android、AI <br><br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、启动服务进程端"><span class="nav-text">二、启动服务进程端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-CW-startService"><span class="nav-text">1. CW.startService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Cl-startService"><span class="nav-text">2. Cl.startService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-CI-startServiceCommon"><span class="nav-text">3.  CI.startServiceCommon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-AM-getService"><span class="nav-text">4. AM.getService</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、SystemServer端"><span class="nav-text">三、SystemServer端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-AMS-startService"><span class="nav-text">5.  AMS.startService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-AS-startServiceLocked"><span class="nav-text">6.  AS.startServiceLocked</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-AMS-getAppStartModeLocked"><span class="nav-text">6.1 AMS.getAppStartModeLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-AMS-appServicesRestrictedInBackgroundLocked"><span class="nav-text">6.2 AMS.appServicesRestrictedInBackgroundLocked</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-AS-startServiceInnerLocked"><span class="nav-text">7. AS.startServiceInnerLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-AS-bringUpServiceLocked"><span class="nav-text">8.AS.bringUpServiceLocked</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-AMS-attachApplicationLocked"><span class="nav-text">8.1 AMS.attachApplicationLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-AS-attachApplicationLocked"><span class="nav-text">8.2 AS.attachApplicationLocked</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-AS-realStartServiceLocked"><span class="nav-text">9.AS.realStartServiceLocked</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-AS-bumpServiceExecutingLocked"><span class="nav-text">9.1 AS.bumpServiceExecutingLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-AS-scheduleServiceTimeoutLocked"><span class="nav-text">9.2 AS.scheduleServiceTimeoutLocked</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、目标进程端"><span class="nav-text">四、目标进程端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-AT-scheduleCreateService"><span class="nav-text">10.AT.scheduleCreateService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-AT-handleMessage"><span class="nav-text">10.1 AT.handleMessage</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-AT-handleCreateService"><span class="nav-text">11.AT.handleCreateService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-Service-onCreate"><span class="nav-text">11.1 Service.onCreate</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-AMS-serviceDoneExecuting"><span class="nav-text">12.AMS.serviceDoneExecuting</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-AS-serviceDoneExecutingLocked"><span class="nav-text">12.1 AS.serviceDoneExecutingLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-AS-serviceDoneExecutingLocked"><span class="nav-text">12.2 AS.serviceDoneExecutingLocked</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-AS-sendServiceArgsLocked"><span class="nav-text">13.AS.sendServiceArgsLocked</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、总结"><span class="nav-text">五、总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2019/startService启动过程/';
      var disqus_title = "startServie启动过程";
      var disqus_url = 'http://zproo.github.io/2019/startService启动过程/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
