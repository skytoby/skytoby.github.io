<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Activity,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="基于Android10.0，分析startActivity的启动过程  一、概述startActivity的整体流程和startService相近，启动后都是通过AMS来完成的。但相比service启动更加复杂，多了任务栈、UI、生命周期。其启动流程如下：  二、启动流程启动Activity，一般是用startActivity。 2.1 Activity.startActivity[-&amp;gt;A">
<meta name="keywords" content="Activity">
<meta property="og:type" content="article">
<meta property="og:title" content="startActivity启动过程">
<meta property="og:url" content="http://zproo.github.io/2019/startActivity启动过程/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="基于Android10.0，分析startActivity的启动过程  一、概述startActivity的整体流程和startService相近，启动后都是通过AMS来完成的。但相比service启动更加复杂，多了任务栈、UI、生命周期。其启动流程如下：  二、启动流程启动Activity，一般是用startActivity。 2.1 Activity.startActivity[-&amp;gt;A">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2019/startActivity启动过程/startActivity.jpg">
<meta property="og:updated_time" content="2019-12-29T14:07:24.298Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="startActivity启动过程">
<meta name="twitter:description" content="基于Android10.0，分析startActivity的启动过程  一、概述startActivity的整体流程和startService相近，启动后都是通过AMS来完成的。但相比service启动更加复杂，多了任务栈、UI、生命周期。其启动流程如下：  二、启动流程启动Activity，一般是用startActivity。 2.1 Activity.startActivity[-&amp;gt;A">
<meta name="twitter:image" content="http://zproo.github.io/2019/startActivity启动过程/startActivity.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2019/startActivity启动过程/">

  <title> startActivity启动过程 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/Activity/" rel="tag" title="Activity">Activity</a>
      
      </div>
      <h1>startActivity启动过程</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2019-08-15T22:18:23+08:00" content="2019-08-15" title="2019-08-15 22:18:23">
          2019-08-15
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                startActivity启动过程
              
            
          </h1>
        

        <div class="post-meta">
		  

          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-08-15T22:18:23+08:00" content="2019-08-15">
              2019-08-15
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/startActivity启动过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/startActivity启动过程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>基于Android10.0，分析startActivity的启动过程</p>
</blockquote>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>startActivity的整体流程和startService相近，启动后都是通过AMS来完成的。但相比service启动更加复杂，多了任务栈、UI、生命周期。其启动流程如下：</p>
<p><img src="/2019/startActivity启动过程/startActivity.jpg" alt="startActivity"></p>
<h2 id="二、启动流程"><a href="#二、启动流程" class="headerlink" title="二、启动流程"></a>二、启动流程</h2><p>启动Activity，一般是用startActivity。</p>
<h3 id="2-1-Activity-startActivity"><a href="#2-1-Activity-startActivity" class="headerlink" title="2.1 Activity.startActivity"></a>2.1 Activity.startActivity</h3><p>[-&gt;Activity.java]</p>
<pre><code>@Override
 public void startActivity(Intent intent) {
     this.startActivity(intent, null);
 }
  @Override
 public void startActivity(Intent intent, @Nullable Bundle options) {
     if (options != null) {
         startActivityForResult(intent, -1, options);
     } else {
         // Note we want to go through this call for compatibility with
         // applications that may have overridden the method.
         startActivityForResult(intent, -1);
     }
 }
</code></pre><h3 id="2-2-startActivityForResult"><a href="#2-2-startActivityForResult" class="headerlink" title="2.2  startActivityForResult"></a>2.2  startActivityForResult</h3><p>[-&gt;ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * @hide</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  @UnsupportedAppUsage</span><br><span class="line">  public void startActivityForResult(</span><br><span class="line">          String who, Intent intent, int requestCode, @Nullable Bundle options) &#123;</span><br><span class="line">      Uri referrer = onProvideReferrer();</span><br><span class="line">      if (referrer != null) &#123;</span><br><span class="line">          intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">      &#125;</span><br><span class="line">      options = transferSpringboardActivityOptions(options);</span><br><span class="line">      Instrumentation.ActivityResult ar =</span><br><span class="line">          mInstrumentation.execStartActivity(</span><br><span class="line">              this, mMainThread.getApplicationThread(), mToken, who,</span><br><span class="line">              intent, requestCode, options);</span><br><span class="line">      if (ar != null) &#123;</span><br><span class="line">          mMainThread.sendActivityResult(</span><br><span class="line">              mToken, who, requestCode,</span><br><span class="line">              ar.getResultCode(), ar.getResultData());</span><br><span class="line">      &#125;</span><br><span class="line">      cancelInputsAndStartExitTransition(options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>execStartActivity方法参数：</p>
<p>mAppThread:类型为ApplicationThread,通过mMainThread.getApplicationThread()获取。</p>
<p>mToken：为Binder类型</p>
<h3 id="2-3-execStartActivity"><a href="#2-3-execStartActivity" class="headerlink" title="2.3  execStartActivity"></a>2.3  execStartActivity</h3><p>[-&gt;Instrumentation.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">      Context who, IBinder contextThread, IBinder token, String target,</span><br><span class="line">      Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">      IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">      if (mActivityMonitors != null) &#123;</span><br><span class="line">          synchronized (mSync) &#123;</span><br><span class="line">              final int N = mActivityMonitors.size();</span><br><span class="line">              for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                  final ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                  ActivityResult result = null;</span><br><span class="line">                  if (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                      result = am.onStartActivity(intent);</span><br><span class="line">                  &#125;</span><br><span class="line">                  if (result != null) &#123;</span><br><span class="line">                      am.mHits++;</span><br><span class="line">                      return result;</span><br><span class="line">                  &#125; else if (am.match(who, null, intent)) &#123;</span><br><span class="line">                      am.mHits++;</span><br><span class="line">                      //如果am阻塞activity启动，则返回</span><br><span class="line">                      if (am.isBlocking()) &#123;</span><br><span class="line">                          return requestCode &gt;= 0 ? am.getResult() : null;</span><br><span class="line">                      &#125;</span><br><span class="line">                      break;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">          intent.migrateExtraStreamToClipData();</span><br><span class="line">          intent.prepareToLeaveProcess(who);</span><br><span class="line">          int result = ActivityManager.getService()</span><br><span class="line">              .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                      intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                      token, target, requestCode, 0, null, options);</span><br><span class="line">          checkStartActivityResult(result, intent);</span><br><span class="line">      &#125; catch (RemoteException e) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-AM-getService"><a href="#2-3-1-AM-getService" class="headerlink" title="2.3.1  AM.getService"></a>2.3.1  AM.getService</h4><p>和Android6.0不同的是Android10.0直接通过AIDL的方式生成了AMS的代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * @hide</span><br><span class="line">    */</span><br><span class="line">   @UnsupportedAppUsage</span><br><span class="line">   public static IActivityManager getService() &#123;</span><br><span class="line">       return IActivityManagerSingleton.get();</span><br><span class="line">   &#125;</span><br><span class="line">   public abstract class Singleton&lt;T&gt; &#123;</span><br><span class="line">   @UnsupportedAppUsage</span><br><span class="line">   private T mInstance;</span><br><span class="line"></span><br><span class="line">   protected abstract T create();</span><br><span class="line"></span><br><span class="line">   @UnsupportedAppUsage</span><br><span class="line">   public final T get() &#123;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           if (mInstance == null) &#123;</span><br><span class="line">               mInstance = create();</span><br><span class="line">           &#125;</span><br><span class="line">           return mInstance;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;  </span><br><span class="line">   @UnsupportedAppUsage</span><br><span class="line">   private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">           new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               protected IActivityManager create() &#123;</span><br><span class="line">                   final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                   //获取AMS的代理</span><br><span class="line">                   final IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                   return am;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-IActivityManager-startActivity"><a href="#2-4-IActivityManager-startActivity" class="headerlink" title="2.4  IActivityManager.startActivity"></a>2.4  IActivityManager.startActivity</h3><p>通过AIDL生成的代理类调用AMS的startActivity，其代理类在编译的时候，会自动生成。</p>
<p>startActivity共有10个参数，参数对应值如下：</p>
<ul>
<li>caller：当前应用的Application对象mAppThread</li>
<li>callingPackage:当前Activity所在的包名</li>
<li>intent：启动Activity传过来的参数</li>
<li>resolvedType：调用intent.resolveTypeIfNeeded获取 </li>
<li>resultTo：来自当前Activity.mToken</li>
<li>resultWho：  来自当前Activity.mEmbeddedID</li>
<li>requestCode:-1</li>
<li>startFlags:0</li>
<li>profilerInfo：null</li>
<li>bOptions:null</li>
</ul>
<h3 id="2-5-AMS-startActivity"><a href="#2-5-AMS-startActivity" class="headerlink" title="2.5 AMS.startActivity"></a>2.5 AMS.startActivity</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">         Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">         int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;</span><br><span class="line">     return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">             resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">             UserHandle.getCallingUserId());</span><br><span class="line"> &#125;</span><br><span class="line">  @Override</span><br><span class="line"> public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">         Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">         int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123;</span><br><span class="line">     return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">             resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,</span><br><span class="line">             true /*validateIncomingUser*/);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-AMS-startActivityAsUser"><a href="#2-6-AMS-startActivityAsUser" class="headerlink" title="2.6 AMS.startActivityAsUser"></a>2.6 AMS.startActivityAsUser</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">           Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">           int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,</span><br><span class="line">           boolean validateIncomingUser) &#123;</span><br><span class="line">       enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line"></span><br><span class="line">       userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">               Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;);</span><br><span class="line"></span><br><span class="line">       // TODO: Switch to user app stacks here.</span><br><span class="line">       return mActivityStartController.obtainStarter(intent, &quot;startActivityAsUser&quot;)</span><br><span class="line">               .setCaller(caller)</span><br><span class="line">               .setCallingPackage(callingPackage)</span><br><span class="line">               .setResolvedType(resolvedType)</span><br><span class="line">               .setResultTo(resultTo)</span><br><span class="line">               .setResultWho(resultWho)</span><br><span class="line">               .setRequestCode(requestCode)</span><br><span class="line">               .setStartFlags(startFlags)</span><br><span class="line">               .setProfilerInfo(profilerInfo)</span><br><span class="line">               .setActivityOptions(bOptions)</span><br><span class="line">               .setMayWait(userId)</span><br><span class="line">               .execute();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过建造者模式，来设置参数，其参数在2.4节有介绍，通过execute方法最后执行。</p>
<h4 id="2-6-1-ASC-obtainStarter"><a href="#2-6-1-ASC-obtainStarter" class="headerlink" title="2.6.1  ASC.obtainStarter"></a>2.6.1  ASC.obtainStarter</h4><p>[-&gt;ActivityStartController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * @return A starter to configure and execute starting an activity. It is valid until after</span><br><span class="line">    *         &#123;@link ActivityStarter#execute&#125; is invoked. At that point, the starter should be</span><br><span class="line">    *         considered invalid and no longer modified or used.</span><br><span class="line">    */</span><br><span class="line">   ActivityStarter obtainStarter(Intent intent, String reason) &#123;</span><br><span class="line">       return mFactory.obtain().setIntent(intent).setReason(reason);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-2-AS-setMayWait"><a href="#2-6-2-AS-setMayWait" class="headerlink" title="2.6.2  AS.setMayWait"></a>2.6.2  AS.setMayWait</h4><p>这个方法在2.6.3节中用到，可以看到这里将mRequest.mayWait设置为true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityStarter setMayWait(int userId) &#123;</span><br><span class="line">     mRequest.mayWait = true;</span><br><span class="line">     mRequest.userId = userId;</span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-3-AS-execute"><a href="#2-6-3-AS-execute" class="headerlink" title="2.6.3  AS.execute"></a>2.6.3  AS.execute</h4><p>[-&gt;ActivityStarter.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Starts an activity based on the request parameters provided earlier.</span><br><span class="line">    * @return The starter result.</span><br><span class="line">    */</span><br><span class="line">   int execute() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           // TODO(b/64750076): Look into passing request directly to these methods to allow</span><br><span class="line">           // for transactional diffs and preprocessing.</span><br><span class="line">           //经过该方法，前面已经设置为true</span><br><span class="line">           if (mRequest.mayWait) &#123;</span><br><span class="line">               return startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                       mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                       mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                       mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                       mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                       mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                       mRequest.inTask, mRequest.reason,</span><br><span class="line">                       mRequest.allowPendingRemoteAnimationRegistryLookup,</span><br><span class="line">                       mRequest.originatingPendingIntent);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                       mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                       mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                       mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                       mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                       mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                       mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                       mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                       mRequest.allowPendingRemoteAnimationRegistryLookup,</span><br><span class="line">                       mRequest.originatingPendingIntent);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           onExecutionComplete();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-AS-startActivityMayWait"><a href="#2-7-AS-startActivityMayWait" class="headerlink" title="2.7  AS.startActivityMayWait"></a>2.7  AS.startActivityMayWait</h3><p>这个方法的参数有21个，具体重要的几个参数2.4节已经介绍过, inTask =  null。</p>
<p>[-&gt;ActivityStarter.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line">private int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">           String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">           IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">           ProfilerInfo profilerInfo, WaitResult outResult,</span><br><span class="line">           Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity,</span><br><span class="line">           int userId, TaskRecord inTask, String reason,</span><br><span class="line">           boolean allowPendingRemoteAnimationRegistryLookup,</span><br><span class="line">           PendingIntentRecord originatingPendingIntent) &#123;</span><br><span class="line">       // Refuse possible leaked file descriptors</span><br><span class="line">       if (intent != null &amp;&amp; intent.hasFileDescriptors()) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //activity开始启动日志</span><br><span class="line">       mSupervisor.getActivityMetricsLogger().notifyActivityLaunching();</span><br><span class="line">       boolean componentSpecified = intent.getComponent() != null;</span><br><span class="line"></span><br><span class="line">       final int realCallingPid = Binder.getCallingPid();</span><br><span class="line">       final int realCallingUid = Binder.getCallingUid();</span><br><span class="line"></span><br><span class="line">       int callingPid;</span><br><span class="line">       if (callingUid &gt;= 0) &#123;</span><br><span class="line">           callingPid = -1;</span><br><span class="line">       &#125; else if (caller == null) &#123;</span><br><span class="line">           callingPid = realCallingPid;</span><br><span class="line">           callingUid = realCallingUid;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           callingPid = callingUid = -1;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Save a copy in case ephemeral needs it</span><br><span class="line">       final Intent ephemeralIntent = new Intent(intent);</span><br><span class="line">       // Don&apos;t modify the client&apos;s object!</span><br><span class="line">       intent = new Intent(intent);</span><br><span class="line">       //对一些特殊的intent做处理</span><br><span class="line">       if (componentSpecified</span><br><span class="line">               &amp;&amp; !(Intent.ACTION_VIEW.equals(intent.getAction()) &amp;&amp; intent.getData() == null)</span><br><span class="line">               &amp;&amp; !Intent.ACTION_INSTALL_INSTANT_APP_PACKAGE.equals(intent.getAction())</span><br><span class="line">               &amp;&amp; !Intent.ACTION_RESOLVE_INSTANT_APP_PACKAGE.equals(intent.getAction())</span><br><span class="line">               &amp;&amp; mService.getPackageManagerInternalLocked()</span><br><span class="line">                       .isInstantAppInstallerComponent(intent.getComponent())) &#123;</span><br><span class="line">           // intercept intents targeted directly to the ephemeral installer the</span><br><span class="line">           // ephemeral installer should never be started with a raw Intent; instead</span><br><span class="line">           // adjust the intent so it looks like a &quot;normal&quot; instant app launch</span><br><span class="line">           intent.setComponent(null /*component*/);</span><br><span class="line">           componentSpecified = false;</span><br><span class="line">       &#125;</span><br><span class="line">       //处理intent信息，当存在多个activity时，弹出resolverAcitvity</span><br><span class="line">       ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,</span><br><span class="line">               0 /* matchFlags */,</span><br><span class="line">                       computeResolveFilterUid(</span><br><span class="line">                               callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">       if (rInfo == null) &#123;</span><br><span class="line">           UserInfo userInfo = mSupervisor.getUserInfo(userId);</span><br><span class="line">           if (userInfo != null &amp;&amp; userInfo.isManagedProfile()) &#123;</span><br><span class="line">               // Special case for managed profiles, if attempting to launch non-cryto aware</span><br><span class="line">               // app in a locked managed profile from an unlocked parent allow it to resolve</span><br><span class="line">               // as user will be sent via confirm credentials to unlock the profile.</span><br><span class="line">               UserManager userManager = UserManager.get(mService.mContext);</span><br><span class="line">               boolean profileLockedAndParentUnlockingOrUnlocked = false;</span><br><span class="line">               long token = Binder.clearCallingIdentity();</span><br><span class="line">               try &#123;</span><br><span class="line">                   UserInfo parent = userManager.getProfileParent(userId);</span><br><span class="line">                   profileLockedAndParentUnlockingOrUnlocked = (parent != null)</span><br><span class="line">                           &amp;&amp; userManager.isUserUnlockingOrUnlocked(parent.id)</span><br><span class="line">                           &amp;&amp; !userManager.isUserUnlockingOrUnlocked(userId);</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   Binder.restoreCallingIdentity(token);</span><br><span class="line">               &#125;</span><br><span class="line">               if (profileLockedAndParentUnlockingOrUnlocked) &#123;</span><br><span class="line">                   rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,</span><br><span class="line">                           PackageManager.MATCH_DIRECT_BOOT_AWARE</span><br><span class="line">                                   | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,</span><br><span class="line">                           computeResolveFilterUid(</span><br><span class="line">                                   callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //收集intent所指向的activity信息</span><br><span class="line">       // Collect information about the target of the Intent.</span><br><span class="line">       ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line"></span><br><span class="line">       synchronized (mService) &#123;</span><br><span class="line">           final ActivityStack stack = mSupervisor.mFocusedStack;</span><br><span class="line">           stack.mConfigWillChange = globalConfig != null</span><br><span class="line">                   &amp;&amp; mService.getGlobalConfiguration().diff(globalConfig) != 0;</span><br><span class="line">           if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,</span><br><span class="line">                   &quot;Starting activity when config will change = &quot; + stack.mConfigWillChange);</span><br><span class="line"></span><br><span class="line">           final long origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">           if (aInfo != null &amp;&amp;</span><br><span class="line">                   (aInfo.applicationInfo.privateFlags</span><br><span class="line">                           &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0 &amp;&amp;</span><br><span class="line">                   mService.mHasHeavyWeightFeature) &#123;</span><br><span class="line">               //heavy-weight进程处理流程</span><br><span class="line">               // This may be a heavy-weight process!  Check to see if we already</span><br><span class="line">               // have another, different heavy-weight process running.</span><br><span class="line">               if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) &#123;</span><br><span class="line">                   final ProcessRecord heavy = mService.mHeavyWeightProcess;</span><br><span class="line">                   if (heavy != null &amp;&amp; (heavy.info.uid != aInfo.applicationInfo.uid</span><br><span class="line">                           || !heavy.processName.equals(aInfo.processName))) &#123;</span><br><span class="line">                       int appCallingUid = callingUid;</span><br><span class="line">                       if (caller != null) &#123;</span><br><span class="line">                           ProcessRecord callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">                           if (callerApp != null) &#123;</span><br><span class="line">                               appCallingUid = callerApp.info.uid;</span><br><span class="line">                           &#125; else &#123;</span><br><span class="line">                               Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                                       + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;</span><br><span class="line">                                       + intent.toString());</span><br><span class="line">                               SafeActivityOptions.abort(options);</span><br><span class="line">                               return ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       IIntentSender target = mService.getIntentSenderLocked(</span><br><span class="line">                               ActivityManager.INTENT_SENDER_ACTIVITY, &quot;android&quot;,</span><br><span class="line">                               appCallingUid, userId, null, null, 0, new Intent[] &#123; intent &#125;,</span><br><span class="line">                               new String[] &#123; resolvedType &#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                                       | PendingIntent.FLAG_ONE_SHOT, null);</span><br><span class="line"></span><br><span class="line">                       Intent newIntent = new Intent();</span><br><span class="line">                       if (requestCode &gt;= 0) &#123;</span><br><span class="line">                           // Caller is requesting a result.</span><br><span class="line">                           newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, true);</span><br><span class="line">                       &#125;</span><br><span class="line">                       newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,</span><br><span class="line">                               new IntentSender(target));</span><br><span class="line">                       if (heavy.activities.size() &gt; 0) &#123;</span><br><span class="line">                           ActivityRecord hist = heavy.activities.get(0);</span><br><span class="line">                           newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,</span><br><span class="line">                                   hist.packageName);</span><br><span class="line">                           newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,</span><br><span class="line">                                   hist.getTask().taskId);</span><br><span class="line">                       &#125;</span><br><span class="line">                       newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,</span><br><span class="line">                               aInfo.packageName);</span><br><span class="line">                       newIntent.setFlags(intent.getFlags());</span><br><span class="line">                       newIntent.setClassName(&quot;android&quot;,</span><br><span class="line">                               HeavyWeightSwitcherActivity.class.getName());</span><br><span class="line">                       intent = newIntent;</span><br><span class="line">                       resolvedType = null;</span><br><span class="line">                       caller = null;</span><br><span class="line">                       callingUid = Binder.getCallingUid();</span><br><span class="line">                       callingPid = Binder.getCallingPid();</span><br><span class="line">                       componentSpecified = true;</span><br><span class="line">                       rInfo = mSupervisor.resolveIntent(intent, null /*resolvedType*/, userId,</span><br><span class="line">                               0 /* matchFlags */, computeResolveFilterUid(</span><br><span class="line">                                       callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">                       aInfo = rInfo != null ? rInfo.activityInfo : null;</span><br><span class="line">                       if (aInfo != null) &#123;</span><br><span class="line">                           aInfo = mService.getActivityInfoForUser(aInfo, userId);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           final ActivityRecord[] outRecord = new ActivityRecord[1];</span><br><span class="line">           //见2.8节</span><br><span class="line">           int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                   voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                   callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                   ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                   allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent);</span><br><span class="line"></span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">           if (stack.mConfigWillChange) &#123;</span><br><span class="line">               // If the caller also wants to switch to a new configuration,</span><br><span class="line">               // do so now.  This allows a clean switch, as we are waiting</span><br><span class="line">               // for the current activity to pause (so we will not destroy</span><br><span class="line">               // it), and have not yet started the next activity.</span><br><span class="line">               mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,</span><br><span class="line">                       &quot;updateConfiguration()&quot;);</span><br><span class="line">               stack.mConfigWillChange = false;</span><br><span class="line">               if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,</span><br><span class="line">                       &quot;Updating to new configuration after starting activity.&quot;);</span><br><span class="line">               mService.updateConfigurationLocked(globalConfig, null, false);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Notify ActivityMetricsLogger that the activity has launched. ActivityMetricsLogger</span><br><span class="line">           // will then wait for the windows to be drawn and populate WaitResult.</span><br><span class="line">           mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(res, outRecord[0]);</span><br><span class="line">           if (outResult != null) &#123;</span><br><span class="line">               outResult.result = res;</span><br><span class="line"></span><br><span class="line">               final ActivityRecord r = outRecord[0];</span><br><span class="line"></span><br><span class="line">               switch(res) &#123;</span><br><span class="line">                   case START_SUCCESS: &#123;</span><br><span class="line">                       mSupervisor.mWaitingActivityLaunched.add(outResult);</span><br><span class="line">                       do &#123;</span><br><span class="line">                           try &#123;</span><br><span class="line">                               mService.wait();</span><br><span class="line">                           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; while (outResult.result != START_TASK_TO_FRONT</span><br><span class="line">                               &amp;&amp; !outResult.timeout &amp;&amp; outResult.who == null);</span><br><span class="line">                       if (outResult.result == START_TASK_TO_FRONT) &#123;</span><br><span class="line">                           res = START_TASK_TO_FRONT;</span><br><span class="line">                       &#125;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   case START_DELIVERED_TO_TOP: &#123;</span><br><span class="line">                       outResult.timeout = false;</span><br><span class="line">                       outResult.who = r.realActivity;</span><br><span class="line">                       outResult.totalTime = 0;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   case START_TASK_TO_FRONT: &#123;</span><br><span class="line">                       // ActivityRecord may represent a different activity, but it should not be</span><br><span class="line">                       // in the resumed state.</span><br><span class="line">                       if (r.nowVisible &amp;&amp; r.isState(RESUMED)) &#123;</span><br><span class="line">                           outResult.timeout = false;</span><br><span class="line">                           outResult.who = r.realActivity;</span><br><span class="line">                           outResult.totalTime = 0;</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           final long startTimeMs = SystemClock.uptimeMillis();</span><br><span class="line">                           mSupervisor.waitActivityVisible(r.realActivity, outResult, startTimeMs);</span><br><span class="line">                           // Note: the timeout variable is not currently not ever set.</span><br><span class="line">                           do &#123;</span><br><span class="line">                               try &#123;</span><br><span class="line">                                   mService.wait();</span><br><span class="line">                               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; while (!outResult.timeout &amp;&amp; outResult.who == null);</span><br><span class="line">                       &#125;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-1-PKMS-resolveIntent"><a href="#2-7-1-PKMS-resolveIntent" class="headerlink" title="2.7.1 PKMS.resolveIntent"></a>2.7.1 PKMS.resolveIntent</h4><p>[-&gt;PackageManagerService.java]</p>
<p>mSupervisor.resolveInten经过层层调用，通过IPC最后会调用PKMS对象中的resolveIntent。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Normally instant apps can only be resolved when they&apos;re visible to the caller.</span><br><span class="line">    * However, if &#123;@code resolveForStart&#125; is &#123;@code true&#125;, all instant apps are visible</span><br><span class="line">    * since we need to allow the system to start any installed application.</span><br><span class="line">    */</span><br><span class="line">   private ResolveInfo resolveIntentInternal(Intent intent, String resolvedType,</span><br><span class="line">           int flags, int userId, boolean resolveForStart, int filterCallingUid) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;resolveIntent&quot;);</span><br><span class="line"></span><br><span class="line">           if (!sUserManager.exists(userId)) return null;</span><br><span class="line">           final int callingUid = Binder.getCallingUid();</span><br><span class="line">           flags = updateFlagsForResolve(flags, userId, intent, filterCallingUid, resolveForStart);</span><br><span class="line">           mPermissionManager.enforceCrossUserPermission(callingUid, userId,</span><br><span class="line">                   false /*requireFullPermission*/, false /*checkShell*/, &quot;resolve intent&quot;);</span><br><span class="line"></span><br><span class="line">           Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;queryIntentActivities&quot;);</span><br><span class="line">           //找到相应的activity组件，并保存intent对象</span><br><span class="line">           final List&lt;ResolveInfo&gt; query = queryIntentActivitiesInternal(intent, resolvedType,</span><br><span class="line">                   flags, filterCallingUid, userId, resolveForStart, true /*allowDynamicSplits*/);</span><br><span class="line">           Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">           //根据priority选择最佳的activity</span><br><span class="line">           final ResolveInfo bestChoice =</span><br><span class="line">                   chooseBestActivity(intent, resolvedType, flags, query, userId);</span><br><span class="line">           return bestChoice;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-2-ASS-resolveActivity"><a href="#2-7-2-ASS-resolveActivity" class="headerlink" title="2.7.2 ASS.resolveActivity"></a>2.7.2 ASS.resolveActivity</h4><p>[-&gt;ActivityStackSupervisor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ActivityInfo resolveActivity(Intent intent, ResolveInfo rInfo, int startFlags,</span><br><span class="line">           ProfilerInfo profilerInfo) &#123;</span><br><span class="line">       final ActivityInfo aInfo = rInfo != null ? rInfo.activityInfo : null;</span><br><span class="line">       if (aInfo != null) &#123;</span><br><span class="line">           // Store the found target back into the intent, because now that</span><br><span class="line">           // we have it we never want to do this again.  For example, if the</span><br><span class="line">           // user navigates back to this point in the history, we should</span><br><span class="line">           // always restart the exact same activity.</span><br><span class="line">           intent.setComponent(new ComponentName(</span><br><span class="line">                   aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line"></span><br><span class="line">           // Don&apos;t debug things in the system process</span><br><span class="line">           if (!aInfo.processName.equals(&quot;system&quot;)) &#123;</span><br><span class="line">               if ((startFlags &amp; ActivityManager.START_FLAG_DEBUG) != 0) &#123;</span><br><span class="line">                   mService.setDebugApp(aInfo.processName, true, false);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if ((startFlags &amp; ActivityManager.START_FLAG_NATIVE_DEBUGGING) != 0) &#123;</span><br><span class="line">                   mService.setNativeDebuggingAppLocked(aInfo.applicationInfo, aInfo.processName);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if ((startFlags &amp; ActivityManager.START_FLAG_TRACK_ALLOCATION) != 0) &#123;</span><br><span class="line">                   mService.setTrackAllocationApp(aInfo.applicationInfo, aInfo.processName);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (profilerInfo != null) &#123;</span><br><span class="line">                   mService.setProfileApp(aInfo.applicationInfo, aInfo.processName, profilerInfo);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           final String intentLaunchToken = intent.getLaunchToken();</span><br><span class="line">           if (aInfo.launchToken == null &amp;&amp; intentLaunchToken != null) &#123;</span><br><span class="line">               aInfo.launchToken = intentLaunchToken;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return aInfo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Activity类有3个flags用于调试</p>
<ul>
<li>START_FLAG_DEBUG：用于调试debug app</li>
<li>START_FLAG_NATIVE_DEBUGGING：用于调试native</li>
<li>START_FLAG_TRACK_ALLOCATION：用于调试allocation tracking</li>
</ul>
<h3 id="2-8-AS-startActivity"><a href="#2-8-AS-startActivity" class="headerlink" title="2.8  AS.startActivity"></a>2.8  AS.startActivity</h3><p>[-&gt;ActivityStarter.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">          String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">          IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">          IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">          String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">          SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">          ActivityRecord[] outActivity, TaskRecord inTask, String reason,</span><br><span class="line">          boolean allowPendingRemoteAnimationRegistryLookup,</span><br><span class="line">          PendingIntentRecord originatingPendingIntent) &#123;</span><br><span class="line"></span><br><span class="line">      if (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;Need to specify a reason.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      mLastStartReason = reason;</span><br><span class="line">      mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">      mLastStartActivityRecord[0] = null;</span><br><span class="line"></span><br><span class="line">      mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">              aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">              callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">              options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">              inTask, allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent);</span><br><span class="line"></span><br><span class="line">      if (outActivity != null) &#123;</span><br><span class="line">          // mLastStartActivityRecord[0] is set in the call to startActivity above.</span><br><span class="line">          outActivity[0] = mLastStartActivityRecord[0];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return getExternalResult(mLastStartActivityResult);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面才正式进入startActivity具体内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">           String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">           IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">           String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">           SafeActivityOptions options,</span><br><span class="line">           boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">           TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup,</span><br><span class="line">           PendingIntentRecord originatingPendingIntent) &#123;</span><br><span class="line">       int err = ActivityManager.START_SUCCESS;</span><br><span class="line">       // Pull the optional Ephemeral Installer-only bundle out of the options early.</span><br><span class="line">       final Bundle verificationBundle</span><br><span class="line">               = options != null ? options.popAppVerificationBundle() : null;</span><br><span class="line">       //获取调用者的进程记录对象</span><br><span class="line">       ProcessRecord callerApp = null;</span><br><span class="line">       if (caller != null) &#123;</span><br><span class="line">           callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">           if (callerApp != null) &#123;</span><br><span class="line">               callingPid = callerApp.pid;</span><br><span class="line">               callingUid = callerApp.info.uid;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                       + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;</span><br><span class="line">                       + intent.toString());</span><br><span class="line">               err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final int userId = aInfo != null &amp;&amp; aInfo.applicationInfo != null</span><br><span class="line">               ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;</span><br><span class="line"></span><br><span class="line">       if (err == ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">           Slog.i(TAG, &quot;START u&quot; + userId + &quot; &#123;&quot; + intent.toShortString(true, true, true, false)</span><br><span class="line">                   + &quot;&#125; from uid &quot; + callingUid);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //获取调用者所在的activity</span><br><span class="line">       ActivityRecord sourceRecord = null;</span><br><span class="line">       ActivityRecord resultRecord = null;</span><br><span class="line">       if (resultTo != null) &#123;</span><br><span class="line">           sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">           if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                   &quot;Will send result to &quot; + resultTo + &quot; &quot; + sourceRecord);</span><br><span class="line">           if (sourceRecord != null) &#123;</span><br><span class="line">               //requestCode = -1 不会进入</span><br><span class="line">               if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                   resultRecord = sourceRecord;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final int launchFlags = intent.getFlags();</span><br><span class="line"></span><br><span class="line">       if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123;</span><br><span class="line">           //activity执行结果的返回由源activity切换到新activity，不需要返回结果则不会进该分支  </span><br><span class="line">           // Transfer the result target from the source activity to the new</span><br><span class="line">           // one being started, including any failures.</span><br><span class="line">           if (requestCode &gt;= 0) &#123;</span><br><span class="line">               SafeActivityOptions.abort(options);</span><br><span class="line">               return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;</span><br><span class="line">           &#125;</span><br><span class="line">           resultRecord = sourceRecord.resultTo;</span><br><span class="line">           if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) &#123;</span><br><span class="line">               resultRecord = null;</span><br><span class="line">           &#125;</span><br><span class="line">           resultWho = sourceRecord.resultWho;</span><br><span class="line">           requestCode = sourceRecord.requestCode;</span><br><span class="line">           sourceRecord.resultTo = null;</span><br><span class="line">           if (resultRecord != null) &#123;</span><br><span class="line">               resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);</span><br><span class="line">           &#125;</span><br><span class="line">           if (sourceRecord.launchedFromUid == callingUid) &#123;</span><br><span class="line">               // The new activity is being launched from the same uid as the previous</span><br><span class="line">               // activity in the flow, and asking to forward its result back to the</span><br><span class="line">               // previous.  In this case the activity is serving as a trampoline between</span><br><span class="line">               // the two, so we also want to update its launchedFromPackage to be the</span><br><span class="line">               // same as the previous activity.  Note that this is safe, since we know</span><br><span class="line">               // these two packages come from the same uid; the caller could just as</span><br><span class="line">               // well have supplied that same package name itself.  This specifially</span><br><span class="line">               // deals with the case of an intent picker/chooser being launched in the app</span><br><span class="line">               // flow to redirect to an activity picked by the user, where we want the final</span><br><span class="line">               // activity to consider it to have been launched by the previous app activity.</span><br><span class="line">               callingPackage = sourceRecord.launchedFromPackage;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123;</span><br><span class="line">           //从intent中无法找到相应的component</span><br><span class="line">           // We couldn&apos;t find a class that can handle the given Intent.</span><br><span class="line">           // That&apos;s the end of that!</span><br><span class="line">           err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123;</span><br><span class="line">           //从intent中无法找到相应的ActivityInfo</span><br><span class="line">           // We couldn&apos;t find the specific class specified in the Intent.</span><br><span class="line">           // Also the end of the line.</span><br><span class="line">           err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null</span><br><span class="line">               &amp;&amp; sourceRecord.getTask().voiceSession != null) &#123;</span><br><span class="line">            //启动的activity是voice session一部分</span><br><span class="line">           // If this activity is being launched as part of a voice session, we need</span><br><span class="line">           // to ensure that it is safe to do so.  If the upcoming activity will also</span><br><span class="line">           // be part of the voice session, we can only launch it if it has explicitly</span><br><span class="line">           // said it supports the VOICE category, or it is a part of the calling app.</span><br><span class="line">           if ((launchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0</span><br><span class="line">                   &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   intent.addCategory(Intent.CATEGORY_VOICE);</span><br><span class="line">                   if (!mService.getPackageManager().activitySupportsIntent(</span><br><span class="line">                           intent.getComponent(), intent, resolvedType)) &#123;</span><br><span class="line">                       Slog.w(TAG,</span><br><span class="line">                               &quot;Activity being started in current voice task does not support voice: &quot;</span><br><span class="line">                                       + intent);</span><br><span class="line">                       err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (RemoteException e) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);</span><br><span class="line">                   err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123;</span><br><span class="line">           //启动是是voice session</span><br><span class="line">           // If the caller is starting a new voice session, just make sure the target</span><br><span class="line">           // is actually allowing it to run this way.</span><br><span class="line">           try &#123;</span><br><span class="line">               if (!mService.getPackageManager().activitySupportsIntent(intent.getComponent(),</span><br><span class="line">                       intent, resolvedType)) &#123;</span><br><span class="line">                   Slog.w(TAG,</span><br><span class="line">                           &quot;Activity being started in new voice task does not support: &quot;</span><br><span class="line">                                   + intent);</span><br><span class="line">                   err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (RemoteException e) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);</span><br><span class="line">               err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();</span><br><span class="line">       //错误则返回</span><br><span class="line">       if (err != START_SUCCESS) &#123;</span><br><span class="line">           if (resultRecord != null) &#123;</span><br><span class="line">               resultStack.sendActivityResultLocked(</span><br><span class="line">                       -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);</span><br><span class="line">           &#125;</span><br><span class="line">           SafeActivityOptions.abort(options);</span><br><span class="line">           return err;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //检查权限</span><br><span class="line">       boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">               requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity,</span><br><span class="line">               inTask != null, callerApp, resultRecord, resultStack);</span><br><span class="line">       abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">               callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line"></span><br><span class="line">       // Merge the two options bundles, while realCallerOptions takes precedence.</span><br><span class="line">       ActivityOptions checkedOptions = options != null</span><br><span class="line">               ? options.getOptions(intent, aInfo, callerApp, mSupervisor)</span><br><span class="line">               : null;</span><br><span class="line">       if (allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">           checkedOptions = mService.getActivityStartController()</span><br><span class="line">                   .getPendingRemoteAnimationRegistry()</span><br><span class="line">                   .overrideOptionsIfNeeded(callingPackage, checkedOptions);</span><br><span class="line">       &#125;</span><br><span class="line">       //ActivityController不为空的情况，比如monkey测试过程</span><br><span class="line">       if (mService.mController != null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               // The Intent we give to the watcher has the extra data</span><br><span class="line">               // stripped off, since it can contain private information.</span><br><span class="line">               Intent watchIntent = intent.cloneFilter();</span><br><span class="line">               abort |= !mService.mController.activityStarting(watchIntent,</span><br><span class="line">                       aInfo.applicationInfo.packageName);</span><br><span class="line">           &#125; catch (RemoteException e) &#123;</span><br><span class="line">               mService.mController = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage);</span><br><span class="line">       if (mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid,</span><br><span class="line">               callingUid, checkedOptions)) &#123;</span><br><span class="line">           // activity被拦截</span><br><span class="line">           // activity start was intercepted, e.g. because the target user is currently in quiet</span><br><span class="line">           // mode (turn off work) or the target application is suspended</span><br><span class="line">           intent = mInterceptor.mIntent;</span><br><span class="line">           rInfo = mInterceptor.mRInfo;</span><br><span class="line">           aInfo = mInterceptor.mAInfo;</span><br><span class="line">           resolvedType = mInterceptor.mResolvedType;</span><br><span class="line">           inTask = mInterceptor.mInTask;</span><br><span class="line">           callingPid = mInterceptor.mCallingPid;</span><br><span class="line">           callingUid = mInterceptor.mCallingUid;</span><br><span class="line">           checkedOptions = mInterceptor.mActivityOptions;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //终止则返回</span><br><span class="line">       if (abort) &#123;</span><br><span class="line">           if (resultRecord != null) &#123;</span><br><span class="line">               resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode,</span><br><span class="line">                       RESULT_CANCELED, null);</span><br><span class="line">           &#125;</span><br><span class="line">           // We pretend to the caller that it was really started, but</span><br><span class="line">           // they will just get a cancel result.</span><br><span class="line">           ActivityOptions.abort(checkedOptions);</span><br><span class="line">           return START_ABORTED;</span><br><span class="line">       &#125;</span><br><span class="line">       //如果需要再检查权限，则启动检查activity</span><br><span class="line">       // If permissions need a review before any of the app components can run, we</span><br><span class="line">       // launch the review activity and pass a pending intent to start the activity</span><br><span class="line">       // we are to launching now after the review is completed.</span><br><span class="line">       if (mService.mPermissionReviewRequired &amp;&amp; aInfo != null) &#123;</span><br><span class="line">           if (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                   aInfo.packageName, userId)) &#123;</span><br><span class="line">               IIntentSender target = mService.getIntentSenderLocked(</span><br><span class="line">                       ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage,</span><br><span class="line">                       callingUid, userId, null, null, 0, new Intent[]&#123;intent&#125;,</span><br><span class="line">                       new String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                               | PendingIntent.FLAG_ONE_SHOT, null);</span><br><span class="line"></span><br><span class="line">               final int flags = intent.getFlags();</span><br><span class="line">               Intent newIntent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line">               newIntent.setFlags(flags</span><br><span class="line">                       | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">               newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);</span><br><span class="line">               newIntent.putExtra(Intent.EXTRA_INTENT, new IntentSender(target));</span><br><span class="line">               if (resultRecord != null) &#123;</span><br><span class="line">                   newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, true);</span><br><span class="line">               &#125;</span><br><span class="line">               intent = newIntent;</span><br><span class="line"></span><br><span class="line">               resolvedType = null;</span><br><span class="line">               callingUid = realCallingUid;</span><br><span class="line">               callingPid = realCallingPid;</span><br><span class="line"></span><br><span class="line">               rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, 0,</span><br><span class="line">                       computeResolveFilterUid(</span><br><span class="line">                               callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">               aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,</span><br><span class="line">                       null /*profilerInfo*/);</span><br><span class="line"></span><br><span class="line">               if (DEBUG_PERMISSIONS_REVIEW) &#123;</span><br><span class="line">                   Slog.i(TAG, &quot;START u&quot; + userId + &quot; &#123;&quot; + intent.toShortString(true, true,</span><br><span class="line">                           true, false) + &quot;&#125; from uid &quot; + callingUid + &quot; on display &quot;</span><br><span class="line">                           + (mSupervisor.mFocusedStack == null</span><br><span class="line">                           ? DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If we have an ephemeral app, abort the process of launching the resolved intent.</span><br><span class="line">       // Instead, launch the ephemeral installer. Once the installer is finished, it</span><br><span class="line">       // starts either the intent we resolved here [on install error] or the ephemeral</span><br><span class="line">       // app [on install success].</span><br><span class="line">       if (rInfo != null &amp;&amp; rInfo.auxiliaryInfo != null) &#123;</span><br><span class="line">           intent = createLaunchIntent(rInfo.auxiliaryInfo, ephemeralIntent,</span><br><span class="line">                   callingPackage, verificationBundle, resolvedType, userId);</span><br><span class="line">           resolvedType = null;</span><br><span class="line">           callingUid = realCallingUid;</span><br><span class="line">           callingPid = realCallingPid;</span><br><span class="line"></span><br><span class="line">           aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //创建activity记录对象</span><br><span class="line">       ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">               callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">               resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null,</span><br><span class="line">               mSupervisor, checkedOptions, sourceRecord);</span><br><span class="line">       if (outActivity != null) &#123;</span><br><span class="line">           outActivity[0] = r;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) &#123;</span><br><span class="line">           // If the caller didn&apos;t specify an explicit time tracker, we want to continue</span><br><span class="line">           // tracking under any it has.</span><br><span class="line">           r.appTimeTracker = sourceRecord.appTimeTracker;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final ActivityStack stack = mSupervisor.mFocusedStack;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">       // If we are starting an activity that is not from the same uid as the currently resumed</span><br><span class="line">       // one, check whether app switches are allowed.</span><br><span class="line">       if (voiceSession == null &amp;&amp; (stack.getResumedActivity() == null</span><br><span class="line">               || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123;</span><br><span class="line">           //如果前台stack还没有resume状态的activity，则检查app是否允许切换，见2.8.1</span><br><span class="line">           if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">                   realCallingPid, realCallingUid, &quot;Activity start&quot;)) &#123;</span><br><span class="line">                //如果不允许切换，则把要启动的activity添加到PendingActivity，并且返回</span><br><span class="line">               mController.addPendingActivityLaunch(new PendingActivityLaunch(r,</span><br><span class="line">                       sourceRecord, startFlags, stack, callerApp));</span><br><span class="line">               ActivityOptions.abort(checkedOptions);</span><br><span class="line">               return ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       if (mService.mDidAppSwitch) &#123;</span><br><span class="line">           //从第一次app切换到第二次允许app,允许切换时间设置为0，则表示可以任意切换app</span><br><span class="line">           // This is the second allowed switch since we stopped switches,</span><br><span class="line">           // so now just generally allow switches.  Use case: user presses</span><br><span class="line">           // home (switches disabled, switch to home, mDidAppSwitch now true);</span><br><span class="line">           // user taps a home icon (coming from home so allowed, we hit here</span><br><span class="line">           // and now allow anyone to switch again).</span><br><span class="line">           mService.mAppSwitchesAllowedTime = 0;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           mService.mDidAppSwitch = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //处理PendingActivity的启动，由于app switch禁用从而被hold的等待的activity，见2.8.2</span><br><span class="line">       mController.doPendingActivityLaunches(false);</span><br><span class="line"></span><br><span class="line">       maybeLogActivityStart(callingUid, callingPackage, realCallingUid, intent, callerApp, r,</span><br><span class="line">               originatingPendingIntent);</span><br><span class="line">       //再走startActivity</span><br><span class="line">       return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">               true /* doResume */, checkedOptions, inTask, outActivity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上面这三个返回值表示启动activity失败</p>
<p>START_INTENT_NOT_RESOLVED：从intent中无法找到相应的component<br>START_CLASS_NOT_FOUND ：从intent中无法找到相应的ActivityInfo<br>START_NOT_VOICE_COMPATIBLE  :不支持voice task </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">                int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">                ActivityRecord[] outActivity) &#123;</span><br><span class="line">        int result = START_CANCELED;</span><br><span class="line">        try &#123;</span><br><span class="line">            mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">            //见2.9节</span><br><span class="line">            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                    startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //不能启动则取消task关联</span><br><span class="line">            // If we are not able to proceed, disassociate the activity from the task. Leaving an</span><br><span class="line">            // activity in an incomplete state can lead to issues, such as performing operations</span><br><span class="line">            // without a window container.</span><br><span class="line">            final ActivityStack stack = mStartActivity.getStack();</span><br><span class="line">            if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != null) &#123;</span><br><span class="line">                stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,</span><br><span class="line">                        null /* intentResultData */, &quot;startActivity&quot;, true /* oomAdj */);</span><br><span class="line">            &#125;</span><br><span class="line">            mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        postStartActivityProcessing(r, result, mTargetStack);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-8-1-AMS-checkAppSwitchAllowedLocked"><a href="#2-8-1-AMS-checkAppSwitchAllowedLocked" class="headerlink" title="2.8.1 AMS.checkAppSwitchAllowedLocked"></a>2.8.1 AMS.checkAppSwitchAllowedLocked</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid,</span><br><span class="line">          int callingPid, int callingUid, String name) &#123;</span><br><span class="line">      if (mAppSwitchesAllowedTime &lt; SystemClock.uptimeMillis()) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      if (mRecentTasks.isCallerRecents(sourceUid)) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      int perm = checkComponentPermission(STOP_APP_SWITCHES, sourcePid, sourceUid, -1, true);</span><br><span class="line">      if (perm == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      if (checkAllowAppSwitchUid(sourceUid)) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      // If the actual IPC caller is different from the logical source, then</span><br><span class="line">      // also see if they are allowed to control app switches.</span><br><span class="line">      if (callingUid != -1 &amp;&amp; callingUid != sourceUid) &#123;</span><br><span class="line">          perm = checkComponentPermission(STOP_APP_SWITCHES, callingPid, callingUid, -1, true);</span><br><span class="line">          if (perm == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">          if (checkAllowAppSwitchUid(callingUid)) &#123;</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Slog.w(TAG, name + &quot; request from &quot; + sourceUid + &quot; stopped&quot;);</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当mAppSwitchesAllowedTime时间小于当前时间或者具有STOP_APP_SWITCHES的权限，则允许app发生切换操作。  其中mAppSwitchesAllowedTime在AMS.stopAppSwitches的过程中会设置，                                    mAppSwitchesAllowedTime = SystemClock.uptimeMillis()+APP_SWITCH_DELAY_TIME(=5s);                                       禁止app切换的timeout时间为5s。</p>
<p>当发送5s超时或者执行ASM.resumeAppSwitches过程会将mAppSwitchesAllowedTime 设置为0，都会开启允许app执行切换的操作。禁止app切换的操作，对于同一个app是不受影响的，可查看AMS.checkComponentPermission</p>
<h4 id="2-8-1-ASC-doPendingActivityLaunches"><a href="#2-8-1-ASC-doPendingActivityLaunches" class="headerlink" title="2.8.1 ASC.doPendingActivityLaunches"></a>2.8.1 ASC.doPendingActivityLaunches</h4><p>[-&gt;ActivityStartController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void doPendingActivityLaunches(boolean doResume) &#123;</span><br><span class="line">      while (!mPendingActivityLaunches.isEmpty()) &#123;</span><br><span class="line">          final PendingActivityLaunch pal = mPendingActivityLaunches.remove(0);</span><br><span class="line">          final boolean resume = doResume &amp;&amp; mPendingActivityLaunches.isEmpty();</span><br><span class="line">          final ActivityStarter starter = obtainStarter(null /* intent */,</span><br><span class="line">                  &quot;pendingActivityLaunch&quot;);</span><br><span class="line">          try &#123;</span><br><span class="line">              starter.startResolvedActivity(pal.r, pal.sourceRecord, null, null, pal.startFlags,</span><br><span class="line">                      resume, null, null, null /* outRecords */);</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              Slog.e(TAG, &quot;Exception during pending activity launch pal=&quot; + pal, e);</span><br><span class="line">              pal.sendErrorResult(e.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>mPendingActivityLaunches记录所有将要启动的Activity，由于在startActivity过程中时app切换功能被禁止，也就是不运行切换的Activity，就会将该Activity加入到mPendingActivityLaunches队列，该队列执行完doPendingActivityLaunches会清空。启动doPendingActivityLaunches的所有Activity，由于doResume=false，那么activity不会进入resume，而是设置delayedResume = true,延迟resume。</p>
<h3 id="2-9-AS-startActivityUnchecked"><a href="#2-9-AS-startActivityUnchecked" class="headerlink" title="2.9  AS.startActivityUnchecked"></a>2.9  AS.startActivityUnchecked</h3><p>[-&gt;ActivityStarter.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">//r是本次要启动的activity，sourceRecord是调用者</span><br><span class="line">// Note: This method should only be called from &#123;@link startActivity&#125;.</span><br><span class="line">  private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">          IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">          int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">          ActivityRecord[] outActivity) &#123;</span><br><span class="line">      //设置初始化状态，见2.9.1</span><br><span class="line">      setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">              voiceInteractor);</span><br><span class="line">      //确定启动taskflag，见2.9.2</span><br><span class="line">      computeLaunchingTaskFlags();</span><br><span class="line">      //确定调用者栈，见2.9.3</span><br><span class="line">      computeSourceStack();</span><br><span class="line"></span><br><span class="line">      mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">      //得到可用的ActivityRecord</span><br><span class="line">      ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class="line"></span><br><span class="line">      int preferredWindowingMode = WINDOWING_MODE_UNDEFINED;</span><br><span class="line">      int preferredLaunchDisplayId = DEFAULT_DISPLAY;</span><br><span class="line">      if (mOptions != null) &#123;</span><br><span class="line">          preferredWindowingMode = mOptions.getLaunchWindowingMode();</span><br><span class="line">          preferredLaunchDisplayId = mOptions.getLaunchDisplayId();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // windowing mode and preferred launch display values from &#123;@link LaunchParams&#125; take</span><br><span class="line">      // priority over those specified in &#123;@link ActivityOptions&#125;.</span><br><span class="line">      if (!mLaunchParams.isEmpty()) &#123;</span><br><span class="line">          if (mLaunchParams.hasPreferredDisplay()) &#123;</span><br><span class="line">              preferredLaunchDisplayId = mLaunchParams.mPreferredDisplayId;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (mLaunchParams.hasWindowingMode()) &#123;</span><br><span class="line">              preferredWindowingMode = mLaunchParams.mWindowingMode;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (reusedActivity != null) &#123;</span><br><span class="line">          //LockTask mode 且设置了NEW_TASK and CLEAR_TASK则返回</span><br><span class="line">          // When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused but</span><br><span class="line">          // still needs to be a lock task mode violation since the task gets cleared out and</span><br><span class="line">          // the device would otherwise leave the locked task.</span><br><span class="line">          if (mService.getLockTaskController().isLockTaskModeViolation(reusedActivity.getTask(),</span><br><span class="line">                  (mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">                          == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123;</span><br><span class="line">              Slog.e(TAG, &quot;startActivityUnchecked: Attempt to violate Lock Task Mode&quot;);</span><br><span class="line">              return START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // True if we are clearing top and resetting of a standard (default) launch mode</span><br><span class="line">          // (&#123;@code LAUNCH_MULTIPLE&#125;) activity. The existing activity will be finished.</span><br><span class="line">          final boolean clearTopAndResetStandardLaunchMode =</span><br><span class="line">                  (mLaunchFlags &amp; (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED))</span><br><span class="line">                          == (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)</span><br><span class="line">                  &amp;&amp; mLaunchMode == LAUNCH_MULTIPLE;</span><br><span class="line"></span><br><span class="line">          //如果启动的activity没有管理task，则用存在activity的task</span><br><span class="line">          // If mStartActivity does not have a task associated with it, associate it with the</span><br><span class="line">          // reused activity&apos;s task. Do not do so if we&apos;re clearing top and resetting for a</span><br><span class="line">          // standard launchMode activity.</span><br><span class="line">          if (mStartActivity.getTask() == null &amp;&amp; !clearTopAndResetStandardLaunchMode) &#123;</span><br><span class="line">              mStartActivity.setTask(reusedActivity.getTask());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (reusedActivity.getTask().intent == null) &#123;</span><br><span class="line">              //设置mStartActivity</span><br><span class="line">              // This task was started because of movement of the activity based on affinity...</span><br><span class="line">              // Now that we are actually launching it, we can assign the base intent.</span><br><span class="line">              reusedActivity.getTask().setIntent(mStartActivity);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // This code path leads to delivering a new intent, we want to make sure we schedule it</span><br><span class="line">          // as the first operation, in case the activity will be resumed as a result of later</span><br><span class="line">          // operations.</span><br><span class="line">          if ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0</span><br><span class="line">                  || isDocumentLaunchesIntoExisting(mLaunchFlags)</span><br><span class="line">                  || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;</span><br><span class="line">              final TaskRecord task = reusedActivity.getTask();</span><br><span class="line">              //LAUNCH_SINGLE_INSTANCE,LAUNCH_SINGLE_TASK模式下，栈移除所有的activity</span><br><span class="line">              // In this situation we want to remove all activities from the task up to the one</span><br><span class="line">              // being started. In most cases this means we are resetting the task to its initial</span><br><span class="line">              // state.</span><br><span class="line">              final ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity,</span><br><span class="line">                      mLaunchFlags);</span><br><span class="line"></span><br><span class="line">              // The above code can remove &#123;@code reusedActivity&#125; from the task, leading to the</span><br><span class="line">              // the &#123;@code ActivityRecord&#125; removing its reference to the &#123;@code TaskRecord&#125;. The</span><br><span class="line">              // task reference is needed in the call below to</span><br><span class="line">              // &#123;@link setTargetStackAndMoveToFrontIfNeeded&#125;.</span><br><span class="line">              if (reusedActivity.getTask() == null) &#123;</span><br><span class="line">                  reusedActivity.setTask(task);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              if (top != null) &#123;</span><br><span class="line">                  //在前台</span><br><span class="line">                  if (top.frontOfTask) &#123;</span><br><span class="line">                      // Activity aliases may mean we use different intents for the top activity,</span><br><span class="line">                      // so make sure the task now has the identity of the new intent.</span><br><span class="line">                      top.getTask().setIntent(mStartActivity);</span><br><span class="line">                  &#125;</span><br><span class="line">                  deliverNewIntent(top);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          mSupervisor.sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, reusedActivity);</span><br><span class="line"></span><br><span class="line">          reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity);</span><br><span class="line"></span><br><span class="line">          final ActivityRecord outResult =</span><br><span class="line">                  outActivity != null &amp;&amp; outActivity.length &gt; 0 ? outActivity[0] : null;</span><br><span class="line"></span><br><span class="line">          // When there is a reused activity and the current result is a trampoline activity,</span><br><span class="line">          // set the reused activity as the result.</span><br><span class="line">          if (outResult != null &amp;&amp; (outResult.finishing || outResult.noDisplay)) &#123;</span><br><span class="line">              outActivity[0] = reusedActivity;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) &#123;</span><br><span class="line">              // We don&apos;t need to start a new activity, and the client said not to do anything</span><br><span class="line">              // if that is the case, so this is it!  And for paranoia, make sure we have</span><br><span class="line">              // correctly resumed the top activity.</span><br><span class="line">              resumeTargetStackIfNeeded();</span><br><span class="line">              return START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (reusedActivity != null) &#123;</span><br><span class="line">              setTaskFromIntentActivity(reusedActivity);</span><br><span class="line"></span><br><span class="line">              if (!mAddingToTask &amp;&amp; mReuseTask == null) &#123;</span><br><span class="line">                  // We didn&apos;t do anything...  but it was needed (a.k.a., client don&apos;t use that</span><br><span class="line">                  // intent!)  And for paranoia, make sure we have correctly resumed the top activity.</span><br><span class="line"></span><br><span class="line">                  resumeTargetStackIfNeeded();</span><br><span class="line">                  if (outActivity != null &amp;&amp; outActivity.length &gt; 0) &#123;</span><br><span class="line">                      outActivity[0] = reusedActivity;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  return mMovedToFront ? START_TASK_TO_FRONT : START_DELIVERED_TO_TOP;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      //启动的activity没有包名，直接返回</span><br><span class="line">      if (mStartActivity.packageName == null) &#123;</span><br><span class="line">          final ActivityStack sourceStack = mStartActivity.resultTo != null</span><br><span class="line">                  ? mStartActivity.resultTo.getStack() : null;</span><br><span class="line">          if (sourceStack != null) &#123;</span><br><span class="line">              sourceStack.sendActivityResultLocked(-1 /* callingUid */, mStartActivity.resultTo,</span><br><span class="line">                      mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED,</span><br><span class="line">                      null /* data */);</span><br><span class="line">          &#125;</span><br><span class="line">          ActivityOptions.abort(mOptions);</span><br><span class="line">          return START_CLASS_NOT_FOUND;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // If the activity being launched is the same as the one currently at the top, then</span><br><span class="line">      // we need to check if it should only be launched once.</span><br><span class="line">      final ActivityStack topStack = mSupervisor.mFocusedStack;</span><br><span class="line">      final ActivityRecord topFocused = topStack.getTopActivity();</span><br><span class="line">      final ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop);</span><br><span class="line">      final boolean dontStart = top != null &amp;&amp; mStartActivity.resultTo == null</span><br><span class="line">              &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class="line">              &amp;&amp; top.userId == mStartActivity.userId</span><br><span class="line">              &amp;&amp; top.app != null &amp;&amp; top.app.thread != null</span><br><span class="line">              &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != 0</span><br><span class="line">              || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK));        </span><br><span class="line">      if (dontStart) &#123;</span><br><span class="line">          // For paranoia, make sure we have correctly resumed the top activity.</span><br><span class="line">          topStack.mLastPausedActivity = null;</span><br><span class="line">          if (mDoResume) &#123;</span><br><span class="line">              mSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">          &#125;</span><br><span class="line">          ActivityOptions.abort(mOptions);</span><br><span class="line">          if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) &#123;</span><br><span class="line">              // We don&apos;t need to start a new activity, and the client said not to do</span><br><span class="line">              // anything if that is the case, so this is it!</span><br><span class="line">              return START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">          &#125;</span><br><span class="line">          //触发onNewIntent</span><br><span class="line">          deliverNewIntent(top);</span><br><span class="line"></span><br><span class="line">          // Don&apos;t use mStartActivity.task to show the toast. We&apos;re not starting a new activity</span><br><span class="line">          // but reusing &apos;top&apos;. Fields in mStartActivity may not be fully initialized.</span><br><span class="line">          mSupervisor.handleNonResizableTaskIfNeeded(top.getTask(), preferredWindowingMode,</span><br><span class="line">                  preferredLaunchDisplayId, topStack);</span><br><span class="line"></span><br><span class="line">          return START_DELIVERED_TO_TOP;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      boolean newTask = false;</span><br><span class="line">      final TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != null)</span><br><span class="line">              ? mSourceRecord.getTask() : null;</span><br><span class="line"></span><br><span class="line">      // Should this be considered a new task?</span><br><span class="line">      int result = START_SUCCESS;</span><br><span class="line">      if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask</span><br><span class="line">              &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123;</span><br><span class="line">          newTask = true;</span><br><span class="line">          result = setTaskFromReuseOrCreateNewTask(taskToAffiliate, topStack);</span><br><span class="line">      &#125; else if (mSourceRecord != null) &#123;</span><br><span class="line">          result = setTaskFromSourceRecord();</span><br><span class="line">      &#125; else if (mInTask != null) &#123;</span><br><span class="line">          result = setTaskFromInTask();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          // This not being started from an existing activity, and not part of a new task...</span><br><span class="line">          // just put it in the top task, though these days this case should never happen.</span><br><span class="line">          setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">      &#125;</span><br><span class="line">      if (result != START_SUCCESS) &#123;</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName,</span><br><span class="line">              mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId);</span><br><span class="line">      mService.grantEphemeralAccessLocked(mStartActivity.userId, mIntent,</span><br><span class="line">              mStartActivity.appInfo.uid, UserHandle.getAppId(mCallingUid));</span><br><span class="line">      if (newTask) &#123;</span><br><span class="line">          EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, mStartActivity.userId,</span><br><span class="line">                  mStartActivity.getTask().taskId);</span><br><span class="line">      &#125;</span><br><span class="line">      ActivityStack.logStartActivity(</span><br><span class="line">              EventLogTags.AM_CREATE_ACTIVITY, mStartActivity, mStartActivity.getTask());</span><br><span class="line">      mTargetStack.mLastPausedActivity = null;</span><br><span class="line"></span><br><span class="line">      mSupervisor.sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, mStartActivity);</span><br><span class="line">      //见2.10节</span><br><span class="line">      mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition,</span><br><span class="line">              mOptions);</span><br><span class="line">      if (mDoResume) &#123;</span><br><span class="line">          final ActivityRecord topTaskActivity =</span><br><span class="line">                  mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">          if (!mTargetStack.isFocusable()</span><br><span class="line">                  || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                  &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">              // 没有获取焦点，不能resume   </span><br><span class="line">              // If the activity is not focusable, we can&apos;t resume it, but still would like to</span><br><span class="line">              // make sure it becomes visible as it starts (this will also trigger entry</span><br><span class="line">              // animation). An example of this are PIP activities.</span><br><span class="line">              // Also, we don&apos;t want to resume activities in a task that currently has an overlay</span><br><span class="line">              // as the starting activity just needs to be in the visible paused state until the</span><br><span class="line">              // over is removed.</span><br><span class="line">              mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">              // Go ahead and tell window manager to execute app transition for this activity</span><br><span class="line">              // since the app transition will not be triggered through the resume channel.</span><br><span class="line">              mService.mWindowManager.executeAppTransition();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              // If the target stack was not previously focusable (previous top running activity</span><br><span class="line">              // on that stack was not visible) then any prior calls to move the stack to the</span><br><span class="line">              // will not update the focused stack.  If starting the new activity now allows the</span><br><span class="line">              // task stack to be focusable, then ensure that we now update the focused stack</span><br><span class="line">              // accordingly.</span><br><span class="line">              if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                  mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              //见2.11节</span><br><span class="line">              mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                      mOptions);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else if (mStartActivity != null) &#123;</span><br><span class="line">          mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">      &#125;</span><br><span class="line">      mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);</span><br><span class="line"></span><br><span class="line">      mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredWindowingMode,</span><br><span class="line">              preferredLaunchDisplayId, mTargetStack);</span><br><span class="line"></span><br><span class="line">      return START_SUCCESS;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>找到或者创建新的Activity所属的Task对象，之后调用AS.startActivityLocked</p>
<h4 id="2-9-1-AS-setInitialState"><a href="#2-9-1-AS-setInitialState" class="headerlink" title="2.9.1 AS.setInitialState"></a>2.9.1 AS.setInitialState</h4><p>[-&gt;ActivityStarter.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">private void setInitialState(ActivityRecord r, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">            boolean doResume, int startFlags, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) &#123;</span><br><span class="line">        reset(false /* clearRequest */);</span><br><span class="line"></span><br><span class="line">        mStartActivity = r;</span><br><span class="line">        mIntent = r.intent;</span><br><span class="line">        mOptions = options;</span><br><span class="line">        mCallingUid = r.launchedFromUid;</span><br><span class="line">        mSourceRecord = sourceRecord;</span><br><span class="line">        mVoiceSession = voiceSession;</span><br><span class="line">        mVoiceInteractor = voiceInteractor;</span><br><span class="line"></span><br><span class="line">        mPreferredDisplayId = getPreferedDisplayId(mSourceRecord, mStartActivity, options);</span><br><span class="line"></span><br><span class="line">        mLaunchParams.reset();</span><br><span class="line"></span><br><span class="line">        mSupervisor.getLaunchParamsController().calculate(inTask, null /*layout*/, r, sourceRecord,</span><br><span class="line">                options, mLaunchParams);</span><br><span class="line"></span><br><span class="line">        mLaunchMode = r.launchMode;</span><br><span class="line">        //当intent和Activity manifest存在冲突，则manifest优先</span><br><span class="line">        mLaunchFlags = adjustLaunchFlagsToDocumentMode(</span><br><span class="line">                r, LAUNCH_SINGLE_INSTANCE == mLaunchMode,</span><br><span class="line">                LAUNCH_SINGLE_TASK == mLaunchMode, mIntent.getFlags());</span><br><span class="line">        mLaunchTaskBehind = r.mLaunchTaskBehind</span><br><span class="line">                &amp;&amp; !isLaunchModeOneOf(LAUNCH_SINGLE_TASK, LAUNCH_SINGLE_INSTANCE)</span><br><span class="line">                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_DOCUMENT) != 0;</span><br><span class="line"></span><br><span class="line">        sendNewTaskResultRequestIfNeeded();</span><br><span class="line">   </span><br><span class="line">        if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_DOCUMENT) != 0 &amp;&amp; r.resultTo == null) &#123;</span><br><span class="line">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we are actually going to launch in to a new task, there are some cases where</span><br><span class="line">        // we further want to do multiple task.</span><br><span class="line">        if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123;</span><br><span class="line">            if (mLaunchTaskBehind</span><br><span class="line">                    || r.info.documentLaunchMode == DOCUMENT_LAUNCH_ALWAYS) &#123;</span><br><span class="line">                mLaunchFlags |= FLAG_ACTIVITY_MULTIPLE_TASK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We&apos;ll invoke onUserLeaving before onPause only if the launching</span><br><span class="line">        // activity did not explicitly state that this is an automated launch.</span><br><span class="line">        mSupervisor.mUserLeaving = (mLaunchFlags &amp; FLAG_ACTIVITY_NO_USER_ACTION) == 0;</span><br><span class="line">        if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,</span><br><span class="line">                &quot;startActivity() =&gt; mUserLeaving=&quot; + mSupervisor.mUserLeaving);</span><br><span class="line">        //当本次不需要resume时，则设置为延迟resume的状态</span><br><span class="line">        // If the caller has asked not to resume at this point, we make note</span><br><span class="line">        // of this in the record so that we can skip it when trying to find</span><br><span class="line">        // the top running activity.</span><br><span class="line">        mDoResume = doResume;</span><br><span class="line">        if (!doResume || !r.okToShowLocked()) &#123;</span><br><span class="line">            r.delayedResume = true;</span><br><span class="line">            mDoResume = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mOptions != null) &#123;</span><br><span class="line">            if (mOptions.getLaunchTaskId() != -1 &amp;&amp; mOptions.getTaskOverlay()) &#123;</span><br><span class="line">                r.mTaskOverlay = true;</span><br><span class="line">                if (!mOptions.canTaskOverlayResume()) &#123;</span><br><span class="line">                    final TaskRecord task = mSupervisor.anyTaskForIdLocked(</span><br><span class="line">                            mOptions.getLaunchTaskId());</span><br><span class="line">                    final ActivityRecord top = task != null ? task.getTopActivity() : null;</span><br><span class="line">                    if (top != null &amp;&amp; !top.isState(RESUMED)) &#123;</span><br><span class="line"></span><br><span class="line">                        // The caller specifies that we&apos;d like to be avoided to be moved to the</span><br><span class="line">                        // front, so be it!</span><br><span class="line">                        mDoResume = false;</span><br><span class="line">                        mAvoidMoveToFront = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (mOptions.getAvoidMoveToFront()) &#123;</span><br><span class="line">                mDoResume = false;</span><br><span class="line">                mAvoidMoveToFront = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mNotTop = (mLaunchFlags &amp; FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;</span><br><span class="line"></span><br><span class="line">        mInTask = inTask;</span><br><span class="line">        // In some flows in to this function, we retrieve the task record and hold on to it</span><br><span class="line">        // without a lock before calling back in to here...  so the task at this point may</span><br><span class="line">        // not actually be in recents.  Check for that, and if it isn&apos;t in recents just</span><br><span class="line">        // consider it invalid.</span><br><span class="line">        if (inTask != null &amp;&amp; !inTask.inRecents) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Starting activity in task not in recents: &quot; + inTask);</span><br><span class="line">            mInTask = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStartFlags = startFlags;</span><br><span class="line">        // If the onlyIfNeeded flag is set, then we can do this if the activity being launched</span><br><span class="line">        // is the same as the one making the call...  or, as a special case, if we do not know</span><br><span class="line">        // the caller then we count the current top activity as the caller.</span><br><span class="line">        if ((startFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) &#123;</span><br><span class="line">            ActivityRecord checkedCaller = sourceRecord;</span><br><span class="line">            if (checkedCaller == null) &#123;</span><br><span class="line">                checkedCaller = mSupervisor.mFocusedStack.topRunningNonDelayedActivityLocked(</span><br><span class="line">                        mNotTop);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!checkedCaller.realActivity.equals(r.realActivity)) &#123;</span><br><span class="line">                //调用者与将要启动的activity不相同时今日该分支</span><br><span class="line">                // Caller is not the same as launcher, so always needed.</span><br><span class="line">                mStartFlags &amp;= ~START_FLAG_ONLY_IF_NEEDED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mNoAnimation = (mLaunchFlags &amp; FLAG_ACTIVITY_NO_ANIMATION) != 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-9-2-AS-computeLaunchingTaskFlags"><a href="#2-9-2-AS-computeLaunchingTaskFlags" class="headerlink" title="2.9.2 AS.computeLaunchingTaskFlags"></a>2.9.2 AS.computeLaunchingTaskFlags</h4><p>[-&gt;ActivityStarter.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">private void computeLaunchingTaskFlags() &#123;</span><br><span class="line">        //当调用者不是来自于activity，而是指定明确task的情况</span><br><span class="line">        // If the caller is not coming from another activity, but has given us an explicit task into</span><br><span class="line">        // which they would like us to launch the new activity, then let&apos;s see about doing that.</span><br><span class="line">        if (mSourceRecord == null &amp;&amp; mInTask != null &amp;&amp; mInTask.getStack() != null) &#123;</span><br><span class="line">            final Intent baseIntent = mInTask.getBaseIntent();</span><br><span class="line">            final ActivityRecord root = mInTask.getRootActivity();</span><br><span class="line">            if (baseIntent == null) &#123;</span><br><span class="line">                ActivityOptions.abort(mOptions);</span><br><span class="line">                throw new IllegalArgumentException(&quot;Launching into task without base intent: &quot;</span><br><span class="line">                        + mInTask);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If this task is empty, then we are adding the first activity -- it</span><br><span class="line">            // determines the root, and must be launching as a NEW_TASK.</span><br><span class="line">            if (isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;</span><br><span class="line">                if (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent())) &#123;</span><br><span class="line">                    ActivityOptions.abort(mOptions);</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Trying to launch singleInstance/Task &quot;</span><br><span class="line">                            + mStartActivity + &quot; into different task &quot; + mInTask);</span><br><span class="line">                &#125;</span><br><span class="line">                if (root != null) &#123;</span><br><span class="line">                    ActivityOptions.abort(mOptions);</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Caller with mInTask &quot; + mInTask</span><br><span class="line">                            + &quot; has root &quot; + root + &quot; but target is singleInstance/Task&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If task is empty, then adopt the interesting intent launch flags in to the</span><br><span class="line">            // activity being started.</span><br><span class="line">            if (root == null) &#123;</span><br><span class="line">                final int flagsOfInterest = FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK</span><br><span class="line">                        | FLAG_ACTIVITY_NEW_DOCUMENT | FLAG_ACTIVITY_RETAIN_IN_RECENTS;</span><br><span class="line">                mLaunchFlags = (mLaunchFlags &amp; ~flagsOfInterest)</span><br><span class="line">                        | (baseIntent.getFlags() &amp; flagsOfInterest);</span><br><span class="line">                mIntent.setFlags(mLaunchFlags);</span><br><span class="line">                mInTask.setIntent(mStartActivity);</span><br><span class="line">                mAddingToTask = true;</span><br><span class="line"></span><br><span class="line">                // If the task is not empty and the caller is asking to start it as the root of</span><br><span class="line">                // a new task, then we don&apos;t actually want to start this on the task. We will</span><br><span class="line">                // bring the task to the front, and possibly give it a new intent.</span><br><span class="line">            &#125; else if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123;</span><br><span class="line">                mAddingToTask = false;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mAddingToTask = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mReuseTask = mInTask;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInTask = null;</span><br><span class="line">            // Launch ResolverActivity in the source task, so that it stays in the task bounds</span><br><span class="line">            // when in freeform workspace.</span><br><span class="line">            // Also put noDisplay activities in the source task. These by itself can be placed</span><br><span class="line">            // in any task/stack, however it could launch other activities like ResolverActivity,</span><br><span class="line">            // and we want those to stay in the original task.</span><br><span class="line">            if ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != null</span><br><span class="line">                    &amp;&amp; mSourceRecord.inFreeformWindowingMode())  &#123;</span><br><span class="line">                mAddingToTask = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mInTask == null) &#123;</span><br><span class="line">            if (mSourceRecord == null) &#123;</span><br><span class="line">                //调用者不是Activity context,则强制创建新task</span><br><span class="line">                // This activity is not being started from another...  in this</span><br><span class="line">                // case we -always- start a new task.</span><br><span class="line">                if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; mInTask == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;startActivity called from non-Activity context; forcing &quot; +</span><br><span class="line">                            &quot;Intent.FLAG_ACTIVITY_NEW_TASK for: &quot; + mIntent);</span><br><span class="line">                    mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">                 //调用者启动模式是single instance，则创建新task</span><br><span class="line">                // The original activity who is starting us is running as a single</span><br><span class="line">                // instance...  this new activity it is starting must go on its</span><br><span class="line">                // own task.</span><br><span class="line">                mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">            &#125; else if (isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;</span><br><span class="line">                //目标activity带有single instance或者single task则创建新的task</span><br><span class="line">                // The activity being started is a single instance...  it always</span><br><span class="line">                // gets launched into its own task.</span><br><span class="line">                mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-9-3-AS-computeSourceStack"><a href="#2-9-3-AS-computeSourceStack" class="headerlink" title="2.9.3 AS.computeSourceStack"></a>2.9.3 AS.computeSourceStack</h4><p>[-&gt;ActivityStarter.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void computeSourceStack() &#123;</span><br><span class="line">       if (mSourceRecord == null) &#123;</span><br><span class="line">           mSourceStack = null;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!mSourceRecord.finishing) &#123;</span><br><span class="line">          //当调用者activity不为空，且不在finishing状态，则其所在的栈赋于sourceStack</span><br><span class="line">           mSourceStack = mSourceRecord.getStack();</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       //当调用者处于finishing状态，则创建新的task</span><br><span class="line">       // If the source is finishing, we can&apos;t further count it as our source. This is because the</span><br><span class="line">       // task it is associated with may now be empty and on its way out, so we don&apos;t want to</span><br><span class="line">       // blindly throw it in to that task.  Instead we will take the NEW_TASK flow and try to find</span><br><span class="line">       // a task for it. But save the task information so it can be used when creating the new task.</span><br><span class="line">       if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;startActivity called from finishing &quot; + mSourceRecord</span><br><span class="line">                   + &quot;; forcing &quot; + &quot;Intent.FLAG_ACTIVITY_NEW_TASK for: &quot; + mIntent);</span><br><span class="line">           mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">           mNewTaskInfo = mSourceRecord.info;</span><br><span class="line"></span><br><span class="line">           // It is not guaranteed that the source record will have a task associated with it. For,</span><br><span class="line">           // example, if this method is being called for processing a pending activity launch, it</span><br><span class="line">           // is possible that the activity has been removed from the task after the launch was</span><br><span class="line">           // enqueued.</span><br><span class="line">           final TaskRecord sourceTask = mSourceRecord.getTask();</span><br><span class="line">           mNewTaskIntent = sourceTask != null ? sourceTask.intent : null;</span><br><span class="line">       &#125;</span><br><span class="line">       mSourceRecord = null;</span><br><span class="line">       mSourceStack = null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-9-4-AS-getReusableIntentActivity"><a href="#2-9-4-AS-getReusableIntentActivity" class="headerlink" title="2.9.4 AS.getReusableIntentActivity"></a>2.9.4 AS.getReusableIntentActivity</h4><p>[-&gt;ActivityStarter.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Decide whether the new activity should be inserted into an existing task. Returns null</span><br><span class="line">     * if not or an ActivityRecord with the task into which the new activity should be added.</span><br><span class="line">     */</span><br><span class="line">    private ActivityRecord getReusableIntentActivity() &#123;</span><br><span class="line">        // We may want to try to place the new activity in to an existing task.  We always</span><br><span class="line">        // do this if the target activity is singleTask or singleInstance; we will also do</span><br><span class="line">        // this if NEW_TASK has been requested, and there is not an additional qualifier telling</span><br><span class="line">        // us to still place it in a new task: multi task, always doc mode, or being asked to</span><br><span class="line">        // launch this as a new task behind the current one.</span><br><span class="line">        boolean putIntoExistingTask = ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp;</span><br><span class="line">                (mLaunchFlags &amp; FLAG_ACTIVITY_MULTIPLE_TASK) == 0)</span><br><span class="line">                || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK);</span><br><span class="line">        // If bring to front is requested, and no result is requested and we have not been given</span><br><span class="line">        // an explicit task to launch in to, and we can find a task that was started with this</span><br><span class="line">        // same component, then instead of launching bring that one to the front.</span><br><span class="line">        putIntoExistingTask &amp;= mInTask == null &amp;&amp; mStartActivity.resultTo == null;</span><br><span class="line">        ActivityRecord intentActivity = null;</span><br><span class="line">        if (mOptions != null &amp;&amp; mOptions.getLaunchTaskId() != -1) &#123;</span><br><span class="line">            final TaskRecord task = mSupervisor.anyTaskForIdLocked(mOptions.getLaunchTaskId());</span><br><span class="line">            intentActivity = task != null ? task.getTopActivity() : null;</span><br><span class="line">        &#125; else if (putIntoExistingTask) &#123;</span><br><span class="line">            if (LAUNCH_SINGLE_INSTANCE == mLaunchMode) &#123;</span><br><span class="line">                // There can be one and only one instance of single instance activity in the</span><br><span class="line">                // history, and it is always in its own unique task, so we do a special search.</span><br><span class="line">               intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info,</span><br><span class="line">                       mStartActivity.isActivityTypeHome());</span><br><span class="line">            &#125; else if ((mLaunchFlags &amp; FLAG_ACTIVITY_LAUNCH_ADJACENT) != 0) &#123;</span><br><span class="line">                // For the launch adjacent case we only want to put the activity in an existing</span><br><span class="line">                // task if the activity already exists in the history.</span><br><span class="line">                intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info,</span><br><span class="line">                        !(LAUNCH_SINGLE_TASK == mLaunchMode));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Otherwise find the best task to put the activity in.</span><br><span class="line">                intentActivity = mSupervisor.findTaskLocked(mStartActivity, mPreferredDisplayId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return intentActivity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面是根据不同的启动模式，来获取ActivityRecord信息，来决定将要启动的activity所在的栈。</p>
<h4 id="2-9-5-Launch-Mode"><a href="#2-9-5-Launch-Mode" class="headerlink" title="2.9.5 Launch Mode"></a>2.9.5 Launch Mode</h4><p>AcitivityInfo.java定义了四类Launch Mode:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constant corresponding to &lt;code&gt;standard&lt;/code&gt; in</span><br><span class="line"> * the &#123;@link android.R.attr#launchMode&#125; attribute.</span><br><span class="line"> */</span><br><span class="line">//每次启动新Activity，都会创建新的Activity，这是最常见标准情形</span><br><span class="line">public static final int LAUNCH_MULTIPLE = 0;</span><br><span class="line">/**</span><br><span class="line"> * Constant corresponding to &lt;code&gt;singleTop&lt;/code&gt; in</span><br><span class="line"> * the &#123;@link android.R.attr#launchMode&#125; attribute.</span><br><span class="line"> */</span><br><span class="line">//当启动新Activity，如果栈顶存在相同Activity，则不会创建新的Activity  </span><br><span class="line">public static final int LAUNCH_SINGLE_TOP = 1;</span><br><span class="line">/**</span><br><span class="line"> * Constant corresponding to &lt;code&gt;singleTask&lt;/code&gt; in</span><br><span class="line"> * the &#123;@link android.R.attr#launchMode&#125; attribute.</span><br><span class="line"> */</span><br><span class="line">//当启动Activity，在栈中存在相同Activity，则不会创建新的Activity</span><br><span class="line">//而是移除该Activity之上的所有Activity</span><br><span class="line">public static final int LAUNCH_SINGLE_TASK = 2;</span><br><span class="line">/**</span><br><span class="line"> * Constant corresponding to &lt;code&gt;singleInstance&lt;/code&gt; in</span><br><span class="line"> * the &#123;@link android.R.attr#launchMode&#125; attribute.</span><br><span class="line"> */</span><br><span class="line"> //每个Task栈只有一个Activity</span><br><span class="line">public static final int LAUNCH_SINGLE_INSTANCE = 3;</span><br></pre></td></tr></table></figure>
<p>常见的flag含义</p>
<p>FLAG_ACTIVITY_NEW_TASK</p>
<p>将新Activity放入新启动的task。</p>
<p>FLAG_ACTIVITY_CLEAR_TASK</p>
<p>启动Activity时，将目标Activity关联的task清除，再启动新task,将该Activity放入该Task。这个flag一般配置FLAG_ACTIVITY_NEW_TASK使用。</p>
<p>FLAG_ACTIVITY_CLEAR_TOP</p>
<p>启动非栈顶Activity时，先清除该Activity之上的Activity.                                                                                                        例如Task已有A,B,C,D，启动A,则需要先清除B,C,D，类似SingleTop。</p>
<h3 id="2-10-AS-startActivityLocked"><a href="#2-10-AS-startActivityLocked" class="headerlink" title="2.10 AS.startActivityLocked"></a>2.10 AS.startActivityLocked</h3><p>[-&gt;ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">void startActivityLocked(ActivityRecord r, ActivityRecord focusedTopActivity,</span><br><span class="line">           boolean newTask, boolean keepCurTransition, ActivityOptions options) &#123;</span><br><span class="line">       TaskRecord rTask = r.getTask();</span><br><span class="line">       final int taskId = rTask.taskId;</span><br><span class="line">       // mLaunchTaskBehind tasks get placed at the back of the task stack.</span><br><span class="line">       if (!r.mLaunchTaskBehind &amp;&amp; (taskForIdLocked(taskId) == null || newTask)) &#123;</span><br><span class="line">           // Last activity in task had been removed or ActivityManagerService is reusing task.</span><br><span class="line">           // Insert or replace.</span><br><span class="line">           // Might not even be in.</span><br><span class="line">           //task中上一个activity被移除，或者ams重用task,则将该task移到顶部</span><br><span class="line">           insertTaskAtTop(rTask, r);</span><br><span class="line">       &#125;</span><br><span class="line">       TaskRecord task = null;</span><br><span class="line">       if (!newTask) &#123;</span><br><span class="line">           // If starting in an existing task, find where that is...</span><br><span class="line">           boolean startIt = true;</span><br><span class="line">           for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123;</span><br><span class="line">               task = mTaskHistory.get(taskNdx);</span><br><span class="line">               if (task.getTopActivity() == null) &#123;</span><br><span class="line">                   // All activities in task are finishing.</span><br><span class="line">                   //该task所有activity都finishing</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               if (task == rTask) &#123;</span><br><span class="line">                   // Here it is!  Now, if this is not yet visible to the</span><br><span class="line">                   // user, then just add it without starting; it will</span><br><span class="line">                   // get started when the user navigates back to it.</span><br><span class="line">                   if (!startIt) &#123;</span><br><span class="line">                       if (DEBUG_ADD_REMOVE) Slog.i(TAG, &quot;Adding activity &quot; + r + &quot; to task &quot;</span><br><span class="line">                               + task, new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">                       r.createWindowContainer();</span><br><span class="line">                       ActivityOptions.abort(options);</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">                   break;</span><br><span class="line">               &#125; else if (task.numFullscreen &gt; 0) &#123;</span><br><span class="line">                   startIt = false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Place a new activity at top of stack, so it is next to interact with the user.</span><br><span class="line"></span><br><span class="line">       // If we are not placing the new activity frontmost, we do not want to deliver the</span><br><span class="line">       // onUserLeaving callback to the actual frontmost activity</span><br><span class="line">       final TaskRecord activityTask = r.getTask();</span><br><span class="line">       if (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) &#123;</span><br><span class="line">           mStackSupervisor.mUserLeaving = false;</span><br><span class="line">           if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,</span><br><span class="line">                   &quot;startActivity() behind front, mUserLeaving=false&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       task = activityTask;</span><br><span class="line"></span><br><span class="line">       // Slot the activity into the history stack and proceed</span><br><span class="line">       if (DEBUG_ADD_REMOVE) Slog.i(TAG, &quot;Adding activity &quot; + r + &quot; to stack to task &quot; + task,</span><br><span class="line">               new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">       // TODO: Need to investigate if it is okay for the controller to already be created by the</span><br><span class="line">       // time we get to this point. I think it is, but need to double check.</span><br><span class="line">       // Use test in b/34179495 to trace the call path.</span><br><span class="line">       if (r.getWindowContainerController() == null) &#123;</span><br><span class="line">           r.createWindowContainer();</span><br><span class="line">       &#125;</span><br><span class="line">       task.setFrontOfTask();</span><br><span class="line">      //当切换到新的task或者下一个activity进程目前没有运行</span><br><span class="line">       if (!isHomeOrRecentsStack() || numActivities() &gt; 0) &#123;</span><br><span class="line">           if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,</span><br><span class="line">                   &quot;Prepare open transition: starting &quot; + r);</span><br><span class="line">           if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) &#123;</span><br><span class="line">               mWindowManager.prepareAppTransition(TRANSIT_NONE, keepCurTransition);</span><br><span class="line">               mStackSupervisor.mNoAnimActivities.add(r);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               int transit = TRANSIT_ACTIVITY_OPEN;</span><br><span class="line">               if (newTask) &#123;</span><br><span class="line">                   if (r.mLaunchTaskBehind) &#123;</span><br><span class="line">                       transit = TRANSIT_TASK_OPEN_BEHIND;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // If a new task is being launched, then mark the existing top activity as</span><br><span class="line">                       // supporting picture-in-picture while pausing only if the starting activity</span><br><span class="line">                       // would not be considered an overlay on top of the current activity</span><br><span class="line">                       // (eg. not fullscreen, or the assistant)</span><br><span class="line">                       if (canEnterPipOnTaskSwitch(focusedTopActivity,</span><br><span class="line">                               null /* toFrontTask */, r, options)) &#123;</span><br><span class="line">                           focusedTopActivity.supportsEnterPipOnTaskSwitch = true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       transit = TRANSIT_TASK_OPEN;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               mWindowManager.prepareAppTransition(transit, keepCurTransition);</span><br><span class="line">               mStackSupervisor.mNoAnimActivities.remove(r);</span><br><span class="line">           &#125;</span><br><span class="line">           boolean doShow = true;</span><br><span class="line">           if (newTask) &#123;</span><br><span class="line">               // Even though this activity is starting fresh, we still need</span><br><span class="line">               // to reset it to make sure we apply affinities to move any</span><br><span class="line">               // existing activities from other tasks in to it.</span><br><span class="line">               // If the caller has requested that the target task be</span><br><span class="line">               // reset, then do so.</span><br><span class="line">               if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123;</span><br><span class="line">                   resetTaskIfNeededLocked(r, r);</span><br><span class="line">                   doShow = topRunningNonDelayedActivityLocked(null) == r;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else if (options != null &amp;&amp; options.getAnimationType()</span><br><span class="line">                   == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class="line">               doShow = false;</span><br><span class="line">           &#125;</span><br><span class="line">           if (r.mLaunchTaskBehind) &#123;</span><br><span class="line">               // Don&apos;t do a starting window for mLaunchTaskBehind. More importantly make sure we</span><br><span class="line">               // tell WindowManager that r is visible even though it is at the back of the stack.</span><br><span class="line">               r.setVisibility(true);</span><br><span class="line">               ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">           &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class="line">               // Figure out if we are transitioning from another activity that is</span><br><span class="line">               // &quot;has the same starting icon&quot; as the next one.  This allows the</span><br><span class="line">               // window manager to keep the previous window it had previously</span><br><span class="line">               // created, if it still had one.</span><br><span class="line">               TaskRecord prevTask = r.getTask();</span><br><span class="line">               ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();</span><br><span class="line">               if (prev != null) &#123;</span><br><span class="line">                  //当前activity属于不同的task</span><br><span class="line">                   // We don&apos;t want to reuse the previous starting preview if:</span><br><span class="line">                   // (1) The current activity is in a different task.</span><br><span class="line">                   if (prev.getTask() != prevTask) &#123;</span><br><span class="line">                       prev = null;</span><br><span class="line">                   &#125;</span><br><span class="line">                   //当前activity已经display</span><br><span class="line">                   // (2) The current activity is already displayed.</span><br><span class="line">                   else if (prev.nowVisible) &#123;</span><br><span class="line">                       prev = null;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               r.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // If this is the first activity, don&apos;t do any fancy animations,</span><br><span class="line">           // because there is nothing for it to animate on top of.</span><br><span class="line">           ActivityOptions.abort(options);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-11-ASS-resumeFocusedStackTopActivityLocked"><a href="#2-11-ASS-resumeFocusedStackTopActivityLocked" class="headerlink" title="2.11  ASS.resumeFocusedStackTopActivityLocked"></a>2.11  ASS.resumeFocusedStackTopActivityLocked</h3><p>[-&gt;ActivityStackSupervisor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">           ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line"></span><br><span class="line">       if (!readyToResume()) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">           return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">       if (r == null || !r.isState(RESUMED)) &#123;</span><br><span class="line">           mFocusedStack.resumeTopActivityUncheckedLocked(null, null);</span><br><span class="line">       &#125; else if (r.isState(RESUMED)) &#123;</span><br><span class="line">           // Kick off any lingering app transitions form the MoveTaskToFront operation.</span><br><span class="line">           mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-12-AS-resumeTopActivityUncheckedLocked"><a href="#2-12-AS-resumeTopActivityUncheckedLocked" class="headerlink" title="2.12 AS.resumeTopActivityUncheckedLocked"></a>2.12 AS.resumeTopActivityUncheckedLocked</h3><p>[-&gt;ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">      //防止递归启动</span><br><span class="line">      if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">          // Don&apos;t even start recursing.</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      boolean result = false;</span><br><span class="line">      try &#123;</span><br><span class="line">          // Protect against recursion.</span><br><span class="line">          mStackSupervisor.inResumeTopActivity = true;</span><br><span class="line">          //见2.13节</span><br><span class="line">          result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">          // When resuming the top activity, it may be necessary to pause the top activity (for</span><br><span class="line">          // example, returning to the lock screen. We suppress the normal pause logic in</span><br><span class="line">          // &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span><br><span class="line">          // end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span><br><span class="line">          // to ensure any necessary pause logic occurs. In the case where the Activity will be</span><br><span class="line">          // shown regardless of the lock screen, the call to</span><br><span class="line">          // &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span><br><span class="line">          final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);</span><br><span class="line">          if (next == null || !next.canTurnScreenOn()) &#123;</span><br><span class="line">              checkReadyForSleep();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          mStackSupervisor.inResumeTopActivity = false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-13-AS-resumeTopActivityInnerLocked"><a href="#2-13-AS-resumeTopActivityInnerLocked" class="headerlink" title="2.13 AS.resumeTopActivityInnerLocked"></a>2.13 AS.resumeTopActivityInnerLocked</h3><p>[-&gt;ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;mService&quot;)</span><br><span class="line">   private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">       //系统没有进入booting或者booted状态被，则不允许启动Activity</span><br><span class="line">       if (!mService.mBooting &amp;&amp; !mService.mBooted) &#123;</span><br><span class="line">           // Not ready yet!</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //找到top-most activity没有finishing的栈顶activity</span><br><span class="line">       // Find the next top-most activity to resume in this stack that is not finishing and is</span><br><span class="line">       // focusable. If it is not focusable, we will fall into the case below to resume the</span><br><span class="line">       // top activity in the next focusable task.</span><br><span class="line">       final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);</span><br><span class="line"></span><br><span class="line">       final boolean hasRunningActivity = next != null;</span><br><span class="line"></span><br><span class="line">       // TODO: Maybe this entire condition can get removed?</span><br><span class="line">       if (hasRunningActivity &amp;&amp; !isAttached()) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       //top running之后的任意处于初始化状态且有显示startingWindow,则移除startingWindow</span><br><span class="line">       mStackSupervisor.cancelInitializingActivities();</span><br><span class="line"></span><br><span class="line">       // Remember how we&apos;ll process this pause/resume situation, and ensure</span><br><span class="line">       // that the state is reset however we wind up proceeding.</span><br><span class="line">       boolean userLeaving = mStackSupervisor.mUserLeaving;</span><br><span class="line">       mStackSupervisor.mUserLeaving = false;</span><br><span class="line"></span><br><span class="line">       if (!hasRunningActivity) &#123;</span><br><span class="line">           //见2.13.1节</span><br><span class="line">           // There are no activities left in the stack, let&apos;s look somewhere else.</span><br><span class="line">           return resumeTopActivityInNextFocusableStack(prev, options, &quot;noMoreActivities&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       next.delayedResume = false;</span><br><span class="line">       //已经resume的情况</span><br><span class="line">       // If the top activity is the resumed one, nothing to do.</span><br><span class="line">       if (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">               &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">           // Make sure we have executed any pending transitions, since there</span><br><span class="line">           // should be nothing left to do at this point.</span><br><span class="line">           executeAppTransition(options);</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                   &quot;resumeTopActivityLocked: Top activity resumed &quot; + next);</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       //处于睡眠或者关机状态，top activity已经暂停的情况</span><br><span class="line">       // If we are sleeping, and there is no resumed activity, and the top</span><br><span class="line">       // activity is paused, well that is the state we want.</span><br><span class="line">       if (shouldSleepOrShutDownActivities()</span><br><span class="line">               &amp;&amp; mLastPausedActivity == next</span><br><span class="line">               &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">           // Make sure we have executed any pending transitions, since there</span><br><span class="line">           // should be nothing left to do at this point.</span><br><span class="line">           executeAppTransition(options);</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                   &quot;resumeTopActivityLocked: Going to sleep and all paused&quot;);</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       //拥有该activity的用户没有启动则直接返回</span><br><span class="line">       // Make sure that the user who owns this activity is started.  If not,</span><br><span class="line">       // we will just leave it as is because someone should be bringing</span><br><span class="line">       // another user&apos;s activities to the top of the stack.</span><br><span class="line">       if (!mService.mUserController.hasStartedUserState(next.userId)) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Skipping resume of top activity &quot; + next</span><br><span class="line">                   + &quot;: user &quot; + next.userId + &quot; is stopped&quot;);</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       // The activity may be waiting for stop, but that is no longer</span><br><span class="line">       // appropriate for it.</span><br><span class="line">       mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">       mStackSupervisor.mGoingToSleepActivities.remove(next);</span><br><span class="line">       next.sleeping = false;</span><br><span class="line">       mStackSupervisor.mActivitiesWaitingForVisibleActivity.remove(next);</span><br><span class="line"></span><br><span class="line">       if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, &quot;Resuming &quot; + next);</span><br><span class="line">       //当处于暂停activity，则直接返回</span><br><span class="line">       // If we are currently pausing an activity, then don&apos;t do anything until that is done.</span><br><span class="line">       if (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">           if (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,</span><br><span class="line">                   &quot;resumeTopActivityLocked: Skip resume: some activity pausing.&quot;);</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">       boolean lastResumedCanPip = false;</span><br><span class="line">       ActivityRecord lastResumed = null;</span><br><span class="line">       final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();</span><br><span class="line">       if (lastFocusedStack != null &amp;&amp; lastFocusedStack != this) &#123;</span><br><span class="line">           // So, why aren&apos;t we using prev here??? See the param comment on the method. prev doesn&apos;t</span><br><span class="line">           // represent the last resumed activity. However, the last focus stack does if it isn&apos;t null.</span><br><span class="line">           lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class="line">           //多窗口模式判断</span><br><span class="line">           if (userLeaving &amp;&amp; inMultiWindowMode() &amp;&amp; lastFocusedStack.shouldBeVisible(next)) &#123;</span><br><span class="line">               // The user isn&apos;t leaving if this stack is the multi-window mode and the last</span><br><span class="line">               // focused stack should still be visible.</span><br><span class="line">               if(DEBUG_USER_LEAVING) Slog.i(TAG_USER_LEAVING, &quot;Overriding userLeaving to false&quot;</span><br><span class="line">                       + &quot; next=&quot; + next + &quot; lastResumed=&quot; + lastResumed);</span><br><span class="line">               userLeaving = false;</span><br><span class="line">           &#125;</span><br><span class="line">           lastResumedCanPip = lastResumed != null &amp;&amp; lastResumed.checkEnterPictureInPictureState(</span><br><span class="line">                   &quot;resumeTopActivity&quot;, userLeaving /* beforeStopping */);</span><br><span class="line">       &#125;</span><br><span class="line">       //要等待暂停当前activity完成，再resume top activity</span><br><span class="line">       // If the flag RESUME_WHILE_PAUSING is set, then continue to schedule the previous activity</span><br><span class="line">       // to be paused, while at the same time resuming the new resume activity only if the</span><br><span class="line">       // previous activity can&apos;t go into Pip since we want to give Pip activities a chance to</span><br><span class="line">       // enter Pip before resuming the next activity.</span><br><span class="line">       final boolean resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != 0</span><br><span class="line">               &amp;&amp; !lastResumedCanPip;</span><br><span class="line">       </span><br><span class="line">       //暂停其他Activity，见13.2节</span><br><span class="line">       boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);</span><br><span class="line">       if (mResumedActivity != null) &#123;</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                   &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">           //当resume状态activity不为空，则需要暂停该Activity</span><br><span class="line">           pausing |= startPausingLocked(userLeaving, false, next, false);</span><br><span class="line">       &#125;</span><br><span class="line">       if (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class="line">           if (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                   &quot;resumeTopActivityLocked: Skip resume: need to start pausing&quot;);</span><br><span class="line">           // At this point we want to put the upcoming activity&apos;s process</span><br><span class="line">           // at the top of the LRU list, since we know we will be needing it</span><br><span class="line">           // very soon and it would be a waste to let it get killed if it</span><br><span class="line">           // happens to be sitting towards the end.</span><br><span class="line">           if (next.app != null &amp;&amp; next.app.thread != null) &#123;</span><br><span class="line">               mService.updateLruProcessLocked(next.app, true, null);</span><br><span class="line">           &#125;</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           if (lastResumed != null) &#123;</span><br><span class="line">               lastResumed.setWillCloseOrEnterPip(true);</span><br><span class="line">           &#125;</span><br><span class="line">           return true;</span><br><span class="line">       &#125; else if (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">               &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">           // It is possible for the activity to be resumed when we paused back stacks above if the</span><br><span class="line">           // next activity doesn&apos;t have to wait for pause to complete.</span><br><span class="line">           // So, nothing else to-do except:</span><br><span class="line">           // Make sure we have executed any pending transitions, since there</span><br><span class="line">           // should be nothing left to do at this point.</span><br><span class="line">           executeAppTransition(options);</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                   &quot;resumeTopActivityLocked: Top activity resumed (dontWaitForPause) &quot; + next);</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If the most recent activity was noHistory but was only stopped rather</span><br><span class="line">       // than stopped+finished because the device went to sleep, we need to make</span><br><span class="line">       // sure to finish it as we&apos;re making a new activity topmost.</span><br><span class="line">       if (shouldSleepActivities() &amp;&amp; mLastNoHistoryActivity != null &amp;&amp;</span><br><span class="line">               !mLastNoHistoryActivity.finishing) &#123;</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                   &quot;no-history finish of &quot; + mLastNoHistoryActivity + &quot; on new resume&quot;);</span><br><span class="line">           requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class="line">                   null, &quot;resume-no-history&quot;, false);</span><br><span class="line">           mLastNoHistoryActivity = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (prev != null &amp;&amp; prev != next) &#123;</span><br><span class="line">           if (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class="line">                   &amp;&amp; next != null &amp;&amp; !next.nowVisible</span><br><span class="line">                   &amp;&amp; checkKeyguardVisibility(next, true /* shouldBeVisible */,</span><br><span class="line">                           next.isTopRunningActivity())) &#123;</span><br><span class="line">               mStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);</span><br><span class="line">               if (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                       &quot;Resuming top, waiting visible to hide: &quot; + prev);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // The next activity is already visible, so hide the previous</span><br><span class="line">               // activity&apos;s windows right now so we can show the new one ASAP.</span><br><span class="line">               // We only do this if the previous is finishing, which should mean</span><br><span class="line">               // it is on top of the one being resumed so hiding it quickly</span><br><span class="line">               // is good.  Otherwise, we want to do the normal route of allowing</span><br><span class="line">               // the resumed activity to be shown so we can decide if the</span><br><span class="line">               // previous should actually be hidden depending on whether the</span><br><span class="line">               // new one is found to be full-screen or not.</span><br><span class="line">               if (prev.finishing) &#123;</span><br><span class="line">                   prev.setVisibility(false);</span><br><span class="line">                   if (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                           &quot;Not waiting for visible to hide: &quot; + prev + &quot;, waitingVisible=&quot;</span><br><span class="line">                           + mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class="line">                           + &quot;, nowVisible=&quot; + next.nowVisible);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   if (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                           &quot;Previous already visible but still waiting to hide: &quot; + prev</span><br><span class="line">                           + &quot;, waitingVisible=&quot;</span><br><span class="line">                           + mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class="line">                           + &quot;, nowVisible=&quot; + next.nowVisible);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Launching this app&apos;s activity, make sure the app is no longer</span><br><span class="line">       // considered stopped.</span><br><span class="line">       try &#123;</span><br><span class="line">           AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                   next.packageName, false, next.userId); /* TODO: Verify if correct userid */</span><br><span class="line">       &#125; catch (RemoteException e1) &#123;</span><br><span class="line">       &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Failed trying to unstop package &quot;</span><br><span class="line">                   + next.packageName + &quot;: &quot; + e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // We are starting up the next activity, so tell the window manager</span><br><span class="line">       // that the previous one will be hidden soon.  This way it can know</span><br><span class="line">       // to ignore it when computing the desired screen orientation.</span><br><span class="line">       boolean anim = true;</span><br><span class="line">       if (prev != null) &#123;</span><br><span class="line">           if (prev.finishing) &#123;</span><br><span class="line">               if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,</span><br><span class="line">                       &quot;Prepare close transition: prev=&quot; + prev);</span><br><span class="line">               if (mStackSupervisor.mNoAnimActivities.contains(prev)) &#123;</span><br><span class="line">                   anim = false;</span><br><span class="line">                   mWindowManager.prepareAppTransition(TRANSIT_NONE, false);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   mWindowManager.prepareAppTransition(prev.getTask() == next.getTask()</span><br><span class="line">                           ? TRANSIT_ACTIVITY_CLOSE</span><br><span class="line">                           : TRANSIT_TASK_CLOSE, false);</span><br><span class="line">               &#125;</span><br><span class="line">               prev.setVisibility(false);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,</span><br><span class="line">                       &quot;Prepare open transition: prev=&quot; + prev);</span><br><span class="line">               if (mStackSupervisor.mNoAnimActivities.contains(next)) &#123;</span><br><span class="line">                   anim = false;</span><br><span class="line">                   mWindowManager.prepareAppTransition(TRANSIT_NONE, false);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   mWindowManager.prepareAppTransition(prev.getTask() == next.getTask()</span><br><span class="line">                           ? TRANSIT_ACTIVITY_OPEN</span><br><span class="line">                           : next.mLaunchTaskBehind</span><br><span class="line">                                   ? TRANSIT_TASK_OPEN_BEHIND</span><br><span class="line">                                   : TRANSIT_TASK_OPEN, false);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, &quot;Prepare open transition: no previous&quot;);</span><br><span class="line">           if (mStackSupervisor.mNoAnimActivities.contains(next)) &#123;</span><br><span class="line">               anim = false;</span><br><span class="line">               mWindowManager.prepareAppTransition(TRANSIT_NONE, false);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mWindowManager.prepareAppTransition(TRANSIT_ACTIVITY_OPEN, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (anim) &#123;</span><br><span class="line">           next.applyOptionsLocked();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           next.clearOptionsLocked();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mStackSupervisor.mNoAnimActivities.clear();</span><br><span class="line">       ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class="line">       //进程存在的情况</span><br><span class="line">       if (next.app != null &amp;&amp; next.app.thread != null) &#123;</span><br><span class="line">           if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, &quot;Resume running: &quot; + next</span><br><span class="line">                   + &quot; stopped=&quot; + next.stopped + &quot; visible=&quot; + next.visible);</span><br><span class="line"></span><br><span class="line">           // If the previous activity is translucent, force a visibility update of</span><br><span class="line">           // the next activity, so that it&apos;s added to WM&apos;s opening app list, and</span><br><span class="line">           // transition animation can be set up properly.</span><br><span class="line">           // For example, pressing Home button with a translucent activity in focus.</span><br><span class="line">           // Launcher is already visible in this case. If we don&apos;t add it to opening</span><br><span class="line">           // apps, maybeUpdateTransitToWallpaper() will fail to identify this as a</span><br><span class="line">           // TRANSIT_WALLPAPER_OPEN animation, and run some funny animation.</span><br><span class="line">           final boolean lastActivityTranslucent = lastStack != null</span><br><span class="line">                   &amp;&amp; (lastStack.inMultiWindowMode()</span><br><span class="line">                   || (lastStack.mLastPausedActivity != null</span><br><span class="line">                   &amp;&amp; !lastStack.mLastPausedActivity.fullscreen));</span><br><span class="line"></span><br><span class="line">           // The contained logic must be synchronized, since we are both changing the visibility</span><br><span class="line">           // and updating the &#123;@link Configuration&#125;. &#123;@link ActivityRecord#setVisibility&#125; will</span><br><span class="line">           // ultimately cause the client code to schedule a layout. Since layouts retrieve the</span><br><span class="line">           // current &#123;@link Configuration&#125;, we must ensure that the below code updates it before</span><br><span class="line">           // the layout can occur.</span><br><span class="line">           synchronized(mWindowManager.getWindowManagerLock()) &#123;</span><br><span class="line">               //设置activity可见</span><br><span class="line">               // This activity is now becoming visible.</span><br><span class="line">               if (!next.visible || next.stopped || lastActivityTranslucent) &#123;</span><br><span class="line">                   next.setVisibility(true);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // schedule launch ticks to collect information about slow apps.</span><br><span class="line">               next.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">               ActivityRecord lastResumedActivity =</span><br><span class="line">                       lastStack == null ? null :lastStack.mResumedActivity;</span><br><span class="line">               final ActivityState lastState = next.getState();</span><br><span class="line"></span><br><span class="line">               mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">               if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to RESUMED: &quot; + next</span><br><span class="line">                       + &quot; (in existing)&quot;);</span><br><span class="line">              //设置activity resume</span><br><span class="line">               next.setState(RESUMED, &quot;resumeTopActivityInnerLocked&quot;);</span><br><span class="line"></span><br><span class="line">               mService.updateLruProcessLocked(next.app, true, null);</span><br><span class="line">               updateLRUListLocked(next);</span><br><span class="line">               mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">               // Have the window manager re-evaluate the orientation of</span><br><span class="line">               // the screen based on the new activity order.</span><br><span class="line">               boolean notUpdated = true;</span><br><span class="line"></span><br><span class="line">               if (mStackSupervisor.isFocusedStack(this)) &#123;</span><br><span class="line">                   // We have special rotation behavior when here is some active activity that</span><br><span class="line">                   // requests specific orientation or Keyguard is locked. Make sure all activity</span><br><span class="line">                   // visibilities are set correctly as well as the transition is updated if needed</span><br><span class="line">                   // to get the correct rotation behavior. Otherwise the following call to update</span><br><span class="line">                   // the orientation may cause incorrect configurations delivered to client as a</span><br><span class="line">                   // result of invisible window resize.</span><br><span class="line">                   // TODO: Remove this once visibilities are set correctly immediately when</span><br><span class="line">                   // starting an activity.</span><br><span class="line">                   notUpdated = !mStackSupervisor.ensureVisibilityAndConfig(next, mDisplayId,</span><br><span class="line">                           true /* markFrozenIfConfigChanged */, false /* deferResume */);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (notUpdated) &#123;</span><br><span class="line">                   // The configuration update wasn&apos;t able to keep the existing</span><br><span class="line">                   // instance of the activity, and instead started a new one.</span><br><span class="line">                   // We should be all done, but let&apos;s just make sure our activity</span><br><span class="line">                   // is still at the top and schedule another run if something</span><br><span class="line">                   // weird happened.</span><br><span class="line">                   ActivityRecord nextNext = topRunningActivityLocked();</span><br><span class="line">                   if (DEBUG_SWITCH || DEBUG_STATES) Slog.i(TAG_STATES,</span><br><span class="line">                           &quot;Activity config changed during resume: &quot; + next</span><br><span class="line">                                   + &quot;, new next: &quot; + nextNext);</span><br><span class="line">                   if (nextNext != next) &#123;</span><br><span class="line">                       // Do over!</span><br><span class="line">                       mStackSupervisor.scheduleResumeTopActivities();</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (!next.visible || next.stopped) &#123;</span><br><span class="line">                       next.setVisibility(true);</span><br><span class="line">                   &#125;</span><br><span class="line">                   next.completeResumeLocked();</span><br><span class="line">                   if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                   //分发所有pending结果</span><br><span class="line">                   final ClientTransaction transaction = ClientTransaction.obtain(next.app.thread,</span><br><span class="line">                           next.appToken);</span><br><span class="line">                   // Deliver all pending results.</span><br><span class="line">                   ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">                   if (a != null) &#123;</span><br><span class="line">                       final int N = a.size();</span><br><span class="line">                       if (!next.finishing &amp;&amp; N &gt; 0) &#123;</span><br><span class="line">                           if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                                   &quot;Delivering results to &quot; + next + &quot;: &quot; + a);</span><br><span class="line">                           transaction.addCallback(ActivityResultItem.obtain(a));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   if (next.newIntents != null) &#123;</span><br><span class="line">                       transaction.addCallback(NewIntentItem.obtain(next.newIntents,</span><br><span class="line">                               false /* andPause */));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   // Well the app will no longer be stopped.</span><br><span class="line">                   // Clear app token stopped state in window manager if needed.</span><br><span class="line">                   next.notifyAppResumed(next.stopped);</span><br><span class="line"></span><br><span class="line">                   EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY, next.userId,</span><br><span class="line">                           System.identityHashCode(next), next.getTask().taskId,</span><br><span class="line">                           next.shortComponentName);</span><br><span class="line"></span><br><span class="line">                   next.sleeping = false;</span><br><span class="line">                   mService.getAppWarningsLocked().onResumeActivity(next);</span><br><span class="line">                   mService.showAskCompatModeDialogLocked(next);</span><br><span class="line">                   next.app.pendingUiClean = true;</span><br><span class="line">                   next.app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">                   next.clearOptionsLocked();</span><br><span class="line">                   //处罚onResume</span><br><span class="line">                   transaction.setLifecycleStateRequest(</span><br><span class="line">                           ResumeActivityItem.obtain(next.app.repProcState,</span><br><span class="line">                                   mService.isNextTransitionForward()));</span><br><span class="line">                   mService.getLifecycleManager().scheduleTransaction(transaction);</span><br><span class="line"></span><br><span class="line">                   if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Resumed &quot;</span><br><span class="line">                           + next);</span><br><span class="line">               &#125; catch (Exception e) &#123;</span><br><span class="line">                   // Whoops, need to restart this activity!</span><br><span class="line">                   if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Resume failed; resetting state to &quot;</span><br><span class="line">                           + lastState + &quot;: &quot; + next);</span><br><span class="line">                   next.setState(lastState, &quot;resumeTopActivityInnerLocked&quot;);</span><br><span class="line"></span><br><span class="line">                   // lastResumedActivity being non-null implies there is a lastStack present.</span><br><span class="line">                   if (lastResumedActivity != null) &#123;</span><br><span class="line">                       lastResumedActivity.setState(RESUMED, &quot;resumeTopActivityInnerLocked&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   Slog.i(TAG, &quot;Restarting because process died: &quot; + next);</span><br><span class="line">                   if (!next.hasBeenLaunched) &#123;</span><br><span class="line">                       next.hasBeenLaunched = true;</span><br><span class="line">                   &#125; else  if (SHOW_APP_STARTING_PREVIEW &amp;&amp; lastStack != null</span><br><span class="line">                           &amp;&amp; lastStack.isTopStackOnDisplay()) &#123;</span><br><span class="line">                       next.showStartingWindow(null /* prev */, false /* newTask */,</span><br><span class="line">                               false /* taskSwitch */);</span><br><span class="line">                   &#125;</span><br><span class="line">                   mStackSupervisor.startSpecificActivityLocked(next, true, false);</span><br><span class="line">                   if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // From this point on, if something goes wrong there is no way</span><br><span class="line">           // to recover the activity.</span><br><span class="line">           try &#123;</span><br><span class="line">               next.completeResumeLocked();</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               // If any exception gets thrown, toss away this</span><br><span class="line">               // activity and try the next one.</span><br><span class="line">               Slog.w(TAG, &quot;Exception thrown during resume of &quot; + next, e);</span><br><span class="line">               requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,</span><br><span class="line">                       &quot;resume-exception&quot;, true);</span><br><span class="line">               if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           //需要重新启动Activity</span><br><span class="line">           // Whoops, need to restart this activity!</span><br><span class="line">           if (!next.hasBeenLaunched) &#123;</span><br><span class="line">               next.hasBeenLaunched = true;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                   next.showStartingWindow(null /* prev */, false /* newTask */,</span><br><span class="line">                           false /* taskSwich */);</span><br><span class="line">               &#125;</span><br><span class="line">               if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, &quot;Restarting: &quot; + next);</span><br><span class="line">           &#125;</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Restarting &quot; + next);</span><br><span class="line">           //见2.14节</span><br><span class="line">           mStackSupervisor.startSpecificActivityLocked(next, true, true);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>主要工作如下：</p>
<ul>
<li>当找不到resume的activity时，则直接回到桌面</li>
<li>当resume状态activity不为空,则执行startPausingLocked,暂停该Activity</li>
<li>当Activity之前启动过，则直接resume，否则执行startSpecificActivityLocked，2.14节将继续讨论。</li>
</ul>
<h4 id="2-13-1-AS-resumeTopActivityInNextFocusableStack"><a href="#2-13-1-AS-resumeTopActivityInNextFocusableStack" class="headerlink" title="2.13.1 AS.resumeTopActivityInNextFocusableStack"></a>2.13.1 AS.resumeTopActivityInNextFocusableStack</h4><p>[-&gt;ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private boolean resumeTopActivityInNextFocusableStack(ActivityRecord prev,</span><br><span class="line">           ActivityOptions options, String reason) &#123;</span><br><span class="line">       if (adjustFocusToNextFocusableStack(reason)) &#123;</span><br><span class="line">           //如果该栈没有全屏，则尝试下一个可见的stack</span><br><span class="line">           // Try to move focus to the next visible stack with a running activity if this</span><br><span class="line">           // stack is not covering the entire screen or is on a secondary display (with no home</span><br><span class="line">           // stack).</span><br><span class="line">           return mStackSupervisor.resumeFocusedStackTopActivityLocked(</span><br><span class="line">                   mStackSupervisor.getFocusedStack(), prev, null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Let&apos;s just start up the Launcher...</span><br><span class="line">       ActivityOptions.abort(options);</span><br><span class="line">       if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">               &quot;resumeTopActivityInNextFocusableStack: &quot; + reason + &quot;, go home&quot;);</span><br><span class="line">       if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">       // Only resume home if on home display</span><br><span class="line">       //启动桌面activity</span><br><span class="line">       return isOnHomeDisplay() &amp;&amp;</span><br><span class="line">               mStackSupervisor.resumeHomeStackTask(prev, reason);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当找不到需要的resume的Activity时，直接回到桌面</p>
<h4 id="2-13-2-AS-pauseBackStacks"><a href="#2-13-2-AS-pauseBackStacks" class="headerlink" title="2.13.2 AS.pauseBackStacks"></a>2.13.2 AS.pauseBackStacks</h4><p>[-&gt;ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Pause all activities in either all of the stacks or just the back stacks.</span><br><span class="line">    * @param userLeaving Passed to pauseActivity() to indicate whether to call onUserLeaving().</span><br><span class="line">    * @param resuming The resuming activity.</span><br><span class="line">    * @param dontWait The resuming activity isn&apos;t going to wait for all activities to be paused</span><br><span class="line">    *                 before resuming.</span><br><span class="line">    * @return true if any activity was paused as a result of this call.</span><br><span class="line">    */</span><br><span class="line">   boolean pauseBackStacks(boolean userLeaving, ActivityRecord resuming, boolean dontWait) &#123;</span><br><span class="line">       boolean someActivityPaused = false;</span><br><span class="line">       for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123;</span><br><span class="line">           final ActivityDisplay display = mActivityDisplays.valueAt(displayNdx);</span><br><span class="line">           for (int stackNdx = display.getChildCount() - 1; stackNdx &gt;= 0; --stackNdx) &#123;</span><br><span class="line">               final ActivityStack stack = display.getChildAt(stackNdx);</span><br><span class="line">               if (!isFocusedStack(stack) &amp;&amp; stack.getResumedActivity() != null) &#123;</span><br><span class="line">                   if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;pauseBackStacks: stack=&quot; + stack +</span><br><span class="line">                           &quot; mResumedActivity=&quot; + stack.getResumedActivity());</span><br><span class="line">                   //见2.13.2节</span><br><span class="line">                   someActivityPaused |= stack.startPausingLocked(userLeaving, false, resuming,</span><br><span class="line">                           dontWait);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return someActivityPaused;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>暂停所有处于后台栈的所有Activity</p>
<h4 id="2-13-3-AS-startPausingLocked"><a href="#2-13-3-AS-startPausingLocked" class="headerlink" title="2.13.3 AS.startPausingLocked"></a>2.13.3 AS.startPausingLocked</h4><p>[-&gt;ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping,</span><br><span class="line">            ActivityRecord resuming, boolean pauseImmediately) &#123;</span><br><span class="line">        if (mPausingActivity != null) &#123;</span><br><span class="line">            Slog.wtf(TAG, &quot;Going to pause when pause is already pending for &quot; + mPausingActivity</span><br><span class="line">                    + &quot; state=&quot; + mPausingActivity.getState());</span><br><span class="line">            if (!shouldSleepActivities()) &#123;</span><br><span class="line">                // Avoid recursion among check for sleep and complete pause during sleeping.</span><br><span class="line">                // Because activity will be paused immediately after resume, just let pause</span><br><span class="line">                // be completed by the order of activity paused from clients.</span><br><span class="line">                completePauseLocked(false, resuming);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityRecord prev = mResumedActivity;</span><br><span class="line"></span><br><span class="line">        if (prev == null) &#123;</span><br><span class="line">            if (resuming == null) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Trying to pause when nothing is resumed&quot;);</span><br><span class="line">                mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (prev == resuming) &#123;</span><br><span class="line">            Slog.wtf(TAG, &quot;Trying to pause activity that is in process of being resumed&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSING: &quot; + prev);</span><br><span class="line">        else if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Start pausing: &quot; + prev);</span><br><span class="line">        mPausingActivity = prev;</span><br><span class="line">        mLastPausedActivity = prev;</span><br><span class="line">        mLastNoHistoryActivity = (prev.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_HISTORY) != 0</span><br><span class="line">                || (prev.info.flags &amp; ActivityInfo.FLAG_NO_HISTORY) != 0 ? prev : null;</span><br><span class="line">        prev.setState(PAUSING, &quot;startPausingLocked&quot;);</span><br><span class="line">        prev.getTask().touchActiveTime();</span><br><span class="line">        clearLaunchTime(prev);</span><br><span class="line"></span><br><span class="line">        mStackSupervisor.getActivityMetricsLogger().stopFullyDrawnTraceIfNeeded();</span><br><span class="line"></span><br><span class="line">        mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">        if (prev.app != null &amp;&amp; prev.app.thread != null) &#123;</span><br><span class="line">            if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev);</span><br><span class="line">            try &#123;</span><br><span class="line">                EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev),</span><br><span class="line">                        prev.shortComponentName, &quot;userLeaving=&quot; + userLeaving);</span><br><span class="line">                mService.updateUsageStats(prev, false);</span><br><span class="line">                //暂停目标Activity</span><br><span class="line">                mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,</span><br><span class="line">                        PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                                prev.configChangeFlags, pauseImmediately));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // Ignore exception, if process died other code will cleanup.</span><br><span class="line">                Slog.w(TAG, &quot;Exception thrown during pause&quot;, e);</span><br><span class="line">                mPausingActivity = null;</span><br><span class="line">                mLastPausedActivity = null;</span><br><span class="line">                mLastNoHistoryActivity = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mPausingActivity = null;</span><br><span class="line">            mLastPausedActivity = null;</span><br><span class="line">            mLastNoHistoryActivity = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we are not going to sleep, we want to ensure the device is</span><br><span class="line">        // awake until the next activity is started.</span><br><span class="line">        if (!uiSleeping &amp;&amp; !mService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">            mStackSupervisor.acquireLaunchWakelock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mPausingActivity != null) &#123;</span><br><span class="line">            // Have the window manager pause its key dispatching until the new</span><br><span class="line">            // activity has started.  If we&apos;re pausing the activity just because</span><br><span class="line">            // the screen is being turned off and the UI is sleeping, don&apos;t interrupt</span><br><span class="line">            // key dispatch; the same activity will pick it up again on wakeup.</span><br><span class="line">            if (!uiSleeping) &#123;</span><br><span class="line">                prev.pauseKeyDispatchingLocked();</span><br><span class="line">            &#125; else if (DEBUG_PAUSE) &#123;</span><br><span class="line">                 Slog.v(TAG_PAUSE, &quot;Key dispatch not paused for screen off&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (pauseImmediately) &#123;</span><br><span class="line">                // If the caller said they don&apos;t want to wait for the pause, then complete</span><br><span class="line">                // the pause now.</span><br><span class="line">                completePauseLocked(false, resuming);</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //500ms,执行暂停超时的消息</span><br><span class="line">                schedulePauseTimeout(prev);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // This activity failed to schedule the</span><br><span class="line">            // pause, so just treat it as being paused now.</span><br><span class="line">            if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Activity not running, resuming next.&quot;);</span><br><span class="line">            if (resuming == null) &#123;  //调度失败，则认为暂停结束开始执行resume操作</span><br><span class="line">                mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过LifecycleManager的方式来暂停Activity操作。对于pauseImmediately= true则执行completePauseLocked操作，否则等待app通知500ms超时再执行该方法。</p>
<h4 id="2-13-4-AS-completePauseLocked"><a href="#2-13-4-AS-completePauseLocked" class="headerlink" title="2.13.4 AS.completePauseLocked"></a>2.13.4 AS.completePauseLocked</h4><p>[-&gt;ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">private void completePauseLocked(boolean resumeNext, ActivityRecord resuming) &#123;</span><br><span class="line">       ActivityRecord prev = mPausingActivity;</span><br><span class="line">       if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Complete pause: &quot; + prev);</span><br><span class="line"></span><br><span class="line">       if (prev != null) &#123;</span><br><span class="line">           prev.setWillCloseOrEnterPip(false);</span><br><span class="line">           final boolean wasStopping = prev.isState(STOPPING);</span><br><span class="line">           prev.setState(PAUSED, &quot;completePausedLocked&quot;);</span><br><span class="line">           if (prev.finishing) &#123;</span><br><span class="line">               if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Executing finish of activity: &quot; + prev);</span><br><span class="line">               prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE, false,</span><br><span class="line">                       &quot;completedPausedLocked&quot;);</span><br><span class="line">           &#125; else if (prev.app != null) &#123;</span><br><span class="line">               if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueue pending stop if needed: &quot; + prev</span><br><span class="line">                       + &quot; wasStopping=&quot; + wasStopping + &quot; visible=&quot; + prev.visible);</span><br><span class="line">               if (mStackSupervisor.mActivitiesWaitingForVisibleActivity.remove(prev)) &#123;</span><br><span class="line">                   if (DEBUG_SWITCH || DEBUG_PAUSE) Slog.v(TAG_PAUSE,</span><br><span class="line">                           &quot;Complete pause, no longer waiting: &quot; + prev);</span><br><span class="line">               &#125;</span><br><span class="line">               if (prev.deferRelaunchUntilPaused) &#123;</span><br><span class="line">                   // Complete the deferred relaunch that was waiting for pause to complete.</span><br><span class="line">                   if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Re-launching after pause: &quot; + prev);</span><br><span class="line">                   prev.relaunchActivityLocked(false /* andResume */,</span><br><span class="line">                           prev.preserveWindowOnDeferredRelaunch);</span><br><span class="line">               &#125; else if (wasStopping) &#123;</span><br><span class="line">                   // We are also stopping, the stop request must have gone soon after the pause.</span><br><span class="line">                   // We can&apos;t clobber it, because the stop confirmation will not be handled.</span><br><span class="line">                   // We don&apos;t need to schedule another stop, we only need to let it happen.</span><br><span class="line">                   prev.setState(STOPPING, &quot;completePausedLocked&quot;);</span><br><span class="line">               &#125; else if (!prev.visible || shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">                   // Clear out any deferred client hide we might currently have.</span><br><span class="line">                   prev.setDeferHidingClient(false);</span><br><span class="line">                   // If we were visible then resumeTopActivities will release resources before</span><br><span class="line">                   // stopping.</span><br><span class="line">                   addToStopping(prev, true /* scheduleIdle */, false /* idleDelayed */);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;App died during pause, not stopping: &quot; + prev);</span><br><span class="line">               prev = null;</span><br><span class="line">           &#125;</span><br><span class="line">           // It is possible the activity was freezing the screen before it was paused.</span><br><span class="line">           // In that case go ahead and remove the freeze this activity has on the screen</span><br><span class="line">           // since it is no longer visible.</span><br><span class="line">           if (prev != null) &#123;</span><br><span class="line">               prev.stopFreezingScreenLocked(true /*force*/);</span><br><span class="line">           &#125;</span><br><span class="line">           mPausingActivity = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (resumeNext) &#123;</span><br><span class="line">           final ActivityStack topStack = mStackSupervisor.getFocusedStack();</span><br><span class="line">           if (!topStack.shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">               mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               checkReadyForSleep();</span><br><span class="line">               ActivityRecord top = topStack.topRunningActivityLocked();</span><br><span class="line">               if (top == null || (prev != null &amp;&amp; top != prev)) &#123;</span><br><span class="line">                   // If there are no more activities available to run, do resume anyway to start</span><br><span class="line">                   // something. Also if the top activity on the stack is not the just paused</span><br><span class="line">                   // activity, we need to go ahead and resume it to ensure we complete an</span><br><span class="line">                   // in-flight app switch.</span><br><span class="line">                   mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (prev != null) &#123;</span><br><span class="line">           prev.resumeKeyDispatchingLocked();</span><br><span class="line"></span><br><span class="line">           if (prev.app != null &amp;&amp; prev.cpuTimeAtResume &gt; 0</span><br><span class="line">                   &amp;&amp; mService.mBatteryStatsService.isOnBattery()) &#123;</span><br><span class="line">               long diff = mService.mProcessCpuTracker.getCpuTimeForPid(prev.app.pid)</span><br><span class="line">                       - prev.cpuTimeAtResume;</span><br><span class="line">               if (diff &gt; 0) &#123;</span><br><span class="line">                   BatteryStatsImpl bsi = mService.mBatteryStatsService.getActiveStatistics();</span><br><span class="line">                   synchronized (bsi) &#123;</span><br><span class="line">                       BatteryStatsImpl.Uid.Proc ps =</span><br><span class="line">                               bsi.getProcessStatsLocked(prev.info.applicationInfo.uid,</span><br><span class="line">                                       prev.info.packageName);</span><br><span class="line">                       if (ps != null) &#123;</span><br><span class="line">                           ps.addForegroundTimeLocked(diff);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           prev.cpuTimeAtResume = 0; // reset it</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Notify when the task stack has changed, but only if visibilities changed (not just</span><br><span class="line">       // focus). Also if there is an active pinned stack - we always want to notify it about</span><br><span class="line">       // task stack changes, because its positioning may depend on it.</span><br><span class="line">       if (mStackSupervisor.mAppVisibilitiesChangedSinceLastPause</span><br><span class="line">               || getDisplay().hasPinnedStack()) &#123;</span><br><span class="line">           mService.mTaskChangeNotificationController.notifyTaskStackChanged();</span><br><span class="line">           mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mStackSupervisor.ensureActivitiesVisibleLocked(resuming, 0, !PRESERVE_WINDOWS);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>暂停Activity完成后，修改暂停activity状态</p>
<h3 id="2-14-ASS-startSpecificActivityLocked"><a href="#2-14-ASS-startSpecificActivityLocked" class="headerlink" title="2.14  ASS.startSpecificActivityLocked"></a>2.14  ASS.startSpecificActivityLocked</h3><p>[-&gt;ActivityStackSupervisor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">           boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">       // Is this activity&apos;s application already running?</span><br><span class="line">       ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">               r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">       if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                       || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                   // Don&apos;t add this if it is a platform component that is marked</span><br><span class="line">                   // to run in multiple processes, because this is actually</span><br><span class="line">                   // part of the framework so doesn&apos;t make sense to track as a</span><br><span class="line">                   // separate apk in the process.</span><br><span class="line">                   app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                           mService.mProcessStats);</span><br><span class="line">               &#125;</span><br><span class="line">               //真正启动Activity，见2.18节</span><br><span class="line">               realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">               return;</span><br><span class="line">           &#125; catch (RemoteException e) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                       + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // If a dead object exception was thrown -- fall through to</span><br><span class="line">           // restart the application.</span><br><span class="line">       &#125;</span><br><span class="line">       //当进程不存在，则创建进程</span><br><span class="line">       mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">               &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-15-AMS-startProcessLocked"><a href="#2-15-AMS-startProcessLocked" class="headerlink" title="2.15 AMS.startProcessLocked"></a>2.15 AMS.startProcessLocked</h3><p>这个过程为启动Android进程的过程，在文章Android进程启动过程解析，详细描述了startProcessLocked整个过程，创建完成新进程之后，在新进程中通过binder ipc方式后调用到AMS.attachApplicationLocked。</p>
<p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">         int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">        ...</span><br><span class="line">         if (app.isolatedEntryPoint != null) &#123;</span><br><span class="line">             // This is an isolated process which should just call an entry point instead of</span><br><span class="line">             // being bound to an application.</span><br><span class="line">             thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">         &#125; else if (app.instr != null) &#123;</span><br><span class="line">             thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                     app.instr.mClass,</span><br><span class="line">                     profilerInfo, app.instr.mArguments,</span><br><span class="line">                     app.instr.mWatcher,</span><br><span class="line">                     app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                     mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                     isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                     new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                     getCommonServicesLocked(app.isolated),</span><br><span class="line">                     mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                     buildSerial, isAutofillCompatEnabled);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                     null, null, null, testMode,</span><br><span class="line">                     mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                     isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                     new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                     getCommonServicesLocked(app.isolated),</span><br><span class="line">                     mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                     buildSerial, isAutofillCompatEnabled);</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">     // See if the top visible activity is waiting to run in this process...</span><br><span class="line">     if (normalMode) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                 didSomething = true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">             Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">             badApp = true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在bindApplication后，调用了ASS.attachApplicationLocked。</p>
<h3 id="2-16-ASS-attachApplicationLocked"><a href="#2-16-ASS-attachApplicationLocked" class="headerlink" title="2.16 ASS.attachApplicationLocked"></a>2.16 ASS.attachApplicationLocked</h3><p>[-&gt;ActivityStackSupervisor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">       final String processName = app.processName;</span><br><span class="line">       boolean didSomething = false;</span><br><span class="line">       for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123;</span><br><span class="line">           final ActivityDisplay display = mActivityDisplays.valueAt(displayNdx);</span><br><span class="line">           for (int stackNdx = display.getChildCount() - 1; stackNdx &gt;= 0; --stackNdx) &#123;</span><br><span class="line">               final ActivityStack stack = display.getChildAt(stackNdx);</span><br><span class="line">               if (!isFocusedStack(stack)) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               stack.getAllRunningVisibleActivitiesLocked(mTmpActivityList);</span><br><span class="line">               //获取前台栈顶第一个非finishing的Activity</span><br><span class="line">               final ActivityRecord top = stack.topRunningActivityLocked();</span><br><span class="line">               final int size = mTmpActivityList.size();</span><br><span class="line">               for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                   final ActivityRecord activity = mTmpActivityList.get(i);</span><br><span class="line">                   if (activity.app == null &amp;&amp; app.uid == activity.info.applicationInfo.uid</span><br><span class="line">                           &amp;&amp; processName.equals(activity.processName)) &#123;</span><br><span class="line">                       try &#123;</span><br><span class="line">                           //真正启动Activity，见2.15节</span><br><span class="line">                           if (realStartActivityLocked(activity, app,</span><br><span class="line">                                   top == activity /* andResume */, true /* checkConfig */)) &#123;</span><br><span class="line">                               didSomething = true;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; catch (RemoteException e) &#123;</span><br><span class="line">                           Slog.w(TAG, &quot;Exception in new application when starting activity &quot;</span><br><span class="line">                                   + top.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">                           throw e;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!didSomething) &#123;</span><br><span class="line">           //启动Activity不成功，确保有可见的Activity</span><br><span class="line">           ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">       &#125;</span><br><span class="line">       return didSomething;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-17-ASS-realStartActivityLocked"><a href="#2-17-ASS-realStartActivityLocked" class="headerlink" title="2.17 ASS.realStartActivityLocked"></a>2.17 ASS.realStartActivityLocked</h3><p>[-&gt;ActivityStackSupervisor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">          boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">      if (!allPausedActivitiesComplete()) &#123;</span><br><span class="line">          //如果Activity没有pausing完成则返回</span><br><span class="line">          // While there are activities pausing we skipping starting any new activities until</span><br><span class="line">          // pauses are complete. NOTE: that we also do this for activities that are starting in</span><br><span class="line">          // the paused state because they will first be resumed then paused on the client side.</span><br><span class="line">          if (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,</span><br><span class="line">                  &quot;realStartActivityLocked: Skipping start of r=&quot; + r</span><br><span class="line">                  + &quot; some activities pausing...&quot;);</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final TaskRecord task = r.getTask();</span><br><span class="line">      final ActivityStack stack = task.getStack();</span><br><span class="line"></span><br><span class="line">      beginDeferResume();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          r.startFreezingScreenLocked(app, 0);</span><br><span class="line">          //启动tick，收集应用启动慢的信息</span><br><span class="line">          // schedule launch ticks to collect information about slow apps.</span><br><span class="line">          r.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">          r.setProcess(app);</span><br><span class="line"></span><br><span class="line">          if (getKeyguardController().isKeyguardLocked()) &#123;</span><br><span class="line">              r.notifyUnknownVisibilityLaunched();</span><br><span class="line">          &#125;</span><br><span class="line">         </span><br><span class="line">          // Have the window manager re-evaluate the orientation of the screen based on the new</span><br><span class="line">          // activity order.  Note that as a result of this, it can call back into the activity</span><br><span class="line">          // manager with a new orientation.  We don&apos;t care about that, because the activity is</span><br><span class="line">          // not currently running so we are just restarting it anyway.</span><br><span class="line">          if (checkConfig) &#123;</span><br><span class="line">              // Deferring resume here because we&apos;re going to launch new activity shortly.</span><br><span class="line">              // We don&apos;t want to perform a redundant launch of the same record while ensuring</span><br><span class="line">              // configurations and trying to resume top activity of focused stack.</span><br><span class="line">              ensureVisibilityAndConfig(r, r.getDisplayId(),</span><br><span class="line">                      false /* markFrozenIfConfigChanged */, true /* deferResume */);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (r.getStack().checkKeyguardVisibility(r, true /* shouldBeVisible */,</span><br><span class="line">                  true /* isTop */)) &#123;</span><br><span class="line">              // We only set the visibility to true if the activity is allowed to be visible</span><br><span class="line">              // based on</span><br><span class="line">              // keyguard state. This avoids setting this into motion in window manager that is</span><br><span class="line">              // later cancelled due to later calls to ensure visible activities that set</span><br><span class="line">              // visibility back to false.</span><br><span class="line">              r.setVisibility(true);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final int applicationInfoUid =</span><br><span class="line">                  (r.info.applicationInfo != null) ? r.info.applicationInfo.uid : -1;</span><br><span class="line">          if ((r.userId != app.userId) || (r.appInfo.uid != applicationInfoUid)) &#123;</span><br><span class="line">              Slog.wtf(TAG,</span><br><span class="line">                      &quot;User ID for activity changing for &quot; + r</span><br><span class="line">                              + &quot; appInfo.uid=&quot; + r.appInfo.uid</span><br><span class="line">                              + &quot; info.ai.uid=&quot; + applicationInfoUid</span><br><span class="line">                              + &quot; old=&quot; + r.app + &quot; new=&quot; + app);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          app.waitingToKill = null;</span><br><span class="line">          r.launchCount++;</span><br><span class="line">          r.lastLaunchTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">          if (DEBUG_ALL) Slog.v(TAG, &quot;Launching: &quot; + r);</span><br><span class="line"></span><br><span class="line">          int idx = app.activities.indexOf(r);</span><br><span class="line">          if (idx &lt; 0) &#123;</span><br><span class="line">              app.activities.add(r);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          mService.updateLruProcessLocked(app, true, null);</span><br><span class="line">          mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">          final LockTaskController lockTaskController = mService.getLockTaskController();</span><br><span class="line">          if (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE</span><br><span class="line">                  || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV</span><br><span class="line">                  || (task.mLockTaskAuth == LOCK_TASK_AUTH_WHITELISTED</span><br><span class="line">                          &amp;&amp; lockTaskController.getLockTaskModeState()</span><br><span class="line">                                  == LOCK_TASK_MODE_LOCKED)) &#123;</span><br><span class="line">              lockTaskController.startLockTaskMode(task, false, 0 /* blank UID */);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              if (app.thread == null) &#123;</span><br><span class="line">                  throw new RemoteException();</span><br><span class="line">              &#125;</span><br><span class="line">              List&lt;ResultInfo&gt; results = null;</span><br><span class="line">              List&lt;ReferrerIntent&gt; newIntents = null;</span><br><span class="line">              if (andResume) &#123;</span><br><span class="line">                  // We don&apos;t need to deliver new intents and/or set results if activity is going</span><br><span class="line">                  // to pause immediately after launch.</span><br><span class="line">                  results = r.results;</span><br><span class="line">                  newIntents = r.newIntents;</span><br><span class="line">              &#125;</span><br><span class="line">              if (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                      &quot;Launching: &quot; + r + &quot; icicle=&quot; + r.icicle + &quot; with results=&quot; + results</span><br><span class="line">                              + &quot; newIntents=&quot; + newIntents + &quot; andResume=&quot; + andResume);</span><br><span class="line">              EventLog.writeEvent(EventLogTags.AM_RESTART_ACTIVITY, r.userId,</span><br><span class="line">                      System.identityHashCode(r), task.taskId, r.shortComponentName);</span><br><span class="line">              if (r.isActivityTypeHome()) &#123;</span><br><span class="line">                  //home进程是该栈的根进程</span><br><span class="line">                  // Home process is the root process of the task.</span><br><span class="line">                  mService.mHomeProcess = task.mActivities.get(0).app;</span><br><span class="line">              &#125;</span><br><span class="line">              mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                      PackageManager.NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">              r.sleeping = false;</span><br><span class="line">              r.forceNewConfig = false;</span><br><span class="line">              mService.getAppWarningsLocked().onStartActivity(r);</span><br><span class="line">              mService.showAskCompatModeDialogLocked(r);</span><br><span class="line">              r.compat = mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);</span><br><span class="line">              ProfilerInfo profilerInfo = null;</span><br><span class="line">              if (mService.mProfileApp != null &amp;&amp; mService.mProfileApp.equals(app.processName)) &#123;</span><br><span class="line">                  if (mService.mProfileProc == null || mService.mProfileProc == app) &#123;</span><br><span class="line">                      mService.mProfileProc = app;</span><br><span class="line">                      ProfilerInfo profilerInfoSvc = mService.mProfilerInfo;</span><br><span class="line">                      if (profilerInfoSvc != null &amp;&amp; profilerInfoSvc.profileFile != null) &#123;</span><br><span class="line">                          if (profilerInfoSvc.profileFd != null) &#123;</span><br><span class="line">                              try &#123;</span><br><span class="line">                                  profilerInfoSvc.profileFd = profilerInfoSvc.profileFd.dup();</span><br><span class="line">                              &#125; catch (IOException e) &#123;</span><br><span class="line">                                  profilerInfoSvc.closeFd();</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          profilerInfo = new ProfilerInfo(profilerInfoSvc);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              app.hasShownUi = true;</span><br><span class="line">              app.pendingUiClean = true;</span><br><span class="line">              //将该进程设置为前台进程PROCESS_STATE_TOP</span><br><span class="line">              app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">              // Because we could be starting an Activity in the system process this may not go</span><br><span class="line">              // across a Binder interface which would create a new Configuration. Consequently</span><br><span class="line">              // we have to always create a new Configuration here.</span><br><span class="line"></span><br><span class="line">              final MergedConfiguration mergedConfiguration = new MergedConfiguration(</span><br><span class="line">                      mService.getGlobalConfiguration(), r.getMergedOverrideConfiguration());</span><br><span class="line">              r.setLastReportedConfiguration(mergedConfiguration);</span><br><span class="line"></span><br><span class="line">              logIfTransactionTooLarge(r.intent, r.icicle);</span><br><span class="line"></span><br><span class="line">              //创建Activity启动事务</span><br><span class="line">              // Create activity launch transaction.</span><br><span class="line">              final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">                      r.appToken);</span><br><span class="line">              clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">                      System.identityHashCode(r), r.info,</span><br><span class="line">                      // TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">                      // and override configs.</span><br><span class="line">                      mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                      mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                      r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                      r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                      profilerInfo));</span><br><span class="line"></span><br><span class="line">              //设置目标事务的状态为onResume</span><br><span class="line">              // Set desired final state.</span><br><span class="line">              final ActivityLifecycleItem lifecycleItem;</span><br><span class="line">              if (andResume) &#123;</span><br><span class="line">                  lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">              &#125;</span><br><span class="line">              clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">              //通过transaciton方式开始activity生命周期，onCreate,onStart,onResume</span><br><span class="line">              // Schedule transaction.</span><br><span class="line">              mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              if ((app.info.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0</span><br><span class="line">                      &amp;&amp; mService.mHasHeavyWeightFeature) &#123;</span><br><span class="line">                  //处理heavy-weight进程</span><br><span class="line">                  // This may be a heavy-weight process!  Note that the package</span><br><span class="line">                  // manager will ensure that only activity can run in the main</span><br><span class="line">                  // process of the .apk, which is the only thing that will be</span><br><span class="line">                  // considered heavy-weight.</span><br><span class="line">                  if (app.processName.equals(app.info.packageName)) &#123;</span><br><span class="line">                      if (mService.mHeavyWeightProcess != null</span><br><span class="line">                              &amp;&amp; mService.mHeavyWeightProcess != app) &#123;</span><br><span class="line">                          Slog.w(TAG, &quot;Starting new heavy weight process &quot; + app</span><br><span class="line">                                  + &quot; when already running &quot;</span><br><span class="line">                                  + mService.mHeavyWeightProcess);</span><br><span class="line">                      &#125;</span><br><span class="line">                      mService.mHeavyWeightProcess = app;</span><br><span class="line">                      Message msg = mService.mHandler.obtainMessage(</span><br><span class="line">                              ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);</span><br><span class="line">                      msg.obj = r;</span><br><span class="line">                      mService.mHandler.sendMessage(msg);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125; catch (RemoteException e) &#123;</span><br><span class="line">              if (r.launchFailed) &#123;</span><br><span class="line">                  //第二次启动失败，则结束该Activity</span><br><span class="line">                  // This is the second time we failed -- finish activity</span><br><span class="line">                  // and give up.</span><br><span class="line">                  Slog.e(TAG, &quot;Second failure launching &quot;</span><br><span class="line">                          + r.intent.getComponent().flattenToShortString()</span><br><span class="line">                          + &quot;, giving up&quot;, e);</span><br><span class="line">                  mService.appDiedLocked(app);</span><br><span class="line">                  stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,</span><br><span class="line">                          &quot;2nd-crash&quot;, false);</span><br><span class="line">                  return false;</span><br><span class="line">              &#125;</span><br><span class="line">              //第一次启动失败，则重启进程</span><br><span class="line">              // This is the first time we failed -- restart process and</span><br><span class="line">              // retry.</span><br><span class="line">              r.launchFailed = true;</span><br><span class="line">              app.activities.remove(r);</span><br><span class="line">              throw e;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          endDeferResume();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      r.launchFailed = false;</span><br><span class="line">       //将该进程加入到mLruActivity队列顶部</span><br><span class="line">      if (stack.updateLRUListLocked(r)) &#123;</span><br><span class="line">          Slog.w(TAG, &quot;Activity &quot; + r + &quot; being launched, but already in LRU list&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // TODO(lifecycler): Resume or pause requests are done as part of launch transaction,</span><br><span class="line">      // so updating the state should be done accordingly.</span><br><span class="line">      if (andResume &amp;&amp; readyToResume()) &#123;</span><br><span class="line">          // As part of the process of launching, ActivityThread also performs</span><br><span class="line">          // a resume.</span><br><span class="line">          stack.minimalResumeActivityLocked(r);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          // This activity is not starting in the resumed state... which should look like we asked</span><br><span class="line">          // it to pause+stop (but remain visible), and it has done so and reported back the</span><br><span class="line">          // current icicle and other state.</span><br><span class="line">          if (DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                  &quot;Moving to PAUSED: &quot; + r + &quot; (starting in paused state)&quot;);</span><br><span class="line">          r.setState(PAUSED, &quot;realStartActivityLocked&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Launch the new version setup screen if needed.  We do this -after-</span><br><span class="line">      // launching the initial activity (that is, home), so that it can have</span><br><span class="line">      // a chance to initialize itself while in the background, making the</span><br><span class="line">      // switch back to it faster and look better.</span><br><span class="line">      if (isFocusedStack(stack)) &#123;</span><br><span class="line">          //当系统发生更新时，只会执行一次的用户向导</span><br><span class="line">          mService.getActivityStartController().startSetupActivity();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Update any services we are bound to that might care about whether</span><br><span class="line">      // their client may have activities.</span><br><span class="line">      if (r.app != null) &#123;</span><br><span class="line">          //更新所有与该Activity具有绑定关系的Service连接</span><br><span class="line">          mService.mServices.updateServiceConnectionActivitiesLocked(r.app);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Android9.0之后，引入了ClientLifecycleManager和ClientTransactionHandler来辅助管理Activity的生命周期。</p>
<p>一个生命周期都抽象出了一个对象。</p>
<p>onCreate (LaunchActivityItem),onResume(ResumeActivityItem), </p>
<p>onPause(PauseActivityItem)，onStop(StopActivityItem),onDestrory(DestroyActivityItem)</p>
<h3 id="2-18-CLM-scheduleTransaction"><a href="#2-18-CLM-scheduleTransaction" class="headerlink" title="2.18  CLM.scheduleTransaction"></a>2.18  CLM.scheduleTransaction</h3><p>[-&gt;ClientLifecycleManager.java]</p>
<p>将2.17节启动Activity生命周期的代码单独分析一下启动的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> //创建Activity启动事务</span><br><span class="line">final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">        r.appToken);</span><br><span class="line">//设置事务callback，状态为onCreate ---&gt;1        </span><br><span class="line">clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">        System.identityHashCode(r), r.info,</span><br><span class="line">        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">        r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">        profilerInfo));</span><br><span class="line"></span><br><span class="line">//设置目标事务的状态为onResume   ----&gt;2</span><br><span class="line">final ActivityLifecycleItem lifecycleItem;</span><br><span class="line">lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">//通过事务方式开始activity生命周期，onCreate,onStart,onResume   ----&gt;3</span><br><span class="line">mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br></pre></td></tr></table></figure>
<h4 id="2-18-1-AMS-getLifecycleManager"><a href="#2-18-1-AMS-getLifecycleManager" class="headerlink" title="2.18.1 AMS.getLifecycleManager"></a>2.18.1 AMS.getLifecycleManager</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClientLifecycleManager getLifecycleManager() &#123;</span><br><span class="line">       return mLifecycleManager;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-18-2-CLM-scheduleTransaction"><a href="#2-18-2-CLM-scheduleTransaction" class="headerlink" title="2.18.2 CLM.scheduleTransaction"></a>2.18.2 CLM.scheduleTransaction</h4><p>[-&gt;ClientLifecycleManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">      final IApplicationThread client = transaction.getClient();</span><br><span class="line">      transaction.schedule();</span><br><span class="line">      if (!(client instanceof Binder)) &#123;</span><br><span class="line">          // If client is not an instance of Binder - it&apos;s a remote call and at this point it is</span><br><span class="line">          // safe to recycle the object. All objects used for local calls will be recycled after</span><br><span class="line">          // the transaction is executed on client in ActivityThread.</span><br><span class="line">          transaction.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-18-3-CT-schedule"><a href="#2-18-3-CT-schedule" class="headerlink" title="2.18.3 CT.schedule"></a>2.18.3 CT.schedule</h4><p>[-&gt;ClientTransaction.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public IApplicationThread getClient() &#123;</span><br><span class="line">       return mClient;</span><br><span class="line">&#125;</span><br><span class="line">public void schedule() throws RemoteException &#123;</span><br><span class="line">       mClient.scheduleTransaction(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-18-4-AT-scheduleTransaction"><a href="#2-18-4-AT-scheduleTransaction" class="headerlink" title="2.18.4 AT.scheduleTransaction"></a>2.18.4 AT.scheduleTransaction</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">      ActivityThread.this.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityThread继承ClientTransactionHandler</p>
<p>[-&gt;ClientTransactionHandler.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** Prepare and schedule transaction for execution. */</span><br><span class="line">void scheduleTransaction(ClientTransaction transaction) &#123;</span><br><span class="line">     transaction.preExecute(this);</span><br><span class="line">     sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-18-5-AT-handleMessage"><a href="#2-18-5-AT-handleMessage" class="headerlink" title="2.18.5 AT.handleMessage"></a>2.18.5 AT.handleMessage</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">         ...</span><br><span class="line">         case EXECUTE_TRANSACTION:</span><br><span class="line">                    final ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">                    mTransactionExecutor.execute(transaction);</span><br><span class="line">                    if (isSystem()) &#123;</span><br><span class="line">                        // Client transactions inside system process are recycled on the client side</span><br><span class="line">                        // instead of ClientLifecycleManager to avoid being cleared before this</span><br><span class="line">                        // message is handled.</span><br><span class="line">                        transaction.recycle();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // TODO(lifecycler): Recycle locally scheduled transactions.</span><br><span class="line">                    break;</span><br><span class="line">           ....</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-18-6-TE-execute"><a href="#2-18-6-TE-execute" class="headerlink" title="2.18.6 TE.execute"></a>2.18.6 TE.execute</h4><p>[-&gt;TransactionExecutor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Resolve transaction.</span><br><span class="line">    * First all callbacks will be executed in the order they appear in the list. If a callback</span><br><span class="line">    * requires a certain pre- or post-execution state, the client will be transitioned accordingly.</span><br><span class="line">    * Then the client will cycle to the final lifecycle state if provided. Otherwise, it will</span><br><span class="line">    * either remain in the initial state, or last state needed by a callback.</span><br><span class="line">    */</span><br><span class="line">   public void execute(ClientTransaction transaction) &#123;</span><br><span class="line">       final IBinder token = transaction.getActivityToken();</span><br><span class="line">       log(&quot;Start resolving transaction for client: &quot; + mTransactionHandler + &quot;, token: &quot; + token);</span><br><span class="line">       //2.18节开始方法的第一步，状态为onCreate</span><br><span class="line">       executeCallbacks(transaction);</span><br><span class="line">       //2.18节开始方法的第二步，最后的状态为onResume</span><br><span class="line">       executeLifecycleState(transaction);</span><br><span class="line">       mPendingActions.clear();</span><br><span class="line">       log(&quot;End resolving transaction&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>[-&gt;TransactionExecutor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public void executeCallbacks(ClientTransaction transaction) &#123;</span><br><span class="line">       final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">       if (callbacks == null) &#123;</span><br><span class="line">           // No callbacks to execute, return early.</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       log(&quot;Resolving callbacks&quot;);</span><br><span class="line"></span><br><span class="line">       final IBinder token = transaction.getActivityToken();</span><br><span class="line">       ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">       // In case when post-execution state of the last callback matches the final state requested</span><br><span class="line">       // for the activity in this transaction, we won&apos;t do the last transition here and do it when</span><br><span class="line">       // moving to final state instead (because it may contain additional parameters from server).</span><br><span class="line">       final ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest();</span><br><span class="line">       final int finalState = finalStateRequest != null ? finalStateRequest.getTargetState()</span><br><span class="line">               : UNDEFINED;</span><br><span class="line">       // Index of the last callback that requests some post-execution state.</span><br><span class="line">       final int lastCallbackRequestingState = lastCallbackRequestingState(transaction);</span><br><span class="line"></span><br><span class="line">       final int size = callbacks.size();</span><br><span class="line">       for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">           final ClientTransactionItem item = callbacks.get(i);</span><br><span class="line">           log(&quot;Resolving callback: &quot; + item);</span><br><span class="line">           final int postExecutionState = item.getPostExecutionState();</span><br><span class="line">           final int closestPreExecutionState = mHelper.getClosestPreExecutionState(r,</span><br><span class="line">                   item.getPostExecutionState());</span><br><span class="line">           if (closestPreExecutionState != UNDEFINED) &#123;</span><br><span class="line">               cycleToPath(r, closestPreExecutionState);</span><br><span class="line">           &#125;</span><br><span class="line">           //将会执行execute方法</span><br><span class="line">           item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">           item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">           if (r == null) &#123;</span><br><span class="line">               // Launch activity request will create an activity record.</span><br><span class="line">               r = mTransactionHandler.getActivityClient(token);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (postExecutionState != UNDEFINED &amp;&amp; r != null) &#123;</span><br><span class="line">               // Skip the very last transition and perform it by explicit state request instead.</span><br><span class="line">               final boolean shouldExcludeLastTransition =</span><br><span class="line">                       i == lastCallbackRequestingState &amp;&amp; finalState == postExecutionState;</span><br><span class="line">               cycleToPath(r, postExecutionState, shouldExcludeLastTransition);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>[-&gt;LaunchActivityItem.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void execute(ClientTransactionHandler client, IBinder token,</span><br><span class="line">           PendingTransactionActions pendingActions) &#123;</span><br><span class="line">       Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">       ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">               mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">               mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">               mProfilerInfo, client);</span><br><span class="line">        //见2.19节，ActivityThread继承ClientTransactionHandler</span><br><span class="line">       client.handleLaunchActivity(r, pendingActions, null /* customIntent */);</span><br><span class="line">       Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-18-7-TE-cycleToPath"><a href="#2-18-7-TE-cycleToPath" class="headerlink" title="2.18.7 TE.cycleToPath"></a>2.18.7 TE.cycleToPath</h4><p>[-&gt;TransactionExecutor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Transition the client between states with an option not to perform the last hop in the</span><br><span class="line">    * sequence. This is used when resolving lifecycle state request, when the last transition must</span><br><span class="line">    * be performed with some specific parameters.</span><br><span class="line">    */</span><br><span class="line">   private void cycleToPath(ActivityClientRecord r, int finish,</span><br><span class="line">           boolean excludeLastState) &#123;</span><br><span class="line">       final int start = r.getLifecycleState();</span><br><span class="line">       log(&quot;Cycle from: &quot; + start + &quot; to: &quot; + finish + &quot; excludeLastState:&quot; + excludeLastState);</span><br><span class="line">       final IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">       performLifecycleSequence(r, path);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /** Transition the client through previously initialized state sequence. */</span><br><span class="line">   private void performLifecycleSequence(ActivityClientRecord r, IntArray path) &#123;</span><br><span class="line">       final int size = path.size();</span><br><span class="line">       for (int i = 0, state; i &lt; size; i++) &#123;</span><br><span class="line">           state = path.get(i);</span><br><span class="line">           log(&quot;Transitioning to state: &quot; + state);</span><br><span class="line">           switch (state) &#123;</span><br><span class="line">               case ON_CREATE:</span><br><span class="line">                   mTransactionHandler.handleLaunchActivity(r, mPendingActions,</span><br><span class="line">                           null /* customIntent */);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_START:</span><br><span class="line">                   mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_RESUME:</span><br><span class="line">                   mTransactionHandler.handleResumeActivity(r.token, false /* finalStateRequest */,</span><br><span class="line">                           r.isForward, &quot;LIFECYCLER_RESUME_ACTIVITY&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_PAUSE:</span><br><span class="line">                   mTransactionHandler.handlePauseActivity(r.token, false /* finished */,</span><br><span class="line">                           false /* userLeaving */, 0 /* configChanges */, mPendingActions,</span><br><span class="line">                           &quot;LIFECYCLER_PAUSE_ACTIVITY&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_STOP:</span><br><span class="line">                   mTransactionHandler.handleStopActivity(r.token, false /* show */,</span><br><span class="line">                           0 /* configChanges */, mPendingActions, false /* finalStateRequest */,</span><br><span class="line">                           &quot;LIFECYCLER_STOP_ACTIVITY&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_DESTROY:</span><br><span class="line">                   mTransactionHandler.handleDestroyActivity(r.token, false /* finishing */,</span><br><span class="line">                           0 /* configChanges */, false /* getNonConfigInstance */,</span><br><span class="line">                           &quot;performLifecycleSequence. cycling to:&quot; + path.get(size - 1));</span><br><span class="line">                   break;</span><br><span class="line">               case ON_RESTART:</span><br><span class="line">                   mTransactionHandler.performRestartActivity(r.token, false /* start */);</span><br><span class="line">                   break;</span><br><span class="line">               default:</span><br><span class="line">                   throw new IllegalArgumentException(&quot;Unexpected lifecycle state: &quot; + state);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>cycleToPath将会执行从start,finish之间的周期方法。</p>
<h3 id="2-19-AT-handleLaunchActivity"><a href="#2-19-AT-handleLaunchActivity" class="headerlink" title="2.19 AT.handleLaunchActivity"></a>2.19 AT.handleLaunchActivity</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Extended implementation of activity launch. Used when server requests a launch or relaunch.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public Activity handleLaunchActivity(ActivityClientRecord r,</span><br><span class="line">        PendingTransactionActions pendingActions, Intent customIntent) &#123;</span><br><span class="line">    // If we are getting ready to gc after going to the background, well</span><br><span class="line">    // we are back active so skip it.</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = true;</span><br><span class="line"></span><br><span class="line">    if (r.profilerInfo != null) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line">    //回调目标Activity的onConfigurationChanged</span><br><span class="line">    // Make sure we are running with the most recent config.</span><br><span class="line">    handleConfigurationChanged(null, null);</span><br><span class="line"></span><br><span class="line">    if (localLOGV) Slog.v(</span><br><span class="line">        TAG, &quot;Handling launch of &quot; + r);</span><br><span class="line"> </span><br><span class="line">    // Initialize before creating the activity</span><br><span class="line">    if (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">        GraphicsEnvironment.earlyInitEGL();</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">     //回调目标Activity的onCreate，正式开始Activity的生命周期</span><br><span class="line">    final Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">        r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; pendingActions != null) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(true);</span><br><span class="line">            pendingActions.setCallOnPostCreate(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //存在error,则停止该Activity</span><br><span class="line">        // If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-20-AT-performLaunchActivity"><a href="#2-20-AT-performLaunchActivity" class="headerlink" title="2.20 AT.performLaunchActivity"></a>2.20 AT.performLaunchActivity</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">      ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">      if (r.packageInfo == null) &#123;</span><br><span class="line">          r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                  Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ComponentName component = r.intent.getComponent();</span><br><span class="line">      if (component == null) &#123;</span><br><span class="line">          component = r.intent.resolveActivity(</span><br><span class="line">              mInitialApplication.getPackageManager());</span><br><span class="line">          r.intent.setComponent(component);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (r.activityInfo.targetActivity != null) &#123;</span><br><span class="line">          component = new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                  r.activityInfo.targetActivity);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">      Activity activity = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">          activity = mInstrumentation.newActivity(</span><br><span class="line">                  cl, component.getClassName(), r.intent);</span><br><span class="line">          StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">          r.intent.setExtrasClassLoader(cl);</span><br><span class="line">          r.intent.prepareToEnterProcess();</span><br><span class="line">          if (r.state != null) &#123;</span><br><span class="line">              r.state.setClassLoader(cl);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">              throw new RuntimeException(</span><br><span class="line">                  &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                  + &quot;: &quot; + e.toString(), e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          //创建Application对象</span><br><span class="line">          Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">          if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</span><br><span class="line">          if (localLOGV) Slog.v(</span><br><span class="line">                  TAG, r + &quot;: app=&quot; + app</span><br><span class="line">                  + &quot;, appName=&quot; + app.getPackageName()</span><br><span class="line">                  + &quot;, pkg=&quot; + r.packageInfo.getPackageName()</span><br><span class="line">                  + &quot;, comp=&quot; + r.intent.getComponent().toShortString()</span><br><span class="line">                  + &quot;, dir=&quot; + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">          if (activity != null) &#123;</span><br><span class="line">              CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">              Configuration config = new Configuration(mCompatConfiguration);</span><br><span class="line">              if (r.overrideConfig != null) &#123;</span><br><span class="line">                  config.updateFrom(r.overrideConfig);</span><br><span class="line">              &#125;</span><br><span class="line">              if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                      + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">              Window window = null;</span><br><span class="line">              if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                  window = r.mPendingRemoveWindow;</span><br><span class="line">                  r.mPendingRemoveWindow = null;</span><br><span class="line">                  r.mPendingRemoveWindowManager = null;</span><br><span class="line">              &#125;</span><br><span class="line">              appContext.setOuterContext(activity);</span><br><span class="line">              //attach方法</span><br><span class="line">              activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                      r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                      r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                      r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">              if (customIntent != null) &#123;</span><br><span class="line">                  activity.mIntent = customIntent;</span><br><span class="line">              &#125;</span><br><span class="line">              r.lastNonConfigurationInstances = null;</span><br><span class="line">              checkAndBlockForNetworkAccess();</span><br><span class="line">              activity.mStartedActivity = false;</span><br><span class="line">              int theme = r.activityInfo.getThemeResource();</span><br><span class="line">              if (theme != 0) &#123;</span><br><span class="line">                  activity.setTheme(theme);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              activity.mCalled = false;</span><br><span class="line">              //进入生命周期的onCreate</span><br><span class="line">              if (r.isPersistable()) &#123;</span><br><span class="line">                  mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">              &#125;</span><br><span class="line">              if (!activity.mCalled) &#123;</span><br><span class="line">                  throw new SuperNotCalledException(</span><br><span class="line">                      &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                      &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              r.activity = activity;</span><br><span class="line">          &#125;</span><br><span class="line">          r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">          mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">      &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">          throw e;</span><br><span class="line"></span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">              throw new RuntimeException(</span><br><span class="line">                  &quot;Unable to start activity &quot; + component</span><br><span class="line">                  + &quot;: &quot; + e.toString(), e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return activity;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-21-callActivityOnCreate"><a href="#2-21-callActivityOnCreate" class="headerlink" title="2.21 callActivityOnCreate"></a>2.21 callActivityOnCreate</h3><p>[-&gt;Instrumentation.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">     prePerformCreate(activity);</span><br><span class="line">     activity.performCreate(icicle);</span><br><span class="line">     postPerformCreate(activity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-22-performCreate"><a href="#2-22-performCreate" class="headerlink" title="2.22 performCreate"></a>2.22 performCreate</h3><p>[-&gt;Activity.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">   final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class="line">       mCanEnterPictureInPicture = true;</span><br><span class="line">       restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">       if (persistentState != null) &#123;</span><br><span class="line">           onCreate(icicle, persistentState);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           onCreate(icicle);</span><br><span class="line">       &#125;</span><br><span class="line">       writeEventLog(LOG_AM_ON_CREATE_CALLED, &quot;performCreate&quot;);</span><br><span class="line">       mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">       mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">               com.android.internal.R.styleable.Window_windowNoDisplay, false);</span><br><span class="line">       mFragments.dispatchActivityCreated();</span><br><span class="line">       mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>到此，介绍了完成了Activity从onCreate,onStart,onResume的生命周期详细过程。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本文从startActivity开始，详细分析了Activity的启动过程。</p>
<ol>
<li>流程[2.1~2.3]:运行在调用者的进程当中，比如桌面启动Activity，则调用者所在的进程为launcher，launcher进程通过IActivityManager.aidl生成的代理类，进入到了systemserver进程（AMS相应的Server端）。</li>
<li>流程[2.3~2.17]:允许在systemserver系统进程中，这个过程为比较复杂且核心的过程，主要如下：<ul>
<li>流程[2.7]:调用resolveActivity，通过PackageManager查询系统中所有符合要求的Activity，当存在多个满足多个条件的Activity则会让用户来选择 。</li>
<li>流程[2.8]:创建ActivityRecord对象，检查intent相关信息和权限，是否允许app切换，然后处理mPendingActivityLaunches中的Activity</li>
<li>流程[2.9]:为Activity找到或创建新的Task对象，设置flags信息</li>
<li>流程[2.13]:当没有处于任务栈中没有Activity时，直接回到桌面了;否则当mResumeActivity不为空是，先执行startPausingLocked方法暂停该Activity，然后进入startSpecificActivityLocked</li>
<li>流程[2.14]:当目标进程已经存在则直接进入2.17，当目标进程不存在时则创建进程，经过调用最后到2.17</li>
<li>流程[2.17]:systemserver进程通过IApplicationThread binder接口，进入到了目标进程。</li>
</ul>
</li>
<li>流程[2.18~2.20]:允许在目标进程，通过Handler消息机制，该进程中的binder线程向主线程发送EXECUTE_TRANSACTION消息，进入事务处理阶段调用到handleLaunchActivity，最后通过发射创建的目标Activity，然后进入到onCreate生命周期。</li>
</ol>
<p>从进程的角度分析</p>
<ol>
<li>点击桌面图标，Launcher进程采用Binder IPC向systemserver进程发送startActivity请求</li>
<li>systemserver进程接收到请求后，向zygote进程发送创建进程的请求</li>
<li>zygote进程fork出新的子进程即app进程</li>
<li>App进程，通过Binder IPC向systemserver进程发起attachApplication请求</li>
<li>systemserver进程收到请求后，进行一系列准备工作后，在通过binderIPC进程发送scheduleTransaction请求</li>
<li>APP进程的binder进程（ApplicationThread）在收到请求后，通过handler向主线程发送EXECUTE_TRANSACTION消息。</li>
<li>主线程收到Message消息后，通过反射机制创建目标Activity，并回调Activity的onCreate方法。</li>
</ol>
<p>到此应用正式启动，开始进入应用的生命周期，执行完onCreate，onStart，onResume方法，makeVisible，UI渲染结束后就可以看到App的主界面了。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>源码路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/content/ContextWrapper.java</span><br><span class="line">frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line">frameworks/base/core/java/android/app/Instrumentation.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityStartController.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityStack.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span><br><span class="line">frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</span><br></pre></td></tr></table></figure>
      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Activity/" rel="tag">#Activity</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/AMS启动流程分析/" rel="next" title="AMS启动流程分析">
                <i class="fa fa-chevron-left"></i> AMS启动流程分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/startService启动过程/" rel="prev" title="startServie启动过程">
                startServie启动过程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、启动流程"><span class="nav-text">二、启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Activity-startActivity"><span class="nav-text">2.1 Activity.startActivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-startActivityForResult"><span class="nav-text">2.2  startActivityForResult</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-execStartActivity"><span class="nav-text">2.3  execStartActivity</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-AM-getService"><span class="nav-text">2.3.1  AM.getService</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-IActivityManager-startActivity"><span class="nav-text">2.4  IActivityManager.startActivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-AMS-startActivity"><span class="nav-text">2.5 AMS.startActivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-AMS-startActivityAsUser"><span class="nav-text">2.6 AMS.startActivityAsUser</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-ASC-obtainStarter"><span class="nav-text">2.6.1  ASC.obtainStarter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-AS-setMayWait"><span class="nav-text">2.6.2  AS.setMayWait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-AS-execute"><span class="nav-text">2.6.3  AS.execute</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-AS-startActivityMayWait"><span class="nav-text">2.7  AS.startActivityMayWait</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-PKMS-resolveIntent"><span class="nav-text">2.7.1 PKMS.resolveIntent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-ASS-resolveActivity"><span class="nav-text">2.7.2 ASS.resolveActivity</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-AS-startActivity"><span class="nav-text">2.8  AS.startActivity</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1-AMS-checkAppSwitchAllowedLocked"><span class="nav-text">2.8.1 AMS.checkAppSwitchAllowedLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1-ASC-doPendingActivityLaunches"><span class="nav-text">2.8.1 ASC.doPendingActivityLaunches</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-AS-startActivityUnchecked"><span class="nav-text">2.9  AS.startActivityUnchecked</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-1-AS-setInitialState"><span class="nav-text">2.9.1 AS.setInitialState</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-2-AS-computeLaunchingTaskFlags"><span class="nav-text">2.9.2 AS.computeLaunchingTaskFlags</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-3-AS-computeSourceStack"><span class="nav-text">2.9.3 AS.computeSourceStack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-4-AS-getReusableIntentActivity"><span class="nav-text">2.9.4 AS.getReusableIntentActivity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-5-Launch-Mode"><span class="nav-text">2.9.5 Launch Mode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-AS-startActivityLocked"><span class="nav-text">2.10 AS.startActivityLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-ASS-resumeFocusedStackTopActivityLocked"><span class="nav-text">2.11  ASS.resumeFocusedStackTopActivityLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-AS-resumeTopActivityUncheckedLocked"><span class="nav-text">2.12 AS.resumeTopActivityUncheckedLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-13-AS-resumeTopActivityInnerLocked"><span class="nav-text">2.13 AS.resumeTopActivityInnerLocked</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-13-1-AS-resumeTopActivityInNextFocusableStack"><span class="nav-text">2.13.1 AS.resumeTopActivityInNextFocusableStack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-13-2-AS-pauseBackStacks"><span class="nav-text">2.13.2 AS.pauseBackStacks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-13-3-AS-startPausingLocked"><span class="nav-text">2.13.3 AS.startPausingLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-13-4-AS-completePauseLocked"><span class="nav-text">2.13.4 AS.completePauseLocked</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-14-ASS-startSpecificActivityLocked"><span class="nav-text">2.14  ASS.startSpecificActivityLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-15-AMS-startProcessLocked"><span class="nav-text">2.15 AMS.startProcessLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-16-ASS-attachApplicationLocked"><span class="nav-text">2.16 ASS.attachApplicationLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-17-ASS-realStartActivityLocked"><span class="nav-text">2.17 ASS.realStartActivityLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-18-CLM-scheduleTransaction"><span class="nav-text">2.18  CLM.scheduleTransaction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-18-1-AMS-getLifecycleManager"><span class="nav-text">2.18.1 AMS.getLifecycleManager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-18-2-CLM-scheduleTransaction"><span class="nav-text">2.18.2 CLM.scheduleTransaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-18-3-CT-schedule"><span class="nav-text">2.18.3 CT.schedule</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-18-4-AT-scheduleTransaction"><span class="nav-text">2.18.4 AT.scheduleTransaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-18-5-AT-handleMessage"><span class="nav-text">2.18.5 AT.handleMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-18-6-TE-execute"><span class="nav-text">2.18.6 TE.execute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-18-7-TE-cycleToPath"><span class="nav-text">2.18.7 TE.cycleToPath</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-19-AT-handleLaunchActivity"><span class="nav-text">2.19 AT.handleLaunchActivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-20-AT-performLaunchActivity"><span class="nav-text">2.20 AT.performLaunchActivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-21-callActivityOnCreate"><span class="nav-text">2.21 callActivityOnCreate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-22-performCreate"><span class="nav-text">2.22 performCreate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、总结"><span class="nav-text">三、总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2019/startActivity启动过程/';
      var disqus_title = "startActivity启动过程";
      var disqus_url = 'http://zproo.github.io/2019/startActivity启动过程/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
