<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="OTA升级,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="一、概述目前Android系统终端的升级主要是通过无线进行的（FOTA，Firmware Over-The-Air），主要流程是通过无线方式将升级包下载到终端，而后调用系统的升级接口进行升级。本文主要分析升级包下载后，调用系统升级接口之后的流程。 1.1  升级包结构升级包是用make otapackage命令生成的，对于差分包，需要生成两个ota整包，再用系统的编译工具利用这两个整包生成一个差分">
<meta name="keywords" content="OTA升级">
<meta property="og:type" content="article">
<meta property="og:title" content="Android OTA升级流程分析">
<meta property="og:url" content="http://zproo.github.io/2019/Android OTA升级流程分析/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="一、概述目前Android系统终端的升级主要是通过无线进行的（FOTA，Firmware Over-The-Air），主要流程是通过无线方式将升级包下载到终端，而后调用系统的升级接口进行升级。本文主要分析升级包下载后，调用系统升级接口之后的流程。 1.1  升级包结构升级包是用make otapackage命令生成的，对于差分包，需要生成两个ota整包，再用系统的编译工具利用这两个整包生成一个差分">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2019/Android%20OTA升级流程分析/recovery.jpg">
<meta property="og:image" content="http://zproo.github.io/2019/Android%20OTA升级流程分析/OTA.jpg">
<meta property="og:updated_time" content="2020-05-07T08:43:35.532Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android OTA升级流程分析">
<meta name="twitter:description" content="一、概述目前Android系统终端的升级主要是通过无线进行的（FOTA，Firmware Over-The-Air），主要流程是通过无线方式将升级包下载到终端，而后调用系统的升级接口进行升级。本文主要分析升级包下载后，调用系统升级接口之后的流程。 1.1  升级包结构升级包是用make otapackage命令生成的，对于差分包，需要生成两个ota整包，再用系统的编译工具利用这两个整包生成一个差分">
<meta name="twitter:image" content="http://zproo.github.io/2019/Android%20OTA升级流程分析/recovery.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2019/Android OTA升级流程分析/">

  <title> Android OTA升级流程分析 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/OTA升级/" rel="tag" title="OTA升级">OTA升级</a>
      
      </div>
      <h1>Android OTA升级流程分析</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2019-12-10T22:18:28+08:00" content="2019-12-10" title="2019-12-10 22:18:28">
          2019-12-10
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android OTA升级流程分析
              
            
          </h1>
        

        <div class="post-meta">
		  

          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-12-10T22:18:28+08:00" content="2019-12-10">
              2019-12-10
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/Android OTA升级流程分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/Android OTA升级流程分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>目前Android系统终端的升级主要是通过无线进行的（FOTA，Firmware Over-The-Air），主要流程是通过无线方式将升级包下载到终端，而后调用系统的升级接口进行升级。本文主要分析升级包下载后，调用系统升级接口之后的流程。</p>
<h3 id="1-1-升级包结构"><a href="#1-1-升级包结构" class="headerlink" title="1.1  升级包结构"></a>1.1  升级包结构</h3><p>升级包是用make otapackage命令生成的，对于差分包，需要生成两个ota整包，再用系统的编译工具利用这两个整包生成一个差分包。下面是某终端Android9.0版本的ota升级包结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├─firmware-update</span><br><span class="line">└─META-INF</span><br><span class="line">    └─com</span><br><span class="line">        ├─android</span><br><span class="line">            ├─metadata</span><br><span class="line">            ├─otacert</span><br><span class="line">        └─google</span><br><span class="line">            └─android</span><br><span class="line">               ├─update-binary</span><br><span class="line">               ├─updater-script</span><br><span class="line"> ├─boot.img</span><br><span class="line"> ├─system.new.dat.br</span><br><span class="line"> ├─system.patch.dat</span><br><span class="line"> ├─system.transfer.list</span><br><span class="line"> ├─vendor.new.dat.br</span><br><span class="line"> ├─vendor.patch.dat</span><br><span class="line"> ├─vendor.transfer.list</span><br></pre></td></tr></table></figure>
<p>firmware-update：目录下主要是一些固件的升级，如mbn、dtbo、vbmeta等</p>
<p>boot.img：更新boot分区所需要的文件，包括kernel+ramdisk</p>
<p>system.new.dat.br：Android8.1镜像后新的压缩格式，为数据部分，里面是system.img数据。</p>
<p>system.transfer.list：数据转换的描述列表。</p>
<p>system.patch.dat：升级时用到，ota包中大小为0。</p>
<p>vendor和system类似。</p>
<p>update-binary：二进制文件，相当于一个脚本解释器，能够识别updater-script中描述的操作，文件的命名由bootable/recovery/install.cpp 中的UPDATE_BINARY_NAME值而定。</p>
<p>updater-script：升级包的升级脚本，文件的命名由bootable/recovery/updater/updater.cpp中的SCRIPT_NAME值而定。</p>
<p>metadata：描述设备信息及环境变量的元数据，主要包括一些编译选项、签名公钥，时间戳以及设备型号等。</p>
<p>otacert：ota签名。</p>
<h3 id="1-2-系统启动模式"><a href="#1-2-系统启动模式" class="headerlink" title="1.2 系统启动模式"></a>1.2 系统启动模式</h3><p>Android系统启动主要有两种：</p>
<p>1.组合键</p>
<p>用户通过按下组合键，不同的终端可以定义组合键，进入不同的工作模式，在bootable/bootloader/lk/app/aboot/aboot.c文件中判断，具体有两种：</p>
<p>bootloader模式，可进一步进入fastboot（快速刷机模式）。</p>
<p>Recovery模式，进入这种模式系统会出现一个简单的ui界面，用来提示用户的进一步操作。</p>
<p><img src="/2019/Android OTA升级流程分析/recovery.jpg" alt="recovery"></p>
<p>2.正常启动</p>
<p>没有按下任何组合键，正常开机，bootloader会读取启动控制信息块BCB(bootloader control block)，它是一个结构体，存放着启动命令Command。根据不同的命令，系统可以进入三种不同的启动模式。下面是Bootloader Message的定义，通过注释可以了解具体结构体中成员变量的含义。</p>
<p>[-&gt;bootloader_message.h]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/* Bootloader Message (2-KiB)</span><br><span class="line"> *</span><br><span class="line"> * This structure describes the content of a block in flash</span><br><span class="line"> * that is used for recovery and the bootloader to talk to</span><br><span class="line"> * each other.</span><br><span class="line"> *</span><br><span class="line"> * The command field is updated by linux when it wants to</span><br><span class="line"> * reboot into recovery or to update radio or bootloader firmware.</span><br><span class="line"> * It is also updated by the bootloader when firmware update</span><br><span class="line"> * is complete (to boot into recovery for any final cleanup)</span><br><span class="line"> *</span><br><span class="line"> * The status field was used by the bootloader after the completion</span><br><span class="line"> * of an &quot;update-radio&quot; or &quot;update-hboot&quot; command, which has been</span><br><span class="line"> * deprecated since Froyo.</span><br><span class="line"> *</span><br><span class="line"> * The recovery field is only written by linux and used</span><br><span class="line"> * for the system to send a message to recovery or the</span><br><span class="line"> * other way around.</span><br><span class="line"> *</span><br><span class="line"> * The stage field is written by packages which restart themselves</span><br><span class="line"> * multiple times, so that the UI can reflect which invocation of the</span><br><span class="line"> * package it is.  If the value is of the format &quot;#/#&quot; (eg, &quot;1/3&quot;),</span><br><span class="line"> * the UI will add a simple indicator of that status.</span><br><span class="line"> *</span><br><span class="line"> * We used to have slot_suffix field for A/B boot control metadata in</span><br><span class="line"> * this struct, which gets unintentionally cleared by recovery or</span><br><span class="line"> * uncrypt. Move it into struct bootloader_message_ab to avoid the</span><br><span class="line"> * issue.</span><br><span class="line"> */</span><br><span class="line">struct bootloader_message &#123;</span><br><span class="line">    char command[32];</span><br><span class="line">    char status[32];</span><br><span class="line">    char recovery[768];</span><br><span class="line"></span><br><span class="line">    // The &apos;recovery&apos; field used to be 1024 bytes.  It has only ever</span><br><span class="line">    // been used to store the recovery command line, so 768 bytes</span><br><span class="line">    // should be plenty.  We carve off the last 256 bytes to store the</span><br><span class="line">    // stage string (for multistage packages) and possible future</span><br><span class="line">    // expansion.</span><br><span class="line">    char stage[32];</span><br><span class="line"></span><br><span class="line">    // The &apos;reserved&apos; field used to be 224 bytes when it was initially</span><br><span class="line">    // carved off from the 1024-byte recovery field. Bump it up to</span><br><span class="line">    // 1184-byte so that the entire bootloader_message struct rounds up</span><br><span class="line">    // to 2048-byte.</span><br><span class="line">    char reserved[1184];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、OTA升级重启前"><a href="#二、OTA升级重启前" class="headerlink" title="二、OTA升级重启前"></a>二、OTA升级重启前</h2><p>前面介绍完OTA升级包和系统启动模式，现在看下真正的ota升级的步骤。无论ota包是通过无线下载还是导入到SD卡，最后都会调用到RecoverySystem.installPackage方法，下面分析下这个详细的流程。</p>
<h3 id="2-1-RS-installPackage"><a href="#2-1-RS-installPackage" class="headerlink" title="2.1 RS.installPackage"></a>2.1 RS.installPackage</h3><p>[-&gt;RecoverySystem.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public static void installPackage(Context context, File packageFile, boolean processed)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        synchronized (sRequestLock) &#123;</span><br><span class="line">            LOG_FILE.delete();</span><br><span class="line">            // Must delete the file in case it was created by system server.</span><br><span class="line">            //删除之前的uncrypt file</span><br><span class="line">            UNCRYPT_PACKAGE_FILE.delete();</span><br><span class="line"></span><br><span class="line">            String filename = packageFile.getCanonicalPath();</span><br><span class="line">            Log.w(TAG, &quot;!!! REBOOTING TO INSTALL &quot; + filename + &quot; !!!&quot;);</span><br><span class="line"></span><br><span class="line">            // If the package name ends with &quot;_s.zip&quot;, it&apos;s a security update.</span><br><span class="line">            boolean securityUpdate = filename.endsWith(&quot;_s.zip&quot;);</span><br><span class="line"></span><br><span class="line">            // If the package is on the /data partition, the package needs to</span><br><span class="line">            // be processed (i.e. uncrypt&apos;d). The caller specifies if that has</span><br><span class="line">            // been done in &apos;processed&apos; parameter.</span><br><span class="line">            //如果升级包的路径是/data/开始</span><br><span class="line">            if (filename.startsWith(&quot;/data/&quot;)) &#123;</span><br><span class="line">                if (processed) &#123;</span><br><span class="line">                    if (!BLOCK_MAP_FILE.exists()) &#123;</span><br><span class="line">                        Log.e(TAG, &quot;Package claimed to have been processed but failed to find &quot;</span><br><span class="line">                                + &quot;the block map file.&quot;);</span><br><span class="line">                        throw new IOException(&quot;Failed to find block map file&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    FileWriter uncryptFile = new FileWriter(UNCRYPT_PACKAGE_FILE);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //将路径写入uncryptFile</span><br><span class="line">                        uncryptFile.write(filename + &quot;/n&quot;);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        uncryptFile.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // UNCRYPT_PACKAGE_FILE needs to be readable and writable</span><br><span class="line">                    // by system server.</span><br><span class="line">                    if (!UNCRYPT_PACKAGE_FILE.setReadable(true, false)</span><br><span class="line">                            || !UNCRYPT_PACKAGE_FILE.setWritable(true, false)) &#123;</span><br><span class="line">                        Log.e(TAG, &quot;Error setting permission for &quot; + UNCRYPT_PACKAGE_FILE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    BLOCK_MAP_FILE.delete();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If the package is on the /data partition, use the block map</span><br><span class="line">                // file as the package name instead.</span><br><span class="line">                filename = &quot;@/cache/recovery/block.map&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String filenameArg = &quot;--update_package=&quot; + filename + &quot;/n&quot;;</span><br><span class="line">            final String localeArg = &quot;--locale=&quot; + Locale.getDefault().toLanguageTag() + &quot;/n&quot;;</span><br><span class="line">            final String securityArg = &quot;--security/n&quot;;</span><br><span class="line"></span><br><span class="line">            String command = filenameArg + localeArg;</span><br><span class="line">            if (securityUpdate) &#123;</span><br><span class="line">                command += securityArg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RecoverySystem rs = (RecoverySystem) context.getSystemService(</span><br><span class="line">                    Context.RECOVERY_SERVICE);</span><br><span class="line">            //向bootloader control block写入命令      </span><br><span class="line">            if (!rs.setupBcb(command)) &#123;</span><br><span class="line">                throw new IOException(&quot;Setup BCB failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Having set up the BCB (bootloader control block), go ahead and reboot</span><br><span class="line">            PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">            String reason = PowerManager.REBOOT_RECOVERY_UPDATE;</span><br><span class="line"></span><br><span class="line">            // On TV, reboot quiescently if the screen is off</span><br><span class="line">            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK)) &#123;</span><br><span class="line">                WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">                if (wm.getDefaultDisplay().getState() != Display.STATE_ON) &#123;</span><br><span class="line">                    reason += &quot;,quiescent&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //重启</span><br><span class="line">            pm.reboot(reason);</span><br><span class="line">            throw new IOException(&quot;Reboot failed (no permissions?)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>private static final File RECOVERY_DIR = new File(“/cache/recovery”);</p>
<p>public static final File UNCRYPT_PACKAGE_FILE = new File(RECOVERY_DIR, “uncrypt_file”);</p>
<p>这里主要是对ota升级包的处理，由于进入recovery模式后，data分区将不能加载，因此需要将其通过block方式，把ota升级包生成稀疏的描述文件，保存在/cache/recovery/block.map中。升级的命令写入到BCB,重启之后bootloader会读取BCB中的command从而进入升级模式。</p>
<h3 id="2-2-RS-setupBcb"><a href="#2-2-RS-setupBcb" class="headerlink" title="2.2 RS.setupBcb"></a>2.2 RS.setupBcb</h3><p>[-&gt;RecoverySystem.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Talks to RecoverySystemService via Binder to set up the BCB.</span><br><span class="line">   */</span><br><span class="line">  private boolean setupBcb(String command) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          //通过binder调用setupBcb</span><br><span class="line">          return mService.setupBcb(command);</span><br><span class="line">      &#125; catch (RemoteException unused) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-RSS-setupBcb"><a href="#2-3-RSS-setupBcb" class="headerlink" title="2.3 RSS.setupBcb"></a>2.3 RSS.setupBcb</h3><p>[-&gt;RecoverySystemService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override // Binder call</span><br><span class="line"> public boolean setupBcb(String command) &#123;</span><br><span class="line">     if (DEBUG) Slog.d(TAG, &quot;setupBcb: [&quot; + command + &quot;]&quot;);</span><br><span class="line">     synchronized (sRequestLock) &#123;</span><br><span class="line">         return setupOrClearBcb(true, command);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-RSS-setupOrClearBcb"><a href="#2-4-RSS-setupOrClearBcb" class="headerlink" title="2.4 RSS.setupOrClearBcb"></a>2.4 RSS.setupOrClearBcb</h3><p>[-&gt;RecoverySystemService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private boolean setupOrClearBcb(boolean isSetup, String command) &#123;</span><br><span class="line">          mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);</span><br><span class="line"></span><br><span class="line">          final boolean available = checkAndWaitForUncryptService();</span><br><span class="line">          if (!available) &#123;</span><br><span class="line">              Slog.e(TAG, &quot;uncrypt service is unavailable.&quot;);</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br><span class="line">          //设置ctl.start属性，启动setup-bcb服务</span><br><span class="line">          if (isSetup) &#123;</span><br><span class="line">              SystemProperties.set(&quot;ctl.start&quot;, &quot;setup-bcb&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              SystemProperties.set(&quot;ctl.start&quot;, &quot;clear-bcb&quot;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Connect to the uncrypt service socket.</span><br><span class="line">          // 连接uncrypt服务</span><br><span class="line">          LocalSocket socket = connectService();</span><br><span class="line">          if (socket == null) &#123;</span><br><span class="line">              Slog.e(TAG, &quot;Failed to connect to uncrypt socket&quot;);</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          DataInputStream dis = null;</span><br><span class="line">          DataOutputStream dos = null;</span><br><span class="line">          try &#123;</span><br><span class="line">              dis = new DataInputStream(socket.getInputStream());</span><br><span class="line">              dos = new DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">              // Send the BCB commands if it&apos;s to setup BCB.</span><br><span class="line">              // 发送BCB commands</span><br><span class="line">              if (isSetup) &#123;</span><br><span class="line">                  byte[] cmdUtf8 = command.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">                  dos.writeInt(cmdUtf8.length);</span><br><span class="line">                  dos.write(cmdUtf8, 0, cmdUtf8.length);</span><br><span class="line">                  dos.flush();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // Read the status from the socket.</span><br><span class="line">              int status = dis.readInt();</span><br><span class="line"></span><br><span class="line">              // Ack receipt of the status code. uncrypt waits for the ack so</span><br><span class="line">              // the socket won&apos;t be destroyed before we receive the code.</span><br><span class="line">              dos.writeInt(0);</span><br><span class="line"></span><br><span class="line">              if (status == 100) &#123;</span><br><span class="line">                  Slog.i(TAG, &quot;uncrypt &quot; + (isSetup ? &quot;setup&quot; : &quot;clear&quot;) +</span><br><span class="line">                          &quot; bcb successfully finished.&quot;);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  // Error in /system/bin/uncrypt.</span><br><span class="line">                  Slog.e(TAG, &quot;uncrypt failed with status: &quot; + status);</span><br><span class="line">                  return false;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              Slog.e(TAG, &quot;IOException when communicating with uncrypt:&quot;, e);</span><br><span class="line">              return false;</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              IoUtils.closeQuietly(dis);</span><br><span class="line">              IoUtils.closeQuietly(dos);</span><br><span class="line">              IoUtils.closeQuietly(socket);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p> SystemProperties.set(“ctl.start”, “setup-bcb”)，通过这种方式来启动服务（SystemProperties设置属性的原理详细见文章<a href="https://skytoby.github.io/2019/Android%20SystemProperties%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Android SystemProperties系统属性分析</a>），而后连接服务，向其中发送BCB command。</p>
<h3 id="2-5-PM-reboot"><a href="#2-5-PM-reboot" class="headerlink" title="2.5  PM.reboot"></a>2.5  PM.reboot</h3><p>[-&gt;PowerManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void reboot(String reason) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           mService.reboot(false, reason, true);</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           throw e.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-PMS-reboot"><a href="#2-6-PMS-reboot" class="headerlink" title="2.6  PMS.reboot"></a>2.6  PMS.reboot</h3><p>[-&gt;PowerManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Reboots the device.</span><br><span class="line"> *</span><br><span class="line"> * @param confirm If true, shows a reboot confirmation dialog.</span><br><span class="line"> * @param reason The reason for the reboot, or null if none.</span><br><span class="line"> * @param wait If true, this call waits for the reboot to complete and does not return.</span><br><span class="line"> */</span><br><span class="line">@Override // Binder call</span><br><span class="line">public void reboot(boolean confirm, String reason, boolean wait) &#123;</span><br><span class="line">    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null);</span><br><span class="line">    if (PowerManager.REBOOT_RECOVERY.equals(reason)</span><br><span class="line">            || PowerManager.REBOOT_RECOVERY_UPDATE.equals(reason)) &#123;</span><br><span class="line">        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        shutdownOrRebootInternal(HALT_MODE_REBOOT, confirm, reason, wait);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传入的参数confirm：false  ， reason：REBOOT_RECOVERY_UPDATE = “recovery-update”，wait：true</p>
<h3 id="2-7-PMS-shutdownOrRebootInternal"><a href="#2-7-PMS-shutdownOrRebootInternal" class="headerlink" title="2.7  PMS.shutdownOrRebootInternal"></a>2.7  PMS.shutdownOrRebootInternal</h3><p>[-&gt;PowerManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private void shutdownOrRebootInternal(final @HaltMode int haltMode, final boolean confirm,</span><br><span class="line">          final String reason, boolean wait) &#123;</span><br><span class="line">      if (mHandler == null || !mSystemReady) &#123;</span><br><span class="line">          if (RescueParty.isAttemptingFactoryReset()) &#123;</span><br><span class="line">              // If we&apos;re stuck in a really low-level reboot loop, and a</span><br><span class="line">              // rescue party is trying to prompt the user for a factory data</span><br><span class="line">              // reset, we must GET TO DA CHOPPA!</span><br><span class="line">              PowerManagerService.lowLevelReboot(reason);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              throw new IllegalStateException(&quot;Too early to call shutdown() or reboot()&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //上面传过来的是HALT_MODE_REBOOT</span><br><span class="line">      Runnable runnable = new Runnable() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              synchronized (this) &#123;</span><br><span class="line">                  if (haltMode == HALT_MODE_REBOOT_SAFE_MODE) &#123;</span><br><span class="line">                      ShutdownThread.rebootSafeMode(getUiContext(), confirm);</span><br><span class="line">                  &#125; else if (haltMode == HALT_MODE_REBOOT) &#123;</span><br><span class="line">                      ShutdownThread.reboot(getUiContext(), reason, confirm);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      ShutdownThread.shutdown(getUiContext(), reason, confirm);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      // ShutdownThread must run on a looper capable of displaying the UI.</span><br><span class="line">      Message msg = Message.obtain(UiThread.getHandler(), runnable);</span><br><span class="line">      msg.setAsynchronous(true);</span><br><span class="line">      UiThread.getHandler().sendMessage(msg);</span><br><span class="line"></span><br><span class="line">      // PowerManager.reboot() is documented not to return so just wait for the inevitable.</span><br><span class="line">      if (wait) &#123;</span><br><span class="line">          synchronized (runnable) &#123;</span><br><span class="line">              while (true) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      runnable.wait();</span><br><span class="line">                  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-ST-reboot"><a href="#2-8-ST-reboot" class="headerlink" title="2.8 ST.reboot"></a>2.8 ST.reboot</h3><p>[-&gt;ShutdownThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void reboot(final Context context, String reason, boolean confirm) &#123;</span><br><span class="line">        mReboot = true;</span><br><span class="line">        mRebootSafeMode = false;</span><br><span class="line">        mRebootHasProgressBar = false;</span><br><span class="line">        mReason = reason;</span><br><span class="line">        shutdownInner(context, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-9-ST-shutdownInner"><a href="#2-9-ST-shutdownInner" class="headerlink" title="2.9 ST.shutdownInner"></a>2.9 ST.shutdownInner</h3><p>[-&gt;ShutdownThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private static void shutdownInner(final Context context, boolean confirm) &#123;</span><br><span class="line">       // ShutdownThread is called from many places, so best to verify here that the context passed</span><br><span class="line">       // in is themed.</span><br><span class="line">       context.assertRuntimeOverlayThemable();</span><br><span class="line"></span><br><span class="line">       // ensure that only one thread is trying to power down.</span><br><span class="line">       // any additional calls are just returned</span><br><span class="line">       synchronized (sIsStartedGuard) &#123;</span><br><span class="line">           if (sIsStarted) &#123;</span><br><span class="line">               Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final int longPressBehavior = context.getResources().getInteger(</span><br><span class="line">                       com.android.internal.R.integer.config_longPressOnPowerBehavior);</span><br><span class="line">       final int resourceId = mRebootSafeMode</span><br><span class="line">               ? com.android.internal.R.string.reboot_safemode_confirm</span><br><span class="line">               : (longPressBehavior == 2</span><br><span class="line">                       ? com.android.internal.R.string.shutdown_confirm_question</span><br><span class="line">                       : com.android.internal.R.string.shutdown_confirm);</span><br><span class="line"></span><br><span class="line">       Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior);</span><br><span class="line"></span><br><span class="line">       if (confirm) &#123;</span><br><span class="line">           final CloseDialogReceiver closer = new CloseDialogReceiver(context);</span><br><span class="line">           if (sConfirmDialog != null) &#123;</span><br><span class="line">               sConfirmDialog.dismiss();</span><br><span class="line">           &#125;</span><br><span class="line">           sConfirmDialog = new AlertDialog.Builder(context)</span><br><span class="line">                   .setTitle(mRebootSafeMode</span><br><span class="line">                           ? com.android.internal.R.string.reboot_safemode_title</span><br><span class="line">                           : com.android.internal.R.string.power_off)</span><br><span class="line">                   .setMessage(resourceId)</span><br><span class="line">                   .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                       public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                           beginShutdownSequence(context);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;)</span><br><span class="line">                   .setNegativeButton(com.android.internal.R.string.no, null)</span><br><span class="line">                   .create();</span><br><span class="line">           closer.dialog = sConfirmDialog;</span><br><span class="line">           sConfirmDialog.setOnDismissListener(closer);</span><br><span class="line">           sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line">           sConfirmDialog.show();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           //走这里</span><br><span class="line">           beginShutdownSequence(context);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-10-ST-beginShutdownSequence"><a href="#2-10-ST-beginShutdownSequence" class="headerlink" title="2.10 ST.beginShutdownSequence"></a>2.10 ST.beginShutdownSequence</h3><p>[-&gt;ShutdownThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private static void beginShutdownSequence(Context context) &#123;</span><br><span class="line">       synchronized (sIsStartedGuard) &#123;</span><br><span class="line">           if (sIsStarted) &#123;</span><br><span class="line">               Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           sIsStarted = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       sInstance.mProgressDialog = showShutdownDialog(context);</span><br><span class="line">       sInstance.mContext = context;</span><br><span class="line">       sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line"></span><br><span class="line">       // make sure we never fall asleep again</span><br><span class="line">       sInstance.mCpuWakeLock = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                   PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;);</span><br><span class="line">           sInstance.mCpuWakeLock.setReferenceCounted(false);</span><br><span class="line">           sInstance.mCpuWakeLock.acquire();</span><br><span class="line">       &#125; catch (SecurityException e) &#123;</span><br><span class="line">           Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">           sInstance.mCpuWakeLock = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // also make sure the screen stays on for better user experience</span><br><span class="line">       sInstance.mScreenWakeLock = null;</span><br><span class="line">       if (sInstance.mPowerManager.isScreenOn()) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                       PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;);</span><br><span class="line">               sInstance.mScreenWakeLock.setReferenceCounted(false);</span><br><span class="line">               sInstance.mScreenWakeLock.acquire();</span><br><span class="line">           &#125; catch (SecurityException e) &#123;</span><br><span class="line">               Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">               sInstance.mScreenWakeLock = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (SecurityLog.isLoggingEnabled()) &#123;</span><br><span class="line">           SecurityLog.writeEvent(SecurityLog.TAG_OS_SHUTDOWN);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // start the thread that initiates shutdown</span><br><span class="line">       sInstance.mHandler = new Handler() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       //启动线程</span><br><span class="line">       sInstance.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-10-1-ST-showShutdownDialog"><a href="#2-10-1-ST-showShutdownDialog" class="headerlink" title="2.10.1 ST.showShutdownDialog"></a>2.10.1 ST.showShutdownDialog</h4><p>[-&gt;ShutdownThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">private static ProgressDialog showShutdownDialog(Context context) &#123;</span><br><span class="line">        // Throw up a system dialog to indicate the device is rebooting / shutting down.</span><br><span class="line">        ProgressDialog pd = new ProgressDialog(context);</span><br><span class="line"></span><br><span class="line">        // Path 1: Reboot to recovery for update</span><br><span class="line">        //   Condition: mReason startswith REBOOT_RECOVERY_UPDATE</span><br><span class="line">        //</span><br><span class="line">        //  Path 1a: uncrypt needed</span><br><span class="line">        //   Condition: if /cache/recovery/uncrypt_file exists but</span><br><span class="line">        //              /cache/recovery/block.map doesn&apos;t.</span><br><span class="line">        //   UI: determinate progress bar (mRebootHasProgressBar == True)</span><br><span class="line">        //</span><br><span class="line">        // * Path 1a is expected to be removed once the GmsCore shipped on</span><br><span class="line">        //   device always calls uncrypt prior to reboot.</span><br><span class="line">        //</span><br><span class="line">        //  Path 1b: uncrypt already done</span><br><span class="line">        //   UI: spinning circle only (no progress bar)</span><br><span class="line">        //</span><br><span class="line">        // Path 2: Reboot to recovery for factory reset</span><br><span class="line">        //   Condition: mReason == REBOOT_RECOVERY</span><br><span class="line">        //   UI: spinning circle only (no progress bar)</span><br><span class="line">        //</span><br><span class="line">        // Path 3: Regular reboot / shutdown</span><br><span class="line">        //   Condition: Otherwise</span><br><span class="line">        //   UI: spinning circle only (no progress bar)</span><br><span class="line"></span><br><span class="line">        // mReason could be &quot;recovery-update&quot; or &quot;recovery-update,quiescent&quot;.</span><br><span class="line">        //传入的是REBOOT_RECOVERY_UPDATE，走这里</span><br><span class="line">        if (mReason != null &amp;&amp; mReason.startsWith(PowerManager.REBOOT_RECOVERY_UPDATE)) &#123;</span><br><span class="line">            // We need the progress bar if uncrypt will be invoked during the</span><br><span class="line">            // reboot, which might be time-consuming.</span><br><span class="line">            mRebootHasProgressBar = RecoverySystem.UNCRYPT_PACKAGE_FILE.exists()</span><br><span class="line">                    &amp;&amp; !(RecoverySystem.BLOCK_MAP_FILE.exists());</span><br><span class="line">            pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));</span><br><span class="line">            //正常升级模式下，mRebootHasProgressBar = true</span><br><span class="line">            if (mRebootHasProgressBar) &#123;</span><br><span class="line">                pd.setMax(100);</span><br><span class="line">                pd.setProgress(0);</span><br><span class="line">                pd.setIndeterminate(false);</span><br><span class="line">                pd.setProgressNumberFormat(null);</span><br><span class="line">                pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                            com.android.internal.R.string.reboot_to_update_prepare));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (showSysuiReboot()) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                pd.setIndeterminate(true);</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                            com.android.internal.R.string.reboot_to_update_reboot));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (mReason != null &amp;&amp; mReason.equals(PowerManager.REBOOT_RECOVERY)) &#123;</span><br><span class="line">            if (RescueParty.isAttemptingFactoryReset()) &#123;</span><br><span class="line">                // We&apos;re not actually doing a factory reset yet; we&apos;re rebooting</span><br><span class="line">                // to ask the user if they&apos;d like to reset, so give them a less</span><br><span class="line">                // scary dialog message.</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.power_off));</span><br><span class="line">                pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));</span><br><span class="line">                pd.setIndeterminate(true);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Factory reset path. Set the dialog message accordingly.</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                            com.android.internal.R.string.reboot_to_reset_message));</span><br><span class="line">                pd.setIndeterminate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (showSysuiReboot()) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            pd.setTitle(context.getText(com.android.internal.R.string.power_off));</span><br><span class="line">            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));</span><br><span class="line">            pd.setIndeterminate(true);</span><br><span class="line">        &#125;</span><br><span class="line">        pd.setCancelable(false);</span><br><span class="line">        pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        pd.show();</span><br><span class="line">        return pd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-11-ST-run"><a href="#2-11-ST-run" class="headerlink" title="2.11 ST.run"></a>2.11 ST.run</h3><p>[-&gt;ShutdownThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Makes sure we handle the shutdown gracefully.</span><br><span class="line">   * Shuts off power regardless of radio state if the allotted time has passed.</span><br><span class="line">   */</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      TimingsTraceLog shutdownTimingLog = newTimingsLog();</span><br><span class="line">      shutdownTimingLog.traceBegin(&quot;SystemServerShutdown&quot;);</span><br><span class="line">      metricShutdownStart();</span><br><span class="line">      metricStarted(METRIC_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">      BroadcastReceiver br = new BroadcastReceiver() &#123;</span><br><span class="line">          @Override public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">              // We don&apos;t allow apps to cancel this, so ignore the result.</span><br><span class="line">              actionDone();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * Write a system property in case the system_server reboots before we</span><br><span class="line">       * get to the actual hardware restart. If that happens, we&apos;ll retry at</span><br><span class="line">       * the beginning of the SystemServer startup.</span><br><span class="line">       */</span><br><span class="line">      &#123;</span><br><span class="line">          String reason = (mReboot ? &quot;1&quot; : &quot;0&quot;) + (mReason != null ? mReason : &quot;&quot;);</span><br><span class="line">          SystemProperties.set(SHUTDOWN_ACTION_PROPERTY, reason);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * If we are rebooting into safe mode, write a system property</span><br><span class="line">       * indicating so.</span><br><span class="line">       */</span><br><span class="line">      if (mRebootSafeMode) &#123;</span><br><span class="line">          SystemProperties.set(REBOOT_SAFEMODE_PROPERTY, &quot;1&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      metricStarted(METRIC_SEND_BROADCAST);</span><br><span class="line">      shutdownTimingLog.traceBegin(&quot;SendShutdownBroadcast&quot;);</span><br><span class="line">      Log.i(TAG, &quot;Sending shutdown broadcast...&quot;);</span><br><span class="line"></span><br><span class="line">      // First send the high-level shut down broadcast.</span><br><span class="line">      mActionDone = false;</span><br><span class="line">      Intent intent = new Intent(Intent.ACTION_SHUTDOWN);</span><br><span class="line">      intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND | Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">      mContext.sendOrderedBroadcastAsUser(intent,</span><br><span class="line">              UserHandle.ALL, null, br, mHandler, 0, null, null);</span><br><span class="line"></span><br><span class="line">      final long endTime = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;</span><br><span class="line">      synchronized (mActionDoneSync) &#123;</span><br><span class="line">          while (!mActionDone) &#123;</span><br><span class="line">              long delay = endTime - SystemClock.elapsedRealtime();</span><br><span class="line">              if (delay &lt;= 0) &#123;</span><br><span class="line">                  Log.w(TAG, &quot;Shutdown broadcast timed out&quot;);</span><br><span class="line">                  break;</span><br><span class="line">              &#125; else if (mRebootHasProgressBar) &#123;</span><br><span class="line">                  int status = (int)((MAX_BROADCAST_TIME - delay) * 1.0 *</span><br><span class="line">                          BROADCAST_STOP_PERCENT / MAX_BROADCAST_TIME);</span><br><span class="line">                  sInstance.setRebootProgress(status, null);</span><br><span class="line">              &#125;</span><br><span class="line">              try &#123;</span><br><span class="line">                  mActionDoneSync.wait(Math.min(delay, ACTION_DONE_POLL_WAIT_MS));</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (mRebootHasProgressBar) &#123;</span><br><span class="line">          sInstance.setRebootProgress(BROADCAST_STOP_PERCENT, null);</span><br><span class="line">      &#125;</span><br><span class="line">      shutdownTimingLog.traceEnd(); // SendShutdownBroadcast</span><br><span class="line">      metricEnded(METRIC_SEND_BROADCAST);</span><br><span class="line"></span><br><span class="line">      Log.i(TAG, &quot;Shutting down activity manager...&quot;);</span><br><span class="line">      shutdownTimingLog.traceBegin(&quot;ShutdownActivityManager&quot;);</span><br><span class="line">      metricStarted(METRIC_AM);</span><br><span class="line"></span><br><span class="line">      final IActivityManager am =</span><br><span class="line">              IActivityManager.Stub.asInterface(ServiceManager.checkService(&quot;activity&quot;));</span><br><span class="line">      if (am != null) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              am.shutdown(MAX_BROADCAST_TIME);</span><br><span class="line">          &#125; catch (RemoteException e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (mRebootHasProgressBar) &#123;</span><br><span class="line">          sInstance.setRebootProgress(ACTIVITY_MANAGER_STOP_PERCENT, null);</span><br><span class="line">      &#125;</span><br><span class="line">      shutdownTimingLog.traceEnd();// ShutdownActivityManager</span><br><span class="line">      metricEnded(METRIC_AM);</span><br><span class="line"></span><br><span class="line">      Log.i(TAG, &quot;Shutting down package manager...&quot;);</span><br><span class="line">      shutdownTimingLog.traceBegin(&quot;ShutdownPackageManager&quot;);</span><br><span class="line">      metricStarted(METRIC_PM);</span><br><span class="line"></span><br><span class="line">      final PackageManagerService pm = (PackageManagerService)</span><br><span class="line">          ServiceManager.getService(&quot;package&quot;);</span><br><span class="line">      if (pm != null) &#123;</span><br><span class="line">          pm.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">      if (mRebootHasProgressBar) &#123;</span><br><span class="line">          sInstance.setRebootProgress(PACKAGE_MANAGER_STOP_PERCENT, null);</span><br><span class="line">      &#125;</span><br><span class="line">      shutdownTimingLog.traceEnd(); // ShutdownPackageManager</span><br><span class="line">      metricEnded(METRIC_PM);</span><br><span class="line"></span><br><span class="line">      // Shutdown radios.</span><br><span class="line">      shutdownTimingLog.traceBegin(&quot;ShutdownRadios&quot;);</span><br><span class="line">      metricStarted(METRIC_RADIOS);</span><br><span class="line">      shutdownRadios(MAX_RADIO_WAIT_TIME);</span><br><span class="line">      if (mRebootHasProgressBar) &#123;</span><br><span class="line">          sInstance.setRebootProgress(RADIO_STOP_PERCENT, null);</span><br><span class="line">      &#125;</span><br><span class="line">      shutdownTimingLog.traceEnd(); // ShutdownRadios</span><br><span class="line">      metricEnded(METRIC_RADIOS);</span><br><span class="line">      </span><br><span class="line">      //为true，将执行uncrypt操作</span><br><span class="line">      if (mRebootHasProgressBar) &#123;</span><br><span class="line">          sInstance.setRebootProgress(MOUNT_SERVICE_STOP_PERCENT, null);</span><br><span class="line"></span><br><span class="line">          // If it&apos;s to reboot to install an update and uncrypt hasn&apos;t been</span><br><span class="line">          // done yet, trigger it now.</span><br><span class="line">          uncrypt();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      shutdownTimingLog.traceEnd(); // SystemServerShutdown</span><br><span class="line">      metricEnded(METRIC_SYSTEM_SERVER);</span><br><span class="line">      saveMetrics(mReboot, mReason);</span><br><span class="line">      // Remaining work will be done by init, including vold shutdown</span><br><span class="line">      rebootOrShutdown(mContext, mReboot, mReason);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-12-ST-uncrypt"><a href="#2-12-ST-uncrypt" class="headerlink" title="2.12 ST.uncrypt"></a>2.12 ST.uncrypt</h3><p>[-&gt;ShutdownThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private void uncrypt() &#123;</span><br><span class="line">        Log.i(TAG, &quot;Calling uncrypt and monitoring the progress...&quot;);</span><br><span class="line"></span><br><span class="line">        final RecoverySystem.ProgressListener progressListener =</span><br><span class="line">                new RecoverySystem.ProgressListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onProgress(int status) &#123;</span><br><span class="line">                if (status &gt;= 0 &amp;&amp; status &lt; 100) &#123;</span><br><span class="line">                    // Scale down to [MOUNT_SERVICE_STOP_PERCENT, 100).</span><br><span class="line">                    status = (int)(status * (100.0 - MOUNT_SERVICE_STOP_PERCENT) / 100);</span><br><span class="line">                    status += MOUNT_SERVICE_STOP_PERCENT;</span><br><span class="line">                    CharSequence msg = mContext.getText(</span><br><span class="line">                            com.android.internal.R.string.reboot_to_update_package);</span><br><span class="line">                    sInstance.setRebootProgress(status, msg);</span><br><span class="line">                &#125; else if (status == 100) &#123;</span><br><span class="line">                    CharSequence msg = mContext.getText(</span><br><span class="line">                            com.android.internal.R.string.reboot_to_update_reboot);</span><br><span class="line">                    sInstance.setRebootProgress(status, msg);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Ignored</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        final boolean[] done = new boolean[1];</span><br><span class="line">        done[0] = false;</span><br><span class="line">        Thread t = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                RecoverySystem rs = (RecoverySystem) mContext.getSystemService(</span><br><span class="line">                        Context.RECOVERY_SERVICE);</span><br><span class="line">                String filename = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    filename = FileUtils.readTextFile(RecoverySystem.UNCRYPT_PACKAGE_FILE, 0, null);</span><br><span class="line">                    rs.processPackage(mContext, new File(filename), progressListener);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    Log.e(TAG, &quot;Error uncrypting file&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                done[0] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            t.join(MAX_UNCRYPT_WAIT_TIME);</span><br><span class="line">        &#125; catch (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!done[0]) &#123;</span><br><span class="line">            Log.w(TAG, &quot;Timed out waiting for uncrypt.&quot;);</span><br><span class="line">            final int uncryptTimeoutError = 100;</span><br><span class="line">            String timeoutMessage = String.format(&quot;uncrypt_time: %d/n&quot; + &quot;uncrypt_error: %d/n&quot;,</span><br><span class="line">                    MAX_UNCRYPT_WAIT_TIME / 1000, uncryptTimeoutError);</span><br><span class="line">            try &#123;</span><br><span class="line">                FileUtils.stringToFile(RecoverySystem.UNCRYPT_STATUS_FILE, timeoutMessage);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, &quot;Failed to write timeout message to uncrypt status&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-13-RS-processPackage"><a href="#2-13-RS-processPackage" class="headerlink" title="2.13 RS.processPackage"></a>2.13 RS.processPackage</h3><p>[-&gt;RecoverySystem.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public static void processPackage(Context context,</span><br><span class="line">                                     File packageFile,</span><br><span class="line">                                     final ProgressListener listener,</span><br><span class="line">                                     final Handler handler)</span><br><span class="line">           throws IOException &#123;</span><br><span class="line">       String filename = packageFile.getCanonicalPath();</span><br><span class="line">       if (!filename.startsWith(&quot;/data/&quot;)) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       RecoverySystem rs = (RecoverySystem) context.getSystemService(Context.RECOVERY_SERVICE);</span><br><span class="line">       IRecoverySystemProgressListener progressListener = null;</span><br><span class="line">       if (listener != null) &#123;</span><br><span class="line">           final Handler progressHandler;</span><br><span class="line">           if (handler != null) &#123;</span><br><span class="line">               progressHandler = handler;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               progressHandler = new Handler(context.getMainLooper());</span><br><span class="line">           &#125;</span><br><span class="line">           progressListener = new IRecoverySystemProgressListener.Stub() &#123;</span><br><span class="line">               int lastProgress = 0;</span><br><span class="line">               long lastPublishTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">               @Override</span><br><span class="line">               public void onProgress(final int progress) &#123;</span><br><span class="line">                   final long now = System.currentTimeMillis();</span><br><span class="line">                   progressHandler.post(new Runnable() &#123;</span><br><span class="line">                       @Override</span><br><span class="line">                       public void run() &#123;</span><br><span class="line">                           if (progress &gt; lastProgress &amp;&amp;</span><br><span class="line">                                   now - lastPublishTime &gt; PUBLISH_PROGRESS_INTERVAL_MS) &#123;</span><br><span class="line">                               lastProgress = progress;</span><br><span class="line">                               lastPublishTime = now;</span><br><span class="line">                               listener.onProgress(progress);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       //通过progressListener传递进度到界面</span><br><span class="line">       if (!rs.uncrypt(filename, progressListener)) &#123;</span><br><span class="line">           throw new IOException(&quot;process package failed&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-14-RS-uncrypt"><a href="#2-14-RS-uncrypt" class="headerlink" title="2.14 RS.uncrypt"></a>2.14 RS.uncrypt</h3><p>[-&gt;RecoverySystem.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Talks to RecoverySystemService via Binder to trigger uncrypt.</span><br><span class="line">    */</span><br><span class="line">   private boolean uncrypt(String packageFile, IRecoverySystemProgressListener listener) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           return mService.uncrypt(packageFile, listener);</span><br><span class="line">       &#125; catch (RemoteException unused) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-15-RSS-uncrypt"><a href="#2-15-RSS-uncrypt" class="headerlink" title="2.15 RSS.uncrypt"></a>2.15 RSS.uncrypt</h3><p>[-&gt;RecoverySystemService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public boolean uncrypt(String filename, IRecoverySystemProgressListener listener) &#123;</span><br><span class="line">            if (DEBUG) Slog.d(TAG, &quot;uncrypt: &quot; + filename);</span><br><span class="line"></span><br><span class="line">            synchronized (sRequestLock) &#123;</span><br><span class="line">                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);</span><br><span class="line"></span><br><span class="line">                final boolean available = checkAndWaitForUncryptService();</span><br><span class="line">                if (!available) &#123;</span><br><span class="line">                    Slog.e(TAG, &quot;uncrypt service is unavailable.&quot;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Write the filename into UNCRYPT_PACKAGE_FILE to be read by</span><br><span class="line">                // uncrypt.</span><br><span class="line">                RecoverySystem.UNCRYPT_PACKAGE_FILE.delete();</span><br><span class="line"></span><br><span class="line">                try (FileWriter uncryptFile = new FileWriter(RecoverySystem.UNCRYPT_PACKAGE_FILE)) &#123;</span><br><span class="line">                    uncryptFile.write(filename + &quot;/n&quot;);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    Slog.e(TAG, &quot;IOException when writing /&quot;&quot; +</span><br><span class="line">                            RecoverySystem.UNCRYPT_PACKAGE_FILE + &quot;/&quot;:&quot;, e);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Trigger uncrypt via init.</span><br><span class="line">                //通过设置ctl.start属性，开启uncrypt服务</span><br><span class="line">                SystemProperties.set(&quot;ctl.start&quot;, &quot;uncrypt&quot;);</span><br><span class="line"></span><br><span class="line">                // Connect to the uncrypt service socket.</span><br><span class="line">                //连接服务</span><br><span class="line">                LocalSocket socket = connectService();</span><br><span class="line">                if (socket == null) &#123;</span><br><span class="line">                    Slog.e(TAG, &quot;Failed to connect to uncrypt socket&quot;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Read the status from the socket.</span><br><span class="line">                DataInputStream dis = null;</span><br><span class="line">                DataOutputStream dos = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dis = new DataInputStream(socket.getInputStream());</span><br><span class="line">                    dos = new DataOutputStream(socket.getOutputStream());</span><br><span class="line">                    int lastStatus = Integer.MIN_VALUE;</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        // 读取进度</span><br><span class="line">                        int status = dis.readInt();</span><br><span class="line">                        // Avoid flooding the log with the same message.</span><br><span class="line">                        if (status == lastStatus &amp;&amp; lastStatus != Integer.MIN_VALUE) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lastStatus = status;</span><br><span class="line"></span><br><span class="line">                        if (status &gt;= 0 &amp;&amp; status &lt;= 100) &#123;</span><br><span class="line">                            // Update status</span><br><span class="line">                            Slog.i(TAG, &quot;uncrypt read status: &quot; + status);</span><br><span class="line">                            if (listener != null) &#123;</span><br><span class="line">                                try &#123;</span><br><span class="line">                                    listener.onProgress(status);</span><br><span class="line">                                &#125; catch (RemoteException ignored) &#123;</span><br><span class="line">                                    Slog.w(TAG, &quot;RemoteException when posting progress&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (status == 100) &#123;</span><br><span class="line">                                Slog.i(TAG, &quot;uncrypt successfully finished.&quot;);</span><br><span class="line">                                // Ack receipt of the final status code. uncrypt</span><br><span class="line">                                // waits for the ack so the socket won&apos;t be</span><br><span class="line">                                // destroyed before we receive the code.</span><br><span class="line">                                dos.writeInt(0);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            // Error in /system/bin/uncrypt.</span><br><span class="line">                            Slog.e(TAG, &quot;uncrypt failed with status: &quot; + status);</span><br><span class="line">                            // Ack receipt of the final status code. uncrypt waits</span><br><span class="line">                            // for the ack so the socket won&apos;t be destroyed before</span><br><span class="line">                            // we receive the code.</span><br><span class="line">                            dos.writeInt(0);</span><br><span class="line">                            return false;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    Slog.e(TAG, &quot;IOException when reading status: &quot;, e);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    IoUtils.closeQuietly(dis);</span><br><span class="line">                    IoUtils.closeQuietly(dos);</span><br><span class="line">                    IoUtils.closeQuietly(socket);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>SystemProperties.set(“ctl.start”, “uncrypt”);这个操作主要是通过init（启动的Properties服务）进行,而后启动uncrypt服务，通过socket方式systemserver和uncrypt进行通信。</p>
<p>[-&gt;uncrypt.rc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">service uncrypt /system/bin/uncrypt</span><br><span class="line">    class main</span><br><span class="line">    socket uncrypt stream 600 system system</span><br><span class="line">    disabled</span><br><span class="line">    oneshot</span><br><span class="line"></span><br><span class="line">service setup-bcb /system/bin/uncrypt --setup-bcb</span><br><span class="line">    class main</span><br><span class="line">    socket uncrypt stream 600 system system</span><br><span class="line">    disabled</span><br><span class="line">    oneshot</span><br><span class="line"></span><br><span class="line">service clear-bcb /system/bin/uncrypt --clear-bcb</span><br><span class="line">    class main</span><br><span class="line">    socket uncrypt stream 600 system system</span><br><span class="line">    disabled</span><br><span class="line">    oneshot</span><br></pre></td></tr></table></figure>
<h3 id="2-16-uncrypt-main"><a href="#2-16-uncrypt-main" class="headerlink" title="2.16 uncrypt.main"></a>2.16 uncrypt.main</h3><p>[-&gt;uncrypt.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// If the filesystem is using an encrypted block device, it will also</span><br><span class="line">// read the file and rewrite it to the same blocks of the underlying</span><br><span class="line">// (unencrypted) block device, so the file contents can be read</span><br><span class="line">// without the need for the decryption key.</span><br><span class="line">//</span><br><span class="line">// The output of this program is a &quot;block map&quot; which looks like this:</span><br><span class="line">//</span><br><span class="line">//     /dev/block/platform/msm_sdcc.1/by-name/userdata     # block device</span><br><span class="line">//     49652 4096                        # file size in bytes, block size</span><br><span class="line">//     3                                 # count of block ranges</span><br><span class="line">//     1000 1008                         # block range 0</span><br><span class="line">//     2100 2102                         # ... block range 1</span><br><span class="line">//     30 33                             # ... block range 2</span><br><span class="line">//</span><br><span class="line">// Each block range represents a half-open interval; the line &quot;30 33&quot;</span><br><span class="line">// reprents the blocks [30, 31, 32].</span><br><span class="line">//</span><br><span class="line">// Recovery can take this block map file and retrieve the underlying</span><br><span class="line">// file data to use as an update package.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * In addition to the uncrypt work, uncrypt also takes care of setting and</span><br><span class="line"> * clearing the bootloader control block (BCB) at /misc partition.</span><br><span class="line"> *</span><br><span class="line"> * uncrypt is triggered as init services on demand. It uses socket to</span><br><span class="line"> * communicate with its caller (i.e. system_server). The socket is managed by</span><br><span class="line"> * init (i.e. created prior to the service starts, and destroyed when uncrypt</span><br><span class="line"> * exits).</span><br><span class="line"> *</span><br><span class="line"> * Below is the uncrypt protocol.</span><br><span class="line"> *</span><br><span class="line"> *    a. caller                 b. init                    c. uncrypt</span><br><span class="line"> * ---------------            ------------               --------------</span><br><span class="line"> *  a1. ctl.start:</span><br><span class="line"> *    setup-bcb /</span><br><span class="line"> *    clear-bcb /</span><br><span class="line"> *    uncrypt</span><br><span class="line"> *</span><br><span class="line"> *                         b2. create socket at</span><br><span class="line"> *                           /dev/socket/uncrypt</span><br><span class="line"> *</span><br><span class="line"> *                                                   c3. listen and accept</span><br><span class="line"> *</span><br><span class="line"> *  a4. send a 4-byte int</span><br><span class="line"> *    (message length)</span><br><span class="line"> *                                                   c5. receive message length</span><br><span class="line"> *  a6. send message</span><br><span class="line"> *                                                   c7. receive message</span><br><span class="line"> *                                                   c8. &lt;do the work; may send</span><br><span class="line"> *                                                      the progress&gt;</span><br><span class="line"> *  a9. &lt;may handle progress&gt;</span><br><span class="line"> *                                                   c10. &lt;upon finishing&gt;</span><br><span class="line"> *                                                     send &quot;100&quot; or &quot;-1&quot;</span><br><span class="line"> *</span><br><span class="line"> *  a11. receive status code</span><br><span class="line"> *  a12. send a 4-byte int to</span><br><span class="line"> *    ack the receive of the</span><br><span class="line"> *    final status code</span><br><span class="line"> *                                                   c13. receive and exit</span><br><span class="line"> *</span><br><span class="line"> *                          b14. destroy the socket</span><br><span class="line"> *</span><br><span class="line"> * Note that a12 and c13 are necessary to ensure a11 happens before the socket</span><br><span class="line"> * gets destroyed in b14.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    enum &#123; UNCRYPT, SETUP_BCB, CLEAR_BCB, UNCRYPT_DEBUG &#125; action;</span><br><span class="line">    const char* input_path = nullptr;</span><br><span class="line">    const char* map_file = CACHE_BLOCK_MAP.c_str();</span><br><span class="line">    //解析参数</span><br><span class="line">    if (argc == 2 &amp;&amp; strcmp(argv[1], &quot;--clear-bcb&quot;) == 0) &#123;</span><br><span class="line">        action = CLEAR_BCB;</span><br><span class="line">    &#125; else if (argc == 2 &amp;&amp; strcmp(argv[1], &quot;--setup-bcb&quot;) == 0) &#123;</span><br><span class="line">        action = SETUP_BCB;</span><br><span class="line">    &#125; else if (argc == 1) &#123;</span><br><span class="line">        action = UNCRYPT;</span><br><span class="line">    &#125; else if (argc == 3) &#123;</span><br><span class="line">        input_path = argv[1];</span><br><span class="line">        map_file = argv[2];</span><br><span class="line">        action = UNCRYPT_DEBUG;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        usage(argv[0]);</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((fstab = read_fstab()) == nullptr) &#123;</span><br><span class="line">        log_uncrypt_error_code(kUncryptFstabReadError);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (action == UNCRYPT_DEBUG) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;uncrypt called in debug mode, skip socket communication&quot;;</span><br><span class="line">        bool success = uncrypt_wrapper(input_path, map_file, -1);</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            LOG(INFO) &lt;&lt; &quot;uncrypt succeeded&quot;;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            LOG(INFO) &lt;&lt; &quot;uncrypt failed&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return success ? 0 : 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // c3. The socket is created by init when starting the service. uncrypt</span><br><span class="line">    // will use the socket to communicate with its caller.</span><br><span class="line">    android::base::unique_fd service_socket(android_get_control_socket(UNCRYPT_SOCKET.c_str()));</span><br><span class="line">    if (service_socket == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to open socket /&quot;&quot; &lt;&lt; UNCRYPT_SOCKET &lt;&lt; &quot;/&quot;&quot;;</span><br><span class="line">        log_uncrypt_error_code(kUncryptSocketOpenError);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    fcntl(service_socket, F_SETFD, FD_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    if (listen(service_socket, 1) == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to listen on socket &quot; &lt;&lt; service_socket.get();</span><br><span class="line">        log_uncrypt_error_code(kUncryptSocketListenError);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android::base::unique_fd socket_fd(accept4(service_socket, nullptr, nullptr, SOCK_CLOEXEC));</span><br><span class="line">    if (socket_fd == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to accept on socket &quot; &lt;&lt; service_socket.get();</span><br><span class="line">        log_uncrypt_error_code(kUncryptSocketAcceptError);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool success = false;</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">        //UNCRYPT操作</span><br><span class="line">        case UNCRYPT:</span><br><span class="line">            success = uncrypt_wrapper(input_path, map_file, socket_fd);</span><br><span class="line">            break;</span><br><span class="line">        case SETUP_BCB:</span><br><span class="line">            success = setup_bcb(socket_fd);</span><br><span class="line">            break;</span><br><span class="line">        case CLEAR_BCB:</span><br><span class="line">            success = clear_bcb(socket_fd);</span><br><span class="line">            break;</span><br><span class="line">        default:  // Should never happen.</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;Invalid uncrypt action code: &quot; &lt;&lt; action;</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // c13. Read a 4-byte code from the client before uncrypt exits. This is to</span><br><span class="line">    // ensure the client to receive the last status code before the socket gets</span><br><span class="line">    // destroyed.</span><br><span class="line">    int code;</span><br><span class="line">    if (android::base::ReadFully(socket_fd, &amp;code, 4)) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;  received &quot; &lt;&lt; code &lt;&lt; &quot;, exiting now&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to read the code&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return success ? 0 : 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过文件头的注释，可以知道具体的通信方式。</p>
<h3 id="2-17-uncrypt-uncrypt-wrapper"><a href="#2-17-uncrypt-uncrypt-wrapper" class="headerlink" title="2.17 uncrypt.uncrypt_wrapper"></a>2.17 uncrypt.uncrypt_wrapper</h3><p>[-&gt;uncrypt.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static bool uncrypt_wrapper(const char* input_path, const char* map_file, const int socket) &#123;</span><br><span class="line">    // Initialize the uncrypt error to kUncryptErrorPlaceholder.</span><br><span class="line">    log_uncrypt_error_code(kUncryptErrorPlaceholder);</span><br><span class="line"></span><br><span class="line">    std::string package;</span><br><span class="line">    if (input_path == nullptr) &#123;</span><br><span class="line">        if (!find_uncrypt_package(UNCRYPT_PATH_FILE, &amp;package)) &#123;</span><br><span class="line">            write_status_to_socket(-1, socket);</span><br><span class="line">            // Overwrite the error message.</span><br><span class="line">            log_uncrypt_error_code(kUncryptPackageMissingError);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        input_path = package.c_str();</span><br><span class="line">    &#125;</span><br><span class="line">    CHECK(map_file != nullptr);</span><br><span class="line"></span><br><span class="line">    auto start = std::chrono::system_clock::now();</span><br><span class="line">    //执行uncrypt操作</span><br><span class="line">    int status = uncrypt(input_path, map_file, socket);</span><br><span class="line">    std::chrono::duration&lt;double&gt; duration = std::chrono::system_clock::now() - start;</span><br><span class="line">    int count = static_cast&lt;int&gt;(duration.count());</span><br><span class="line"></span><br><span class="line">    std::string uncrypt_message = android::base::StringPrintf(&quot;uncrypt_time: %d/n&quot;, count);</span><br><span class="line">    if (status != 0) &#123;</span><br><span class="line">        // Log the time cost and error code if uncrypt fails.</span><br><span class="line">        uncrypt_message += android::base::StringPrintf(&quot;uncrypt_error: %d/n&quot;, status);</span><br><span class="line">        if (!android::base::WriteStringToFile(uncrypt_message, UNCRYPT_STATUS)) &#123;</span><br><span class="line">            PLOG(WARNING) &lt;&lt; &quot;failed to write to &quot; &lt;&lt; UNCRYPT_STATUS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write_status_to_socket(-1, socket);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!android::base::WriteStringToFile(uncrypt_message, UNCRYPT_STATUS)) &#123;</span><br><span class="line">        PLOG(WARNING) &lt;&lt; &quot;failed to write to &quot; &lt;&lt; UNCRYPT_STATUS;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过socket方式通知进度</span><br><span class="line">    write_status_to_socket(100, socket);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-18-uncrypt-uncrypt"><a href="#2-18-uncrypt-uncrypt" class="headerlink" title="2.18  uncrypt.uncrypt"></a>2.18  uncrypt.uncrypt</h3><p>[-&gt;uncrypt.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static int uncrypt(const char* input_path, const char* map_file, const int socket) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;update package is /&quot;&quot; &lt;&lt; input_path &lt;&lt; &quot;/&quot;&quot;;</span><br><span class="line"></span><br><span class="line">    // Turn the name of the file we&apos;re supposed to convert into an absolute path, so we can find</span><br><span class="line">    // what filesystem it&apos;s on.</span><br><span class="line">    char path[PATH_MAX+1];</span><br><span class="line">    if (realpath(input_path, path) == nullptr) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to convert /&quot;&quot; &lt;&lt; input_path &lt;&lt; &quot;/&quot; to absolute path&quot;;</span><br><span class="line">        return kUncryptRealpathFindError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool encryptable;</span><br><span class="line">    bool encrypted;</span><br><span class="line">    bool f2fs_fs;</span><br><span class="line">    const char* blk_dev = find_block_device(path, &amp;encryptable, &amp;encrypted, &amp;f2fs_fs);</span><br><span class="line">    if (blk_dev == nullptr) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;failed to find block device for &quot; &lt;&lt; path;</span><br><span class="line">        return kUncryptBlockDeviceFindError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the filesystem it&apos;s on isn&apos;t encrypted, we only produce the</span><br><span class="line">    // block map, we don&apos;t rewrite the file contents (it would be</span><br><span class="line">    // pointless to do so).</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;encryptable: &quot; &lt;&lt; (encryptable ? &quot;yes&quot; : &quot;no&quot;);</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;  encrypted: &quot; &lt;&lt; (encrypted ? &quot;yes&quot; : &quot;no&quot;);</span><br><span class="line"></span><br><span class="line">    // Recovery supports installing packages from 3 paths: /cache,</span><br><span class="line">    // /data, and /sdcard.  (On a particular device, other locations</span><br><span class="line">    // may work, but those are three we actually expect.)</span><br><span class="line">    //</span><br><span class="line">    // On /data we want to convert the file to a block map so that we</span><br><span class="line">    // can read the package without mounting the partition.  On /cache</span><br><span class="line">    // and /sdcard we leave the file alone.</span><br><span class="line">    if (strncmp(path, &quot;/data/&quot;, 6) == 0) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;writing block map &quot; &lt;&lt; map_file;</span><br><span class="line">        //生成blockmap</span><br><span class="line">        return produce_block_map(path, map_file, blk_dev, encrypted, f2fs_fs, socket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-19-uncrypt-produce-block-map"><a href="#2-19-uncrypt-produce-block-map" class="headerlink" title="2.19  uncrypt.produce_block_map"></a>2.19  uncrypt.produce_block_map</h3><p>[-&gt;uncrypt.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">  static int produce_block_map(const char* path, const char* map_file, const char* blk_dev,</span><br><span class="line">                             bool encrypted, bool f2fs_fs, int socket) &#123;</span><br><span class="line">    std::string err;</span><br><span class="line">    if (!android::base::RemoveFileIfExists(map_file, &amp;err)) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;failed to remove the existing map file &quot; &lt;&lt; map_file &lt;&lt; &quot;: &quot; &lt;&lt; err;</span><br><span class="line">        return kUncryptFileRemoveError;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string tmp_map_file = std::string(map_file) + &quot;.tmp&quot;;</span><br><span class="line">    android::base::unique_fd mapfd(open(tmp_map_file.c_str(),</span><br><span class="line">                                        O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR));</span><br><span class="line">    if (mapfd == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to open &quot; &lt;&lt; tmp_map_file;</span><br><span class="line">        return kUncryptFileOpenError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure we can write to the socket.</span><br><span class="line">    if (!write_status_to_socket(0, socket)) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;failed to write to socket &quot; &lt;&lt; socket;</span><br><span class="line">        return kUncryptSocketWriteError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct stat sb;</span><br><span class="line">    if (stat(path, &amp;sb) != 0) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;failed to stat &quot; &lt;&lt; path;</span><br><span class="line">        return kUncryptFileStatError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; &quot; block size: &quot; &lt;&lt; sb.st_blksize &lt;&lt; &quot; bytes&quot;;</span><br><span class="line"></span><br><span class="line">    int blocks = ((sb.st_size-1) / sb.st_blksize) + 1;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;  file size: &quot; &lt;&lt; sb.st_size &lt;&lt; &quot; bytes, &quot; &lt;&lt; blocks &lt;&lt; &quot; blocks&quot;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;int&gt; ranges;</span><br><span class="line"></span><br><span class="line">    std::string s = android::base::StringPrintf(&quot;%s/n%&quot; PRId64 &quot; %&quot; PRId64 &quot;/n&quot;,</span><br><span class="line">                       blk_dev, static_cast&lt;int64_t&gt;(sb.st_size),</span><br><span class="line">                       static_cast&lt;int64_t&gt;(sb.st_blksize));</span><br><span class="line">    if (!android::base::WriteStringToFd(s, mapfd)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to write &quot; &lt;&lt; tmp_map_file;</span><br><span class="line">        return kUncryptWriteError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;unsigned char&gt;&gt; buffers;</span><br><span class="line">    /*</span><br><span class="line">     * buffers大小为5，static constexpr int WINDOW_SIZE = 5;</span><br><span class="line">     */</span><br><span class="line">    if (encrypted) &#123;</span><br><span class="line">        buffers.resize(WINDOW_SIZE, std::vector&lt;unsigned char&gt;(sb.st_blksize));</span><br><span class="line">    &#125;</span><br><span class="line">    int head_block = 0;</span><br><span class="line">    int head = 0, tail = 0;</span><br><span class="line"></span><br><span class="line">    android::base::unique_fd fd(open(path, O_RDONLY));</span><br><span class="line">    if (fd == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to open &quot; &lt;&lt; path &lt;&lt; &quot; for reading&quot;;</span><br><span class="line">        return kUncryptFileOpenError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android::base::unique_fd wfd;</span><br><span class="line">    if (encrypted) &#123;</span><br><span class="line">        wfd.reset(open(blk_dev, O_WRONLY));</span><br><span class="line">        if (wfd == -1) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; &quot;failed to open &quot; &lt;&lt; blk_dev &lt;&lt; &quot; for writing&quot;;</span><br><span class="line">            return kUncryptBlockOpenError;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifndef F2FS_IOC_SET_DONTMOVE</span><br><span class="line">#ifndef F2FS_IOCTL_MAGIC</span><br><span class="line">#define F2FS_IOCTL_MAGIC		0xf5</span><br><span class="line">#endif</span><br><span class="line">#define F2FS_IOC_SET_DONTMOVE		_IO(F2FS_IOCTL_MAGIC, 13)</span><br><span class="line">#endif</span><br><span class="line">    if (f2fs_fs &amp;&amp; ioctl(fd, F2FS_IOC_SET_DONTMOVE) &lt; 0) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;Failed to set non-movable file for f2fs: &quot; &lt;&lt; path &lt;&lt; &quot; on &quot; &lt;&lt; blk_dev;</span><br><span class="line">        return kUncryptIoctlError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off64_t pos = 0;</span><br><span class="line">    int last_progress = 0;</span><br><span class="line">    while (pos &lt; sb.st_size) &#123;</span><br><span class="line">        // Update the status file, progress must be between [0, 99].</span><br><span class="line">        int progress = static_cast&lt;int&gt;(100 * (double(pos) / double(sb.st_size)));</span><br><span class="line">        if (progress &gt; last_progress) &#123;</span><br><span class="line">            last_progress = progress;</span><br><span class="line">            write_status_to_socket(progress, socket);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((tail+1) % WINDOW_SIZE == head) &#123;</span><br><span class="line">            // write out head buffer</span><br><span class="line">            int block = head_block;</span><br><span class="line">            if (ioctl(fd, FIBMAP, &amp;block) != 0) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; &quot;failed to find block &quot; &lt;&lt; head_block;</span><br><span class="line">                return kUncryptIoctlError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (block == 0) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;failed to find block &quot; &lt;&lt; head_block &lt;&lt; &quot;, retrying&quot;;</span><br><span class="line">                int error = retry_fibmap(fd, path, &amp;block, head_block);</span><br><span class="line">                if (error != kUncryptNoError) &#123;</span><br><span class="line">                    return error;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            add_block_to_ranges(ranges, block);</span><br><span class="line">             //data分区是否加密</span><br><span class="line">            if (encrypted) &#123;</span><br><span class="line">                if (write_at_offset(buffers[head].data(), sb.st_blksize, wfd,</span><br><span class="line">                                    static_cast&lt;off64_t&gt;(sb.st_blksize) * block) != 0) &#123;</span><br><span class="line">                    return kUncryptWriteError;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = (head + 1) % WINDOW_SIZE;</span><br><span class="line">            ++head_block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // read next block to tail</span><br><span class="line">        // data分区加密</span><br><span class="line">        if (encrypted) &#123;</span><br><span class="line">            size_t to_read = static_cast&lt;size_t&gt;(</span><br><span class="line">                    std::min(static_cast&lt;off64_t&gt;(sb.st_blksize), sb.st_size - pos));</span><br><span class="line">            if (!android::base::ReadFully(fd, buffers[tail].data(), to_read)) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; &quot;failed to read &quot; &lt;&lt; path;</span><br><span class="line">                return kUncryptReadError;</span><br><span class="line">            &#125;</span><br><span class="line">            pos += to_read;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If we&apos;re not encrypting; we don&apos;t need to actually read</span><br><span class="line">            // anything, just skip pos forward as if we&apos;d read a</span><br><span class="line">            // block.</span><br><span class="line">            pos += sb.st_blksize;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = (tail+1) % WINDOW_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (head != tail) &#123;</span><br><span class="line">        // write out head buffer</span><br><span class="line">        int block = head_block;</span><br><span class="line">        if (ioctl(fd, FIBMAP, &amp;block) != 0) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; &quot;failed to find block &quot; &lt;&lt; head_block;</span><br><span class="line">            return kUncryptIoctlError;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (block == 0) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;failed to find block &quot; &lt;&lt; head_block &lt;&lt; &quot;, retrying&quot;;</span><br><span class="line">            int error = retry_fibmap(fd, path, &amp;block, head_block);</span><br><span class="line">            if (error != kUncryptNoError) &#123;</span><br><span class="line">                return error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        add_block_to_ranges(ranges, block);</span><br><span class="line">        //data分区是否加密</span><br><span class="line">        if (encrypted) &#123;</span><br><span class="line">            if (write_at_offset(buffers[head].data(), sb.st_blksize, wfd,</span><br><span class="line">                                static_cast&lt;off64_t&gt;(sb.st_blksize) * block) != 0) &#123;</span><br><span class="line">                return kUncryptWriteError;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = (head + 1) % WINDOW_SIZE;</span><br><span class="line">        ++head_block;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!android::base::WriteStringToFd(</span><br><span class="line">            android::base::StringPrintf(&quot;%zu/n&quot;, ranges.size() / 2), mapfd)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to write &quot; &lt;&lt; tmp_map_file;</span><br><span class="line">        return kUncryptWriteError;</span><br><span class="line">    &#125;</span><br><span class="line">    for (size_t i = 0; i &lt; ranges.size(); i += 2) &#123;</span><br><span class="line">        if (!android::base::WriteStringToFd(</span><br><span class="line">                android::base::StringPrintf(&quot;%d %d/n&quot;, ranges[i], ranges[i+1]), mapfd)) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; &quot;failed to write &quot; &lt;&lt; tmp_map_file;</span><br><span class="line">            return kUncryptWriteError;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fsync(mapfd) == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to fsync /&quot;&quot; &lt;&lt; tmp_map_file &lt;&lt; &quot;/&quot;&quot;;</span><br><span class="line">        return kUncryptFileSyncError;</span><br><span class="line">    &#125;</span><br><span class="line">    if (close(mapfd.release()) == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to close &quot; &lt;&lt; tmp_map_file;</span><br><span class="line">        return kUncryptFileCloseError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (encrypted) &#123;</span><br><span class="line">        if (fsync(wfd) == -1) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; &quot;failed to fsync /&quot;&quot; &lt;&lt; blk_dev &lt;&lt; &quot;/&quot;&quot;;</span><br><span class="line">            return kUncryptFileSyncError;</span><br><span class="line">        &#125;</span><br><span class="line">        if (close(wfd.release()) == -1) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; &quot;failed to close &quot; &lt;&lt; blk_dev;</span><br><span class="line">            return kUncryptFileCloseError;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (rename(tmp_map_file.c_str(), map_file) == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to rename &quot; &lt;&lt; tmp_map_file &lt;&lt; &quot; to &quot; &lt;&lt; map_file;</span><br><span class="line">        return kUncryptFileRenameError;</span><br><span class="line">    &#125;</span><br><span class="line">    // Sync dir to make rename() result written to disk.</span><br><span class="line">    std::string file_name = map_file;</span><br><span class="line">    std::string dir_name = dirname(&amp;file_name[0]);</span><br><span class="line">    android::base::unique_fd dfd(open(dir_name.c_str(), O_RDONLY | O_DIRECTORY));</span><br><span class="line">    if (dfd == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to open dir &quot; &lt;&lt; dir_name;</span><br><span class="line">        return kUncryptFileOpenError;</span><br><span class="line">    &#125;</span><br><span class="line">    if (fsync(dfd) == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to fsync &quot; &lt;&lt; dir_name;</span><br><span class="line">        return kUncryptFileSyncError;</span><br><span class="line">    &#125;</span><br><span class="line">    if (close(dfd.release()) == -1) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;failed to close &quot; &lt;&lt; dir_name;</span><br><span class="line">        return kUncryptFileCloseError;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将ota升级包生成block.map，如果升级包在的分区data是加密，那么每次获得每个block实际索引时，读取解密后的block数据到buffer，每当有5个block数据时，然后把buffer数据写入到实际的对应索引block中。</p>
<p>执行完成uncrypt操作，接着2.11节，执行重启的操作。</p>
<p>如果要测试uncrypt的功能，可以在adb shell环境下测试，将ota包推到data目录下，直接执行uncrypt命名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># uncrypt /data/ota.zip /cache/recovery/block.map</span><br><span class="line"># cat /cache/recovery/block.map</span><br><span class="line">/dev/block/bootdevice/by-name/userdata    //block device</span><br><span class="line">1189005639 4096                           //文件大小，block块大小</span><br><span class="line">2                                         //block块的个数</span><br><span class="line">440320 524288                             //第一个block块的范围区间</span><br><span class="line">561152 767469                             //第二个block块的范围区间</span><br></pre></td></tr></table></figure>
<h3 id="2-20-ST-rebootOrShutdown"><a href="#2-20-ST-rebootOrShutdown" class="headerlink" title="2.20 ST.rebootOrShutdown"></a>2.20 ST.rebootOrShutdown</h3><p>接着2.11中run方法继续。</p>
<p>[-&gt;ShutdownThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void rebootOrShutdown(final Context context, boolean reboot, String reason) &#123;</span><br><span class="line">       // 传过来reboot为true</span><br><span class="line">       if (reboot) &#123;</span><br><span class="line">           Log.i(TAG, &quot;Rebooting, reason: &quot; + reason);</span><br><span class="line">           PowerManagerService.lowLevelReboot(reason);</span><br><span class="line">           Log.e(TAG, &quot;Reboot failed, will attempt shutdown instead&quot;);</span><br><span class="line">           reason = null;</span><br><span class="line">       &#125; else if (SHUTDOWN_VIBRATE_MS &gt; 0 &amp;&amp; context != null) &#123;</span><br><span class="line">           // vibrate before shutting down</span><br><span class="line">           Vibrator vibrator = new SystemVibrator(context);</span><br><span class="line">           try &#123;</span><br><span class="line">               vibrator.vibrate(SHUTDOWN_VIBRATE_MS, VIBRATION_ATTRIBUTES);</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               // Failure to vibrate shouldn&apos;t interrupt shutdown.  Just log it.</span><br><span class="line">               Log.w(TAG, &quot;Failed to vibrate during shutdown.&quot;, e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // vibrator is asynchronous so we need to wait to avoid shutting down too soon.</span><br><span class="line">           try &#123;</span><br><span class="line">               Thread.sleep(SHUTDOWN_VIBRATE_MS);</span><br><span class="line">           &#125; catch (InterruptedException unused) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // Shutdown power</span><br><span class="line">       Log.i(TAG, &quot;Performing low-level shutdown...&quot;);</span><br><span class="line">       PowerManagerService.lowLevelShutdown(reason);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-20-1-PWS-lowLevelReboot"><a href="#2-20-1-PWS-lowLevelReboot" class="headerlink" title="2.20.1 PWS.lowLevelReboot"></a>2.20.1 PWS.lowLevelReboot</h4><p>[-&gt;PowerManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Low-level function to reboot the device. On success, this</span><br><span class="line">    * function doesn&apos;t return. If more than 20 seconds passes from</span><br><span class="line">    * the time a reboot is requested, this method returns.</span><br><span class="line">    *</span><br><span class="line">    * @param reason code to pass to the kernel (e.g. &quot;recovery&quot;), or null.</span><br><span class="line">    */</span><br><span class="line">   public static void lowLevelReboot(String reason) &#123;</span><br><span class="line">       if (reason == null) &#123;</span><br><span class="line">           reason = &quot;&quot;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If the reason is &quot;quiescent&quot;, it means that the boot process should proceed</span><br><span class="line">       // without turning on the screen/lights.</span><br><span class="line">       // The &quot;quiescent&quot; property is sticky, meaning that any number</span><br><span class="line">       // of subsequent reboots should honor the property until it is reset.</span><br><span class="line">       if (reason.equals(PowerManager.REBOOT_QUIESCENT)) &#123;</span><br><span class="line">           sQuiescent = true;</span><br><span class="line">           reason = &quot;&quot;;</span><br><span class="line">       &#125; else if (reason.endsWith(&quot;,&quot; + PowerManager.REBOOT_QUIESCENT)) &#123;</span><br><span class="line">           sQuiescent = true;</span><br><span class="line">           reason = reason.substring(0,</span><br><span class="line">                   reason.length() - PowerManager.REBOOT_QUIESCENT.length() - 1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (reason.equals(PowerManager.REBOOT_RECOVERY)</span><br><span class="line">               || reason.equals(PowerManager.REBOOT_RECOVERY_UPDATE)) &#123;</span><br><span class="line">           reason = &quot;recovery&quot;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (sQuiescent) &#123;</span><br><span class="line">           // Pass the optional &quot;quiescent&quot; argument to the bootloader to let it know</span><br><span class="line">           // that it should not turn the screen/lights on.</span><br><span class="line">           reason = reason + &quot;,quiescent&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       //重启操作</span><br><span class="line">       SystemProperties.set(&quot;sys.powerctl&quot;, &quot;reboot,&quot; + reason);</span><br><span class="line">       try &#123;</span><br><span class="line">           Thread.sleep(20 * 1000L);</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">       &#125;</span><br><span class="line">       Slog.wtf(TAG, &quot;Unexpected return from lowLevelReboot!&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-20-2-PWS-lowLevelReboot"><a href="#2-20-2-PWS-lowLevelReboot" class="headerlink" title="2.20.2 PWS.lowLevelReboot"></a>2.20.2 PWS.lowLevelReboot</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void lowLevelShutdown(String reason) &#123;</span><br><span class="line">      if (reason == null) &#123;</span><br><span class="line">          reason = &quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      //关机</span><br><span class="line">      SystemProperties.set(&quot;sys.powerctl&quot;, &quot;shutdown,&quot; + reason);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-21-小结"><a href="#2-21-小结" class="headerlink" title="2.21 小结"></a>2.21 小结</h3><p>OTA升级重启前，主要的操作是对升级包进行处理的过程，对升级包提前处理的原因是因为在进入recovery模式进行升级时无法加载升级包所在的分区。在重启前的主要操作如下：</p>
<p>1.通过SystemProperties设置属性(setup-bcb)，向BCB中设置升级的Command；</p>
<p>2.通过SystemProperties设置属性(uncrypt)，开启uncrypt服务，将升级包生成一系列的block块，recovery可以读取block.map文件并获取这个文件的数据作为升级包；</p>
<p>3.uncrypt完成后，重启。</p>
<h2 id="三、OTA升级重启后"><a href="#三、OTA升级重启后" class="headerlink" title="三、OTA升级重启后"></a>三、OTA升级重启后</h2><p>终端重启后，加载bootloader过程中，由于之前写入的recovery的command，则将进入recovery模式.</p>
<h3 id="3-1-aboot-aboot-init"><a href="#3-1-aboot-aboot-init" class="headerlink" title="3.1 aboot.aboot_init"></a>3.1 aboot.aboot_init</h3><p>[-&gt;aboot.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line">void aboot_init(const struct app_descriptor *app)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned reboot_mode = 0;</span><br><span class="line">	int boot_err_type = 0;</span><br><span class="line">	int boot_slot = INVALID;</span><br><span class="line"></span><br><span class="line">	/* Initialise wdog to catch early lk crashes */</span><br><span class="line">#if WDOG_SUPPORT</span><br><span class="line">	msm_wdog_init();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* Setup page size information for nv storage */</span><br><span class="line">	if (target_is_emmc_boot())</span><br><span class="line">	&#123;</span><br><span class="line">		page_size = mmc_page_size();</span><br><span class="line">		page_mask = page_size - 1;</span><br><span class="line">		mmc_blocksize = mmc_get_device_blocksize();</span><br><span class="line">		mmc_blocksize_mask = mmc_blocksize - 1;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		page_size = flash_page_size();</span><br><span class="line">		page_mask = page_size - 1;</span><br><span class="line">	&#125;</span><br><span class="line">	ASSERT((MEMBASE + MEMSIZE) &gt; MEMBASE);</span><br><span class="line"></span><br><span class="line">	read_device_info(&amp;device);</span><br><span class="line">	read_allow_oem_unlock(&amp;device);</span><br><span class="line"></span><br><span class="line">	/* Detect multi-slot support */</span><br><span class="line">	if (partition_multislot_is_supported())</span><br><span class="line">	&#123;</span><br><span class="line">		boot_slot = partition_find_active_slot();</span><br><span class="line">		if (boot_slot == INVALID)</span><br><span class="line">		&#123;</span><br><span class="line">			boot_into_fastboot = true;</span><br><span class="line">			dprintf(INFO, &quot;Active Slot: (INVALID)/n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			/* Setting the state of system to boot active slot */</span><br><span class="line">			partition_mark_active_slot(boot_slot);</span><br><span class="line">			dprintf(INFO, &quot;Active Slot: (%s)/n&quot;, SUFFIX_SLOT(boot_slot));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Display splash screen if enabled */</span><br><span class="line">#if DISPLAY_SPLASH_SCREEN</span><br><span class="line">#if NO_ALARM_DISPLAY</span><br><span class="line">	if (!check_alarm_boot()) &#123;</span><br><span class="line">#endif</span><br><span class="line">		dprintf(SPEW, &quot;Display Init: Start/n&quot;);</span><br><span class="line">#if DISPLAY_HDMI_PRIMARY</span><br><span class="line">	if (!strlen(device.display_panel))</span><br><span class="line">		strlcpy(device.display_panel, DISPLAY_PANEL_HDMI,</span><br><span class="line">			sizeof(device.display_panel));</span><br><span class="line">#endif</span><br><span class="line">#if ENABLE_WBC</span><br><span class="line">		/* Wait if the display shutdown is in progress */</span><br><span class="line">		while(pm_app_display_shutdown_in_prgs());</span><br><span class="line">		if (!pm_appsbl_display_init_done())</span><br><span class="line">			target_display_init(device.display_panel);</span><br><span class="line">		else</span><br><span class="line">			display_image_on_screen();</span><br><span class="line">#else</span><br><span class="line">		target_display_init(device.display_panel);</span><br><span class="line">#endif</span><br><span class="line">		dprintf(SPEW, &quot;Display Init: Done/n&quot;);</span><br><span class="line">#if NO_ALARM_DISPLAY</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	target_serialno((unsigned char *) sn_buf);</span><br><span class="line">	dprintf(SPEW,&quot;serial number: %s/n&quot;,sn_buf);</span><br><span class="line"></span><br><span class="line">	memset(display_panel_buf, &apos;/0&apos;, MAX_PANEL_BUF_SIZE);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Check power off reason if user force reset,</span><br><span class="line">	 * if yes phone will do normal boot.</span><br><span class="line">	 */</span><br><span class="line">	if (is_user_force_reset())</span><br><span class="line">		goto normal_boot;</span><br><span class="line"></span><br><span class="line">	/* Check if we should do something other than booting up */</span><br><span class="line">	if (keys_get_state(KEY_VOLUMEUP) &amp;&amp; keys_get_state(KEY_VOLUMEDOWN))</span><br><span class="line">	&#123;</span><br><span class="line">		dprintf(ALWAYS,&quot;dload mode key sequence detected/n&quot;);</span><br><span class="line">		reboot_device(EMERGENCY_DLOAD);</span><br><span class="line">		dprintf(CRITICAL,&quot;Failed to reboot into dload mode/n&quot;);</span><br><span class="line"></span><br><span class="line">		boot_into_fastboot = true;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!boot_into_fastboot)</span><br><span class="line">	&#123;</span><br><span class="line">		if (keys_get_state(KEY_HOME) || keys_get_state(KEY_VOLUMEUP))</span><br><span class="line">			boot_into_recovery = 1;</span><br><span class="line">		if (!boot_into_recovery &amp;&amp;</span><br><span class="line">			(keys_get_state(KEY_BACK) || keys_get_state(KEY_VOLUMEDOWN)))</span><br><span class="line">			boot_into_fastboot = true;</span><br><span class="line">	&#125;</span><br><span class="line">	#if NO_KEYPAD_DRIVER</span><br><span class="line">	if (fastboot_trigger())</span><br><span class="line">		boot_into_fastboot = true;</span><br><span class="line">	#endif</span><br><span class="line"></span><br><span class="line">#if USE_PON_REBOOT_REG</span><br><span class="line">	reboot_mode = check_hard_reboot_mode();</span><br><span class="line">#else</span><br><span class="line">	reboot_mode = check_reboot_mode();</span><br><span class="line">#endif</span><br><span class="line">	if (reboot_mode == RECOVERY_MODE)</span><br><span class="line">	&#123;</span><br><span class="line">		boot_into_recovery = 1;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(reboot_mode == FASTBOOT_MODE)</span><br><span class="line">	&#123;</span><br><span class="line">		boot_into_fastboot = true;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(reboot_mode == ALARM_BOOT)</span><br><span class="line">	&#123;</span><br><span class="line">		boot_reason_alarm = true;</span><br><span class="line">	&#125;</span><br><span class="line">#if VERIFIED_BOOT || VERIFIED_BOOT_2</span><br><span class="line">	else if (VB_M &lt;= target_get_vb_version())</span><br><span class="line">	&#123;</span><br><span class="line">		if (reboot_mode == DM_VERITY_ENFORCING)</span><br><span class="line">		&#123;</span><br><span class="line">			device.verity_mode = 1;</span><br><span class="line">			write_device_info(&amp;device);</span><br><span class="line">		&#125;</span><br><span class="line">#if ENABLE_VB_ATTEST</span><br><span class="line">		else if (reboot_mode == DM_VERITY_EIO)</span><br><span class="line">#else</span><br><span class="line">		else if (reboot_mode == DM_VERITY_LOGGING)</span><br><span class="line">#endif</span><br><span class="line">		&#123;</span><br><span class="line">			device.verity_mode = 0;</span><br><span class="line">			write_device_info(&amp;device);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (reboot_mode == DM_VERITY_KEYSCLEAR)</span><br><span class="line">		&#123;</span><br><span class="line">			if(send_delete_keys_to_tz())</span><br><span class="line">				ASSERT(0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">normal_boot:</span><br><span class="line">	if (!boot_into_fastboot)</span><br><span class="line">	&#123;</span><br><span class="line">		if (target_is_emmc_boot())</span><br><span class="line">		&#123;</span><br><span class="line">			if(emmc_recovery_init())</span><br><span class="line">				dprintf(ALWAYS,&quot;error in emmc_recovery_init/n&quot;);</span><br><span class="line">			if(target_use_signed_kernel())</span><br><span class="line">			&#123;</span><br><span class="line">				if((device.is_unlocked) || (device.is_tampered))</span><br><span class="line">				&#123;</span><br><span class="line">				#ifdef TZ_TAMPER_FUSE</span><br><span class="line">					set_tamper_fuse_cmd(HLOS_IMG_TAMPER_FUSE);</span><br><span class="line">				#endif</span><br><span class="line">				#if USE_PCOM_SECBOOT</span><br><span class="line">					set_tamper_flag(device.is_tampered);</span><br><span class="line">				#endif</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">retry_boot:</span><br><span class="line">			/* Trying to boot active partition */</span><br><span class="line">			if (partition_multislot_is_supported())</span><br><span class="line">			&#123;</span><br><span class="line">				boot_slot = partition_find_boot_slot();</span><br><span class="line">				partition_mark_active_slot(boot_slot);</span><br><span class="line">				if (boot_slot == INVALID)</span><br><span class="line">					goto fastboot;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			boot_err_type = boot_linux_from_mmc();</span><br><span class="line">			switch (boot_err_type)</span><br><span class="line">			&#123;</span><br><span class="line">				case ERR_INVALID_PAGE_SIZE:</span><br><span class="line">				case ERR_DT_PARSE:</span><br><span class="line">				case ERR_ABOOT_ADDR_OVERLAP:</span><br><span class="line">				case ERR_INVALID_BOOT_MAGIC:</span><br><span class="line">					if(partition_multislot_is_supported())</span><br><span class="line">					&#123;</span><br><span class="line">						/*</span><br><span class="line">						 * Deactivate current slot, as it failed to</span><br><span class="line">						 * boot, and retry next slot.</span><br><span class="line">						 */</span><br><span class="line">						partition_deactivate_slot(boot_slot);</span><br><span class="line">						goto retry_boot;</span><br><span class="line">					&#125;</span><br><span class="line">					else</span><br><span class="line">						break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">				/* going to fastboot menu */</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">		    //见3.2节</span><br><span class="line">			recovery_init();</span><br><span class="line">	#if USE_PCOM_SECBOOT</span><br><span class="line">		if((device.is_unlocked) || (device.is_tampered))</span><br><span class="line">			set_tamper_flag(device.is_tampered);</span><br><span class="line">	#endif</span><br><span class="line">			boot_linux_from_flash();</span><br><span class="line">		&#125;</span><br><span class="line">		dprintf(CRITICAL, &quot;ERROR: Could not do normal boot. Reverting &quot;</span><br><span class="line">			&quot;to fastboot mode./n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">fastboot:</span><br><span class="line">	/* We are here means regular boot did not happen. Start fastboot. */</span><br><span class="line"></span><br><span class="line">	/* register aboot specific fastboot commands */</span><br><span class="line">	aboot_fastboot_register_commands();</span><br><span class="line"></span><br><span class="line">	/* dump partition table for debug info */</span><br><span class="line">	partition_dump();</span><br><span class="line"></span><br><span class="line">	/* initialize and start fastboot */</span><br><span class="line">#if !VERIFIED_BOOT_2</span><br><span class="line">	fastboot_init(target_get_scratch_address(), target_get_max_flash_size());</span><br><span class="line">#else</span><br><span class="line">	/* Add salt buffer offset at start of image address to copy VB salt */</span><br><span class="line">	fastboot_init(ADD_SALT_BUFF_OFFSET(target_get_scratch_address()),</span><br><span class="line">		SUB_SALT_BUFF_OFFSET(target_get_max_flash_size()));</span><br><span class="line">#endif</span><br><span class="line">#if FBCON_DISPLAY_MSG</span><br><span class="line">	display_fastboot_menu();</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>aboot执行后读取bootloader中command命令，执行recovery_init.</p>
<h3 id="3-2-recovery-recovery-init"><a href="#3-2-recovery-recovery-init" class="headerlink" title="3.2 recovery.recovery_init"></a>3.2 recovery.recovery_init</h3><p>[-&gt;recovery.c]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">/* Bootloader / Recovery Flow</span><br><span class="line"> *</span><br><span class="line"> * On every boot, the bootloader will read the recovery_message</span><br><span class="line"> * from flash and check the command field.  The bootloader should</span><br><span class="line"> * deal with the command field not having a 0 terminator correctly</span><br><span class="line"> * (so as to not crash if the block is invalid or corrupt).</span><br><span class="line"> *</span><br><span class="line"> * The bootloader will have to publish the partition that contains</span><br><span class="line"> * the recovery_message to the linux kernel so it can update it.</span><br><span class="line"> *</span><br><span class="line"> * if command == &quot;boot-recovery&quot; -&gt; boot recovery.img</span><br><span class="line"> * else if command == &quot;update-radio&quot; -&gt; update radio image (below)</span><br><span class="line"> * else -&gt; boot boot.img (normal boot)</span><br><span class="line"> *</span><br><span class="line"> * Radio Update Flow</span><br><span class="line"> * 1. the bootloader will attempt to load and validate the header</span><br><span class="line"> * 2. if the header is invalid, status=&quot;invalid-update&quot;, goto #8</span><br><span class="line"> * 3. display the busy image on-screen</span><br><span class="line"> * 4. if the update image is invalid, status=&quot;invalid-radio-image&quot;, goto #8</span><br><span class="line"> * 5. attempt to update the firmware (depending on the command)</span><br><span class="line"> * 6. if successful, status=&quot;okay&quot;, goto #8</span><br><span class="line"> * 7. if failed, and the old image can still boot, status=&quot;failed-update&quot;</span><br><span class="line"> * 8. write the recovery_message, leaving the recovery field</span><br><span class="line"> *    unchanged, updating status, and setting command to</span><br><span class="line"> *    &quot;boot-recovery&quot;</span><br><span class="line"> * 9. reboot</span><br><span class="line"> *</span><br><span class="line"> * The bootloader will not modify or erase the cache partition.</span><br><span class="line"> * It is recovery&apos;s responsibility to clean up the mess afterwards.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int recovery_init (void)</span><br><span class="line">&#123;</span><br><span class="line">	struct recovery_message msg;</span><br><span class="line">	char partition_name[32];</span><br><span class="line">	unsigned valid_command = 0;</span><br><span class="line">	int update_status = 0;</span><br><span class="line"></span><br><span class="line">	// get recovery message</span><br><span class="line">	if (get_recovery_message(&amp;msg))</span><br><span class="line">		return -1;</span><br><span class="line">	msg.command[sizeof(msg.command)-1] = &apos;/0&apos;; //Ensure termination</span><br><span class="line">	if (msg.command[0] != 0 &amp;&amp; msg.command[0] != 255) &#123;</span><br><span class="line">		dprintf(INFO,&quot;Recovery command: %d %s/n&quot;,</span><br><span class="line">			sizeof(msg.command), msg.command);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!strcmp(&quot;boot-recovery&quot;,msg.command))</span><br><span class="line">	&#123;</span><br><span class="line">		if(!strcmp(&quot;RADIO&quot;,msg.status))</span><br><span class="line">		&#123;</span><br><span class="line">			/* We&apos;re now here due to radio update, so check for update status */</span><br><span class="line">			int ret = get_boot_info_apps(UPDATE_STATUS, (unsigned int *) &amp;update_status);</span><br><span class="line"></span><br><span class="line">			if(!ret &amp;&amp; (update_status &amp; 0x01))</span><br><span class="line">			&#123;</span><br><span class="line">				dprintf(INFO,&quot;radio update success/n&quot;);</span><br><span class="line">				strlcpy(msg.status, &quot;OKAY&quot;, sizeof(msg.status));</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				dprintf(INFO,&quot;radio update failed/n&quot;);</span><br><span class="line">				strlcpy(msg.status, &quot;failed-update&quot;, sizeof(msg.status));</span><br><span class="line">			&#125;</span><br><span class="line">			strlcpy(msg.command, &quot;&quot;, sizeof(msg.command));	// clearing recovery command</span><br><span class="line">			set_recovery_message(&amp;msg);	// send recovery message</span><br><span class="line">			boot_into_recovery = 1;		// Boot in recovery mode</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		boot_into_recovery = 1;		// Boot in recovery mode</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!strcmp(&quot;update-radio&quot;,msg.command)) &#123;</span><br><span class="line">		dprintf(INFO,&quot;start radio update/n&quot;);</span><br><span class="line">		valid_command = 1;</span><br><span class="line">		strlcpy(partition_name, &quot;FOTA&quot;, sizeof(partition_name));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//Todo: Add support for bootloader update too.</span><br><span class="line"></span><br><span class="line">	if(!valid_command) &#123;</span><br><span class="line">		//We need not to do anything</span><br><span class="line">		return 0; // Boot in normal mode</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (set_ssd_radio_update(partition_name)) &#123;</span><br><span class="line">		/* If writing to FOTA partition fails */</span><br><span class="line">		strlcpy(msg.command, &quot;&quot;, sizeof(msg.command));</span><br><span class="line">		strlcpy(msg.status, &quot;failed-update&quot;, sizeof(msg.status));</span><br><span class="line">		goto SEND_RECOVERY_MSG;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		/* Setting this to check the radio update status */</span><br><span class="line">		strlcpy(msg.command, &quot;boot-recovery&quot;, sizeof(msg.command));</span><br><span class="line">		strlcpy(msg.status, &quot;RADIO&quot;, sizeof(msg.status));</span><br><span class="line">		goto SEND_RECOVERY_MSG;</span><br><span class="line">	&#125;</span><br><span class="line">	strlcpy(msg.status, &quot;OKAY&quot;, sizeof(msg.status));</span><br><span class="line"></span><br><span class="line">SEND_RECOVERY_MSG:</span><br><span class="line">	set_recovery_message(&amp;msg);	// send recovery message</span><br><span class="line">	boot_into_recovery = 1;		// Boot in recovery mode</span><br><span class="line">	reboot_device(0);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参照代码前注释boot recovery.img之后，将会执行recovery.cpp中的main方法。</p>
<h3 id="3-3-recovery-main"><a href="#3-3-recovery-main" class="headerlink" title="3.3 recovery.main"></a>3.3 recovery.main</h3><p>[-&gt;recovery.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The recovery tool communicates with the main system through /cache files.</span><br><span class="line"> *   /cache/recovery/command - INPUT - command line for tool, one arg per line</span><br><span class="line"> *   /cache/recovery/log - OUTPUT - combined log file from recovery run(s)</span><br><span class="line"> *</span><br><span class="line"> * The arguments which may be supplied in the recovery.command file:</span><br><span class="line"> *   --update_package=path - verify install an OTA package file</span><br><span class="line"> *   --wipe_data - erase user data (and cache), then reboot</span><br><span class="line"> *   --prompt_and_wipe_data - prompt the user that data is corrupt,</span><br><span class="line"> *       with their consent erase user data (and cache), then reboot</span><br><span class="line"> *   --wipe_cache - wipe cache (but not user data), then reboot</span><br><span class="line"> *   --set_encrypted_filesystem=on|off - enables / diasables encrypted fs</span><br><span class="line"> *   --just_exit - do nothing; exit and reboot</span><br><span class="line"> *</span><br><span class="line"> * After completing, we remove /cache/recovery/command and reboot.</span><br><span class="line"> * Arguments may also be supplied in the bootloader control block (BCB).</span><br><span class="line"> * These important scenarios must be safely restartable at any point:</span><br><span class="line"> *</span><br><span class="line"> * FACTORY RESET</span><br><span class="line"> * 1. user selects &quot;factory reset&quot;</span><br><span class="line"> * 2. main system writes &quot;--wipe_data&quot; to /cache/recovery/command</span><br><span class="line"> * 3. main system reboots into recovery</span><br><span class="line"> * 4. get_args() writes BCB with &quot;boot-recovery&quot; and &quot;--wipe_data&quot;</span><br><span class="line"> *    -- after this, rebooting will restart the erase --</span><br><span class="line"> * 5. erase_volume() reformats /data</span><br><span class="line"> * 6. erase_volume() reformats /cache</span><br><span class="line"> * 7. finish_recovery() erases BCB</span><br><span class="line"> *    -- after this, rebooting will restart the main system --</span><br><span class="line"> * 8. main() calls reboot() to boot main system</span><br><span class="line"> *</span><br><span class="line"> * OTA INSTALL</span><br><span class="line"> * 1. main system downloads OTA package to /cache/some-filename.zip</span><br><span class="line"> * 2. main system writes &quot;--update_package=/cache/some-filename.zip&quot;</span><br><span class="line"> * 3. main system reboots into recovery</span><br><span class="line"> * 4. get_args() writes BCB with &quot;boot-recovery&quot; and &quot;--update_package=...&quot;</span><br><span class="line"> *    -- after this, rebooting will attempt to reinstall the update --</span><br><span class="line"> * 5. install_package() attempts to install the update</span><br><span class="line"> *    NOTE: the package install must itself be restartable from any point</span><br><span class="line"> * 6. finish_recovery() erases BCB</span><br><span class="line"> *    -- after this, rebooting will (try to) restart the main system --</span><br><span class="line"> * 7. ** if install failed **</span><br><span class="line"> *    7a. prompt_and_wait() shows an error icon and waits for the user</span><br><span class="line"> *    7b. the user reboots (pulling the battery, etc) into the main system</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> int main(int argc, char **argv) &#123;</span><br><span class="line">  // We don&apos;t have logcat yet under recovery; so we&apos;ll print error on screen and</span><br><span class="line">  // log to stdout (which is redirected to recovery.log) as we used to do.</span><br><span class="line">  android::base::InitLogging(argv, &amp;UiLogger);</span><br><span class="line"></span><br><span class="line">  // Take last pmsg contents and rewrite it to the current pmsg session.</span><br><span class="line">  static const char filter[] = &quot;recovery/&quot;;</span><br><span class="line">  // Do we need to rotate?</span><br><span class="line">  bool doRotate = false;</span><br><span class="line"></span><br><span class="line">  __android_log_pmsg_file_read(LOG_ID_SYSTEM, ANDROID_LOG_INFO, filter, logbasename, &amp;doRotate);</span><br><span class="line">  // Take action to refresh pmsg contents</span><br><span class="line">  __android_log_pmsg_file_read(LOG_ID_SYSTEM, ANDROID_LOG_INFO, filter, logrotate, &amp;doRotate);</span><br><span class="line"></span><br><span class="line">  // If this binary is started with the single argument &quot;--adbd&quot;,</span><br><span class="line">  // instead of being the normal recovery binary, it turns into kind</span><br><span class="line">  // of a stripped-down version of adbd that only supports the</span><br><span class="line">  // &apos;sideload&apos; command.  Note this must be a real argument, not</span><br><span class="line">  // anything in the command file or bootloader control block; the</span><br><span class="line">  // only way recovery should be run with this argument is when it</span><br><span class="line">  // starts a copy of itself from the apply_from_adb() function.</span><br><span class="line">  if (argc == 2 &amp;&amp; strcmp(argv[1], &quot;--adbd&quot;) == 0) &#123;</span><br><span class="line">    minadbd_main();</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  time_t start = time(nullptr);</span><br><span class="line"></span><br><span class="line">  // redirect_stdio should be called only in non-sideload mode. Otherwise</span><br><span class="line">  // we may have two logger instances with different timestamps.</span><br><span class="line">  redirect_stdio(TEMPORARY_LOG_FILE);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Starting recovery (pid %d) on %s&quot;, getpid(), ctime(&amp;start));</span><br><span class="line"></span><br><span class="line">  load_volume_table();</span><br><span class="line">  has_cache = volume_for_mount_point(CACHE_ROOT) != nullptr;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; args = get_args(argc, argv);</span><br><span class="line">  std::vector&lt;char*&gt; args_to_parse(args.size());</span><br><span class="line">  std::transform(args.cbegin(), args.cend(), args_to_parse.begin(),</span><br><span class="line">                 [](const std::string&amp; arg) &#123; return const_cast&lt;char*&gt;(arg.c_str()); &#125;);</span><br><span class="line"></span><br><span class="line">  const char* update_package = nullptr;</span><br><span class="line">  bool should_wipe_data = false;</span><br><span class="line">  bool should_prompt_and_wipe_data = false;</span><br><span class="line">  bool should_wipe_cache = false;</span><br><span class="line">  bool should_wipe_ab = false;</span><br><span class="line">  size_t wipe_package_size = 0;</span><br><span class="line">  bool show_text = false;</span><br><span class="line">  bool sideload = false;</span><br><span class="line">  bool sideload_auto_reboot = false;</span><br><span class="line">  bool just_exit = false;</span><br><span class="line">  bool shutdown_after = false;</span><br><span class="line">  int retry_count = 0;</span><br><span class="line">  bool security_update = false;</span><br><span class="line">  int status = INSTALL_SUCCESS;</span><br><span class="line">  bool mount_required = true;</span><br><span class="line"></span><br><span class="line">  if (has_cache &amp;&amp; ensure_path_mounted(CACHE_ROOT) == 0) &#123;</span><br><span class="line">  //Create /cache/recovery specifically if it is not created</span><br><span class="line">  //As in cases where device is booted into recovery directly after</span><br><span class="line">  //flashing recovery folder is not created in init</span><br><span class="line">    mkdir_recursively(CACHE_LOG_DIR, 0777, false, sehandle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int arg;</span><br><span class="line">  int option_index;</span><br><span class="line">  //解析参数</span><br><span class="line">  while ((arg = getopt_long(args_to_parse.size(), args_to_parse.data(), &quot;&quot;, OPTIONS,</span><br><span class="line">                            &amp;option_index)) != -1) &#123;</span><br><span class="line">    switch (arg) &#123;</span><br><span class="line">      case &apos;n&apos;:</span><br><span class="line">        android::base::ParseInt(optarg, &amp;retry_count, 0);</span><br><span class="line">        break;</span><br><span class="line">      case &apos;u&apos;:</span><br><span class="line">        update_package = optarg;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;w&apos;:</span><br><span class="line">        should_wipe_data = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;c&apos;:</span><br><span class="line">        should_wipe_cache = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;t&apos;:</span><br><span class="line">        show_text = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;s&apos;:</span><br><span class="line">        sideload = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;a&apos;:</span><br><span class="line">        sideload = true;</span><br><span class="line">        sideload_auto_reboot = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;x&apos;:</span><br><span class="line">        just_exit = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;l&apos;:</span><br><span class="line">        locale = optarg;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;p&apos;:</span><br><span class="line">        shutdown_after = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;r&apos;:</span><br><span class="line">        reason = optarg;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;e&apos;:</span><br><span class="line">        security_update = true;</span><br><span class="line">        break;</span><br><span class="line">      case 0: &#123;</span><br><span class="line">        std::string option = OPTIONS[option_index].name;</span><br><span class="line">        if (option == &quot;wipe_ab&quot;) &#123;</span><br><span class="line">          should_wipe_ab = true;</span><br><span class="line">        &#125; else if (option == &quot;wipe_package_size&quot;) &#123;</span><br><span class="line">          android::base::ParseUint(optarg, &amp;wipe_package_size);</span><br><span class="line">        &#125; else if (option == &quot;prompt_and_wipe_data&quot;) &#123;</span><br><span class="line">          should_prompt_and_wipe_data = true;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case &apos;?&apos;:</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;Invalid command argument&quot;;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (locale.empty()) &#123;</span><br><span class="line">    if (has_cache) &#123;</span><br><span class="line">      locale = load_locale_from_cache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (locale.empty()) &#123;</span><br><span class="line">      locale = DEFAULT_LOCALE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;locale is [%s]/n&quot;, locale.c_str());</span><br><span class="line">  printf(&quot;stage is [%s]/n&quot;, stage.c_str());</span><br><span class="line">  printf(&quot;reason is [%s]/n&quot;, reason);</span><br><span class="line"></span><br><span class="line">  Device* device = make_device();</span><br><span class="line">  if (android::base::GetBoolProperty(&quot;ro.boot.quiescent&quot;, false)) &#123;</span><br><span class="line">    printf(&quot;Quiescent recovery mode./n&quot;);</span><br><span class="line">    ui = new StubRecoveryUI();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ui = device-&gt;GetUI();</span><br><span class="line"></span><br><span class="line">    if (!ui-&gt;Init(locale)) &#123;</span><br><span class="line">      printf(&quot;Failed to initialize UI, use stub UI instead./n&quot;);</span><br><span class="line">      ui = new StubRecoveryUI();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Set background string to &quot;installing security update&quot; for security update,</span><br><span class="line">  // otherwise set it to &quot;installing system update&quot;.</span><br><span class="line">  ui-&gt;SetSystemUpdateText(security_update);</span><br><span class="line"></span><br><span class="line">  int st_cur, st_max;</span><br><span class="line">  if (!stage.empty() &amp;&amp; sscanf(stage.c_str(), &quot;%d/%d&quot;, &amp;st_cur, &amp;st_max) == 2) &#123;</span><br><span class="line">    ui-&gt;SetStage(st_cur, st_max);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ui-&gt;SetBackground(RecoveryUI::NONE);</span><br><span class="line">  if (show_text) ui-&gt;ShowText(true);</span><br><span class="line"></span><br><span class="line">  sehandle = selinux_android_file_context_handle();</span><br><span class="line">  selinux_android_set_sehandle(sehandle);</span><br><span class="line">  if (!sehandle) &#123;</span><br><span class="line">    ui-&gt;Print(&quot;Warning: No file_contexts/n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  device-&gt;StartRecovery();</span><br><span class="line"></span><br><span class="line">  printf(&quot;Command:&quot;);</span><br><span class="line">  for (const auto&amp; arg : args) &#123;</span><br><span class="line">    printf(&quot; /&quot;%s/&quot;&quot;, arg.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;/n/n&quot;);</span><br><span class="line"></span><br><span class="line">   if (update_package) &#123;</span><br><span class="line">        if (!strncmp(&quot;/sdcard&quot;, update_package, 7)) &#123;</span><br><span class="line">            //If this is a UFS device lets mount the sdcard ourselves.Depending</span><br><span class="line">            //on if the device is UFS or EMMC based the path to the sdcard</span><br><span class="line">            //device changes so we cannot rely on the block dev path from</span><br><span class="line">            //recovery.fstab file</span><br><span class="line">            if (is_ufs_dev()) &#123;</span><br><span class="line">                if(do_sdcard_mount_for_ufs() != 0) &#123;</span><br><span class="line">                    status = INSTALL_ERROR;</span><br><span class="line">                    goto error;</span><br><span class="line">                &#125;</span><br><span class="line">                mount_required = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ui-&gt;Print(&quot;Update via sdcard on EMMC dev. Using path from fstab/n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  property_list(print_property, nullptr);</span><br><span class="line">  printf(&quot;/n&quot;);</span><br><span class="line"></span><br><span class="line">  ui-&gt;Print(&quot;Supported API: %d/n&quot;, kRecoveryApiVersion);</span><br><span class="line"></span><br><span class="line">  if (update_package != nullptr) &#123;</span><br><span class="line">    // It&apos;s not entirely true that we will modify the flash. But we want</span><br><span class="line">    // to log the update attempt since update_package is non-NULL.</span><br><span class="line">    modified_flash = true;</span><br><span class="line"></span><br><span class="line">    if (!is_battery_ok()) &#123;</span><br><span class="line">      ui-&gt;Print(&quot;battery capacity is not enough for installing package, needed is %d%%/n&quot;,</span><br><span class="line">                BATTERY_OK_PERCENTAGE);</span><br><span class="line">      // Log the error code to last_install when installation skips due to</span><br><span class="line">      // low battery.</span><br><span class="line">      log_failure_code(kLowBattery, update_package);</span><br><span class="line">      status = INSTALL_SKIPPED;</span><br><span class="line">    &#125; else if (bootreason_in_blacklist()) &#123;</span><br><span class="line">      // Skip update-on-reboot when bootreason is kernel_panic or similar</span><br><span class="line">      ui-&gt;Print(&quot;bootreason is in the blacklist; skip OTA installation/n&quot;);</span><br><span class="line">      log_failure_code(kBootreasonInBlacklist, update_package);</span><br><span class="line">      status = INSTALL_SKIPPED;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // It&apos;s a fresh update. Initialize the retry_count in the BCB to 1; therefore we can later</span><br><span class="line">      // identify the interrupted update due to unexpected reboots.</span><br><span class="line">      if (retry_count == 0) &#123;</span><br><span class="line">        set_retry_bootloader_message(retry_count + 1, args);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //见3.4节，安装升级包</span><br><span class="line">      status = install_package(update_package, &amp;should_wipe_cache, TEMPORARY_INSTALL_FILE, mount_required,</span><br><span class="line">                                retry_count);</span><br><span class="line">      if (status == INSTALL_SUCCESS &amp;&amp; should_wipe_cache) &#123;</span><br><span class="line">        wipe_cache(false, device);</span><br><span class="line">      &#125;</span><br><span class="line">      if (status != INSTALL_SUCCESS) &#123;</span><br><span class="line">        ui-&gt;Print(&quot;Installation aborted./n&quot;);</span><br><span class="line">        // When I/O error happens, reboot and retry installation RETRY_LIMIT</span><br><span class="line">        // times before we abandon this OTA update.</span><br><span class="line">        if (status == INSTALL_RETRY &amp;&amp; retry_count &lt; RETRY_LIMIT) &#123;</span><br><span class="line">          copy_logs();</span><br><span class="line">          retry_count += 1;</span><br><span class="line">          set_retry_bootloader_message(retry_count, args);</span><br><span class="line">          // Print retry count on screen.</span><br><span class="line">          ui-&gt;Print(&quot;Retry attempt %d/n&quot;, retry_count);</span><br><span class="line"></span><br><span class="line">          // Reboot and retry the update</span><br><span class="line">          if (!reboot(&quot;reboot,recovery&quot;)) &#123;</span><br><span class="line">            ui-&gt;Print(&quot;Reboot failed/n&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">              pause();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // If this is an eng or userdebug build, then automatically</span><br><span class="line">        // turn the text display on if the script fails so the error</span><br><span class="line">        // message is visible.</span><br><span class="line">        if (is_ro_debuggable()) &#123;</span><br><span class="line">          ui-&gt;ShowText(true);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (should_wipe_data) &#123;</span><br><span class="line">    if (!wipe_data(device)) &#123;</span><br><span class="line">      status = INSTALL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (should_prompt_and_wipe_data) &#123;</span><br><span class="line">    ui-&gt;ShowText(true);</span><br><span class="line">    ui-&gt;SetBackground(RecoveryUI::ERROR);</span><br><span class="line">    if (!prompt_and_wipe_data(device)) &#123;</span><br><span class="line">      status = INSTALL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    ui-&gt;ShowText(false);</span><br><span class="line">  &#125; else if (should_wipe_cache) &#123;</span><br><span class="line">    if (!wipe_cache(false, device)) &#123;</span><br><span class="line">      status = INSTALL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (should_wipe_ab) &#123;</span><br><span class="line">    if (!wipe_ab_device(wipe_package_size)) &#123;</span><br><span class="line">      status = INSTALL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (sideload) &#123;</span><br><span class="line">    // &apos;adb reboot sideload&apos; acts the same as user presses key combinations</span><br><span class="line">    // to enter the sideload mode. When &apos;sideload-auto-reboot&apos; is used, text</span><br><span class="line">    // display will NOT be turned on by default. And it will reboot after</span><br><span class="line">    // sideload finishes even if there are errors. Unless one turns on the</span><br><span class="line">    // text display during the installation. This is to enable automated</span><br><span class="line">    // testing.</span><br><span class="line">    if (!sideload_auto_reboot) &#123;</span><br><span class="line">      ui-&gt;ShowText(true);</span><br><span class="line">    &#125;</span><br><span class="line">    status = apply_from_adb(&amp;should_wipe_cache, TEMPORARY_INSTALL_FILE);</span><br><span class="line">    if (status == INSTALL_SUCCESS &amp;&amp; should_wipe_cache) &#123;</span><br><span class="line">      if (!wipe_cache(false, device)) &#123;</span><br><span class="line">        status = INSTALL_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ui-&gt;Print(&quot;/nInstall from ADB complete (status: %d)./n&quot;, status);</span><br><span class="line">    if (sideload_auto_reboot) &#123;</span><br><span class="line">      ui-&gt;Print(&quot;Rebooting automatically./n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (!just_exit) &#123;</span><br><span class="line">    // If this is an eng or userdebug build, automatically turn on the text display if no command</span><br><span class="line">    // is specified. Note that this should be called before setting the background to avoid</span><br><span class="line">    // flickering the background image.</span><br><span class="line">    if (is_ro_debuggable()) &#123;</span><br><span class="line">      ui-&gt;ShowText(true);</span><br><span class="line">    &#125;</span><br><span class="line">    status = INSTALL_NONE;  // No command specified</span><br><span class="line">    ui-&gt;SetBackground(RecoveryUI::NO_COMMAND);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">  if (status == INSTALL_ERROR || status == INSTALL_CORRUPT) &#123;</span><br><span class="line">    ui-&gt;SetBackground(RecoveryUI::ERROR);</span><br><span class="line">    if (!ui-&gt;IsTextVisible()) &#123;</span><br><span class="line">      sleep(5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Device::BuiltinAction after = shutdown_after ? Device::SHUTDOWN : Device::REBOOT;</span><br><span class="line">  // 1. If the recovery menu is visible, prompt and wait for commands.</span><br><span class="line">  // 2. If the state is INSTALL_NONE, wait for commands. (i.e. In user build, manually reboot into</span><br><span class="line">  //    recovery to sideload a package.)</span><br><span class="line">  // 3. sideload_auto_reboot is an option only available in user-debug build, reboot the device</span><br><span class="line">  //    without waiting.</span><br><span class="line">  // 4. In all other cases, reboot the device. Therefore, normal users will observe the device</span><br><span class="line">  //    reboot after it shows the &quot;error&quot; screen for 5s.</span><br><span class="line">  if ((status == INSTALL_NONE &amp;&amp; !sideload_auto_reboot) || ui-&gt;IsTextVisible()) &#123;</span><br><span class="line">    Device::BuiltinAction temp = prompt_and_wait(device, status);</span><br><span class="line">    if (temp != Device::NO_ACTION) &#123;</span><br><span class="line">      after = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Save logs and clean up before rebooting or shutting down.</span><br><span class="line">  // 见3.8节</span><br><span class="line">  finish_recovery();</span><br><span class="line"></span><br><span class="line">  switch (after) &#123;</span><br><span class="line">    case Device::SHUTDOWN:</span><br><span class="line">      ui-&gt;Print(&quot;Shutting down.../n&quot;);</span><br><span class="line">      android::base::SetProperty(ANDROID_RB_PROPERTY, &quot;shutdown,&quot;);</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case Device::REBOOT_BOOTLOADER:</span><br><span class="line">      ui-&gt;Print(&quot;Rebooting to bootloader.../n&quot;);</span><br><span class="line">      android::base::SetProperty(ANDROID_RB_PROPERTY, &quot;reboot,bootloader&quot;);</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      ui-&gt;Print(&quot;Rebooting.../n&quot;);</span><br><span class="line">      reboot(&quot;reboot,&quot;);</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    pause();</span><br><span class="line">  &#125;</span><br><span class="line">  // Should be unreachable.</span><br><span class="line">  return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取参数后，根据相应的参数执行相应的操作，这里是执行OTA INSTALL的流程，install_package完成之执行finish_recovery操作，之后正式完成升级的操作。</p>
<h3 id="3-4-install-install-package"><a href="#3-4-install-install-package" class="headerlink" title="3.4 install.install_package"></a>3.4 install.install_package</h3><p>[-&gt;install.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">int install_package(const std::string&amp; path, bool* wipe_cache, const std::string&amp; install_file,</span><br><span class="line">                    bool needs_mount, int retry_count) &#123;</span><br><span class="line">  CHECK(!path.empty());</span><br><span class="line">  CHECK(!install_file.empty());</span><br><span class="line">  CHECK(wipe_cache != nullptr);</span><br><span class="line"></span><br><span class="line">  modified_flash = true;</span><br><span class="line">  auto start = std::chrono::system_clock::now();</span><br><span class="line"></span><br><span class="line">  int start_temperature = GetMaxValueFromThermalZone();</span><br><span class="line">  int max_temperature = start_temperature;</span><br><span class="line"></span><br><span class="line">  int result = 0;</span><br><span class="line">  std::vector&lt;std::string&gt; log_buffer;</span><br><span class="line">  if (needs_mount == true)</span><br><span class="line">          result = setup_install_mounts();</span><br><span class="line">  if (result != 0 ) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;failed to set up expected mounts for install; aborting&quot;;</span><br><span class="line">    result = INSTALL_ERROR;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //见3.5节</span><br><span class="line">    result = really_install_package(path, wipe_cache, needs_mount, &amp;log_buffer, retry_count,</span><br><span class="line">                                    &amp;max_temperature);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Measure the time spent to apply OTA update in seconds.</span><br><span class="line">  std::chrono::duration&lt;double&gt; duration = std::chrono::system_clock::now() - start;</span><br><span class="line">  int time_total = static_cast&lt;int&gt;(duration.count());</span><br><span class="line"></span><br><span class="line">  bool has_cache = volume_for_mount_point(&quot;/cache&quot;) != nullptr;</span><br><span class="line">  // Skip logging the uncrypt_status on devices without /cache.</span><br><span class="line">  if (has_cache) &#123;</span><br><span class="line">    static constexpr const char* UNCRYPT_STATUS = &quot;/cache/recovery/uncrypt_status&quot;;</span><br><span class="line">    if (ensure_path_mounted(UNCRYPT_STATUS) != 0) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; &quot;Can&apos;t mount &quot; &lt;&lt; UNCRYPT_STATUS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      std::string uncrypt_status;</span><br><span class="line">      if (!android::base::ReadFileToString(UNCRYPT_STATUS, &amp;uncrypt_status)) &#123;</span><br><span class="line">        PLOG(WARNING) &lt;&lt; &quot;failed to read uncrypt status&quot;;</span><br><span class="line">      &#125; else if (!android::base::StartsWith(uncrypt_status, &quot;uncrypt_&quot;)) &#123;</span><br><span class="line">        LOG(WARNING) &lt;&lt; &quot;corrupted uncrypt_status: &quot; &lt;&lt; uncrypt_status;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        log_buffer.push_back(android::base::Trim(uncrypt_status));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // The first two lines need to be the package name and install result.</span><br><span class="line">  std::vector&lt;std::string&gt; log_header = &#123;</span><br><span class="line">    path,</span><br><span class="line">    result == INSTALL_SUCCESS ? &quot;1&quot; : &quot;0&quot;,</span><br><span class="line">    &quot;time_total: &quot; + std::to_string(time_total),</span><br><span class="line">    &quot;retry: &quot; + std::to_string(retry_count),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  int end_temperature = GetMaxValueFromThermalZone();</span><br><span class="line">  max_temperature = std::max(end_temperature, max_temperature);</span><br><span class="line">  if (start_temperature &gt; 0) &#123;</span><br><span class="line">    log_buffer.push_back(&quot;temperature_start: &quot; + std::to_string(start_temperature));</span><br><span class="line">  &#125;</span><br><span class="line">  if (end_temperature &gt; 0) &#123;</span><br><span class="line">    log_buffer.push_back(&quot;temperature_end: &quot; + std::to_string(end_temperature));</span><br><span class="line">  &#125;</span><br><span class="line">  if (max_temperature &gt; 0) &#123;</span><br><span class="line">    log_buffer.push_back(&quot;temperature_max: &quot; + std::to_string(max_temperature));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string log_content =</span><br><span class="line">      android::base::Join(log_header, &quot;/n&quot;) + &quot;/n&quot; + android::base::Join(log_buffer, &quot;/n&quot;) + &quot;/n&quot;;</span><br><span class="line">  if (!android::base::WriteStringToFile(log_content, install_file)) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; &quot;failed to write &quot; &lt;&lt; install_file;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Write a copy into last_log.</span><br><span class="line">  LOG(INFO) &lt;&lt; log_content;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-install-really-install-package"><a href="#3-5-install-really-install-package" class="headerlink" title="3.5 install.really_install_package"></a>3.5 install.really_install_package</h3><p>[-&gt;install.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static int really_install_package(const std::string&amp; path, bool* wipe_cache, bool needs_mount,</span><br><span class="line">                                  std::vector&lt;std::string&gt;* log_buffer, int retry_count,</span><br><span class="line">                                  int* max_temperature) &#123;</span><br><span class="line">  //ui显示                                </span><br><span class="line">  ui-&gt;SetBackground(RecoveryUI::INSTALLING_UPDATE);</span><br><span class="line">  ui-&gt;Print(&quot;Finding update package.../n&quot;);</span><br><span class="line">  // Give verification half the progress bar...</span><br><span class="line">  ui-&gt;SetProgressType(RecoveryUI::DETERMINATE);</span><br><span class="line">  ui-&gt;ShowProgress(VERIFICATION_PROGRESS_FRACTION, VERIFICATION_PROGRESS_TIME);</span><br><span class="line">  LOG(INFO) &lt;&lt; &quot;Update location: &quot; &lt;&lt; path;</span><br><span class="line"></span><br><span class="line">  // Map the update package into memory.</span><br><span class="line">  ui-&gt;Print(&quot;Opening update package.../n&quot;);</span><br><span class="line"></span><br><span class="line">  if (needs_mount) &#123;</span><br><span class="line">    if (path[0] == &apos;@&apos;) &#123;</span><br><span class="line">      ensure_path_mounted(path.substr(1).c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ensure_path_mounted(path.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemMapping map;</span><br><span class="line">  if (!map.MapFile(path)) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;failed to map file&quot;;</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(&quot;error: %d&quot;, kMapFileFailure));</span><br><span class="line">    return INSTALL_CORRUPT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Verify package.</span><br><span class="line">  // 校验升级包</span><br><span class="line">  if (!verify_package(map.addr, map.length)) &#123;</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(&quot;error: %d&quot;, kZipVerificationFailure));</span><br><span class="line">    return INSTALL_CORRUPT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Try to open the package.</span><br><span class="line">  ZipArchiveHandle zip;</span><br><span class="line">  int err = OpenArchiveFromMemory(map.addr, map.length, path.c_str(), &amp;zip);</span><br><span class="line">  if (err != 0) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;Can&apos;t open &quot; &lt;&lt; path &lt;&lt; &quot; : &quot; &lt;&lt; ErrorCodeString(err);</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(&quot;error: %d&quot;, kZipOpenFailure));</span><br><span class="line"></span><br><span class="line">    CloseArchive(zip);</span><br><span class="line">    return INSTALL_CORRUPT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Additionally verify the compatibility of the package.</span><br><span class="line">  if (!verify_package_compatibility(zip)) &#123;</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(&quot;error: %d&quot;, kPackageCompatibilityFailure));</span><br><span class="line">    CloseArchive(zip);</span><br><span class="line">    return INSTALL_CORRUPT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Verify and install the contents of the package.</span><br><span class="line">  ui-&gt;Print(&quot;Installing update.../n&quot;);</span><br><span class="line">  if (retry_count &gt; 0) &#123;</span><br><span class="line">    ui-&gt;Print(&quot;Retry attempt: %d/n&quot;, retry_count);</span><br><span class="line">  &#125;</span><br><span class="line">  ui-&gt;SetEnableReboot(false);</span><br><span class="line">  //见3.6节</span><br><span class="line">  int result = try_update_binary(path, zip, wipe_cache, log_buffer, retry_count, max_temperature);</span><br><span class="line">  ui-&gt;SetEnableReboot(true);</span><br><span class="line">  ui-&gt;Print(&quot;/n&quot;);</span><br><span class="line"></span><br><span class="line">  CloseArchive(zip);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-install-try-update-binary"><a href="#3-6-install-try-update-binary" class="headerlink" title="3.6 install.try_update_binary"></a>3.6 install.try_update_binary</h3><p>[-&gt;install.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">static int try_update_binary(const std::string&amp; package, ZipArchiveHandle zip, bool* wipe_cache,</span><br><span class="line">                             std::vector&lt;std::string&gt;* log_buffer, int retry_count,</span><br><span class="line">                             int* max_temperature) &#123;</span><br><span class="line">  read_source_target_build(zip, log_buffer);</span><br><span class="line"></span><br><span class="line">  int pipefd[2];</span><br><span class="line">  pipe(pipefd);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; args;</span><br><span class="line">#ifdef AB_OTA_UPDATER</span><br><span class="line">  //执行update_binary_command操作，见3.7节</span><br><span class="line">  int ret = update_binary_command(package, zip, &quot;/sbin/update_engine_sideload&quot;, retry_count,</span><br><span class="line">                                  pipefd[1], &amp;args);</span><br><span class="line">#else</span><br><span class="line">  int ret = update_binary_command(package, zip, &quot;/tmp/update-binary&quot;, retry_count, pipefd[1],</span><br><span class="line">                                  &amp;args);</span><br><span class="line">#endif</span><br><span class="line">  if (ret) &#123;</span><br><span class="line">    close(pipefd[0]);</span><br><span class="line">    close(pipefd[1]);</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(&quot;error: %d&quot;, kUpdateBinaryCommandFailure));</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // When executing the update binary contained in the package, the</span><br><span class="line">  // arguments passed are:</span><br><span class="line">  //</span><br><span class="line">  //   - the version number for this interface</span><br><span class="line">  //</span><br><span class="line">  //   - an FD to which the program can write in order to update the</span><br><span class="line">  //     progress bar.  The program can write single-line commands:</span><br><span class="line">  //</span><br><span class="line">  //        progress &lt;frac&gt; &lt;secs&gt;</span><br><span class="line">  //            fill up the next &lt;frac&gt; part of of the progress bar</span><br><span class="line">  //            over &lt;secs&gt; seconds.  If &lt;secs&gt; is zero, use</span><br><span class="line">  //            set_progress commands to manually control the</span><br><span class="line">  //            progress of this segment of the bar.</span><br><span class="line">  //</span><br><span class="line">  //        set_progress &lt;frac&gt;</span><br><span class="line">  //            &lt;frac&gt; should be between 0.0 and 1.0; sets the</span><br><span class="line">  //            progress bar within the segment defined by the most</span><br><span class="line">  //            recent progress command.</span><br><span class="line">  //</span><br><span class="line">  //        ui_print &lt;string&gt;</span><br><span class="line">  //            display &lt;string&gt; on the screen.</span><br><span class="line">  //</span><br><span class="line">  //        wipe_cache</span><br><span class="line">  //            a wipe of cache will be performed following a successful</span><br><span class="line">  //            installation.</span><br><span class="line">  //</span><br><span class="line">  //        clear_display</span><br><span class="line">  //            turn off the text display.</span><br><span class="line">  //</span><br><span class="line">  //        enable_reboot</span><br><span class="line">  //            packages can explicitly request that they want the user</span><br><span class="line">  //            to be able to reboot during installation (useful for</span><br><span class="line">  //            debugging packages that don&apos;t exit).</span><br><span class="line">  //</span><br><span class="line">  //        retry_update</span><br><span class="line">  //            updater encounters some issue during the update. It requests</span><br><span class="line">  //            a reboot to retry the same package automatically.</span><br><span class="line">  //</span><br><span class="line">  //        log &lt;string&gt;</span><br><span class="line">  //            updater requests logging the string (e.g. cause of the</span><br><span class="line">  //            failure).</span><br><span class="line">  //</span><br><span class="line">  //   - the name of the package zip file.</span><br><span class="line">  //</span><br><span class="line">  //   - an optional argument &quot;retry&quot; if this update is a retry of a failed</span><br><span class="line">  //   update attempt.</span><br><span class="line">  //</span><br><span class="line"></span><br><span class="line">  // Convert the vector to a NULL-terminated char* array suitable for execv.</span><br><span class="line">  const char* chr_args[args.size() + 1];</span><br><span class="line">  chr_args[args.size()] = nullptr;</span><br><span class="line">  for (size_t i = 0; i &lt; args.size(); i++) &#123;</span><br><span class="line">    chr_args[i] = args[i].c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">  if (pid == -1) &#123;</span><br><span class="line">    close(pipefd[0]);</span><br><span class="line">    close(pipefd[1]);</span><br><span class="line">    PLOG(ERROR) &lt;&lt; &quot;Failed to fork update binary&quot;;</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(&quot;error: %d&quot;, kForkUpdateBinaryFailure));</span><br><span class="line">    return INSTALL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (pid == 0) &#123;</span><br><span class="line">    umask(022);</span><br><span class="line">    close(pipefd[0]);</span><br><span class="line">    execv(chr_args[0], const_cast&lt;char**&gt;(chr_args));</span><br><span class="line">    // Bug: 34769056</span><br><span class="line">    // We shouldn&apos;t use LOG/PLOG in the forked process, since they may cause</span><br><span class="line">    // the child process to hang. This deadlock results from an improperly</span><br><span class="line">    // copied mutex in the ui functions.</span><br><span class="line">    fprintf(stdout, &quot;E:Can&apos;t run %s (%s)/n&quot;, chr_args[0], strerror(errno));</span><br><span class="line">    _exit(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  close(pipefd[1]);</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;bool&gt; logger_finished(false);</span><br><span class="line">  std::thread temperature_logger(log_max_temperature, max_temperature, std::ref(logger_finished));</span><br><span class="line"></span><br><span class="line">  *wipe_cache = false;</span><br><span class="line">  bool retry_update = false;</span><br><span class="line"></span><br><span class="line">  char buffer[1024];</span><br><span class="line">  FILE* from_child = fdopen(pipefd[0], &quot;r&quot;);</span><br><span class="line">  while (fgets(buffer, sizeof(buffer), from_child) != nullptr) &#123;</span><br><span class="line">    std::string line(buffer);</span><br><span class="line">    size_t space = line.find_first_of(&quot; /n&quot;);</span><br><span class="line">    std::string command(line.substr(0, space));</span><br><span class="line">    if (command.empty()) continue;</span><br><span class="line"></span><br><span class="line">    // Get rid of the leading and trailing space and/or newline.</span><br><span class="line">    std::string args = space == std::string::npos ? &quot;&quot; : android::base::Trim(line.substr(space));</span><br><span class="line"></span><br><span class="line">    if (command == &quot;progress&quot;) &#123;</span><br><span class="line">      std::vector&lt;std::string&gt; tokens = android::base::Split(args, &quot; &quot;);</span><br><span class="line">      double fraction;</span><br><span class="line">      int seconds;</span><br><span class="line">      if (tokens.size() == 2 &amp;&amp; android::base::ParseDouble(tokens[0].c_str(), &amp;fraction) &amp;&amp;</span><br><span class="line">          android::base::ParseInt(tokens[1], &amp;seconds)) &#123;</span><br><span class="line">        ui-&gt;ShowProgress(fraction * (1 - VERIFICATION_PROGRESS_FRACTION), seconds);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;invalid /&quot;progress/&quot; parameters: &quot; &lt;&lt; line;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (command == &quot;set_progress&quot;) &#123;</span><br><span class="line">      std::vector&lt;std::string&gt; tokens = android::base::Split(args, &quot; &quot;);</span><br><span class="line">      double fraction;</span><br><span class="line">      if (tokens.size() == 1 &amp;&amp; android::base::ParseDouble(tokens[0].c_str(), &amp;fraction)) &#123;</span><br><span class="line">        ui-&gt;SetProgress(fraction);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;invalid /&quot;set_progress/&quot; parameters: &quot; &lt;&lt; line;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (command == &quot;ui_print&quot;) &#123;</span><br><span class="line">      ui-&gt;PrintOnScreenOnly(&quot;%s/n&quot;, args.c_str());</span><br><span class="line">      fflush(stdout);</span><br><span class="line">    &#125; else if (command == &quot;wipe_cache&quot;) &#123;</span><br><span class="line">      *wipe_cache = true;</span><br><span class="line">    &#125; else if (command == &quot;clear_display&quot;) &#123;</span><br><span class="line">      ui-&gt;SetBackground(RecoveryUI::NONE);</span><br><span class="line">    &#125; else if (command == &quot;enable_reboot&quot;) &#123;</span><br><span class="line">      // packages can explicitly request that they want the user</span><br><span class="line">      // to be able to reboot during installation (useful for</span><br><span class="line">      // debugging packages that don&apos;t exit).</span><br><span class="line">      ui-&gt;SetEnableReboot(true);</span><br><span class="line">    &#125; else if (command == &quot;retry_update&quot;) &#123;</span><br><span class="line">      retry_update = true;</span><br><span class="line">    &#125; else if (command == &quot;log&quot;) &#123;</span><br><span class="line">      if (!args.empty()) &#123;</span><br><span class="line">        // Save the logging request from updater and write to last_install later.</span><br><span class="line">        log_buffer-&gt;push_back(args);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;invalid /&quot;log/&quot; parameters: &quot; &lt;&lt; line;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      LOG(ERROR) &lt;&lt; &quot;unknown command [&quot; &lt;&lt; command &lt;&lt; &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(from_child);</span><br><span class="line"></span><br><span class="line">  int status;</span><br><span class="line">  waitpid(pid, &amp;status, 0);</span><br><span class="line"></span><br><span class="line">  logger_finished.store(true);</span><br><span class="line">  finish_log_temperature.notify_one();</span><br><span class="line">  temperature_logger.join();</span><br><span class="line"></span><br><span class="line">  if (retry_update) &#123;</span><br><span class="line">    return INSTALL_RETRY;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;Error in &quot; &lt;&lt; package &lt;&lt; &quot; (Status &quot; &lt;&lt; WEXITSTATUS(status) &lt;&lt; &quot;)&quot;;</span><br><span class="line">    return INSTALL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return INSTALL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-install-update-binary-command"><a href="#3-7-install-update-binary-command" class="headerlink" title="3.7 install.update_binary_command"></a>3.7 install.update_binary_command</h3><p>[-&gt;install.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int update_binary_command(const std::string&amp; package, ZipArchiveHandle zip,</span><br><span class="line">                          const std::string&amp; binary_path, int retry_count, int status_fd,</span><br><span class="line">                          std::vector&lt;std::string&gt;* cmd) &#123;</span><br><span class="line">  CHECK(cmd != nullptr);</span><br><span class="line"></span><br><span class="line">  // On traditional updates we extract the update binary from the package.</span><br><span class="line">  static constexpr const char* UPDATE_BINARY_NAME = &quot;META-INF/com/google/android/update-binary&quot;;</span><br><span class="line">  ZipString binary_name(UPDATE_BINARY_NAME);</span><br><span class="line">  ZipEntry binary_entry;</span><br><span class="line">  if (FindEntry(zip, binary_name, &amp;binary_entry) != 0) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;Failed to find update binary &quot; &lt;&lt; UPDATE_BINARY_NAME;</span><br><span class="line">    return INSTALL_CORRUPT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unlink(binary_path.c_str());</span><br><span class="line">  int fd = open(binary_path.c_str(), O_CREAT | O_WRONLY | O_TRUNC | O_CLOEXEC, 0755);</span><br><span class="line">  if (fd == -1) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; &quot;Failed to create &quot; &lt;&lt; binary_path;</span><br><span class="line">    return INSTALL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int32_t error = ExtractEntryToFile(zip, &amp;binary_entry, fd);</span><br><span class="line">  close(fd);</span><br><span class="line">  if (error != 0) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;Failed to extract &quot; &lt;&lt; UPDATE_BINARY_NAME &lt;&lt; &quot;: &quot; &lt;&lt; ErrorCodeString(error);</span><br><span class="line">    return INSTALL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *cmd = &#123;</span><br><span class="line">    binary_path,</span><br><span class="line">    std::to_string(kRecoveryApiVersion),</span><br><span class="line">    std::to_string(status_fd),</span><br><span class="line">    package,</span><br><span class="line">  &#125;;</span><br><span class="line">  if (retry_count &gt; 0) &#123;</span><br><span class="line">    cmd-&gt;push_back(&quot;retry&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面介绍到update-binary相当于一个脚本解释器，能够识别updater-script中描述的操作。来看下updater-script中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">show_progress(0.650000, 0);</span><br><span class="line">ui_print(&quot;Patching system image unconditionally...&quot;);</span><br><span class="line">block_image_update(&quot;/dev/block/bootdevice/by-name/system&quot;, package_extract_file(&quot;system.transfer.list&quot;), &quot;system.new.dat.br&quot;, &quot;system.patch.dat&quot;) ||</span><br><span class="line">  abort(&quot;E1001: Failed to update system image.&quot;);</span><br><span class="line">show_progress(0.100000, 0);</span><br><span class="line">ui_print(&quot;Patching vendor image unconditionally...&quot;);</span><br><span class="line">block_image_update(&quot;/dev/block/bootdevice/by-name/vendor&quot;, package_extract_file(&quot;vendor.transfer.list&quot;), &quot;vendor.new.dat.br&quot;, &quot;vendor.patch.dat&quot;) ||</span><br><span class="line">  abort(&quot;E2001: Failed to update vendor image.&quot;);</span><br><span class="line">show_progress(0.050000, 5);</span><br><span class="line">package_extract_file(&quot;boot.img&quot;, &quot;/dev/block/bootdevice/by-name/boot&quot;);</span><br><span class="line">show_progress(0.200000, 10);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>调用的是block_image_update，传入的是升级包里面的system.transfer.list和system.new.dat.br来实现升级。</p>
<p>block_image_update在bootable/recovery/updater/blockimg.cpp中，具体的实现PerformBlockImageUpdate函数中，这里不再详细展开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void RegisterBlockImageFunctions() &#123;</span><br><span class="line">  RegisterFunction(&quot;block_image_verify&quot;, BlockImageVerifyFn);</span><br><span class="line">  RegisterFunction(&quot;block_image_update&quot;, BlockImageUpdateFn);</span><br><span class="line">  RegisterFunction(&quot;block_image_recover&quot;, BlockImageRecoverFn);</span><br><span class="line">  RegisterFunction(&quot;check_first_block&quot;, CheckFirstBlockFn);</span><br><span class="line">  RegisterFunction(&quot;range_sha1&quot;, RangeSha1Fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来system.transfer.list中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">583603</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">erase 6,1020,7774,524808,527824,580432,773491</span><br><span class="line">new 6,0,207,222,508,8286,8817</span><br><span class="line">new 2,8817,9841</span><br><span class="line">new 2,9841,10865</span><br><span class="line">...</span><br><span class="line">zero 6,524360,524808,527824,528336,579920,579984</span><br><span class="line">zero 6,579984,580432,773491,774003,786268,786332</span><br><span class="line">zero 2,786332,786431</span><br></pre></td></tr></table></figure>
<p>其中</p>
<p>4：为transfer的版本，目前支持1-4版本</p>
<p>583603：为总共new的block数量</p>
<p>0：stash slots没有使用，所以这里两个都是0</p>
<p>erase：需要擦除的block块范围数</p>
<p>new:     需要写入的block块范围数</p>
<p>zero:     需要填充0的block块范围数</p>
<h3 id="3-8-recovery-finish-recovery"><a href="#3-8-recovery-finish-recovery" class="headerlink" title="3.8 recovery.finish_recovery"></a>3.8 recovery.finish_recovery</h3><p>[-&gt;recovery.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static void finish_recovery() &#123;</span><br><span class="line">  // Save the locale to cache, so if recovery is next started up without a &apos;--locale&apos; argument</span><br><span class="line">  // (e.g., directly from the bootloader) it will use the last-known locale.</span><br><span class="line">  if (!locale.empty() &amp;&amp; has_cache) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Saving locale /&quot;&quot; &lt;&lt; locale &lt;&lt; &quot;/&quot;&quot;;</span><br><span class="line">    if (ensure_path_mounted(LOCALE_FILE) != 0) &#123;</span><br><span class="line">      LOG(ERROR) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; LOCALE_FILE;</span><br><span class="line">    &#125; else if (!android::base::WriteStringToFile(locale, LOCALE_FILE)) &#123;</span><br><span class="line">      PLOG(ERROR) &lt;&lt; &quot;Failed to save locale to &quot; &lt;&lt; LOCALE_FILE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  copy_logs();</span><br><span class="line"></span><br><span class="line">  // Reset to normal system boot so recovery won&apos;t cycle indefinitely.</span><br><span class="line">  std::string err;</span><br><span class="line">  if (!clear_bootloader_message(&amp;err)) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;Failed to clear BCB message: &quot; &lt;&lt; err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Remove the command file, so recovery won&apos;t repeat indefinitely.</span><br><span class="line">  if (has_cache) &#123;</span><br><span class="line">    if (ensure_path_mounted(COMMAND_FILE) != 0 || (unlink(COMMAND_FILE) &amp;&amp; errno != ENOENT)) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; &quot;Can&apos;t unlink &quot; &lt;&lt; COMMAND_FILE;</span><br><span class="line">    &#125;</span><br><span class="line">    ensure_path_unmounted(CACHE_ROOT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sync();  // For good measure.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成升级后，清除BCB操作。</p>
<h3 id="3-9-小结"><a href="#3-9-小结" class="headerlink" title="3.9 小结"></a>3.9 小结</h3><p>ota升级重启后，主要的操作如下:</p>
<p>1.加载bootloader，读取bootloader中的command命令</p>
<p>2.读取到升级的命令后，boot recovery.img，recovery.cpp中的main函数执行。</p>
<p>3.执行install_package操作，这里会解析ota包中的内容（block.map的形式），执行相应的升级包中脚本操作，同时会同步进行一些ui的显示操作。</p>
<p>4.install_package操作完成后，最后finish_recovery，完成升级的操作。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文分析Android终端ota升级的全过程。从介绍ota升级包的格式和系统启动模式开始作为基础，后面详细分析了从升级重启前到重启后的详细流程，其中升级重启前的流程如下：</p>
<p><img src="/2019/Android OTA升级流程分析/OTA.jpg" alt="OTA"></p>
<p>OTA升级重启前，主要的操作是对升级包进行处理的过程，对升级包提前处理的原因是因为在进入recovery模式进行升级时无法加载升级包所在的分区。在重启前的主要操作如下：</p>
<p>1.通过SystemProperties设置属性(setup-bcb)，向BCB中设置升级的Command；</p>
<p>2.通过SystemProperties设置属性(uncrypt)，开启uncrypt服务，将升级包生成一系列的block块，recovery可以读取block.map文件并获取这个文件的数据作为升级包；</p>
<p>3.uncrypt完成后，重启。</p>
<p>ota升级重启后，主要的操作如下:</p>
<p>1.加载bootloader，读取bootloader中的command命令</p>
<p>2.读取到升级的命令后，boot recovery.img，recovery.cpp中的main函数执行。</p>
<p>3.执行install_package操作，这里会解析ota包中的内容（block.map的形式），执行相应的升级包中脚本操作，同时会同步进行一些ui的显示操作。</p>
<p>4.install_package操作完成后，最后finish_recovery，完成升级的操作。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>源码路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/RecoverySystem.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/RecoverySystemService.java</span><br><span class="line">frameworks/base/core/java/android/os/PowerManager.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/power/ShutdownThread.java</span><br><span class="line"></span><br><span class="line">bootable/recovery/uncrypt/uncrypt.cpp</span><br><span class="line">bootable/recovery/uncrypt/uncrypt.rc</span><br><span class="line">bootable/bootloader/lk/app/aboot/aboot.c</span><br><span class="line">bootable/bootloader/lk/app/aboot/recovery.c</span><br><span class="line">bootable/recovery/updater/install.cpp</span><br><span class="line">bootable/recovery/install.cpp</span><br><span class="line">bootable/recovery/bootloader_message/include/bootloader_message/bootloader_message.h</span><br><span class="line">bootable/recovery/updater/blockimg.cpp</span><br></pre></td></tr></table></figure>
      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OTA升级/" rel="tag">#OTA升级</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/Android SystemProperties系统属性分析/" rel="next" title="Android SystemProperties系统属性分析">
                <i class="fa fa-chevron-left"></i> Android SystemProperties系统属性分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/深入理解Binder机制1-AIDL原理/" rel="prev" title="深入理解Binder机制1-AIDL原理">
                深入理解Binder机制1-AIDL原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-升级包结构"><span class="nav-text">1.1  升级包结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-系统启动模式"><span class="nav-text">1.2 系统启动模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、OTA升级重启前"><span class="nav-text">二、OTA升级重启前</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-RS-installPackage"><span class="nav-text">2.1 RS.installPackage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-RS-setupBcb"><span class="nav-text">2.2 RS.setupBcb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-RSS-setupBcb"><span class="nav-text">2.3 RSS.setupBcb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-RSS-setupOrClearBcb"><span class="nav-text">2.4 RSS.setupOrClearBcb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-PM-reboot"><span class="nav-text">2.5  PM.reboot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-PMS-reboot"><span class="nav-text">2.6  PMS.reboot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-PMS-shutdownOrRebootInternal"><span class="nav-text">2.7  PMS.shutdownOrRebootInternal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-ST-reboot"><span class="nav-text">2.8 ST.reboot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-ST-shutdownInner"><span class="nav-text">2.9 ST.shutdownInner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-ST-beginShutdownSequence"><span class="nav-text">2.10 ST.beginShutdownSequence</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-10-1-ST-showShutdownDialog"><span class="nav-text">2.10.1 ST.showShutdownDialog</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-ST-run"><span class="nav-text">2.11 ST.run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-ST-uncrypt"><span class="nav-text">2.12 ST.uncrypt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-13-RS-processPackage"><span class="nav-text">2.13 RS.processPackage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-14-RS-uncrypt"><span class="nav-text">2.14 RS.uncrypt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-15-RSS-uncrypt"><span class="nav-text">2.15 RSS.uncrypt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-16-uncrypt-main"><span class="nav-text">2.16 uncrypt.main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-17-uncrypt-uncrypt-wrapper"><span class="nav-text">2.17 uncrypt.uncrypt_wrapper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-18-uncrypt-uncrypt"><span class="nav-text">2.18  uncrypt.uncrypt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-19-uncrypt-produce-block-map"><span class="nav-text">2.19  uncrypt.produce_block_map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-20-ST-rebootOrShutdown"><span class="nav-text">2.20 ST.rebootOrShutdown</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-20-1-PWS-lowLevelReboot"><span class="nav-text">2.20.1 PWS.lowLevelReboot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-20-2-PWS-lowLevelReboot"><span class="nav-text">2.20.2 PWS.lowLevelReboot</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-21-小结"><span class="nav-text">2.21 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、OTA升级重启后"><span class="nav-text">三、OTA升级重启后</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-aboot-aboot-init"><span class="nav-text">3.1 aboot.aboot_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-recovery-recovery-init"><span class="nav-text">3.2 recovery.recovery_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-recovery-main"><span class="nav-text">3.3 recovery.main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-install-install-package"><span class="nav-text">3.4 install.install_package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-install-really-install-package"><span class="nav-text">3.5 install.really_install_package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-install-try-update-binary"><span class="nav-text">3.6 install.try_update_binary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-install-update-binary-command"><span class="nav-text">3.7 install.update_binary_command</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-recovery-finish-recovery"><span class="nav-text">3.8 recovery.finish_recovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-小结"><span class="nav-text">3.9 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、总结"><span class="nav-text">四、总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2019/Android OTA升级流程分析/';
      var disqus_title = "Android OTA升级流程分析";
      var disqus_url = 'http://zproo.github.io/2019/Android OTA升级流程分析/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
