<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="PackageManagerService,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="基于Android10.0，分析PackageManagerService启动  一、PakageManagerService概述1.1  作用PakageManagerService(简称PKMS)，是Android核心服务之一，管理着所有package相关的工作。 如：安装、卸载应用 ​       查询、增加、删除permission相关信息 ​       查询Application相关">
<meta name="keywords" content="PackageManagerService">
<meta property="og:type" content="article">
<meta property="og:title" content="PackageManagerService启动流程分析">
<meta property="og:url" content="http://zproo.github.io/2019/PackageManagerService启动流程分析/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="基于Android10.0，分析PackageManagerService启动  一、PakageManagerService概述1.1  作用PakageManagerService(简称PKMS)，是Android核心服务之一，管理着所有package相关的工作。 如：安装、卸载应用 ​       查询、增加、删除permission相关信息 ​       查询Application相关">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2019/PackageManagerService启动流程分析/pkms.jpg">
<meta property="og:image" content="http://zproo.github.io/2019/PackageManagerService启动流程分析/scanDir.png">
<meta property="og:updated_time" content="2019-12-29T14:12:12.747Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PackageManagerService启动流程分析">
<meta name="twitter:description" content="基于Android10.0，分析PackageManagerService启动  一、PakageManagerService概述1.1  作用PakageManagerService(简称PKMS)，是Android核心服务之一，管理着所有package相关的工作。 如：安装、卸载应用 ​       查询、增加、删除permission相关信息 ​       查询Application相关">
<meta name="twitter:image" content="http://zproo.github.io/2019/PackageManagerService启动流程分析/pkms.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2019/PackageManagerService启动流程分析/">

  <title> PackageManagerService启动流程分析 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/PackageManagerService/" rel="tag" title="PackageManagerService">PackageManagerService</a>
      
      </div>
      <h1>PackageManagerService启动流程分析</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2019-06-30T21:18:23+08:00" content="2019-06-30" title="2019-06-30 21:18:23">
          2019-06-30
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                PackageManagerService启动流程分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-06-30T21:18:23+08:00" content="2019-06-30">
              2019-06-30
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/PackageManagerService启动流程分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/PackageManagerService启动流程分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>基于Android10.0，分析PackageManagerService启动</p>
</blockquote>
<h2 id="一、PakageManagerService概述"><a href="#一、PakageManagerService概述" class="headerlink" title="一、PakageManagerService概述"></a>一、PakageManagerService概述</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1  作用"></a>1.1  作用</h3><p>PakageManagerService(简称PKMS)，是Android核心服务之一，管理着所有package相关的工作。</p>
<p>如：安装、卸载应用</p>
<p>​       查询、增加、删除permission相关信息</p>
<p>​       查询Application相关信息</p>
<p>​       查询已安装应用</p>
<p>​       清除用户数据，缓存</p>
<h3 id="1-2-PKMS类关系"><a href="#1-2-PKMS类关系" class="headerlink" title="1.2 PKMS类关系"></a>1.2 PKMS类关系</h3><p>PKMS是通过Binder进行通信。IPackageManager.aidl通过工具生成Binder的服务端IPackageManager.Stub和</p>
<p>客户端IPackageManager.Stub.Proxy，编译后生成的路径在 out/target/common 目录下。</p>
<p>Binder服务端：PackageManagerService继承于IPackageManager.Stub</p>
<p>Binder客户端：ApplicationPackageManager（简称APM）的成员变量mPM继承于IPackageManager.Stub.Proxy;</p>
<p>​                         APM继承于PakageManager对象</p>
<p><img src="/2019/PackageManagerService启动流程分析/pkms.jpg" alt=""></p>
<h3 id="1-3-PKMS类成员"><a href="#1-3-PKMS类成员" class="headerlink" title="1.3  PKMS类成员"></a>1.3  PKMS类成员</h3><p>PKMS类共有二万多行，这里就简单介绍一下其中重要的类和成员变量。</p>
<p>重要成员支持类</p>
<p><strong>PackageParser</strong></p>
<p>这个类主要用于解析APK,解析AndroidManifest.xml文件得到package的所有信息，PackageParser.Package用于存储得到的信息。</p>
<p><strong>Settings</strong></p>
<p>这个类表示它服务处理设置和读取包的各种状态，是动态的，比如shareUser，permission，signature，userid等相关信息。安装包就是从安装的package中抽取信息更新Settings中的内容，特别是shareUser和origPackge。为了加速启动，Setting内容会写入data/system/pakcages.xml、packages-backup.xml和packages.list，下次启动时会直接载入。</p>
<p><strong>Installer</strong></p>
<p>这个类是协助安装的过程，操作基本上是在cpp里面，真正的工作是由installd执行，installd通过Native Binder实现。</p>
<p><strong>类成员</strong></p>
<p>//代表系统已经安装的package</p>
<p>final ArrayMap&lt;String, PackageParser.Package&gt; mPackages</p>
<p>//被升级过的应用列表</p>
<p>final private ArrayMap&lt;String, File&gt; mExpectingBetter </p>
<p>//保存PackageManager动态设置信息</p>
<p> final Settings mSettings;</p>
<h3 id="1-4-PKMS启动流程"><a href="#1-4-PKMS启动流程" class="headerlink" title="1.4 PKMS启动流程"></a>1.4 PKMS启动流程</h3><p>SystemServer启动过程中涉及的PKMS如下：</p>
<p>主要在下面的两个方法中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private voi run() &#123;</span><br><span class="line">    ...</span><br><span class="line">    startBootstrapServices();</span><br><span class="line">    startOtherServices();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startBootstrapServices方法相关PKMS的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Starts the small tangle of critical services that are needed to get</span><br><span class="line"> * the system off the ground.  These services have complex mutual dependencies</span><br><span class="line"> * which is why we initialize them all in one place here.  Unless your service</span><br><span class="line"> * is also entwined in these dependencies, it should be initialized in one of</span><br><span class="line"> * the other functions.</span><br><span class="line"> */</span><br><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    </span><br><span class="line">    //启动installer服务，PKMS相关任务的执行者</span><br><span class="line">    // Wait for installd to finish starting up so that it has a chance to</span><br><span class="line">    // create critical directories such as /data/user with the appropriate</span><br><span class="line">    // permissions.  We need this to complete before we initialize other services.</span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">    ....</span><br><span class="line">    //加密状态仅仅解析核心应用</span><br><span class="line">    // Only run &quot;core&quot; apps if we&apos;re encrypting the device.</span><br><span class="line">    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</span><br><span class="line">    if (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);</span><br><span class="line">        mOnlyCore = true;</span><br><span class="line">    &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);</span><br><span class="line">        mOnlyCore = true;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    //启动PackagemanagerService服务</span><br><span class="line">    traceBeginAndSlog(&quot;StartPackageManagerService&quot;);</span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    //是否是开机后第一次启动</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    //获取包管理</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面最重要的是PKMS.mian()操作，主要是创建PKMS服务，并注册到ServiceManager中。</p>
<p>startOtherServices方法中相关PKMS的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Starts a miscellaneous grab bag of stuff that has yet to be refactored</span><br><span class="line"> * and organized.</span><br><span class="line"> */</span><br><span class="line">private void startOtherServices() &#123;</span><br><span class="line">    //非加密状态</span><br><span class="line">    if (!mOnlyCore) &#123;</span><br><span class="line">        traceBeginAndSlog(&quot;UpdatePackagesIfNeeded&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            //dexopt是android上Java字节码的一种优化技术，可提高运行效率</span><br><span class="line">            //对应用dexopt的顺序进行排序，并执行dexopt操作</span><br><span class="line">            mPackageManagerService.updatePackagesIfNeeded();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            reportWtf(&quot;update packages&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        traceEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    traceBeginAndSlog(&quot;PerformFstrimIfNeeded&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        //当3天未执行fstrim时，则执行fstrim操作</span><br><span class="line">        mPackageManagerService.performFstrimIfNeeded();</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        reportWtf(&quot;performing fstrim&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    //通知系统进入就绪状态</span><br><span class="line">    mPackageManagerService.systemReady();</span><br><span class="line">    ...</span><br><span class="line">    //等待所有应用准备好,主要是等待应用处理的线程结束</span><br><span class="line">    // Wait for all packages to be prepared</span><br><span class="line">    mPackageManagerService.waitForAppDataPrepared();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SystemServer启动过程中，PKMS最主要的操作如下：</p>
<ul>
<li>PKMS.main()</li>
<li>PKMS.updatePackagesIfNeeded()</li>
<li>PKMS.systemReady()</li>
</ul>
<h2 id="二、PKMS-main"><a href="#二、PKMS-main" class="headerlink" title="二、PKMS.main"></a>二、PKMS.main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static PackageManagerService main(Context context, Installer installer,</span><br><span class="line">          boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">      // Self-check for initial settings.</span><br><span class="line">      PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line"></span><br><span class="line">      PackageManagerService m = new PackageManagerService(context, installer,</span><br><span class="line">              factoryTest, onlyCore);</span><br><span class="line">      m.enableSystemUserPackages();</span><br><span class="line">      //讲PKMS注册到ServiceManager中</span><br><span class="line">      ServiceManager.addService(&quot;package&quot;, m);</span><br><span class="line">      final PackageManagerNative pmn = m.new PackageManagerNative();</span><br><span class="line">      ServiceManager.addService(&quot;package_native&quot;, pmn);</span><br><span class="line">      return m;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>main方法主要功能是创建PKMS对象，创建PKMS对象的执行时间比较长，在其构造函数做了很多的“重力活”，这也是Android启动慢的原因之一。构造函数的主要功能是扫描Android系统中目标文件夹中的APK，从而建立合适的数据结构来管理诸如：Package信息，四大组件、权限等各种信息。PKMS工作流程相对简单，复杂的是其中用于保存各种信息的数据结构以及它们之间的关系。PKMS构造函数主要分为五个阶段，每个阶段都会输出日志到EventLog，除了阶段1的开始部分代码，后面的代码都同时持有同步锁mPackage、mInstallLock。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public PackageManagerService(Context context, Installer installer,</span><br><span class="line">           boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">           </span><br><span class="line">       阶段1：BOOT_PROGRESS_PMS_START         </span><br><span class="line">       synchronized (mInstallLock) &#123;</span><br><span class="line">         synchronized (mPackages) &#123;</span><br><span class="line">             ...</span><br><span class="line">             阶段2：BOOT_PROGRESS_PMS_SYSTEM_SCAN_START </span><br><span class="line">             阶段3：BOOT_PROGRESS_PMS_DATA_SCAN_START </span><br><span class="line">             阶段4：BOOT_PROGRESS_PMS_SCAN_END </span><br><span class="line">             阶段5：BOOT_PROGRESS_PMS_READY </span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // Now after opening every single application zip, make sure they</span><br><span class="line">       // are all flushed.  Not really needed, but keeps things nice and</span><br><span class="line">       // tidy.</span><br><span class="line">       Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;GC&quot;);</span><br><span class="line">       Runtime.getRuntime().gc();</span><br><span class="line">       Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line"></span><br><span class="line">       // The initial scanning above does many calls into installd while</span><br><span class="line">       // holding the mPackages lock, but we&apos;re mostly interested in yelling</span><br><span class="line">       // once we have a booted system.</span><br><span class="line">       mInstaller.setWarnIfHeld(mPackages);</span><br><span class="line">       Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-PMS-START"><a href="#2-1-PMS-START" class="headerlink" title="2.1  PMS_START"></a>2.1  PMS_START</h3><p>主要的工作如下：</p>
<ul>
<li>创建Settings对象；</li>
<li>将8类shareUserId到mSettings；</li>
<li>初始化SystemConfig；</li>
<li>创建名为“PackageManager”的handler线程<code>mHandlerThread</code>;</li>
<li>创建UserManagerService、PermissionManagerService服务；</li>
<li>通过解析目录中的xmL文件构造共享mSharedLibraries；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">LockGuard.installLock(mPackages, LockGuard.INDEX_PACKAGES);</span><br><span class="line">Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;create package manager&quot;);</span><br><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,</span><br><span class="line">        SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">if (mSdkVersion &lt;= 0) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;**** ro.build.version.sdk not set!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mContext = context;</span><br><span class="line">//运行在非工厂模式</span><br><span class="line">mFactoryTest = factoryTest;</span><br><span class="line">//标记是否加载核心服务</span><br><span class="line">mOnlyCore = onlyCore;</span><br><span class="line">//显示屏幕相关，如分辨率、屏幕尺寸</span><br><span class="line">mMetrics = new DisplayMetrics();</span><br><span class="line">//安装器，和本地守护进程installed交互，通信方式为socket</span><br><span class="line">mInstaller = installer;</span><br><span class="line"></span><br><span class="line">// Create sub-components that provide services / data. Order here is important.</span><br><span class="line">synchronized (mInstallLock) &#123;</span><br><span class="line">synchronized (mPackages) &#123;</span><br><span class="line">    //只用于系统内部的packagemanager</span><br><span class="line">    // Expose private service for system components to use.</span><br><span class="line">    LocalServices.addService(</span><br><span class="line">            PackageManagerInternal.class, new PackageManagerInternalImpl());</span><br><span class="line">    //用户管理服务</span><br><span class="line">    sUserManager = new UserManagerService(context, this,</span><br><span class="line">    new UserDataPreparer(mInstaller, mInstallLock, mContext, mOnlyCore), mPackages);</span><br><span class="line">    //权限管理服务</span><br><span class="line">    mPermissionManager = PermissionManagerService.create(context,</span><br><span class="line">            new DefaultPermissionGrantedCallback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onDefaultRuntimePermissionsGranted(int userId) &#123;</span><br><span class="line">                    synchronized(mPackages) &#123;</span><br><span class="line">                        mSettings.onDefaultRuntimePermissionsGrantedLPr(userId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, mPackages /*externalLock*/);</span><br><span class="line">    mDefaultPermissionPolicy = mPermissionManager.getDefaultPermissionGrantPolicy();</span><br><span class="line">    //该类用于存储系统运行过程中的一些设置</span><br><span class="line">    mSettings = new Settings(mPermissionManager.getPermissionSettings(), mPackages);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//添加八种sharedUserId到mSettings</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.system&quot;, Process.SYSTEM_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.phone&quot;, RADIO_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.log&quot;, LOG_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.nfc&quot;, NFC_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.bluetooth&quot;, BLUETOOTH_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.shell&quot;, SHELL_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.se&quot;, SE_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.networkstack&quot;, NETWORKSTACK_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">//该值和调试相关，一般不设置该属性，separateProcesses在扫描文件目录中用到</span><br><span class="line">String separateProcesses = SystemProperties.get(&quot;debug.separate_processes&quot;);</span><br><span class="line">if (separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) &#123;</span><br><span class="line">    if (&quot;*&quot;.equals(separateProcesses)) &#123;</span><br><span class="line">        mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</span><br><span class="line">        mSeparateProcesses = null;</span><br><span class="line">        Slog.w(TAG, &quot;Running with debug.separate_processes: * (ALL)&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mDefParseFlags = 0;</span><br><span class="line">        mSeparateProcesses = separateProcesses.split(&quot;,&quot;);</span><br><span class="line">        Slog.w(TAG, &quot;Running with debug.separate_processes: &quot;</span><br><span class="line">                + separateProcesses);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    mDefParseFlags = 0;</span><br><span class="line">    mSeparateProcesses = null;</span><br><span class="line">&#125;</span><br><span class="line">//dexopt相关对象初始化</span><br><span class="line">mPackageDexOptimizer = new PackageDexOptimizer(installer, mInstallLock, context,</span><br><span class="line">        &quot;*dexopt*&quot;);</span><br><span class="line">DexManager.Listener dexManagerListener = DexLogger.getListener(this,</span><br><span class="line">        installer, mInstallLock);</span><br><span class="line">mDexManager = new DexManager(mContext, this, mPackageDexOptimizer, installer, mInstallLock,</span><br><span class="line">        dexManagerListener);</span><br><span class="line">mArtManagerService = new ArtManagerService(mContext, this, installer, mInstallLock);</span><br><span class="line">mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">mOnPermissionChangeListeners = new OnPermissionChangeListeners(</span><br><span class="line">        FgThread.get().getLooper());</span><br><span class="line">//获取当前设置的显示信息</span><br><span class="line">getDefaultDisplayMetrics(context, mMetrics);   </span><br><span class="line">//通过SystemConfig读取系统的feature、permission等配置</span><br><span class="line">Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;get system config&quot;);</span><br><span class="line">SystemConfig systemConfig = SystemConfig.getInstance();</span><br><span class="line">mAvailableFeatures = systemConfig.getAvailableFeatures();</span><br><span class="line">Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line"></span><br><span class="line">mProtectedPackages = new ProtectedPackages(mContext);</span><br><span class="line"></span><br><span class="line">synchronized (mInstallLock) &#123;</span><br><span class="line">// writer</span><br><span class="line">synchronized (mPackages) &#123;</span><br><span class="line">    //创建handler线程，主要工作是程序安装和卸载等</span><br><span class="line">    mHandlerThread = new ServiceThread(TAG,</span><br><span class="line">            Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    mHandler = new PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">    mProcessLoggingHandler = new ProcessLoggingHandler();</span><br><span class="line">    //将mHandler加入到Watchdog中，安装应用可能会有大量的I/O操作会比较耗时</span><br><span class="line">    //因此这里的watchdog设置为10min，一般为60s或者30s</span><br><span class="line">    Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</span><br><span class="line">    mInstantAppRegistry = new InstantAppRegistry(this);</span><br><span class="line">    </span><br><span class="line">    //通过systemconfig获取系统中的共享库列表</span><br><span class="line">    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</span><br><span class="line">    final int builtInLibCount = libConfig.size();</span><br><span class="line">    for (int i = 0; i &lt; builtInLibCount; i++) &#123;</span><br><span class="line">        String name = libConfig.keyAt(i);</span><br><span class="line">        String path = libConfig.valueAt(i);</span><br><span class="line">        addSharedLibraryLPw(path, null, null, name, SharedLibraryInfo.VERSION_UNDEFINED,</span><br><span class="line">                SharedLibraryInfo.TYPE_BUILTIN, PLATFORM_PACKAGE_NAME, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    // Builtin libraries cannot encode their dependency where they are</span><br><span class="line">    // defined, so fix that now.</span><br><span class="line">    setupBuiltinSharedLibraryDependenciesLocked();</span><br><span class="line">    </span><br><span class="line">    //打开SELinux的policy文件，/etc/selinux/plat_mac_permissions.xml</span><br><span class="line">    SELinuxMMAC.readInstallPolicy();</span><br><span class="line"></span><br><span class="line">    //将framework-res.apk添加到AssetManager</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;loadFallbacks&quot;);</span><br><span class="line">    FallbackCategoryProvider.loadFallbacks();</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    </span><br><span class="line">    //读取package.xml的内容，解析后插到mSettings的mPackages等变量中</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;read user settings&quot;);</span><br><span class="line">    mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(false));</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    </span><br><span class="line">    //清理代码路径不存在的异常package</span><br><span class="line">    // Clean up orphaned packages for which the code path doesn&apos;t exist</span><br><span class="line">    // and they are an update to a system app - caused by bug/32321269</span><br><span class="line">    final int packageSettingCount = mSettings.mPackages.size();</span><br><span class="line">    for (int i = packageSettingCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">        if (!isExternal(ps) &amp;&amp; (ps.codePath == null || !ps.codePath.exists())</span><br><span class="line">                &amp;&amp; mSettings.getDisabledSystemPkgLPr(ps.name) != null) &#123;</span><br><span class="line">            mSettings.mPackages.removeAt(i);</span><br><span class="line">            mSettings.enableSystemPackageLPw(ps.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //PKMS是否首次启动 </span><br><span class="line">    if (!mOnlyCore &amp;&amp; mFirstBoot) &#123;</span><br><span class="line">        //copy定时，等100s #platform/system/extras/cppreopt/</span><br><span class="line">        requestCopyPreoptedFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    //代替缺省的ResolverActivity #ResolverActivity</span><br><span class="line">    String customResolverActivity = Resources.getSystem().getString(</span><br><span class="line">            R.string.config_customResolverActivity);</span><br><span class="line">    if (TextUtils.isEmpty(customResolverActivity)) &#123;</span><br><span class="line">        customResolverActivity = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mCustomResolverComponentName = ComponentName.unflattenFromString(</span><br><span class="line">                customResolverActivity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-1-new-Settings"><a href="#2-1-1-new-Settings" class="headerlink" title="2.1.1 new Settings"></a>2.1.1 new Settings</h4><p>Setting构造函数主要工作是创建系统文件夹和一些包管理的文件。</p>
<p>packages.xml、packages-backup.xml是一组，用于描述系统所安装的Package信息，其中packages-backup.xml是packages.xml的备份</p>
<p>packages.list用于描述系统中存在的所有非系统自带的apk信息以及UID大于10000的apk。当APK有变化时，PKMS就会更新该文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Settings(File dataDir, PermissionSettings permission, Object lock) &#123;</span><br><span class="line">       mLock = lock;</span><br><span class="line">       mPermissions = permission;</span><br><span class="line">       //创建mRuntimePermissionsPersistence，是Setting内部类</span><br><span class="line">       mRuntimePermissionsPersistence = new RuntimePermissionPersistence(mLock);</span><br><span class="line">       </span><br><span class="line">       //初始化文件路径</span><br><span class="line">       mSystemDir = new File(dataDir, &quot;system&quot;);</span><br><span class="line">       mSystemDir.mkdirs();</span><br><span class="line">       FileUtils.setPermissions(mSystemDir.toString(),</span><br><span class="line">               FileUtils.S_IRWXU|FileUtils.S_IRWXG</span><br><span class="line">               |FileUtils.S_IROTH|FileUtils.S_IXOTH,</span><br><span class="line">               -1, -1);</span><br><span class="line">       mSettingsFilename = new File(mSystemDir, &quot;packages.xml&quot;);</span><br><span class="line">       mBackupSettingsFilename = new File(mSystemDir, &quot;packages-backup.xml&quot;);</span><br><span class="line">       mPackageListFilename = new File(mSystemDir, &quot;packages.list&quot;);</span><br><span class="line">       FileUtils.setPermissions(mPackageListFilename, 0640, SYSTEM_UID, PACKAGE_INFO_GID);</span><br><span class="line"></span><br><span class="line">       final File kernelDir = new File(&quot;/config/sdcardfs&quot;);</span><br><span class="line">       mKernelMappingFilename = kernelDir.exists() ? kernelDir : null;</span><br><span class="line">       </span><br><span class="line">       //下面两个文件路径不推荐使用</span><br><span class="line">       // Deprecated: Needed for migration</span><br><span class="line">       mStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped.xml&quot;);</span><br><span class="line">       mBackupStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped-backup.xml&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-addSharedUserLPw"><a href="#2-1-2-addSharedUserLPw" class="headerlink" title="2.1.2  addSharedUserLPw"></a>2.1.2  addSharedUserLPw</h4><p>该方法将shareUserId name和一个int类型的UID对应起来。UID的定义在Process.java中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SharedUserSetting addSharedUserLPw(String name, int uid, int pkgFlags, int pkgPrivateFlags) &#123;</span><br><span class="line">       //获取SharedUserSetting对象</span><br><span class="line">       SharedUserSetting s = mSharedUsers.get(name);</span><br><span class="line">       if (s != null) &#123;</span><br><span class="line">           if (s.userId == uid) &#123;</span><br><span class="line">               return s;</span><br><span class="line">           &#125;</span><br><span class="line">           PackageManagerService.reportSettingsProblem(Log.ERROR,</span><br><span class="line">                   &quot;Adding duplicate shared user, keeping first: &quot; + name);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       //没有在mSharedUsers找到则新建，并保存起来</span><br><span class="line">       s = new SharedUserSetting(name, pkgFlags, pkgPrivateFlags);</span><br><span class="line">       s.userId = uid;</span><br><span class="line">       if (addUserIdLPw(uid, s, name)) &#123;</span><br><span class="line">           mSharedUsers.put(name, s);</span><br><span class="line">           return s;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>UID、GID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Defines the root UID.</span><br><span class="line">    */</span><br><span class="line">   public static final int ROOT_UID = 0;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Defines the UID/GID under which system code runs.</span><br><span class="line">    */</span><br><span class="line">   public static final int SYSTEM_UID = 1000;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Defines the UID/GID under which the telephony code runs.</span><br><span class="line">    */</span><br><span class="line">   public static final int PHONE_UID = 1001;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Defines the UID/GID for the user shell.</span><br><span class="line">    */</span><br><span class="line">   public static final int SHELL_UID = 2000;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Defines the UID/GID for the log group.</span><br><span class="line">    * @hide</span><br><span class="line">    */</span><br><span class="line">   @UnsupportedAppUsage</span><br><span class="line">   public static final int LOG_UID = 1007;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Defines the UID/GID for the WIFI supplicant process.</span><br><span class="line">    * @hide</span><br><span class="line">    */</span><br><span class="line">   @UnsupportedAppUsage</span><br><span class="line">   public static final int WIFI_UID = 1010;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   //第一个应用package的起始UID为10000</span><br><span class="line">    /**</span><br><span class="line">    * Defines the start of a range of UIDs (and GIDs), going from this</span><br><span class="line">    * number to &#123;@link #LAST_APPLICATION_UID&#125; that are reserved for assigning</span><br><span class="line">    * to applications.</span><br><span class="line">    */</span><br><span class="line">   public static final int FIRST_APPLICATION_UID = 10000;</span><br><span class="line">   //最后一个应用package的UID为19999</span><br><span class="line">   /**</span><br><span class="line">    * Last of application-specific UIDs starting at</span><br><span class="line">    * &#123;@link #FIRST_APPLICATION_UID&#125;.</span><br><span class="line">    */</span><br><span class="line">   public static final int LAST_APPLICATION_UID = 19999;</span><br></pre></td></tr></table></figure>
<p>Setting模块的AndroidManifest.xml里面，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:androidprv=&quot;http://schemas.android.com/apk/prv/res/android&quot;</span><br><span class="line">        package=&quot;com.android.settings&quot;</span><br><span class="line">        coreApp=&quot;true&quot;</span><br><span class="line">        android:sharedUserId=&quot;android.uid.system&quot;&gt;</span><br></pre></td></tr></table></figure>
<p> 在xml里面android:sharedUserId属性设置为”android.uid.system”。sharedUserId这个属性主要有两个作用：</p>
<p>1.两个或者多个声明了同一种sharedUserId的应用可以共享彼此的数据</p>
<p>2.通过声明特定sharedUserId，该应用所在进程将赋予指定的UID。如Setting声明了system的uid，则就可以共享system用户所对应的权限。</p>
<p>除了了xml了声明sharedUserId外，应用编译的时候还必须使用对应的证书进行签名。如Setting需要platform的签名。</p>
<p><strong>PID、UID的区别</strong></p>
<p>PID是进程的身份识别，程序一旦运行，就会给应用分配唯一的PID。一个应用可能包含多个进程，每个进程有唯一的一个PID。进程终止后PID被系统回收，再次打开应用，会分配一个PID（新进程的PID一般比之前的号大）。</p>
<p>调用adb shell ps可以查看系统运行的进程。</p>
<p>UID是用户ID。UID在linux中就是用户ID,表明哪个用户运行了这个程序，主要用于权限的管理。而Android为单用户系统，这时候UID被赋予了新的使命，数据共享，为了实现数据共享，android为每个应用都分配了不同的uid,不像传统的linux，每个用户相同就为之分配相同的UID。</p>
<p>GID时用户组ID。对于普通的应用程序来说GID等于UID，由于每个应用程序的UID和GID不相同，所以不管是native还是java层都能够达到保护私有数据的作用。</p>
<p>adb shell cat /proc/PID号/status</p>
<h4 id="2-1-3-SystemConfig-getInstance"><a href="#2-1-3-SystemConfig-getInstance" class="headerlink" title="2.1.3  SystemConfig.getInstance"></a>2.1.3  SystemConfig.getInstance</h4><p>SystemConfig构造函数中主要通过readPermissions函数将对应目录下的xml文件中定义的各个节点读取出来保存到SystemConfig成员变量中。在终端的/system/etc/permissions目录下可以看到很多xml配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">SystemConfig() &#123;</span><br><span class="line">        // Read configuration from system</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getRootDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_ALL);</span><br><span class="line"></span><br><span class="line">        // Read configuration from the old permissions dir</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getRootDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_ALL);</span><br><span class="line"></span><br><span class="line">        // Vendors are only allowed to customze libs, features and privapp permissions</span><br><span class="line">        int vendorPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_PRIVAPP_PERMISSIONS;</span><br><span class="line">        if (Build.VERSION.FIRST_SDK_INT &lt;= Build.VERSION_CODES.O_MR1) &#123;</span><br><span class="line">            // For backward compatibility</span><br><span class="line">            vendorPermissionFlag |= (ALLOW_PERMISSIONS | ALLOW_APP_CONFIGS);</span><br><span class="line">        &#125;</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getVendorDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), vendorPermissionFlag);</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getVendorDirectory(), &quot;etc&quot;, &quot;permissions&quot;), vendorPermissionFlag);</span><br><span class="line"></span><br><span class="line">        // Allow ODM to customize system configs as much as Vendor, because /odm is another</span><br><span class="line">        // vendor partition other than /vendor.</span><br><span class="line">        int odmPermissionFlag = vendorPermissionFlag;</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getOdmDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), odmPermissionFlag);</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getOdmDirectory(), &quot;etc&quot;, &quot;permissions&quot;), odmPermissionFlag);</span><br><span class="line"></span><br><span class="line">        String skuProperty = SystemProperties.get(SKU_PROPERTY, &quot;&quot;);</span><br><span class="line">        if (!skuProperty.isEmpty()) &#123;</span><br><span class="line">            String skuDir = &quot;sku_&quot; + skuProperty;</span><br><span class="line"></span><br><span class="line">            readPermissions(Environment.buildPath(</span><br><span class="line">                    Environment.getOdmDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;, skuDir), odmPermissionFlag);</span><br><span class="line">            readPermissions(Environment.buildPath(</span><br><span class="line">                    Environment.getOdmDirectory(), &quot;etc&quot;, &quot;permissions&quot;, skuDir),</span><br><span class="line">                    odmPermissionFlag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Allow OEM to customize features and OEM permissions</span><br><span class="line">        int oemPermissionFlag = ALLOW_FEATURES | ALLOW_OEM_PERMISSIONS;</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getOemDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), oemPermissionFlag);</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getOemDirectory(), &quot;etc&quot;, &quot;permissions&quot;), oemPermissionFlag);</span><br><span class="line"></span><br><span class="line">        // Allow Product to customize all system configs</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getProductDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_ALL);</span><br><span class="line">        readPermissions(Environment.buildPath(</span><br><span class="line">                Environment.getProductDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_ALL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如下是终端的/system/etc/permissions目录的xml配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HWSTF:/system/etc/permissions $ ls -all</span><br><span class="line">total 300</span><br><span class="line">drwxr-xr-x  2 root root  4096 2018-08-08 00:01:00.000000000 +0800 .</span><br><span class="line">drwxr-xr-x 26 root root  4096 2018-08-08 00:01:00.000000000 +0800 ..</span><br><span class="line">-rw-r--r--  1 root root  1515 2018-08-08 00:01:00.000000000 +0800 HiViewTunnel-core.xml</span><br><span class="line">-rw-r--r--  1 root root   830 2018-08-08 00:01:00.000000000 +0800 android.hardware.bluetooth_le.xml</span><br><span class="line">-rw-r--r--  1 root root   927 2018-08-08 00:01:00.000000000 +0800 android.hardware.faketouch.xml</span><br><span class="line">-rw-r--r--  1 root root   834 2018-08-08 00:01:00.000000000 +0800 android.hardware.fingerprint.xml</span><br><span class="line">-rw-r--r--  1 root root   942 2018-08-08 00:01:00.000000000 +0800 android.hardware.location.gps.xml</span><br><span class="line">-rw-r--r--  1 root root   949 2018-08-08 00:01:00.000000000 +0800 android.hardware.location.xml</span><br><span class="line">-rw-r--r--  1 root root   888 2018-08-08 00:01:00.000000000 +0800 android.hardware.nfc.hce.xml</span><br><span class="line">-rw-r--r--  1 root root   891 2018-08-08 00:01:00.000000000 +0800 android.hardware.nfc.hcef.xml</span><br><span class="line">-rw-r--r--  1 root root   921 2018-08-08 00:01:00.000000000 +0800 android.hardware.nfc.xml</span><br><span class="line">-rw-r--r--  1 root root   870 2018-08-08 00:01:00.000000000 +0800 android.hardware.opengles.aep.xml</span><br><span class="line">-rw-r--r--  1 root root   824 2018-08-08 00:01:00.000000000 +0800 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这些配置文件都是编译时从framework指定位置拷贝过来的（framework/native/data/etc）,下面是platform.xml里面的部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;permissions&gt;</span><br><span class="line"></span><br><span class="line">    &lt;permission name=&quot;android.permission.BLUETOOTH_ADMIN&quot; &gt;</span><br><span class="line">        &lt;group gid=&quot;net_bt_admin&quot; /&gt;</span><br><span class="line">    &lt;/permission&gt;</span><br><span class="line">    &lt;permission name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">    &lt;assign-permission name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; uid=&quot;media&quot; /&gt;</span><br><span class="line">    &lt;library name=&quot;org.apache.http.legacy&quot;</span><br><span class="line">            file=&quot;/system/framework/org.apache.http.legacy.boot.jar&quot; /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=&quot;com.android.providers.downloads&quot; /&gt;</span><br><span class="line">    &lt;!-- These are the packages that shouldn&apos;t run as system user --&gt;</span><br><span class="line">    &lt;system-user-blacklisted-app package=&quot;com.android.wallpaper.livepicker&quot; /&gt;</span><br><span class="line">    &lt;allow-in-data-usage-save package=&quot;com.dti.att&quot; /&gt;</span><br><span class="line">    &lt;feature name=&quot;android.hardware.vulkan.level&quot; version=&quot;0&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line"> &lt;/permissions&gt;</span><br></pre></td></tr></table></figure>
<p>readPermissions方法内部调用readPermissionsFromXml方法来解析xml里面的各个节点，其中xml涉及到的标签内容有permission、assign-permission、library、feature等，这些标签的内容解析出来保存到SystemConfig的对应数据结构的全局变量中，以便管理查询。</p>
<p>feature用来描述设备是否支持硬件特性；  </p>
<p>library用于指定系统库，当应用程序运行时，系统会为进程加载一些必须的库；</p>
<p> assign-permission将system中描述的permission与uid关联；</p>
<p> permission将permission和gid关联。</p>
<h4 id="2-1-4-readLPw"><a href="#2-1-4-readLPw" class="headerlink" title="2.1.4 readLPw"></a>2.1.4 readLPw</h4><p>读取在Settings初始化时的文件，并保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line">boolean readLPw(@NonNull List&lt;UserInfo&gt; users) &#123;</span><br><span class="line">      FileInputStream str = null;</span><br><span class="line">      //备份的文件是否存在</span><br><span class="line">      if (mBackupSettingsFilename.exists()) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              //data/system/packages_backup.xml</span><br><span class="line">              str = new FileInputStream(mBackupSettingsFilename);</span><br><span class="line">              mReadMessages.append(&quot;Reading from backup settings file/n&quot;);</span><br><span class="line">              PackageManagerService.reportSettingsProblem(Log.INFO,</span><br><span class="line">                      &quot;Need to read from backup settings file&quot;);</span><br><span class="line">              if (mSettingsFilename.exists()) &#123;</span><br><span class="line">                  // If both the backup and settings file exist, we</span><br><span class="line">                  // ignore the settings since it might have been</span><br><span class="line">                  // corrupted.</span><br><span class="line">                  Slog.w(PackageManagerService.TAG, &quot;Cleaning up settings file &quot;</span><br><span class="line">                          + mSettingsFilename);</span><br><span class="line">                  mSettingsFilename.delete();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (java.io.IOException e) &#123;</span><br><span class="line">              // We&apos;ll try for the normal settings file.</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mPendingPackages.clear();</span><br><span class="line">      mPastSignatures.clear();</span><br><span class="line">      mKeySetRefs.clear();</span><br><span class="line">      mInstallerPackages.clear();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          if (str == null) &#123;</span><br><span class="line">              if (!mSettingsFilename.exists()) &#123;</span><br><span class="line">                  mReadMessages.append(&quot;No settings file found/n&quot;);</span><br><span class="line">                  PackageManagerService.reportSettingsProblem(Log.INFO,</span><br><span class="line">                          &quot;No settings file; creating initial state&quot;);</span><br><span class="line">                  // It&apos;s enough to just touch version details to create them</span><br><span class="line">                  // with default values</span><br><span class="line">                  findOrCreateVersion(StorageManager.UUID_PRIVATE_INTERNAL).forceCurrent();</span><br><span class="line">                  findOrCreateVersion(StorageManager.UUID_PRIMARY_PHYSICAL).forceCurrent();</span><br><span class="line">                  return false;</span><br><span class="line">              &#125;</span><br><span class="line">              // data/system/packages.xml</span><br><span class="line">              str = new FileInputStream(mSettingsFilename);</span><br><span class="line">          &#125;</span><br><span class="line">          XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">          parser.setInput(str, StandardCharsets.UTF_8.name());</span><br><span class="line"></span><br><span class="line">          int type;</span><br><span class="line">          while ((type = parser.next()) != XmlPullParser.START_TAG</span><br><span class="line">                  &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">              ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">              mReadMessages.append(&quot;No start tag found in settings file/n&quot;);</span><br><span class="line">              PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                      &quot;No start tag found in package manager settings&quot;);</span><br><span class="line">              Slog.wtf(PackageManagerService.TAG,</span><br><span class="line">                      &quot;No start tag found in package manager settings&quot;);</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          int outerDepth = parser.getDepth();</span><br><span class="line">          //解析xml文件</span><br><span class="line">          while ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                  &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">              if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              String tagName = parser.getName();</span><br><span class="line">              if (tagName.equals(&quot;package&quot;)) &#123;</span><br><span class="line">                  readPackageLPw(parser);</span><br><span class="line">              &#125; else if (tagName.equals(&quot;permissions&quot;)) &#123;</span><br><span class="line">                  mPermissions.readPermissions(parser);</span><br><span class="line">              &#125; else if (tagName.equals(&quot;permission-trees&quot;)) &#123;</span><br><span class="line">                  mPermissions.readPermissionTrees(parser);</span><br><span class="line">              &#125; else if (tagName.equals(&quot;shared-user&quot;)) &#123;</span><br><span class="line">                  readSharedUserLPw(parser);</span><br><span class="line">              &#125; else if (tagName.equals(&quot;preferred-packages&quot;)) &#123;</span><br><span class="line">                  // no longer used.</span><br><span class="line">              &#125; else if (tagName.equals(&quot;preferred-activities&quot;)) &#123;</span><br><span class="line">                  // Upgrading from old single-user implementation;</span><br><span class="line">                  // these are the preferred activities for user 0.</span><br><span class="line">                  readPreferredActivitiesLPw(parser, 0);</span><br><span class="line">              &#125; else if (tagName.equals(TAG_PERSISTENT_PREFERRED_ACTIVITIES)) &#123;</span><br><span class="line">                  // TODO: check whether this is okay! as it is very</span><br><span class="line">                  // similar to how preferred-activities are treated</span><br><span class="line">                  readPersistentPreferredActivitiesLPw(parser, 0);</span><br><span class="line">              &#125; else if (tagName.equals(TAG_CROSS_PROFILE_INTENT_FILTERS)) &#123;</span><br><span class="line">                  // TODO: check whether this is okay! as it is very</span><br><span class="line">                  // similar to how preferred-activities are treated</span><br><span class="line">                  readCrossProfileIntentFiltersLPw(parser, 0);</span><br><span class="line">              &#125; else if (tagName.equals(TAG_DEFAULT_BROWSER)) &#123;</span><br><span class="line">                  readDefaultAppsLPw(parser, 0);</span><br><span class="line">              &#125; else if (tagName.equals(&quot;updated-package&quot;)) &#123;</span><br><span class="line">                  readDisabledSysPackageLPw(parser);</span><br><span class="line">              &#125; else if (tagName.equals(&quot;cleaning-package&quot;)) &#123;</span><br><span class="line">                  String name = parser.getAttributeValue(null, ATTR_NAME);</span><br><span class="line">                  String userStr = parser.getAttributeValue(null, ATTR_USER);</span><br><span class="line">                  String codeStr = parser.getAttributeValue(null, ATTR_CODE);</span><br><span class="line">                  if (name != null) &#123;</span><br><span class="line">                      int userId = UserHandle.USER_SYSTEM;</span><br><span class="line">                      boolean andCode = true;</span><br><span class="line">                      try &#123;</span><br><span class="line">                          if (userStr != null) &#123;</span><br><span class="line">                              userId = Integer.parseInt(userStr);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                      &#125;</span><br><span class="line">                      if (codeStr != null) &#123;</span><br><span class="line">                          andCode = Boolean.parseBoolean(codeStr);</span><br><span class="line">                      &#125;</span><br><span class="line">                      addPackageToCleanLPw(new PackageCleanItem(userId, name, andCode));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else if (tagName.equals(&quot;renamed-package&quot;)) &#123;</span><br><span class="line">                  String nname = parser.getAttributeValue(null, &quot;new&quot;);</span><br><span class="line">                  String oname = parser.getAttributeValue(null, &quot;old&quot;);</span><br><span class="line">                  if (nname != null &amp;&amp; oname != null) &#123;</span><br><span class="line">                      mRenamedPackages.put(nname, oname);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else if (tagName.equals(&quot;restored-ivi&quot;)) &#123;</span><br><span class="line">                  readRestoredIntentFilterVerifications(parser);</span><br><span class="line">              &#125; else if (tagName.equals(&quot;last-platform-version&quot;)) &#123;</span><br><span class="line">                  // Upgrade from older XML schema</span><br><span class="line">                  final VersionInfo internal = findOrCreateVersion(</span><br><span class="line">                          StorageManager.UUID_PRIVATE_INTERNAL);</span><br><span class="line">                  final VersionInfo external = findOrCreateVersion(</span><br><span class="line">                          StorageManager.UUID_PRIMARY_PHYSICAL);</span><br><span class="line"></span><br><span class="line">                  internal.sdkVersion = XmlUtils.readIntAttribute(parser, &quot;internal&quot;, 0);</span><br><span class="line">                  external.sdkVersion = XmlUtils.readIntAttribute(parser, &quot;external&quot;, 0);</span><br><span class="line">                  internal.fingerprint = external.fingerprint =</span><br><span class="line">                          XmlUtils.readStringAttribute(parser, &quot;fingerprint&quot;);</span><br><span class="line"></span><br><span class="line">              &#125; else if (tagName.equals(&quot;database-version&quot;)) &#123;</span><br><span class="line">                  // Upgrade from older XML schema</span><br><span class="line">                  final VersionInfo internal = findOrCreateVersion(</span><br><span class="line">                          StorageManager.UUID_PRIVATE_INTERNAL);</span><br><span class="line">                  final VersionInfo external = findOrCreateVersion(</span><br><span class="line">                          StorageManager.UUID_PRIMARY_PHYSICAL);</span><br><span class="line"></span><br><span class="line">                  internal.databaseVersion = XmlUtils.readIntAttribute(parser, &quot;internal&quot;, 0);</span><br><span class="line">                  external.databaseVersion = XmlUtils.readIntAttribute(parser, &quot;external&quot;, 0);</span><br><span class="line"></span><br><span class="line">              &#125; else if (tagName.equals(&quot;verifier&quot;)) &#123;</span><br><span class="line">                  final String deviceIdentity = parser.getAttributeValue(null, &quot;device&quot;);</span><br><span class="line">                  try &#123;</span><br><span class="line">                      mVerifierDeviceIdentity = VerifierDeviceIdentity.parse(deviceIdentity);</span><br><span class="line">                  &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">                      Slog.w(PackageManagerService.TAG, &quot;Discard invalid verifier device id: &quot;</span><br><span class="line">                              + e.getMessage());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) &#123;</span><br><span class="line">                  final String enforcement = parser.getAttributeValue(null, ATTR_ENFORCEMENT);</span><br><span class="line">                  mReadExternalStorageEnforced =</span><br><span class="line">                          &quot;1&quot;.equals(enforcement) ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">              &#125; else if (tagName.equals(&quot;keyset-settings&quot;)) &#123;</span><br><span class="line">                  mKeySetManagerService.readKeySetsLPw(parser, mKeySetRefs);</span><br><span class="line">              &#125; else if (TAG_VERSION.equals(tagName)) &#123;</span><br><span class="line">                  final String volumeUuid = XmlUtils.readStringAttribute(parser,</span><br><span class="line">                          ATTR_VOLUME_UUID);</span><br><span class="line">                  final VersionInfo ver = findOrCreateVersion(volumeUuid);</span><br><span class="line">                  ver.sdkVersion = XmlUtils.readIntAttribute(parser, ATTR_SDK_VERSION);</span><br><span class="line">                  ver.databaseVersion = XmlUtils.readIntAttribute(parser, ATTR_DATABASE_VERSION);</span><br><span class="line">                  ver.fingerprint = XmlUtils.readStringAttribute(parser, ATTR_FINGERPRINT);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  Slog.w(PackageManagerService.TAG, &quot;Unknown element under &lt;packages&gt;: &quot;</span><br><span class="line">                          + parser.getName());</span><br><span class="line">                  XmlUtils.skipCurrentTag(parser);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          str.close();</span><br><span class="line"></span><br><span class="line">      &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">          mReadMessages.append(&quot;Error reading: &quot; + e.toString());</span><br><span class="line">          PackageManagerService.reportSettingsProblem(Log.ERROR, &quot;Error reading settings: &quot; + e);</span><br><span class="line">          Slog.wtf(PackageManagerService.TAG, &quot;Error reading package manager settings&quot;, e);</span><br><span class="line"></span><br><span class="line">      &#125; catch (java.io.IOException e) &#123;</span><br><span class="line">          mReadMessages.append(&quot;Error reading: &quot; + e.toString());</span><br><span class="line">          PackageManagerService.reportSettingsProblem(Log.ERROR, &quot;Error reading settings: &quot; + e);</span><br><span class="line">          Slog.wtf(PackageManagerService.TAG, &quot;Error reading package manager settings&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">      //这里解析xml结束</span><br><span class="line">      </span><br><span class="line">      //如果build的版本不匹配，删除用户运行时权限</span><br><span class="line">      // If the build is setup to drop runtime permissions</span><br><span class="line">      // on update drop the files before loading them.</span><br><span class="line">      if (PackageManagerService.CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE) &#123;</span><br><span class="line">          final VersionInfo internal = getInternalVersion();</span><br><span class="line">          if (!Build.FINGERPRINT.equals(internal.fingerprint)) &#123;</span><br><span class="line">              for (UserInfo user : users) &#123;</span><br><span class="line">                  mRuntimePermissionsPersistence.deleteUserRuntimePermissionsFile(user.id);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      //没有处理的具有sharedUserID的package需要添加</span><br><span class="line">      final int N = mPendingPackages.size();</span><br><span class="line"></span><br><span class="line">      for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">          final PackageSetting p = mPendingPackages.get(i);</span><br><span class="line">          final int sharedUserId = p.getSharedUserId();</span><br><span class="line">          final Object idObj = getUserIdLPr(sharedUserId);</span><br><span class="line">          if (idObj instanceof SharedUserSetting) &#123;</span><br><span class="line">              final SharedUserSetting sharedUser = (SharedUserSetting) idObj;</span><br><span class="line">              p.sharedUser = sharedUser;</span><br><span class="line">              p.appId = sharedUser.userId;</span><br><span class="line">              addPackageSettingLPw(p, sharedUser);</span><br><span class="line">          &#125; else if (idObj != null) &#123;</span><br><span class="line">              String msg = &quot;Bad package setting: package &quot; + p.name + &quot; has shared uid &quot;</span><br><span class="line">                      + sharedUserId + &quot; that is not a shared uid/n&quot;;</span><br><span class="line">              mReadMessages.append(msg);</span><br><span class="line">              PackageManagerService.reportSettingsProblem(Log.ERROR, msg);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              String msg = &quot;Bad package setting: package &quot; + p.name + &quot; has shared uid &quot;</span><br><span class="line">                      + sharedUserId + &quot; that is not defined/n&quot;;</span><br><span class="line">              mReadMessages.append(msg);</span><br><span class="line">              PackageManagerService.reportSettingsProblem(Log.ERROR, msg);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      mPendingPackages.clear();</span><br><span class="line">      //备份的强制停止的包</span><br><span class="line">      if (mBackupStoppedPackagesFilename.exists()</span><br><span class="line">              || mStoppedPackagesFilename.exists()) &#123;</span><br><span class="line">          // Read old file</span><br><span class="line">          readStoppedLPw();</span><br><span class="line">          mBackupStoppedPackagesFilename.delete();</span><br><span class="line">          mStoppedPackagesFilename.delete();</span><br><span class="line">          // Migrate to new file format</span><br><span class="line">          writePackageRestrictionsLPr(UserHandle.USER_SYSTEM);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          for (UserInfo user : users) &#123;</span><br><span class="line">              readPackageRestrictionsLPr(user.id);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (UserInfo user : users) &#123;</span><br><span class="line">          mRuntimePermissionsPersistence.readStateForUserSyncLPr(user.id);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * Make sure all the updated system packages have their shared users</span><br><span class="line">       * associated with them.</span><br><span class="line">       */</span><br><span class="line">      final Iterator&lt;PackageSetting&gt; disabledIt = mDisabledSysPackages.values().iterator();</span><br><span class="line">      while (disabledIt.hasNext()) &#123;</span><br><span class="line">          final PackageSetting disabledPs = disabledIt.next();</span><br><span class="line">          final Object id = getUserIdLPr(disabledPs.appId);</span><br><span class="line">          if (id != null &amp;&amp; id instanceof SharedUserSetting) &#123;</span><br><span class="line">              disabledPs.sharedUser = (SharedUserSetting) id;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mReadMessages.append(&quot;Read completed successfully: &quot; + mPackages.size() + &quot; packages, &quot;</span><br><span class="line">              + mSharedUsers.size() + &quot; shared uids/n&quot;);</span><br><span class="line"></span><br><span class="line">      writeKernelMappingLPr();</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-PMS-SYSTEM-SCAN-START"><a href="#2-2-PMS-SYSTEM-SCAN-START" class="headerlink" title="2.2  PMS_SYSTEM_SCAN_START"></a>2.2  PMS_SYSTEM_SCAN_START</h3><p>主要的工作是扫描系统apk。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">扫描目录</span><br><span class="line">/vendor/overlay </span><br><span class="line">/product/overlay</span><br><span class="line">/system/frameworks</span><br><span class="line">/system/priv-app</span><br><span class="line">/system/app</span><br><span class="line">/vendor/priv-app</span><br><span class="line">/vendor/app</span><br><span class="line">/odm/priv-app</span><br><span class="line">/odm/app</span><br><span class="line">/oem/app</span><br><span class="line">/oem/priv-app</span><br><span class="line">/product/app</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line">long startTime = SystemClock.uptimeMillis();</span><br><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,</span><br><span class="line">        startTime);</span><br><span class="line"></span><br><span class="line">final String bootClassPath = System.getenv(&quot;BOOTCLASSPATH&quot;);</span><br><span class="line">final String systemServerClassPath = System.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line"></span><br><span class="line">if (bootClassPath == null) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;No BOOTCLASSPATH found!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (systemServerClassPath == null) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;No SYSTEMSERVERCLASSPATH found!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//创建framework目录为/system/framework</span><br><span class="line">File frameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;);</span><br><span class="line"></span><br><span class="line">//是否升级</span><br><span class="line">final VersionInfo ver = mSettings.getInternalVersion();</span><br><span class="line">mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</span><br><span class="line">if (mIsUpgrade) &#123;</span><br><span class="line">    logCriticalInfo(Log.INFO,</span><br><span class="line">            &quot;Upgrading from &quot; + ver.fingerprint + &quot; to &quot; + Build.FINGERPRINT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//各个版本版本</span><br><span class="line">// when upgrading from pre-M, promote system app permissions from install to runtime</span><br><span class="line">mPromoteSystemApps =</span><br><span class="line">        mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</span><br><span class="line"></span><br><span class="line">// When upgrading from pre-N, we need to handle package extraction like first boot,</span><br><span class="line">// as there is no profiling data available.</span><br><span class="line">mIsPreNUpgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N;</span><br><span class="line"></span><br><span class="line">mIsPreNMR1Upgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N_MR1;</span><br><span class="line"></span><br><span class="line">//是否需要提升权限</span><br><span class="line">// save off the names of pre-existing system packages prior to scanning; we don&apos;t</span><br><span class="line">// want to automatically grant runtime permissions for new system apps</span><br><span class="line">if (mPromoteSystemApps) &#123;</span><br><span class="line">    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</span><br><span class="line">    while (pkgSettingIter.hasNext()) &#123;</span><br><span class="line">        PackageSetting ps = pkgSettingIter.next();</span><br><span class="line">        if (isSystemApp(ps)) &#123;</span><br><span class="line">            mExistingSystemPackages.add(ps.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//扫描目录解析包信息缓存路径</span><br><span class="line">mCacheDir = preparePackageParserCache(mIsUpgrade);</span><br><span class="line">//定义扫描参数</span><br><span class="line">// Set flag to monitor and not change apk file paths when</span><br><span class="line">// scanning install directories.</span><br><span class="line">int scanFlags = SCAN_BOOTING | SCAN_INITIAL;</span><br><span class="line"></span><br><span class="line">if (mIsUpgrade || mFirstBoot) &#123;</span><br><span class="line">    scanFlags = scanFlags | SCAN_FIRST_BOOT_OR_UPGRADE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扫描 /vendor/overlay/ 、 product/overlay目录</span><br><span class="line">// Collect vendor/product overlay packages. (Do this before scanning any apps.)</span><br><span class="line">// For security and version matching reason, only consider</span><br><span class="line">// overlay packages if they reside in the right directory.</span><br><span class="line">scanDirTracedLI(new File(VENDOR_OVERLAY_DIR),</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_VENDOR,</span><br><span class="line">        0);</span><br><span class="line">scanDirTracedLI(new File(PRODUCT_OVERLAY_DIR),</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_PRODUCT,</span><br><span class="line">        0);</span><br><span class="line"></span><br><span class="line">mParallelPackageParserCallback.findStaticOverlayPackages();</span><br><span class="line"></span><br><span class="line">//扫描 /system/frameworks目录</span><br><span class="line">// Find base frameworks (resource packages without code).</span><br><span class="line">scanDirTracedLI(frameworkDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_NO_DEX</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_PRIVILEGED,</span><br><span class="line">        0);</span><br><span class="line">        </span><br><span class="line">//扫描 /system/priv-app目录</span><br><span class="line">// Collect privileged system packages.</span><br><span class="line">final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;);</span><br><span class="line">scanDirTracedLI(privilegedAppDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_PRIVILEGED,</span><br><span class="line">        0);</span><br><span class="line">        </span><br><span class="line">//扫描 /system/app目录</span><br><span class="line">// Collect ordinary system packages.</span><br><span class="line">final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;);</span><br><span class="line">scanDirTracedLI(systemAppDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM,</span><br><span class="line">        0);</span><br><span class="line"></span><br><span class="line">//扫描 /vendor/priv-app目录</span><br><span class="line">// Collect privileged vendor packages.</span><br><span class="line">File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), &quot;priv-app&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    privilegedVendorAppDir = privilegedVendorAppDir.getCanonicalFile();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // failed to look up canonical path, continue with original one</span><br><span class="line">&#125;</span><br><span class="line">scanDirTracedLI(privilegedVendorAppDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_VENDOR</span><br><span class="line">        | SCAN_AS_PRIVILEGED,</span><br><span class="line">        0);</span><br><span class="line"></span><br><span class="line">//扫描 /vendor/app目录</span><br><span class="line">// Collect ordinary vendor packages.</span><br><span class="line">File vendorAppDir = new File(Environment.getVendorDirectory(), &quot;app&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    vendorAppDir = vendorAppDir.getCanonicalFile();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // failed to look up canonical path, continue with original one</span><br><span class="line">&#125;</span><br><span class="line">scanDirTracedLI(vendorAppDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_VENDOR,</span><br><span class="line">        0);</span><br><span class="line"></span><br><span class="line">//扫描 /odm/priv-app目录</span><br><span class="line">// Collect privileged odm packages. /odm is another vendor partition</span><br><span class="line">// other than /vendor.</span><br><span class="line">File privilegedOdmAppDir = new File(Environment.getOdmDirectory(),</span><br><span class="line">            &quot;priv-app&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    privilegedOdmAppDir = privilegedOdmAppDir.getCanonicalFile();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // failed to look up canonical path, continue with original one</span><br><span class="line">&#125;</span><br><span class="line">scanDirTracedLI(privilegedOdmAppDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_VENDOR</span><br><span class="line">        | SCAN_AS_PRIVILEGED,</span><br><span class="line">        0);</span><br><span class="line"></span><br><span class="line">//扫描 /odm/app目录</span><br><span class="line">// Collect ordinary odm packages. /odm is another vendor partition</span><br><span class="line">// other than /vendor.</span><br><span class="line">File odmAppDir = new File(Environment.getOdmDirectory(), &quot;app&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    odmAppDir = odmAppDir.getCanonicalFile();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // failed to look up canonical path, continue with original one</span><br><span class="line">&#125;</span><br><span class="line">scanDirTracedLI(odmAppDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_VENDOR,</span><br><span class="line">        0);</span><br><span class="line"></span><br><span class="line">//扫描 /oem/app目录</span><br><span class="line">// Collect all OEM packages.</span><br><span class="line">final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;);</span><br><span class="line">scanDirTracedLI(oemAppDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_OEM,</span><br><span class="line">        0);</span><br><span class="line"></span><br><span class="line">//扫描 /oem/priv-app目录</span><br><span class="line">// Collected privileged product packages.</span><br><span class="line">File privilegedProductAppDir = new File(Environment.getProductDirectory(), &quot;priv-app&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    privilegedProductAppDir = privilegedProductAppDir.getCanonicalFile();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // failed to look up canonical path, continue with original one</span><br><span class="line">&#125;</span><br><span class="line">scanDirTracedLI(privilegedProductAppDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_PRODUCT</span><br><span class="line">        | SCAN_AS_PRIVILEGED,</span><br><span class="line">        0);</span><br><span class="line"></span><br><span class="line">//扫描 /product/app目录</span><br><span class="line">// Collect ordinary product packages.</span><br><span class="line">File productAppDir = new File(Environment.getProductDirectory(), &quot;app&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    productAppDir = productAppDir.getCanonicalFile();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // failed to look up canonical path, continue with original one</span><br><span class="line">&#125;</span><br><span class="line">scanDirTracedLI(productAppDir,</span><br><span class="line">        mDefParseFlags</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">        scanFlags</span><br><span class="line">        | SCAN_AS_SYSTEM</span><br><span class="line">        | SCAN_AS_PRODUCT,</span><br><span class="line">        0);</span><br><span class="line"></span><br><span class="line">//删除不存在的系统包</span><br><span class="line">// Prune any system packages that no longer exist.</span><br><span class="line">final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;&gt;();</span><br><span class="line">// Stub packages must either be replaced with full versions in the /data</span><br><span class="line">// partition or be disabled.</span><br><span class="line">final List&lt;String&gt; stubSystemApps = new ArrayList&lt;&gt;();</span><br><span class="line">if (!mOnlyCore) &#123;</span><br><span class="line">    // do this first before mucking with mPackages for the &quot;expecting better&quot; case</span><br><span class="line">    final Iterator&lt;PackageParser.Package&gt; pkgIterator = mPackages.values().iterator();</span><br><span class="line">    while (pkgIterator.hasNext()) &#123;</span><br><span class="line">        final PackageParser.Package pkg = pkgIterator.next();</span><br><span class="line">        if (pkg.isStub) &#123;</span><br><span class="line">            stubSystemApps.add(pkg.packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</span><br><span class="line">    while (psit.hasNext()) &#123;</span><br><span class="line">        PackageSetting ps = psit.next();</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * If this is not a system app, it can&apos;t be a</span><br><span class="line">         * disable system app.</span><br><span class="line">         */</span><br><span class="line">        if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * If the package is scanned, it&apos;s not erased.</span><br><span class="line">         */</span><br><span class="line">        final PackageParser.Package scannedPkg = mPackages.get(ps.name);</span><br><span class="line">        if (scannedPkg != null) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * If the system app is both scanned and in the</span><br><span class="line">             * disabled packages list, then it must have been</span><br><span class="line">             * added via OTA. Remove it from the currently</span><br><span class="line">             * scanned package so the previously user-installed</span><br><span class="line">             * application can be scanned.</span><br><span class="line">             */</span><br><span class="line">            if (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                logCriticalInfo(Log.WARN,</span><br><span class="line">                        &quot;Expecting better updated system app for &quot; + ps.name</span><br><span class="line">                        + &quot;; removing system app.  Last known&quot;</span><br><span class="line">                        + &quot; codePath=&quot; + ps.codePathString</span><br><span class="line">                        + &quot;, versionCode=&quot; + ps.versionCode</span><br><span class="line">                        + &quot;; scanned versionCode=&quot; + scannedPkg.getLongVersionCode());</span><br><span class="line">                removePackageLI(scannedPkg, true);</span><br><span class="line">                mExpectingBetter.put(ps.name, ps.codePath);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">            psit.remove();</span><br><span class="line">            logCriticalInfo(Log.WARN, &quot;System package &quot; + ps.name</span><br><span class="line">                    + &quot; no longer exists; it&apos;s data will be wiped&quot;);</span><br><span class="line">            // Actual deletion of code and data will be handled by later</span><br><span class="line">            // reconciliation step</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // we still have a disabled system package, but, it still might have</span><br><span class="line">            // been removed. check the code path still exists and check there&apos;s</span><br><span class="line">            // still a package. the latter can happen if an OTA keeps the same</span><br><span class="line">            // code path, but, changes the package name.</span><br><span class="line">            final PackageSetting disabledPs =</span><br><span class="line">                    mSettings.getDisabledSystemPkgLPr(ps.name);</span><br><span class="line">            if (disabledPs.codePath == null || !disabledPs.codePath.exists()</span><br><span class="line">                    || disabledPs.pkg == null) &#123;</span><br><span class="line">                possiblyDeletedUpdatedSystemApps.add(ps.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//删除临时文件</span><br><span class="line">//delete tmp files</span><br><span class="line">deleteTempPackageFiles();</span><br><span class="line"></span><br><span class="line">final int cachedSystemApps = PackageParser.sCachedPackageReadCount.get();</span><br><span class="line"></span><br><span class="line">//删除不相关包中的所有共享userIDs</span><br><span class="line">// Remove any shared userIDs that have no associated packages</span><br><span class="line">mSettings.pruneSharedUsersLPw();</span><br><span class="line">final long systemScanTime = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">final int systemPackagesCount = mPackages.size();</span><br><span class="line">Slog.i(TAG, &quot;Finished scanning system apps. Time: &quot; + systemScanTime</span><br><span class="line">        + &quot; ms, packageCount: &quot; + systemPackagesCount</span><br><span class="line">        + &quot; , timePerPackage: &quot;</span><br><span class="line">        + (systemPackagesCount == 0 ? 0 : systemScanTime / systemPackagesCount)</span><br><span class="line">        + &quot; , cached: &quot; + cachedSystemApps);</span><br><span class="line">if (mIsUpgrade &amp;&amp; systemPackagesCount &gt; 0) &#123;</span><br><span class="line">    MetricsLogger.histogram(null, &quot;ota_package_manager_system_app_avg_scan_time&quot;,</span><br><span class="line">            ((int) systemScanTime) / systemPackagesCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-1-PackageParser-Package"><a href="#2-2-1-PackageParser-Package" class="headerlink" title="2.2.1 PackageParser.Package"></a>2.2.1 PackageParser.Package</h4><p>Package数据，表示从磁盘上的apk文件解析出来的package，一个包由一个基础的apk和多个拆分的apk构成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line">     * Representation of a full package parsed from APK files on disk. A package</span><br><span class="line">     * consists of a single base APK, and zero or more split APKs.</span><br><span class="line">     */</span><br><span class="line">    public final static class Package implements Parcelable &#123;</span><br><span class="line">        //表示包名</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public String packageName;</span><br><span class="line">        //表示manifest中声明的包名</span><br><span class="line">        // The package name declared in the manifest as the package can be</span><br><span class="line">        // renamed, for example static shared libs use synthetic package names.</span><br><span class="line">        public String manifestPackageName;</span><br><span class="line">        //表示拆包的包名</span><br><span class="line">        /** Names of any split APKs, ordered by parsed splitName */</span><br><span class="line">        public String[] splitNames;</span><br><span class="line"></span><br><span class="line">        // TODO: work towards making these paths invariant</span><br><span class="line">        //对应一个volume的uid</span><br><span class="line">        public String volumeUuid;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Path where this package was found on disk. For monolithic packages</span><br><span class="line">         * this is path to single base APK file; for cluster packages this is</span><br><span class="line">         * path to the cluster directory.</span><br><span class="line">         */</span><br><span class="line">         //表示代码路径</span><br><span class="line">        public String codePath;</span><br><span class="line"></span><br><span class="line">        /** Path of base APK */</span><br><span class="line">        //表示base APK路径</span><br><span class="line">        public String baseCodePath;</span><br><span class="line">        //表示拆分APK路径</span><br><span class="line">        /** Paths of any split APKs, ordered by parsed splitName */ </span><br><span class="line">        public String[] splitCodePaths;</span><br><span class="line">        //表示base APK调整版本号</span><br><span class="line">        /** Revision code of base APK */</span><br><span class="line">        public int baseRevisionCode;</span><br><span class="line">         //表示拆分APK调整版本号</span><br><span class="line">        /** Revision codes of any split APKs, ordered by parsed splitName */</span><br><span class="line">        public int[] splitRevisionCodes;</span><br><span class="line">        </span><br><span class="line">         //表示拆分APK的标注数组</span><br><span class="line">        /** Flags of any split APKs; ordered by parsed splitName */</span><br><span class="line">        public int[] splitFlags;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Private flags of any split APKs; ordered by parsed splitName.</span><br><span class="line">         *</span><br><span class="line">         * &#123;@hide&#125;</span><br><span class="line">         */</span><br><span class="line">         //表示拆分APK的私有标注数组</span><br><span class="line">        public int[] splitPrivateFlags;</span><br><span class="line">        //表示是否支持硬件加速</span><br><span class="line">        public boolean baseHardwareAccelerated;</span><br><span class="line"></span><br><span class="line">        //对应application对象，对应AndroidManifest里面的&lt;Application&gt;</span><br><span class="line">        // For now we only support one application per package.</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public ApplicationInfo applicationInfo = new ApplicationInfo();</span><br><span class="line">        </span><br><span class="line">        //apk安装包中，对应AndroidManifest里面的&lt;Permission&gt;</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public final ArrayList&lt;Permission&gt; permissions = new ArrayList&lt;Permission&gt;(0);</span><br><span class="line">        //apk安装包中，对应AndroidManifest里面的&lt;PermissionGroup&gt;</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public final ArrayList&lt;PermissionGroup&gt; permissionGroups = new ArrayList&lt;PermissionGroup&gt;(0);</span><br><span class="line">        //apk安装包中，对应AndroidManifest里面的&lt;Activity&gt;</span><br><span class="line">        //不是通常说的Activity，而是PackageParse的内部类Activity</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public final ArrayList&lt;Activity&gt; activities = new ArrayList&lt;Activity&gt;(0);</span><br><span class="line">        </span><br><span class="line">        //apk安装包中，对应AndroidManifest里面的&lt;Receiver&gt;</span><br><span class="line">        //不是通常说的Activity，而是PackageParse的内部类Activity</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public final ArrayList&lt;Activity&gt; receivers = new ArrayList&lt;Activity&gt;(0);</span><br><span class="line">        </span><br><span class="line">        //apk安装包中，对应AndroidManifest里面的&lt;Provider&gt;</span><br><span class="line">        //不是通常说的Provider，而是PackageParse的内部类Provider</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public final ArrayList&lt;Provider&gt; providers = new ArrayList&lt;Provider&gt;(0);</span><br><span class="line">        </span><br><span class="line">        //apk安装包中，对应AndroidManifest里面的&lt;Service&gt;</span><br><span class="line">        //不是通常说的Service，而是PackageParse的内部类Service</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public final ArrayList&lt;Service&gt; services = new ArrayList&lt;Service&gt;(0);</span><br><span class="line">        </span><br><span class="line">        //apk安装包中，对应AndroidManifest里面的&lt;Instrumentation&gt;</span><br><span class="line">        //不是通常说的Instrumentation，而是内部类Instrumentation</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public final ArrayList&lt;Instrumentation&gt; instrumentation = new ArrayList&lt;Instrumentation&gt;(0);</span><br><span class="line">        //apk安装包中请求的权限</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public final ArrayList&lt;String&gt; requestedPermissions = new ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        //apk安装包中保内广播的action</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public ArrayList&lt;String&gt; protectedBroadcasts;</span><br><span class="line">        //父包</span><br><span class="line">        public Package parentPackage;</span><br><span class="line">        //子包</span><br><span class="line">        public ArrayList&lt;Package&gt; childPackages;</span><br><span class="line">        //共享库名称</span><br><span class="line">        public String staticSharedLibName = null;</span><br><span class="line">        //共享库版本</span><br><span class="line">        public long staticSharedLibVersion = 0;</span><br><span class="line">        //依赖库名称</span><br><span class="line">        public ArrayList&lt;String&gt; libraryNames = null;</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        //使用库名称</span><br><span class="line">        public ArrayList&lt;String&gt; usesLibraries = null;</span><br><span class="line">        //使用静态库名称</span><br><span class="line">        public ArrayList&lt;String&gt; usesStaticLibraries = null;</span><br><span class="line">        //使用静态库版本</span><br><span class="line">        public long[] usesStaticLibrariesVersions = null;</span><br><span class="line">        public String[][] usesStaticLibrariesCertDigests = null;</span><br><span class="line">         //使用其它的库</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public ArrayList&lt;String&gt; usesOptionalLibraries = null;</span><br><span class="line">         //使用静态库文件</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public String[] usesLibraryFiles = null;</span><br><span class="line">         //使用共享库信息</span><br><span class="line">        public ArrayList&lt;SharedLibraryInfo&gt; usesLibraryInfos = null;</span><br><span class="line">         //安装包中某个Activity信息的集合 在AndroidManifest里面对应&lt;preferred&gt;标签</span><br><span class="line">        public ArrayList&lt;ActivityIntentInfo&gt; preferredActivityFilters = null;</span><br><span class="line">         //安装包中 AndroidManifest中对应original-package的集合</span><br><span class="line">        public ArrayList&lt;String&gt; mOriginalPackages = null;</span><br><span class="line">         //真实包名，通常和mOriginalPackages一起使用</span><br><span class="line">        public String mRealPackage = null;</span><br><span class="line">        //APK安装包 AndroidManifest中对应adopt-permissions的集合</span><br><span class="line">        public ArrayList&lt;String&gt; mAdoptPermissions = null;</span><br><span class="line">       //独立的存储应用程序元数据，避免多个不需要的引用</span><br><span class="line">        // We store the application meta-data independently to avoid multiple unwanted references</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public Bundle mAppMetaData = null;</span><br><span class="line">        //版本号</span><br><span class="line">        // The version code declared for this package.</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public int mVersionCode;</span><br><span class="line">        //主版本号</span><br><span class="line">        // The major version code declared for this package.</span><br><span class="line">        public int mVersionCodeMajor;</span><br><span class="line">        //长版本号   </span><br><span class="line">        // Return long containing mVersionCode and mVersionCodeMajor.</span><br><span class="line">        public long getLongVersionCode() &#123;</span><br><span class="line">            return PackageInfo.composeLongVersionCode(mVersionCodeMajor, mVersionCode);</span><br><span class="line">        &#125;</span><br><span class="line">        //版本名</span><br><span class="line">        // The version name declared for this package.</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public String mVersionName;</span><br><span class="line">        //共享用户Id</span><br><span class="line">        // The shared user id that this package wants to use.</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public String mSharedUserId;</span><br><span class="line">        //共享用户标签</span><br><span class="line">        // The shared user label that this package wants to use.</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public int mSharedUserLabel;</span><br><span class="line">        //签名</span><br><span class="line">        // Signatures that were read from the package.</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        @NonNull public SigningDetails mSigningDetails = SigningDetails.UNKNOWN;</span><br><span class="line">        //dexopt的位置，以便pkms跟踪执行dexopt的位置</span><br><span class="line">        // For use by package manager service for quick lookup of</span><br><span class="line">        // preferred up order.</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public int mPreferredOrder = 0;</span><br><span class="line">        //最后一次使用package的时间</span><br><span class="line">        // For use by package manager to keep track of when a package was last used.</span><br><span class="line">        public long[] mLastPackageUsageTimeInMills =</span><br><span class="line">                new long[PackageManager.NOTIFY_PACKAGE_USE_REASONS_COUNT];</span><br><span class="line"></span><br><span class="line">        // // User set enabled state.</span><br><span class="line">        // public int mSetEnabled = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;</span><br><span class="line">        //</span><br><span class="line">        // // Whether the package has been stopped.</span><br><span class="line">        // public boolean mSetStopped = false;</span><br><span class="line">        </span><br><span class="line">        //附加数据</span><br><span class="line">        // Additional data supplied by callers.</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public Object mExtras;</span><br><span class="line">         </span><br><span class="line">        //硬件配置信息，对应AndroidManifest里面的&lt;users-configuration&gt;标签</span><br><span class="line">        // Applications hardware preferences</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public ArrayList&lt;ConfigurationInfo&gt; configPreferences = null;</span><br><span class="line">        //特性组信息，对应AndroidManifest里面的&lt;uses-feature&gt;标签 </span><br><span class="line">        // Applications requested features</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public ArrayList&lt;FeatureInfo&gt; reqFeatures = null;</span><br><span class="line">         //特性组信息，对应AndroidManifest里面的&lt;feature-group&gt;标签 </span><br><span class="line">        // Applications requested feature groups</span><br><span class="line">        public ArrayList&lt;FeatureGroupInfo&gt; featureGroups = null;</span><br><span class="line">        </span><br><span class="line">        //安装的属性</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public int installLocation;</span><br><span class="line"></span><br><span class="line">        //是否是核心</span><br><span class="line">        public boolean coreApp;</span><br><span class="line">        </span><br><span class="line">        //是否是全局必要，所有用户都需要的应用程序，无法为用户卸载</span><br><span class="line">        /* An app that&apos;s required for all users and cannot be uninstalled for a user */</span><br><span class="line">        public boolean mRequiredForAllUsers;</span><br><span class="line">        </span><br><span class="line">        //受限账户的验证类型</span><br><span class="line">        /* The restricted account authenticator type that is used by this application */</span><br><span class="line">        public String mRestrictedAccountType;</span><br><span class="line">        //账户的类型</span><br><span class="line">        /* The required account type without which this application will not function */</span><br><span class="line">        public String mRequiredAccountType;</span><br><span class="line">        </span><br><span class="line">        //对应AndroidManifest里面的&lt;overlay&gt;标签 </span><br><span class="line">        public String mOverlayTarget;</span><br><span class="line">        //overlay类别</span><br><span class="line">        public String mOverlayCategory;</span><br><span class="line">        //overlay优先等级</span><br><span class="line">        public int mOverlayPriority;</span><br><span class="line">        //是否是静态overlay</span><br><span class="line">        public boolean mOverlayIsStatic;</span><br><span class="line">        //编译sdk版本</span><br><span class="line">        public int mCompileSdkVersion;</span><br><span class="line">         //编译sdk版本名称</span><br><span class="line">        public String mCompileSdkVersionCodename;</span><br><span class="line">        </span><br><span class="line">        //下面用来给KeySetManagerService的数据</span><br><span class="line">        /**</span><br><span class="line">         * Data used to feed the KeySetManagerService</span><br><span class="line">         */</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public ArraySet&lt;String&gt; mUpgradeKeySets; //升级</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public ArrayMap&lt;String, ArraySet&lt;PublicKey&gt;&gt; mKeySetMapping; //公钥</span><br><span class="line"></span><br><span class="line">        //有abi的话覆盖</span><br><span class="line">        /**</span><br><span class="line">         * The install time abi override for this package, if any.</span><br><span class="line">         *</span><br><span class="line">         * TODO: This seems like a horrible place to put the abiOverride because</span><br><span class="line">         * this isn&apos;t something the packageParser parsers. However, this fits in with</span><br><span class="line">         * the rest of the PackageManager where package scanning randomly pushes</span><br><span class="line">         * and prods fields out of &#123;@code this.applicationInfo&#125;.</span><br><span class="line">         */</span><br><span class="line">        public String cpuAbiOverride;</span><br><span class="line">        //是否用32位的abi</span><br><span class="line">        /**</span><br><span class="line">         * The install time abi override to choose 32bit abi&apos;s when multiple abi&apos;s</span><br><span class="line">         * are present. This is only meaningfull for multiarch applications.</span><br><span class="line">         * The use32bitAbi attribute is ignored if cpuAbiOverride is also set.</span><br><span class="line">         */</span><br><span class="line">        public boolean use32bitAbi;</span><br><span class="line">        //限制升级hash</span><br><span class="line">        public byte[] restrictUpdateHash;</span><br><span class="line">        //是否对InstantApps可见</span><br><span class="line">        /** Set if the app or any of its components are visible to instant applications. */</span><br><span class="line">        public boolean visibleToInstantApps;</span><br><span class="line">        //是否是备份</span><br><span class="line">        /** Whether or not the package is a stub and must be replaced by the full version. */</span><br><span class="line">        public boolean isStub;</span><br><span class="line"></span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        public Package(String packageName) &#123;</span><br><span class="line">            this.packageName = packageName;</span><br><span class="line">            this.manifestPackageName = packageName;</span><br><span class="line">            applicationInfo.packageName = packageName;</span><br><span class="line">            applicationInfo.uid = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-scanDirTracedLI"><a href="#2-2-2-scanDirTracedLI" class="headerlink" title="2.2.2 scanDirTracedLI"></a>2.2.2 scanDirTracedLI</h4><p>这个是扫描目录的函数，主要是解析apk中xml的数据，并把相关信息保存到PackageParser.Package中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void scanDirTracedLI(File scanDir, final int parseFlags, int scanFlags, long currentTime) &#123;</span><br><span class="line">       Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;scanDir [&quot; + scanDir.getAbsolutePath() + &quot;]&quot;);</span><br><span class="line">       try &#123;</span><br><span class="line">           scanDirLI(scanDir, parseFlags, scanFlags, currentTime);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>里面跳转的方法比较多，其主要流程如下：</p>
<p><img src="/2019/PackageManagerService启动流程分析/scanDir.png" alt=""></p>
<h3 id="2-3-PMS-DATA-SCAN-START"><a href="#2-3-PMS-DATA-SCAN-START" class="headerlink" title="2.3 PMS_DATA_SCAN_START"></a>2.3 PMS_DATA_SCAN_START</h3><p>主要的工作是扫描data分区的apk，利用上一步获取的系统应用信息执行相关操作，最后更新动态库路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line">//非加密状态</span><br><span class="line">if (!mOnlyCore) &#123;</span><br><span class="line">         EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</span><br><span class="line">                 SystemClock.uptimeMillis());</span><br><span class="line">                 </span><br><span class="line">         //扫描 /data/app目录</span><br><span class="line">         scanDirTracedLI(sAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);</span><br><span class="line">         //扫描 /data/app-private目录</span><br><span class="line">         scanDirTracedLI(sDrmAppPrivateInstallDir, mDefParseFlags</span><br><span class="line">                 | PackageParser.PARSE_FORWARD_LOCK,</span><br><span class="line">                 scanFlags | SCAN_REQUIRE_KNOWN, 0);</span><br><span class="line"></span><br><span class="line">         //放在possiblyDeletedUpdatedSystemApps中的应用是在package.xml标记成待升级的系统应用</span><br><span class="line">         //但是文件却不存在了，因此需要检查用户目录下升级文件是否还存在，然后处理</span><br><span class="line">         // Remove disable package settings for updated system apps that were</span><br><span class="line">         // removed via an OTA. If the update is no longer present, remove the</span><br><span class="line">         // app completely. Otherwise, revoke their system privileges.</span><br><span class="line">         for (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</span><br><span class="line">             PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</span><br><span class="line">             mSettings.removeDisabledSystemPackageLPw(deletedAppName);</span><br><span class="line">             final String msg;</span><br><span class="line">             if (deletedPkg == null) &#123;</span><br><span class="line">                 //用户目录中也没有，在肯定是残留应用，删除操作在后面</span><br><span class="line">                 // should have found an update, but, we didn&apos;t; remove everything</span><br><span class="line">                 msg = &quot;Updated system package &quot; + deletedAppName</span><br><span class="line">                         + &quot; no longer exists; removing its data&quot;;</span><br><span class="line">                 // Actual deletion of code and data will be handled by later</span><br><span class="line">                 // reconciliation step</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                //如果用户空间找到了文件，则说明系统目录下的文件可能被删除了</span><br><span class="line">                //因此需要把应用的属性去掉，以普通应用的方式运行</span><br><span class="line">                 // found an update; revoke system privileges</span><br><span class="line">                 msg = &quot;Updated system package + &quot; + deletedAppName</span><br><span class="line">                         + &quot; no longer exists; revoking system privileges&quot;;</span><br><span class="line"></span><br><span class="line">                 // Don&apos;t do anything if a stub is removed from the system image. If</span><br><span class="line">                 // we were to remove the uncompressed version from the /data partition,</span><br><span class="line">                 // this is where it&apos;d be done.</span><br><span class="line"></span><br><span class="line">                 final PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</span><br><span class="line">                 deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">                 deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">             &#125;</span><br><span class="line">             logCriticalInfo(Log.WARN, msg);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         //这个列表的应用是带有升级包的系统应用，前面已经把他们从mPackages列表中清除</span><br><span class="line">         //并加入到该列表，最后也对他们扫描处理，但是不会放到mPackages中</span><br><span class="line">         /*</span><br><span class="line">          * Make sure all system apps that we expected to appear on</span><br><span class="line">          * the userdata partition actually showed up. If they never</span><br><span class="line">          * appeared, crawl back and revive the system version.</span><br><span class="line">          */</span><br><span class="line">         for (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123;</span><br><span class="line">             final String packageName = mExpectingBetter.keyAt(i);</span><br><span class="line">             if (!mPackages.containsKey(packageName)) &#123;</span><br><span class="line">                 final File scanFile = mExpectingBetter.valueAt(i);</span><br><span class="line"></span><br><span class="line">                 logCriticalInfo(Log.WARN, &quot;Expected better &quot; + packageName</span><br><span class="line">                         + &quot; but never showed up; reverting to system&quot;);</span><br><span class="line"></span><br><span class="line">                  //确保应用位于下面七个系统应用目录，如果不在则不需要处理</span><br><span class="line">                 final @ParseFlags int reparseFlags;</span><br><span class="line">                 final @ScanFlags int rescanFlags;</span><br><span class="line">                 if (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</span><br><span class="line">                     reparseFlags =</span><br><span class="line">                             mDefParseFlags |</span><br><span class="line">                             PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">                     rescanFlags =</span><br><span class="line">                             scanFlags</span><br><span class="line">                             | SCAN_AS_SYSTEM</span><br><span class="line">                             | SCAN_AS_PRIVILEGED;</span><br><span class="line">                 &#125; else if (FileUtils.contains(systemAppDir, scanFile)) &#123;</span><br><span class="line">                     reparseFlags =</span><br><span class="line">                             mDefParseFlags |</span><br><span class="line">                             PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">                     rescanFlags =</span><br><span class="line">                             scanFlags</span><br><span class="line">                             | SCAN_AS_SYSTEM;</span><br><span class="line">                 &#125; else if (FileUtils.contains(privilegedVendorAppDir, scanFile)</span><br><span class="line">                         || FileUtils.contains(privilegedOdmAppDir, scanFile)) &#123;</span><br><span class="line">                     reparseFlags =</span><br><span class="line">                             mDefParseFlags |</span><br><span class="line">                             PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">                     rescanFlags =</span><br><span class="line">                             scanFlags</span><br><span class="line">                             | SCAN_AS_SYSTEM</span><br><span class="line">                             | SCAN_AS_VENDOR</span><br><span class="line">                             | SCAN_AS_PRIVILEGED;</span><br><span class="line">                 &#125; else if (FileUtils.contains(vendorAppDir, scanFile)</span><br><span class="line">                         || FileUtils.contains(odmAppDir, scanFile)) &#123;</span><br><span class="line">                     reparseFlags =</span><br><span class="line">                             mDefParseFlags |</span><br><span class="line">                             PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">                     rescanFlags =</span><br><span class="line">                             scanFlags</span><br><span class="line">                             | SCAN_AS_SYSTEM</span><br><span class="line">                             | SCAN_AS_VENDOR;</span><br><span class="line">                 &#125; else if (FileUtils.contains(oemAppDir, scanFile)) &#123;</span><br><span class="line">                     reparseFlags =</span><br><span class="line">                             mDefParseFlags |</span><br><span class="line">                             PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">                     rescanFlags =</span><br><span class="line">                             scanFlags</span><br><span class="line">                             | SCAN_AS_SYSTEM</span><br><span class="line">                             | SCAN_AS_OEM;</span><br><span class="line">                 &#125; else if (FileUtils.contains(privilegedProductAppDir, scanFile)) &#123;</span><br><span class="line">                     reparseFlags =</span><br><span class="line">                             mDefParseFlags |</span><br><span class="line">                             PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">                     rescanFlags =</span><br><span class="line">                             scanFlags</span><br><span class="line">                             | SCAN_AS_SYSTEM</span><br><span class="line">                             | SCAN_AS_PRODUCT</span><br><span class="line">                             | SCAN_AS_PRIVILEGED;</span><br><span class="line">                 &#125; else if (FileUtils.contains(productAppDir, scanFile)) &#123;</span><br><span class="line">                     reparseFlags =</span><br><span class="line">                             mDefParseFlags |</span><br><span class="line">                             PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">                     rescanFlags =</span><br><span class="line">                             scanFlags</span><br><span class="line">                             | SCAN_AS_SYSTEM</span><br><span class="line">                             | SCAN_AS_PRODUCT;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     Slog.e(TAG, &quot;Ignoring unexpected fallback path &quot; + scanFile);</span><br><span class="line">                     continue;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 //把这个应用标记为系统应用，从mSettings.mDisabledSysPackages中删除</span><br><span class="line">                 //因为在scanDirLi-&gt;scanPackageLI中会执行mSettings.disableSystemPakcageLPw</span><br><span class="line">                 //此时包名的标签只有&lt;update-package&gt;,执行到这部之后变成&lt;package&gt;标签</span><br><span class="line">                 //在下面的scanPackageTracedLI中会添加一个&lt;update-package&gt;标签</span><br><span class="line">                 mSettings.enableSystemPackageLPw(packageName);</span><br><span class="line"></span><br><span class="line">                 try &#123;</span><br><span class="line">                     scanPackageTracedLI(scanFile, reparseFlags, rescanFlags, 0, null);</span><br><span class="line">                 &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">                     Slog.e(TAG, &quot;Failed to parse original system package: &quot;</span><br><span class="line">                             + e.getMessage());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">         //解压安装备份的系统应用，确保备份的系统应用被更新</span><br><span class="line">         // Uncompress and install any stubbed system applications.</span><br><span class="line">         // This must be done last to ensure all stubs are replaced or disabled.</span><br><span class="line">         decompressSystemApplications(stubSystemApps, scanFlags);</span><br><span class="line"></span><br><span class="line">         final int cachedNonSystemApps = PackageParser.sCachedPackageReadCount.get()</span><br><span class="line">                         - cachedSystemApps;</span><br><span class="line"></span><br><span class="line">         final long dataScanTime = SystemClock.uptimeMillis() - systemScanTime - startTime;</span><br><span class="line">         final int dataPackagesCount = mPackages.size() - systemPackagesCount;</span><br><span class="line">         Slog.i(TAG, &quot;Finished scanning non-system apps. Time: &quot; + dataScanTime</span><br><span class="line">                 + &quot; ms, packageCount: &quot; + dataPackagesCount</span><br><span class="line">                 + &quot; , timePerPackage: &quot;</span><br><span class="line">                 + (dataPackagesCount == 0 ? 0 : dataScanTime / dataPackagesCount)</span><br><span class="line">                 + &quot; , cached: &quot; + cachedNonSystemApps);</span><br><span class="line">         if (mIsUpgrade &amp;&amp; dataPackagesCount &gt; 0) &#123;</span><br><span class="line">             MetricsLogger.histogram(null, &quot;ota_package_manager_data_app_avg_scan_time&quot;,</span><br><span class="line">                     ((int) dataScanTime) / dataPackagesCount);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     //清空mExpectingBetter列表</span><br><span class="line">     mExpectingBetter.clear();</span><br><span class="line">     </span><br><span class="line">     //获取存储管理包名</span><br><span class="line">     // Resolve the storage manager.</span><br><span class="line">     mStorageManagerPackage = getStorageManagerPackageName();</span><br><span class="line">     </span><br><span class="line">     //获取引导包名</span><br><span class="line">     // Resolve protected action filters. Only the setup wizard is allowed to</span><br><span class="line">     // have a high priority filter for these actions.</span><br><span class="line">     mSetupWizardPackage = getSetupWizardPackageName();</span><br><span class="line">     if (mProtectedFilters.size() &gt; 0) &#123;</span><br><span class="line">         if (DEBUG_FILTERS &amp;&amp; mSetupWizardPackage == null) &#123;</span><br><span class="line">             Slog.i(TAG, &quot;No setup wizard;&quot;</span><br><span class="line">                 + &quot; All protected intents capped to priority 0&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         for (ActivityIntentInfo filter : mProtectedFilters) &#123;</span><br><span class="line">             if (filter.activity.info.packageName.equals(mSetupWizardPackage)) &#123;</span><br><span class="line">                 if (DEBUG_FILTERS) &#123;</span><br><span class="line">                     Slog.i(TAG, &quot;Found setup wizard;&quot;</span><br><span class="line">                         + &quot; allow priority &quot; + filter.getPriority() + &quot;;&quot;</span><br><span class="line">                         + &quot; package: &quot; + filter.activity.info.packageName</span><br><span class="line">                         + &quot; activity: &quot; + filter.activity.className</span><br><span class="line">                         + &quot; priority: &quot; + filter.getPriority());</span><br><span class="line">                 &#125;</span><br><span class="line">                 // skip setup wizard; allow it to keep the high priority filter</span><br><span class="line">                 continue;</span><br><span class="line">             &#125;</span><br><span class="line">             if (DEBUG_FILTERS) &#123;</span><br><span class="line">                 Slog.i(TAG, &quot;Protected action; cap priority to 0;&quot;</span><br><span class="line">                         + &quot; package: &quot; + filter.activity.info.packageName</span><br><span class="line">                         + &quot; activity: &quot; + filter.activity.className</span><br><span class="line">                         + &quot; origPrio: &quot; + filter.getPriority());</span><br><span class="line">             &#125;</span><br><span class="line">             filter.setPriority(0);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mSystemTextClassifierPackage = getSystemTextClassifierPackageName();</span><br><span class="line"></span><br><span class="line">     mDeferProtectedFilters = false;</span><br><span class="line">     mProtectedFilters.clear();</span><br><span class="line">     </span><br><span class="line">     //更新所有应用的动态库路径</span><br><span class="line">     // Now that we know all of the shared libraries, update all clients to have</span><br><span class="line">     // the correct library paths.</span><br><span class="line">     updateAllSharedLibrariesLPw(null);</span><br><span class="line"></span><br><span class="line">     for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</span><br><span class="line">         //调整更新Abis为共享用户所用</span><br><span class="line">         // NOTE: We ignore potential failures here during a system scan (like</span><br><span class="line">         // the rest of the commands above) because there&apos;s precious little we</span><br><span class="line">         // can do about it. A settings error is reported, though.</span><br><span class="line">         final List&lt;String&gt; changedAbiCodePath =</span><br><span class="line">                 adjustCpuAbisForSharedUserLPw(setting.packages, null /*scannedPackage*/);</span><br><span class="line">         if (changedAbiCodePath != null &amp;&amp; changedAbiCodePath.size() &gt; 0) &#123;</span><br><span class="line">             for (int i = changedAbiCodePath.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                 final String codePathString = changedAbiCodePath.get(i);</span><br><span class="line">                 try &#123;</span><br><span class="line">                     mInstaller.rmdex(codePathString,</span><br><span class="line">                             getDexCodeInstructionSet(getPreferredInstructionSet()));</span><br><span class="line">                 &#125; catch (InstallerException ignored) &#123;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         // Adjust seInfo to ensure apps which share a sharedUserId are placed in the same</span><br><span class="line">         // SELinux domain.</span><br><span class="line">         setting.fixSeInfoLocked();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Now that we know all the packages we are keeping,</span><br><span class="line">     // read and update their last usage times.</span><br><span class="line">     mPackageUsage.read(mPackages);</span><br><span class="line">     mCompilerStats.read();</span><br></pre></td></tr></table></figure>
<h3 id="2-4-PMS-SCAN-END"><a href="#2-4-PMS-SCAN-END" class="headerlink" title="2.4 PMS_SCAN_END"></a>2.4 PMS_SCAN_END</h3><p>主要的工作如下：</p>
<ul>
<li>更新所有权限;</li>
<li>为系统应用准备空间和数据</li>
<li>将上述信息写回/data/system/packages.xml;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,</span><br><span class="line">        SystemClock.uptimeMillis());</span><br><span class="line">Slog.i(TAG, &quot;Time to scan packages: &quot;</span><br><span class="line">        + ((SystemClock.uptimeMillis()-startTime)/1000f)</span><br><span class="line">        + &quot; seconds&quot;);</span><br><span class="line">//如果sdk版本发生变化，则可能permission的定义也发生变化，因此需要重新更新应用权限</span><br><span class="line">// If the platform SDK has changed since the last time we booted,</span><br><span class="line">// we need to re-grant app permission to catch any new ones that</span><br><span class="line">// appear.  This is really a hack, and means that apps can in some</span><br><span class="line">// cases get permissions that the user didn&apos;t initially explicitly</span><br><span class="line">// allow...  it would be nice to have some better way to handle</span><br><span class="line">// this situation.</span><br><span class="line">final boolean sdkUpdated = (ver.sdkVersion != mSdkVersion);</span><br><span class="line">if (sdkUpdated) &#123;</span><br><span class="line">    Slog.i(TAG, &quot;Platform changed from &quot; + ver.sdkVersion + &quot; to &quot;</span><br><span class="line">            + mSdkVersion + &quot;; regranting permissions for internal storage&quot;);</span><br><span class="line">&#125;</span><br><span class="line">mPermissionManager.updateAllPermissions(</span><br><span class="line">        StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, mPackages.values(),</span><br><span class="line">        mPermissionCallback);</span><br><span class="line">ver.sdkVersion = mSdkVersion;</span><br><span class="line"></span><br><span class="line">//如果是第一次启动或者是android M升级后的第一次启动，需要执行一些初始化操作</span><br><span class="line">// If this is the first boot or an update from pre-M, and it is a normal</span><br><span class="line">// boot, then we need to initialize the default preferred apps across</span><br><span class="line">// all defined users.</span><br><span class="line">if (!onlyCore &amp;&amp; (mPromoteSystemApps || mFirstBoot)) &#123;</span><br><span class="line">    for (UserInfo user : sUserManager.getUsers(true)) &#123;</span><br><span class="line">        mSettings.applyDefaultPreferredAppsLPw(this, user.id);</span><br><span class="line">        applyFactoryDefaultBrowserLPw(user.id);</span><br><span class="line">        primeDomainVerificationsLPw(user.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line">//为系统应用准备空间和数据</span><br><span class="line">// Prepare storage for system user really early during boot,</span><br><span class="line">// since core system apps like SettingsProvider and SystemUI</span><br><span class="line">// can&apos;t wait for user to start</span><br><span class="line">final int storageFlags;</span><br><span class="line">if (StorageManager.isFileEncryptedNativeOrEmulated()) &#123;</span><br><span class="line">    storageFlags = StorageManager.FLAG_STORAGE_DE;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL,</span><br><span class="line">        UserHandle.USER_SYSTEM, storageFlags, true /* migrateAppData */,</span><br><span class="line">        true /* onlyCoreApps */);</span><br><span class="line">mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(() -&gt; &#123;</span><br><span class="line">    TimingsTraceLog traceLog = new TimingsTraceLog(&quot;SystemServerTimingAsync&quot;,</span><br><span class="line">            Trace.TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    traceLog.traceBegin(&quot;AppDataFixup&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        mInstaller.fixupAppData(StorageManager.UUID_PRIVATE_INTERNAL,</span><br><span class="line">                StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE);</span><br><span class="line">    &#125; catch (InstallerException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Trouble fixing GIDs&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    traceLog.traceEnd();</span><br><span class="line"></span><br><span class="line">    traceLog.traceBegin(&quot;AppDataPrepare&quot;);</span><br><span class="line">    if (deferPackages == null || deferPackages.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (String pkgName : deferPackages) &#123;</span><br><span class="line">        PackageParser.Package pkg = null;</span><br><span class="line">        synchronized (mPackages) &#123;</span><br><span class="line">            PackageSetting ps = mSettings.getPackageLPr(pkgName);</span><br><span class="line">            if (ps != null &amp;&amp; ps.getInstalled(UserHandle.USER_SYSTEM)) &#123;</span><br><span class="line">                pkg = ps.pkg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pkg != null) &#123;</span><br><span class="line">            synchronized (mInstallLock) &#123;</span><br><span class="line">                prepareAppDataAndMigrateLIF(pkg, UserHandle.USER_SYSTEM, storageFlags,</span><br><span class="line">                        true /* maybeMigrateAppData */);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    traceLog.traceEnd();</span><br><span class="line">    Slog.i(TAG, &quot;Deferred reconcileAppsData finished &quot; + count + &quot; packages&quot;);</span><br><span class="line">&#125;, &quot;prepareAppData&quot;);</span><br><span class="line">           </span><br><span class="line">//如果是执行OTA升级后的第一次启动，需要清除cache</span><br><span class="line">// If this is first boot after an OTA, and a normal boot, then</span><br><span class="line">// we need to clear code cache directories.</span><br><span class="line">// Note that we do *not* clear the application profiles. These remain valid</span><br><span class="line">// across OTAs and are used to drive profile verification (post OTA) and</span><br><span class="line">// profile compilation (without waiting to collect a fresh set of profiles).</span><br><span class="line">if (mIsUpgrade &amp;&amp; !onlyCore) &#123;</span><br><span class="line">    Slog.i(TAG, &quot;Build fingerprint changed; clearing code caches&quot;);</span><br><span class="line">    for (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123;</span><br><span class="line">        final PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</span><br><span class="line">            // No apps are running this early, so no need to freeze</span><br><span class="line">            clearAppDataLIF(ps.pkg, UserHandle.USER_ALL,</span><br><span class="line">                    StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE</span><br><span class="line">                            | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ver.fingerprint = Build.FINGERPRINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkDefaultBrowser();</span><br><span class="line"></span><br><span class="line">// clear only after permissions and other defaults have been updated</span><br><span class="line">mExistingSystemPackages.clear();</span><br><span class="line">mPromoteSystemApps = false;</span><br><span class="line"></span><br><span class="line">// All the changes are done during package scanning.</span><br><span class="line">ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</span><br><span class="line"></span><br><span class="line">//把Settings的内容保存到packages.xml中</span><br><span class="line">// can downgrade to reader</span><br><span class="line">Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;write settings&quot;);</span><br><span class="line">mSettings.writeLPr();</span><br><span class="line">Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br></pre></td></tr></table></figure>
<h3 id="2-5-PMS-READY"><a href="#2-5-PMS-READY" class="headerlink" title="2.5  PMS_READY"></a>2.5  PMS_READY</h3><p>主要工作是创建PackageInstallerService服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    if (!mOnlyCore) &#123;</span><br><span class="line">        mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr();</span><br><span class="line">        mRequiredInstallerPackage = getRequiredInstallerLPr();</span><br><span class="line">        mRequiredUninstallerPackage = getRequiredUninstallerLPr();</span><br><span class="line">        mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</span><br><span class="line">        if (mIntentFilterVerifierComponent != null) &#123;</span><br><span class="line">            mIntentFilterVerifier = new IntentVerifierProxy(mContext,</span><br><span class="line">                    mIntentFilterVerifierComponent);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mIntentFilterVerifier = null;</span><br><span class="line">        &#125;</span><br><span class="line">        mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr(</span><br><span class="line">                PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES,</span><br><span class="line">                SharedLibraryInfo.VERSION_UNDEFINED);</span><br><span class="line">        mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr(</span><br><span class="line">                PackageManager.SYSTEM_SHARED_LIBRARY_SHARED,</span><br><span class="line">                SharedLibraryInfo.VERSION_UNDEFINED);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mRequiredVerifierPackage = null;</span><br><span class="line">        mRequiredInstallerPackage = null;</span><br><span class="line">        mRequiredUninstallerPackage = null;</span><br><span class="line">        mIntentFilterVerifierComponent = null;</span><br><span class="line">        mIntentFilterVerifier = null;</span><br><span class="line">        mServicesSystemSharedLibraryPackageName = null;</span><br><span class="line">        mSharedSystemSharedLibraryPackageName = null;</span><br><span class="line">    &#125;</span><br><span class="line">    //启动PackageInstallerService服务</span><br><span class="line">    mInstallerService = new PackageInstallerService(context, this);</span><br><span class="line">    final Pair&lt;ComponentName, String&gt; instantAppResolverComponent =</span><br><span class="line">            getInstantAppResolverLPr();</span><br><span class="line">    if (instantAppResolverComponent != null) &#123;</span><br><span class="line">        if (DEBUG_INSTANT) &#123;</span><br><span class="line">            Slog.d(TAG, &quot;Set ephemeral resolver: &quot; + instantAppResolverComponent);</span><br><span class="line">        &#125;</span><br><span class="line">        mInstantAppResolverConnection = new InstantAppResolverConnection(</span><br><span class="line">                mContext, instantAppResolverComponent.first,</span><br><span class="line">                instantAppResolverComponent.second);</span><br><span class="line">        mInstantAppResolverSettingsComponent =</span><br><span class="line">                getInstantAppResolverSettingsLPr(instantAppResolverComponent.first);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstantAppResolverConnection = null;</span><br><span class="line">        mInstantAppResolverSettingsComponent = null;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化 installer activity</span><br><span class="line">    updateInstantAppInstallerLocked(null);</span><br><span class="line">    </span><br><span class="line">    //更新使用的Packages</span><br><span class="line">    // Read and update the usage of dex files.</span><br><span class="line">    // Do this at the end of PM init so that all the packages have their</span><br><span class="line">    // data directory reconciled.</span><br><span class="line">    // At this point we know the code paths of the packages, so we can validate</span><br><span class="line">    // the disk file and build the internal cache.</span><br><span class="line">    // The usage file is expected to be small so loading and verifying it</span><br><span class="line">    // should take a fairly small time compare to the other activities (e.g. package</span><br><span class="line">    // scanning).</span><br><span class="line">    final Map&lt;Integer, List&lt;PackageInfo&gt;&gt; userPackages = new HashMap&lt;&gt;();</span><br><span class="line">    final int[] currentUserIds = UserManagerService.getInstance().getUserIds();</span><br><span class="line">    for (int userId : currentUserIds) &#123;</span><br><span class="line">        userPackages.put(userId, getInstalledPackages(/*flags*/ 0, userId).getList());</span><br><span class="line">    &#125;</span><br><span class="line">    mDexManager.load(userPackages);</span><br><span class="line">    if (mIsUpgrade) &#123;</span><br><span class="line">        MetricsLogger.histogram(null, &quot;ota_package_manager_init_time&quot;,</span><br><span class="line">                (int) (SystemClock.uptimeMillis() - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // synchronized (mPackages)</span><br><span class="line">&#125; // synchronized (mInstallLock)</span><br><span class="line"></span><br><span class="line">// Now after opening every single application zip, make sure they</span><br><span class="line">// are all flushed.  Not really needed, but keeps things nice and</span><br><span class="line">// tidy.</span><br><span class="line">Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;GC&quot;);</span><br><span class="line">Runtime.getRuntime().gc();</span><br><span class="line">Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line"></span><br><span class="line">//mPackages锁被占用，则给出警告提示</span><br><span class="line">// The initial scanning above does many calls into installd while</span><br><span class="line">// holding the mPackages lock, but we&apos;re mostly interested in yelling</span><br><span class="line">// once we have a booted system.</span><br><span class="line">mInstaller.setWarnIfHeld(mPackages);</span><br><span class="line"></span><br><span class="line">Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br></pre></td></tr></table></figure>
<h2 id="三、PKMS操作"><a href="#三、PKMS操作" class="headerlink" title="三、PKMS操作"></a>三、PKMS操作</h2><h3 id="3-1-getPackageManager"><a href="#3-1-getPackageManager" class="headerlink" title="3.1 getPackageManager"></a>3.1 getPackageManager</h3><p>在ContextImpl中</p>
<p>/frameworks/base/core/java/android/app/ContextImpl.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public PackageManager getPackageManager() &#123;</span><br><span class="line">       if (mPackageManager != null) &#123;</span><br><span class="line">           return mPackageManager;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">       if (pm != null) &#123;</span><br><span class="line">           // Doesn&apos;t matter if we make more than one instance.</span><br><span class="line">           return (mPackageManager = new ApplicationPackageManager(this, pm));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>/frameworks/base/core/java/android/app/ActivityThread.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">    public static IPackageManager getPackageManager() &#123;</span><br><span class="line">        if (sPackageManager != null) &#123;</span><br><span class="line">            //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</span><br><span class="line">            return sPackageManager;</span><br><span class="line">        &#125;</span><br><span class="line">        IBinder b = ServiceManager.getService(&quot;package&quot;);</span><br><span class="line">        //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</span><br><span class="line">        sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">        //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</span><br><span class="line">        return sPackageManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-updatePackagesIfNeeded"><a href="#3-2-updatePackagesIfNeeded" class="headerlink" title="3.2 updatePackagesIfNeeded"></a>3.2 updatePackagesIfNeeded</h3><p>这里主要是对package进行Dexopt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void updatePackagesIfNeeded() &#123;</span><br><span class="line">       enforceSystemOrRoot(&quot;Only the system can request package update&quot;);</span><br><span class="line"></span><br><span class="line">       // We need to re-extract after an OTA.</span><br><span class="line">       boolean causeUpgrade = isUpgrade();</span><br><span class="line"></span><br><span class="line">       // First boot or factory reset.</span><br><span class="line">       // Note: we also handle devices that are upgrading to N right now as if it is their</span><br><span class="line">       //       first boot, as they do not have profile data.</span><br><span class="line">       boolean causeFirstBoot = isFirstBoot() || mIsPreNUpgrade;</span><br><span class="line"></span><br><span class="line">       // We need to re-extract after a pruned cache, as AoT-ed files will be out of date.</span><br><span class="line">       boolean causePrunedCache = VMRuntime.didPruneDalvikCache();</span><br><span class="line"></span><br><span class="line">       if (!causeUpgrade &amp;&amp; !causeFirstBoot &amp;&amp; !causePrunedCache) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       List&lt;PackageParser.Package&gt; pkgs;</span><br><span class="line">       synchronized (mPackages) &#123;</span><br><span class="line">           pkgs = PackageManagerServiceUtils.getPackagesForDexopt(mPackages.values(), this);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final long startTime = System.nanoTime();</span><br><span class="line">       final int[] stats = performDexOptUpgrade(pkgs, mIsPreNUpgrade /* showDialog */,</span><br><span class="line">                   causeFirstBoot ? REASON_FIRST_BOOT : REASON_BOOT,</span><br><span class="line">                   false /* bootComplete */);</span><br><span class="line"></span><br><span class="line">       final int elapsedTimeSeconds =</span><br><span class="line">               (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime);</span><br><span class="line"></span><br><span class="line">       MetricsLogger.histogram(mContext, &quot;opt_dialog_num_dexopted&quot;, stats[0]);</span><br><span class="line">       MetricsLogger.histogram(mContext, &quot;opt_dialog_num_skipped&quot;, stats[1]);</span><br><span class="line">       MetricsLogger.histogram(mContext, &quot;opt_dialog_num_failed&quot;, stats[2]);</span><br><span class="line">       MetricsLogger.histogram(mContext, &quot;opt_dialog_num_total&quot;, getOptimizablePackages().size());</span><br><span class="line">       MetricsLogger.histogram(mContext, &quot;opt_dialog_time_s&quot;, elapsedTimeSeconds);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>PackageManagerServiceUtils.getPackagesForDexopt的方法，主要的功能是根据app的重要性，对dexopt的顺序进行排序，重要的app将会首先会执行Dexopt操作，以防止设备空间不足。排序的原则是根据app的使用时间长短。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// Sort apps by importance for dexopt ordering. Important apps are given</span><br><span class="line">  // more priority in case the device runs out of space.</span><br><span class="line">  public static List&lt;PackageParser.Package&gt; getPackagesForDexopt(</span><br><span class="line">          Collection&lt;PackageParser.Package&gt; packages,</span><br><span class="line">          PackageManagerService packageManagerService) &#123;</span><br><span class="line">      return getPackagesForDexopt(packages, packageManagerService, DEBUG_DEXOPT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static List&lt;PackageParser.Package&gt; getPackagesForDexopt(</span><br><span class="line">          Collection&lt;PackageParser.Package&gt; packages,</span><br><span class="line">          PackageManagerService packageManagerService,</span><br><span class="line">          boolean debug) &#123;</span><br><span class="line">      ArrayList&lt;PackageParser.Package&gt; remainingPkgs = new ArrayList&lt;&gt;(packages);</span><br><span class="line">      LinkedList&lt;PackageParser.Package&gt; result = new LinkedList&lt;&gt;();</span><br><span class="line">      ArrayList&lt;PackageParser.Package&gt; sortTemp = new ArrayList&lt;&gt;(remainingPkgs.size());</span><br><span class="line"></span><br><span class="line">      // Give priority to core apps.</span><br><span class="line">      applyPackageFilter((pkg) -&gt; pkg.coreApp, result, remainingPkgs, sortTemp,</span><br><span class="line">              packageManagerService);</span><br><span class="line"></span><br><span class="line">      // Give priority to system apps that listen for pre boot complete.</span><br><span class="line">      Intent intent = new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);</span><br><span class="line">      final ArraySet&lt;String&gt; pkgNames = getPackageNamesForIntent(intent, UserHandle.USER_SYSTEM);</span><br><span class="line">      applyPackageFilter((pkg) -&gt; pkgNames.contains(pkg.packageName), result, remainingPkgs,</span><br><span class="line">              sortTemp, packageManagerService);</span><br><span class="line"></span><br><span class="line">      // Give priority to apps used by other apps.</span><br><span class="line">      DexManager dexManager = packageManagerService.getDexManager();</span><br><span class="line">      applyPackageFilter((pkg) -&gt;</span><br><span class="line">              dexManager.getPackageUseInfoOrDefault(pkg.packageName)</span><br><span class="line">                      .isAnyCodePathUsedByOtherApps(),</span><br><span class="line">              result, remainingPkgs, sortTemp, packageManagerService);</span><br><span class="line"></span><br><span class="line">      // Filter out packages that aren&apos;t recently used, add all remaining apps.</span><br><span class="line">      // TODO: add a property to control this?</span><br><span class="line">      Predicate&lt;PackageParser.Package&gt; remainingPredicate;</span><br><span class="line">      if (!remainingPkgs.isEmpty() &amp;&amp; packageManagerService.isHistoricalPackageUsageAvailable()) &#123;</span><br><span class="line">          if (debug) &#123;</span><br><span class="line">              Log.i(TAG, &quot;Looking at historical package use&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          // Get the package that was used last.</span><br><span class="line">          PackageParser.Package lastUsed = Collections.max(remainingPkgs, (pkg1, pkg2) -&gt;</span><br><span class="line">                  Long.compare(pkg1.getLatestForegroundPackageUseTimeInMills(),</span><br><span class="line">                          pkg2.getLatestForegroundPackageUseTimeInMills()));</span><br><span class="line">          if (debug) &#123;</span><br><span class="line">              Log.i(TAG, &quot;Taking package &quot; + lastUsed.packageName + &quot; as reference in time use&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          //统计app使用的时长</span><br><span class="line">          long estimatedPreviousSystemUseTime =</span><br><span class="line">                  lastUsed.getLatestForegroundPackageUseTimeInMills();</span><br><span class="line">          // Be defensive if for some reason package usage has bogus data.</span><br><span class="line">          if (estimatedPreviousSystemUseTime != 0) &#123;</span><br><span class="line">              final long cutoffTime = estimatedPreviousSystemUseTime - SEVEN_DAYS_IN_MILLISECONDS;</span><br><span class="line">              remainingPredicate =</span><br><span class="line">                      (pkg) -&gt; pkg.getLatestForegroundPackageUseTimeInMills() &gt;= cutoffTime;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              // No meaningful historical info. Take all.</span><br><span class="line">              remainingPredicate = (pkg) -&gt; true;</span><br><span class="line">          &#125;</span><br><span class="line">          //根据时长进行排序</span><br><span class="line">          sortPackagesByUsageDate(remainingPkgs, packageManagerService);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          // No historical info. Take all.</span><br><span class="line">          remainingPredicate = (pkg) -&gt; true;</span><br><span class="line">      &#125;</span><br><span class="line">      applyPackageFilter(remainingPredicate, result, remainingPkgs, sortTemp,</span><br><span class="line">              packageManagerService);</span><br><span class="line"></span><br><span class="line">      if (debug) &#123;</span><br><span class="line">          Log.i(TAG, &quot;Packages to be dexopted: &quot; + packagesToString(result));</span><br><span class="line">          Log.i(TAG, &quot;Packages skipped from dexopt: &quot; + packagesToString(remainingPkgs));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>performDexOptUpgrade方法是对packages执行dexopt操作。首先是创建package的配置文件，配置文件生成后再执行performDexOptTraced的操作，里面最后执行的操作是mInstaller.dexopt方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Performs dexopt on the set of packages in &#123;@code packages&#125; and returns an int array</span><br><span class="line">   * containing statistics about the invocation. The array consists of three elements,</span><br><span class="line">   * which are (in order) &#123;@code numberOfPackagesOptimized&#125;, &#123;@code numberOfPackagesSkipped&#125;</span><br><span class="line">   * and &#123;@code numberOfPackagesFailed&#125;.</span><br><span class="line">   */</span><br><span class="line">  private int[] performDexOptUpgrade(List&lt;PackageParser.Package&gt; pkgs, boolean showDialog,</span><br><span class="line">          final int compilationReason, boolean bootComplete) &#123;</span><br><span class="line"></span><br><span class="line">      int numberOfPackagesVisited = 0;</span><br><span class="line">      int numberOfPackagesOptimized = 0;</span><br><span class="line">      int numberOfPackagesSkipped = 0;</span><br><span class="line">      int numberOfPackagesFailed = 0;</span><br><span class="line">      final int numberOfPackagesToDexopt = pkgs.size();</span><br><span class="line"></span><br><span class="line">      for (PackageParser.Package pkg : pkgs) &#123;</span><br><span class="line">          numberOfPackagesVisited++;</span><br><span class="line"></span><br><span class="line">          boolean useProfileForDexopt = false;</span><br><span class="line">          </span><br><span class="line">          //生成配置文件</span><br><span class="line">          if ((isFirstBoot() || isUpgrade()) &amp;&amp; isSystemApp(pkg)) &#123;</span><br><span class="line">              // Copy over initial preopt profiles since we won&apos;t get any JIT samples for methods</span><br><span class="line">              // that are already compiled.</span><br><span class="line">              File profileFile = new File(getPrebuildProfilePath(pkg));</span><br><span class="line">              // Copy profile if it exists.</span><br><span class="line">              if (profileFile.exists()) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      // We could also do this lazily before calling dexopt in</span><br><span class="line">                      // PackageDexOptimizer to prevent this happening on first boot. The issue</span><br><span class="line">                      // is that we don&apos;t have a good way to say &quot;do this only once&quot;.</span><br><span class="line">                      if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(),</span><br><span class="line">                              pkg.applicationInfo.uid, pkg.packageName,</span><br><span class="line">                              ArtManager.getProfileName(null))) &#123;</span><br><span class="line">                          Log.e(TAG, &quot;Installer failed to copy system profile!&quot;);</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          // Disabled as this causes speed-profile compilation during first boot</span><br><span class="line">                          // even if things are already compiled.</span><br><span class="line">                          // useProfileForDexopt = true;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                      Log.e(TAG, &quot;Failed to copy profile &quot; + profileFile.getAbsolutePath() + &quot; &quot;,</span><br><span class="line">                              e);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);</span><br><span class="line">                  // Handle compressed APKs in this path. Only do this for stubs with profiles to</span><br><span class="line">                  // minimize the number off apps being speed-profile compiled during first boot.</span><br><span class="line">                  // The other paths will not change the filter.</span><br><span class="line">                  if (disabledPs != null &amp;&amp; disabledPs.pkg.isStub) &#123;</span><br><span class="line">                      // The package is the stub one, remove the stub suffix to get the normal</span><br><span class="line">                      // package and APK names.</span><br><span class="line">                      String systemProfilePath =</span><br><span class="line">                              getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, &quot;&quot;);</span><br><span class="line">                      profileFile = new File(systemProfilePath);</span><br><span class="line">                      // If we have a profile for a compressed APK, copy it to the reference</span><br><span class="line">                      // location.</span><br><span class="line">                      // Note that copying the profile here will cause it to override the</span><br><span class="line">                      // reference profile every OTA even though the existing reference profile</span><br><span class="line">                      // may have more data. We can&apos;t copy during decompression since the</span><br><span class="line">                      // directories are not set up at that point.</span><br><span class="line">                      if (profileFile.exists()) &#123;</span><br><span class="line">                          try &#123;</span><br><span class="line">                              // We could also do this lazily before calling dexopt in</span><br><span class="line">                              // PackageDexOptimizer to prevent this happening on first boot. The</span><br><span class="line">                              // issue is that we don&apos;t have a good way to say &quot;do this only</span><br><span class="line">                              // once&quot;.</span><br><span class="line">                              if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(),</span><br><span class="line">                                      pkg.applicationInfo.uid, pkg.packageName,</span><br><span class="line">                                      ArtManager.getProfileName(null))) &#123;</span><br><span class="line">                                  Log.e(TAG, &quot;Failed to copy system profile for stub package!&quot;);</span><br><span class="line">                              &#125; else &#123;</span><br><span class="line">                                  useProfileForDexopt = true;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125; catch (Exception e) &#123;</span><br><span class="line">                              Log.e(TAG, &quot;Failed to copy profile &quot; +</span><br><span class="line">                                      profileFile.getAbsolutePath() + &quot; &quot;, e);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (!PackageDexOptimizer.canOptimizePackage(pkg)) &#123;</span><br><span class="line">              if (DEBUG_DEXOPT) &#123;</span><br><span class="line">                  Log.i(TAG, &quot;Skipping update of of non-optimizable app &quot; + pkg.packageName);</span><br><span class="line">              &#125;</span><br><span class="line">              numberOfPackagesSkipped++;</span><br><span class="line">              continue;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (DEBUG_DEXOPT) &#123;</span><br><span class="line">              Log.i(TAG, &quot;Updating app &quot; + numberOfPackagesVisited + &quot; of &quot; +</span><br><span class="line">                      numberOfPackagesToDexopt + &quot;: &quot; + pkg.packageName);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (showDialog) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  ActivityManager.getService().showBootMessage(</span><br><span class="line">                          mContext.getResources().getString(R.string.android_upgrading_apk,</span><br><span class="line">                                  numberOfPackagesVisited, numberOfPackagesToDexopt), true);</span><br><span class="line">              &#125; catch (RemoteException e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">              synchronized (mPackages) &#123;</span><br><span class="line">                  mDexOptDialogShown = true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          int pkgCompilationReason = compilationReason;</span><br><span class="line">          if (useProfileForDexopt) &#123;</span><br><span class="line">              // Use background dexopt mode to try and use the profile. Note that this does not</span><br><span class="line">              // guarantee usage of the profile.</span><br><span class="line">              pkgCompilationReason = PackageManagerService.REASON_BACKGROUND_DEXOPT;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) &#123;</span><br><span class="line">              mArtManagerService.compileLayouts(pkg);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // checkProfiles is false to avoid merging profiles during boot which</span><br><span class="line">          // might interfere with background compilation (b/28612421).</span><br><span class="line">          // Unfortunately this will also means that &quot;pm.dexopt.boot=speed-profile&quot; will</span><br><span class="line">          // behave differently than &quot;pm.dexopt.bg-dexopt=speed-profile&quot; but that&apos;s a</span><br><span class="line">          // trade-off worth doing to save boot time work.</span><br><span class="line">          int dexoptFlags = bootComplete ? DexoptOptions.DEXOPT_BOOT_COMPLETE : 0;</span><br><span class="line">          if (compilationReason == REASON_FIRST_BOOT) &#123;</span><br><span class="line">              // TODO: This doesn&apos;t cover the upgrade case, we should check for this too.</span><br><span class="line">              dexoptFlags |= DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE;</span><br><span class="line">          &#125;</span><br><span class="line">          //执行dexopt操作</span><br><span class="line">          int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(</span><br><span class="line">                  pkg.packageName,</span><br><span class="line">                  pkgCompilationReason,</span><br><span class="line">                  dexoptFlags));</span><br><span class="line"></span><br><span class="line">          switch (primaryDexOptStaus) &#123;</span><br><span class="line">              case PackageDexOptimizer.DEX_OPT_PERFORMED:</span><br><span class="line">                  numberOfPackagesOptimized++;</span><br><span class="line">                  break;</span><br><span class="line">              case PackageDexOptimizer.DEX_OPT_SKIPPED:</span><br><span class="line">                  numberOfPackagesSkipped++;</span><br><span class="line">                  break;</span><br><span class="line">              case PackageDexOptimizer.DEX_OPT_FAILED:</span><br><span class="line">                  numberOfPackagesFailed++;</span><br><span class="line">                  break;</span><br><span class="line">              default:</span><br><span class="line">                  Log.e(TAG, &quot;Unexpected dexopt return code &quot; + primaryDexOptStaus);</span><br><span class="line">                  break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return new int[] &#123; numberOfPackagesOptimized, numberOfPackagesSkipped,</span><br><span class="line">              numberOfPackagesFailed &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-performFstrimIfNeeded"><a href="#3-3-performFstrimIfNeeded" class="headerlink" title="3.3 performFstrimIfNeeded"></a>3.3 performFstrimIfNeeded</h3><p>这个操作主要是用来清理磁盘碎片，条件是离上一次的清理的时间间隔3天。sm.runMaintenance方法调用的是StorageManagerService中的runMaintenance方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private static final long DEFAULT_MANDATORY_FSTRIM_INTERVAL = 3 * DateUtils.DAY_IN_MILLIS;</span><br><span class="line">@Override</span><br><span class="line">  public void performFstrimIfNeeded() &#123;</span><br><span class="line">      enforceSystemOrRoot(&quot;Only the system can request fstrim&quot;);</span><br><span class="line"></span><br><span class="line">      // Before everything else, see whether we need to fstrim.</span><br><span class="line">      try &#123;</span><br><span class="line">          IStorageManager sm = PackageHelper.getStorageManager();</span><br><span class="line">          if (sm != null) &#123;</span><br><span class="line">              boolean doTrim = false;</span><br><span class="line">              final long interval = android.provider.Settings.Global.getLong(</span><br><span class="line">                      mContext.getContentResolver(),</span><br><span class="line">                      android.provider.Settings.Global.FSTRIM_MANDATORY_INTERVAL,</span><br><span class="line">                      DEFAULT_MANDATORY_FSTRIM_INTERVAL);</span><br><span class="line">              //是否大于三天</span><br><span class="line">              if (interval &gt; 0) &#123;</span><br><span class="line">                  final long timeSinceLast = System.currentTimeMillis() - sm.lastMaintenance();</span><br><span class="line">                  if (timeSinceLast &gt; interval) &#123;</span><br><span class="line">                      doTrim = true;</span><br><span class="line">                      Slog.w(TAG, &quot;No disk maintenance in &quot; + timeSinceLast</span><br><span class="line">                              + &quot;; running immediately&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              if (doTrim) &#123;</span><br><span class="line">                  final boolean dexOptDialogShown;</span><br><span class="line">                  synchronized (mPackages) &#123;</span><br><span class="line">                      dexOptDialogShown = mDexOptDialogShown;</span><br><span class="line">                  &#125;</span><br><span class="line">                  if (!isFirstBoot() &amp;&amp; dexOptDialogShown) &#123;</span><br><span class="line">                      try &#123;</span><br><span class="line">                          ActivityManager.getService().showBootMessage(</span><br><span class="line">                                  mContext.getResources().getString(</span><br><span class="line">                                          R.string.android_upgrading_fstrim), true);</span><br><span class="line">                      &#125; catch (RemoteException e) &#123;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  //执行操作</span><br><span class="line">                  sm.runMaintenance();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              Slog.e(TAG, &quot;storageManager service unavailable!&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (RemoteException e) &#123;</span><br><span class="line">          // Can&apos;t happen; StorageManagerService is local</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// Binder entry point for kicking off an immediate fstrim</span><br><span class="line">   @Override</span><br><span class="line">   public void runMaintenance() &#123;</span><br><span class="line">       enforcePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);</span><br><span class="line">       runIdleMaintenance(null);</span><br><span class="line">   &#125;</span><br><span class="line">    @Override</span><br><span class="line">   public void fstrim(int flags, IVoldTaskListener listener) &#123;</span><br><span class="line">       enforcePermission(android.Manifest.permission.MOUNT_FORMAT_FILESYSTEMS);</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           mVold.fstrim(flags, new IVoldTaskListener.Stub() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onStatus(int status, PersistableBundle extras) &#123;</span><br><span class="line">                   dispatchOnStatus(listener, status, extras);</span><br><span class="line"></span><br><span class="line">                   // Ignore trim failures</span><br><span class="line">                   if (status != 0) return;</span><br><span class="line"></span><br><span class="line">                   final String path = extras.getString(&quot;path&quot;);</span><br><span class="line">                   final long bytes = extras.getLong(&quot;bytes&quot;);</span><br><span class="line">                   final long time = extras.getLong(&quot;time&quot;);</span><br><span class="line"></span><br><span class="line">                   final DropBoxManager dropBox = mContext.getSystemService(DropBoxManager.class);</span><br><span class="line">                   dropBox.addText(TAG_STORAGE_TRIM, scrubPath(path) + &quot; &quot; + bytes + &quot; &quot; + time);</span><br><span class="line"></span><br><span class="line">                   synchronized (mLock) &#123;</span><br><span class="line">                       final VolumeRecord rec = findRecordForPath(path);</span><br><span class="line">                       if (rec != null) &#123;</span><br><span class="line">                           rec.lastTrimMillis = System.currentTimeMillis();</span><br><span class="line">                           writeSettingsLocked();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               @Override</span><br><span class="line">               public void onFinished(int status, PersistableBundle extras) &#123;</span><br><span class="line">                   dispatchOnFinished(listener, status, extras);</span><br><span class="line"></span><br><span class="line">                   // TODO: benchmark when desired</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           throw e.rethrowAsRuntimeException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-systemReady"><a href="#3-4-systemReady" class="headerlink" title="3.4 systemReady"></a>3.4 systemReady</h3><p>系统初始化完成并且PKMS也初始化完成，PKMS需要进行的操作，如通知其他服务执行systemReady操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void systemReady() &#123;</span><br><span class="line">       enforceSystemOrRoot(&quot;Only the system can claim the system is ready&quot;);</span><br><span class="line"></span><br><span class="line">       mSystemReady = true;</span><br><span class="line">       final ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">       ContentObserver co = new ContentObserver(mHandler) &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onChange(boolean selfChange) &#123;</span><br><span class="line">               mWebInstantAppsDisabled =</span><br><span class="line">                       (Global.getInt(resolver, Global.ENABLE_EPHEMERAL_FEATURE, 1) == 0) ||</span><br><span class="line">                               (Secure.getInt(resolver, Secure.INSTANT_APPS_ENABLED, 1) == 0);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       mContext.getContentResolver().registerContentObserver(android.provider.Settings.Global</span><br><span class="line">                       .getUriFor(Global.ENABLE_EPHEMERAL_FEATURE),</span><br><span class="line">               false, co, UserHandle.USER_SYSTEM);</span><br><span class="line">       mContext.getContentResolver().registerContentObserver(android.provider.Settings.Secure</span><br><span class="line">                       .getUriFor(Secure.INSTANT_APPS_ENABLED), false, co, UserHandle.USER_SYSTEM);</span><br><span class="line">       co.onChange(true);</span><br><span class="line"></span><br><span class="line">       // Disable any carrier apps. We do this very early in boot to prevent the apps from being</span><br><span class="line">       // disabled after already being started.</span><br><span class="line">       CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), this,</span><br><span class="line">               mContext.getContentResolver(), UserHandle.USER_SYSTEM);</span><br><span class="line"></span><br><span class="line">       disableSkuSpecificApps();</span><br><span class="line"></span><br><span class="line">       // Read the compatibilty setting when the system is ready.</span><br><span class="line">       boolean compatibilityModeEnabled = android.provider.Settings.Global.getInt(</span><br><span class="line">               mContext.getContentResolver(),</span><br><span class="line">               android.provider.Settings.Global.COMPATIBILITY_MODE, 1) == 1;</span><br><span class="line">       PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled);</span><br><span class="line">       if (DEBUG_SETTINGS) &#123;</span><br><span class="line">           Log.d(TAG, &quot;compatibility mode:&quot; + compatibilityModeEnabled);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int[] grantPermissionsUserIds = EMPTY_INT_ARRAY;</span><br><span class="line"></span><br><span class="line">       synchronized (mPackages) &#123;</span><br><span class="line">           // Verify that all of the preferred activity components actually</span><br><span class="line">           // exist.  It is possible for applications to be updated and at</span><br><span class="line">           // that point remove a previously declared activity component that</span><br><span class="line">           // had been set as a preferred activity.  We try to clean this up</span><br><span class="line">           // the next time we encounter that preferred activity, but it is</span><br><span class="line">           // possible for the user flow to never be able to return to that</span><br><span class="line">           // situation so here we do a sanity check to make sure we haven&apos;t</span><br><span class="line">           // left any junk around.</span><br><span class="line">           ArrayList&lt;PreferredActivity&gt; removed = new ArrayList&lt;PreferredActivity&gt;();</span><br><span class="line">           for (int i=0; i&lt;mSettings.mPreferredActivities.size(); i++) &#123;</span><br><span class="line">               PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i);</span><br><span class="line">               removed.clear();</span><br><span class="line">               for (PreferredActivity pa : pir.filterSet()) &#123;</span><br><span class="line">                   if (mActivities.mActivities.get(pa.mPref.mComponent) == null) &#123;</span><br><span class="line">                       removed.add(pa);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (removed.size() &gt; 0) &#123;</span><br><span class="line">                   for (int r=0; r&lt;removed.size(); r++) &#123;</span><br><span class="line">                       PreferredActivity pa = removed.get(r);</span><br><span class="line">                       Slog.w(TAG, &quot;Removing dangling preferred activity: &quot;</span><br><span class="line">                               + pa.mPref.mComponent);</span><br><span class="line">                       pir.removeFilter(pa);</span><br><span class="line">                   &#125;</span><br><span class="line">                   mSettings.writePackageRestrictionsLPr(</span><br><span class="line">                           mSettings.mPreferredActivities.keyAt(i));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           for (int userId : UserManagerService.getInstance().getUserIds()) &#123;</span><br><span class="line">               if (!mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) &#123;</span><br><span class="line">                   grantPermissionsUserIds = ArrayUtils.appendInt(</span><br><span class="line">                           grantPermissionsUserIds, userId);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       sUserManager.systemReady();</span><br><span class="line">       // If we upgraded grant all default permissions before kicking off.</span><br><span class="line">       for (int userId : grantPermissionsUserIds) &#123;</span><br><span class="line">           mDefaultPermissionPolicy.grantDefaultPermissions(userId);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (grantPermissionsUserIds == EMPTY_INT_ARRAY) &#123;</span><br><span class="line">           // If we did not grant default permissions, we preload from this the</span><br><span class="line">           // default permission exceptions lazily to ensure we don&apos;t hit the</span><br><span class="line">           // disk on a new user creation.</span><br><span class="line">           mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Now that we&apos;ve scanned all packages, and granted any default</span><br><span class="line">       // permissions, ensure permissions are updated. Beware of dragons if you</span><br><span class="line">       // try optimizing this.</span><br><span class="line">       synchronized (mPackages) &#123;</span><br><span class="line">           mPermissionManager.updateAllPermissions(</span><br><span class="line">                   StorageManager.UUID_PRIVATE_INTERNAL, false, mPackages.values(),</span><br><span class="line">                   mPermissionCallback);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Kick off any messages waiting for system ready</span><br><span class="line">       if (mPostSystemReadyMessages != null) &#123;</span><br><span class="line">           for (Message msg : mPostSystemReadyMessages) &#123;</span><br><span class="line">               msg.sendToTarget();</span><br><span class="line">           &#125;</span><br><span class="line">           mPostSystemReadyMessages = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Watch for external volumes that come and go over time</span><br><span class="line">       final StorageManager storage = mContext.getSystemService(StorageManager.class);</span><br><span class="line">       storage.registerListener(mStorageListener);</span><br><span class="line"></span><br><span class="line">       mInstallerService.systemReady();</span><br><span class="line">       mDexManager.systemReady();</span><br><span class="line">       mPackageDexOptimizer.systemReady();</span><br><span class="line"></span><br><span class="line">       StorageManagerInternal StorageManagerInternal = LocalServices.getService(</span><br><span class="line">               StorageManagerInternal.class);</span><br><span class="line">       StorageManagerInternal.addExternalStoragePolicy(</span><br><span class="line">               new StorageManagerInternal.ExternalStorageMountPolicy() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public int getMountMode(int uid, String packageName) &#123;</span><br><span class="line">               if (Process.isIsolated(uid)) &#123;</span><br><span class="line">                   return Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">               &#125;</span><br><span class="line">               if (checkUidPermission(READ_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) &#123;</span><br><span class="line">                   return Zygote.MOUNT_EXTERNAL_DEFAULT;</span><br><span class="line">               &#125;</span><br><span class="line">               if (checkUidPermission(WRITE_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) &#123;</span><br><span class="line">                   return Zygote.MOUNT_EXTERNAL_READ;</span><br><span class="line">               &#125;</span><br><span class="line">               return Zygote.MOUNT_EXTERNAL_WRITE;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public boolean hasExternalStorage(int uid, String packageName) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       // Now that we&apos;re mostly running, clean up stale users and apps</span><br><span class="line">       sUserManager.reconcileUsers(StorageManager.UUID_PRIVATE_INTERNAL);</span><br><span class="line">       reconcileApps(StorageManager.UUID_PRIVATE_INTERNAL);</span><br><span class="line"></span><br><span class="line">       mPermissionManager.systemReady();</span><br><span class="line"></span><br><span class="line">       if (mInstantAppResolverConnection != null) &#123;</span><br><span class="line">           mContext.registerReceiver(new BroadcastReceiver() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">                   mInstantAppResolverConnection.optimisticBind();</span><br><span class="line">                   mContext.unregisterReceiver(this);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, new IntentFilter(Intent.ACTION_BOOT_COMPLETED));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-waitForAppDataPrepared"><a href="#3-5-waitForAppDataPrepared" class="headerlink" title="3.5  waitForAppDataPrepared"></a>3.5  waitForAppDataPrepared</h3><p>该方法主要是等待mPrepareAppDataFuture多线程的任务都处理完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void waitForAppDataPrepared() &#123;</span><br><span class="line">       if (mPrepareAppDataFuture == null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       ConcurrentUtils.waitForFutureNoInterrupt(mPrepareAppDataFuture, &quot;wait for prepareAppData&quot;);</span><br><span class="line">       mPrepareAppDataFuture = null;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  /**</span><br><span class="line">    * Waits if necessary for the computation to complete, and then retrieves its result.</span><br><span class="line">    * &lt;p&gt;If &#123;@code InterruptedException&#125; occurs, this method will interrupt the current thread</span><br><span class="line">    * and throw &#123;@code IllegalStateException&#125;&lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * @param future future to wait for result</span><br><span class="line">    * @param description short description of the operation</span><br><span class="line">    * @return the computed result</span><br><span class="line">    * @throws IllegalStateException if interrupted during wait</span><br><span class="line">    * @throws RuntimeException if an error occurs while waiting for &#123;@link Future#get()&#125;</span><br><span class="line">    * @see Future#get()</span><br><span class="line">    */</span><br><span class="line">   public static &lt;T&gt; T waitForFutureNoInterrupt(Future&lt;T&gt; future, String description) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           return future.get();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">           throw new IllegalStateException(description + &quot; interrupted&quot;);</span><br><span class="line">       &#125; catch (ExecutionException e) &#123;</span><br><span class="line">           throw new RuntimeException(description + &quot; failed&quot;, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、PKMS总结"><a href="#四、PKMS总结" class="headerlink" title="四、PKMS总结"></a>四、PKMS总结</h2><p>主要介绍了PKMS从SystemServer开始启动的相关流程，并详细介绍了流程相关的重要方法。PKMS初始化按照其代码的日志区分可以分为五个阶段，但从其功能上来说，可以分为三个阶段：</p>
<p>第一阶段：主要是扫描解析XML文件，并将其中的信息保存到特定的数据结构中，为下一阶段工作提供重要的参考信息；第二阶段：扫描各个目录下的APK，可以看到手机上apk，扫描的工作量就越大，系统启动速度也就越慢；                            第三阶段：主要是更新相关信息并启动PackageInstallerService服务。</p>
<p>PKMS构造函数工作任务非常繁重，特别是在扫描apk的时候。如果需要优化该流程以加快启动速度，则这个是一个好的方向。如延时扫描不重要的apk，或者保存Package信息到文件，然后启动时从文件中恢复这些信息以减少APK文件读取并解析xml的工作量。但是一直没有比较满意的方案，原因很多，比如apk之间有着比较多微妙的关系，因此到底延时扫描哪些apk，尚不能确定。还有一种方案是，PKMS可以启动多个线程扫描不同的目录，在android10.0中可以看到在扫描的时候已经启动多线程来扫描。对于PKMS的优化，Google基本上能想到基本上已经优化了，我们也可以思考。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>对于这些流程中有一些操作并没有详细的描述，由于篇幅有限将单独介绍。</p>
<p><a href="https://skytoby.github.io/2019/PKMS%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">PKMS相关类分析</a></p>
<p><a href="https://skytoby.github.io/2019/installd%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">installd守护进程</a></p>
<p><a href="https://skytoby.github.io/2019/fstrim/" target="_blank" rel="noopener">fstrim解析</a></p>
<p><a href="https://skytoby.github.io/2019/Android%20dex%EF%BC%8Codex%EF%BC%8Coat%EF%BC%8Cvdex%EF%BC%8Cart%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">Android dex，odex，oat，vdex，art文件结构</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/thh159/article/details/88289642" target="_blank" rel="noopener">https://blog.csdn.net/thh159/article/details/88289642</a></p>
<p><a href="https://www.jianshu.com/p/cbf8e73f41ed" target="_blank" rel="noopener">https://www.jianshu.com/p/cbf8e73f41ed</a></p>
<p><a href="https://blog.csdn.net/innost/article/details/47253179" target="_blank" rel="noopener">https://blog.csdn.net/innost/article/details/47253179</a></p>
<p><a href="https://blog.csdn.net/xiaosongluo/article/details/52014585" target="_blank" rel="noopener">https://blog.csdn.net/xiaosongluo/article/details/52014585</a></p>
<p><a href="https://blog.csdn.net/u013553529/article/details/61962439" target="_blank" rel="noopener">https://blog.csdn.net/u013553529/article/details/61962439</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="源码路径"><a href="#源码路径" class="headerlink" title="源码路径"></a><strong>源码路径</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/content/pm/PackageManager.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span><br><span class="line">frameworks/base/core/java/android/app/ApplicationPackageManager.java</span><br><span class="line">frameworks/base/core/java/android/content/pm/IPackageManager.aidl</span><br><span class="line">frameworks/base/services/java/com/android/server/SystemServer.java</span><br></pre></td></tr></table></figure>
<h3 id="LI、LIF、LPw、LPr的含义"><a href="#LI、LIF、LPw、LPr的含义" class="headerlink" title="LI、LIF、LPw、LPr的含义"></a>LI、LIF、LPw、LPr的含义</h3><p>PackageManagerService中方法名中LI、LIF、LPw、LPr的含义</p>
<p>PackageManagerService内部用两个锁，mInstallLock和mPackages。LI、LIF、LPw、LPr中的L,指的是Lock,而后米娜跟的是I和P两个锁，I表示mInstallLock同步锁，P表示mPackages同步锁。LPw、LPr中的w表示writing，r表示reading。LIF中的F表示Frozen.</p>
<p>mInstallLockt同步锁是指安装app的时候，对安装的处理要用synchronized保护起来，用于保护所有对installd的访问，installd通常包含对应用数据的繁重操作。</p>
<p>mPackages同步锁用来保护内存中已经解析的包信息以及其他相关状态。因为争抢mPackage锁的请求很多，只能短时间持有这个锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这种情况是允许的，因为mPackages处理完成之后，其他对mPackages操作的请求可以处理，不需要等待太久</span><br><span class="line">//由于mInstall的时间很长， synchronized (mPackages)比较快，不会对mInstallLock有很大影响</span><br><span class="line">synchronized (mInstallLock) &#123;</span><br><span class="line">       synchronized (mPackages) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //不允许，mInstall的时间很长，会导致mPackages锁住的时间变长</span><br><span class="line">  synchronized (mPackages) &#123;</span><br><span class="line">       synchronized (mInstallLock) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>  @GuardedBy注解，用于标记哪些变量要用同步锁保护起来。</p>
<p>PackageManagerService中的注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Keep track of all those APKs everywhere.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Internally there are two important locks:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link #mPackages&#125; is used to guard all in-memory parsed package details</span><br><span class="line"> * and other related state. It is a fine-grained lock that should only be held</span><br><span class="line"> * momentarily, as it&apos;s one of the most contended locks in the system.</span><br><span class="line"> * &lt;li&gt;&#123;@link #mInstallLock&#125; is used to guard all &#123;@code installd&#125; access, whose</span><br><span class="line"> * operations typically involve heavy lifting of application data on disk. Since</span><br><span class="line"> * &#123;@code installd&#125; is single-threaded, and it&apos;s operations can often be slow,</span><br><span class="line"> * this lock should never be acquired while already holding &#123;@link #mPackages&#125;.</span><br><span class="line"> * Conversely, it&apos;s safe to acquire &#123;@link #mPackages&#125; momentarily while already</span><br><span class="line"> * holding &#123;@link #mInstallLock&#125;.</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> * Many internal methods rely on the caller to hold the appropriate locks, and</span><br><span class="line"> * this contract is expressed through method name suffixes:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;fooLI(): the caller must hold &#123;@link #mInstallLock&#125;</span><br><span class="line"> * &lt;li&gt;fooLIF(): the caller must hold &#123;@link #mInstallLock&#125; and the package</span><br><span class="line"> * being modified must be frozen</span><br><span class="line"> * &lt;li&gt;fooLPr(): the caller must hold &#123;@link #mPackages&#125; for reading</span><br><span class="line"> * &lt;li&gt;fooLPw(): the caller must hold &#123;@link #mPackages&#125; for writing</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Because this class is very central to the platform&apos;s security; please run all</span><br><span class="line"> * CTS and unit tests whenever making modifications:</span><br><span class="line"> *</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * $ runtest -c android.content.pm.PackageManagerTests frameworks-core</span><br><span class="line"> * $ cts-tradefed run commandAndExit cts -m CtsAppSecurityHostTestCases</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="A-B（无缝）系统更新"><a href="#A-B（无缝）系统更新" class="headerlink" title="A/B（无缝）系统更新"></a>A/B（无缝）系统更新</h3><p><a href="https://source.android.google.cn/devices/tech/ota/ab" target="_blank" rel="noopener">A/B 系统更新</a>（也称为无缝更新）的目标是确保在<a href="https://source.android.google.cn/devices/tech/ota/index.html" target="_blank" rel="noopener">无线下载 (OTA) 更新</a>期间在磁盘上保留一个可正常启动和使用的系统。采用这种方式可以降低更新之后设备无法启动的可能性，这意味着用户需要将设备送到维修和保修中心进行更换和刷机的情况将会减少。其他某些商业级操作系统（例如 <a href="https://www.chromium.org/chromium-os" target="_blank" rel="noopener">ChromeOS</a>）也成功使用了 A/B 更新机制。</p>
<p>要详细了解 A/B 系统更新，请参见<a href="https://source.android.google.cn/devices/tech/ota/ab#slots" target="_blank" rel="noopener">分区选择（槽位）</a>一节。</p>
<p><strong>A/B 系统更新可带来以下好处**</strong>：</p>
<ul>
<li>OTA 更新可以在系统运行期间进行，而不会打断用户。用户可以在 OTA 期间继续使用其设备。在更新期间，唯一的一次宕机发生在设备重新启动到更新后的磁盘分区时。</li>
<li>更新后，重新启动所用的时间不会超过常规重新启动所用的时间。</li>
<li>如果 OTA 无法应用（例如，因为刷机失败），用户将不会受到影响。用户将继续运行旧的操作系统，并且客户端可以重新尝试进行更新。</li>
<li>如果 OTA 更新已应用但无法启动，设备将重新启动回旧分区，并且仍然可以使用。客户端可以重新尝试进行更新。</li>
<li>任何错误（例如 I/O 错误）都只会影响<strong>未使用</strong>的分区组，并且用户可以进行重试。由于 I/O 负载被特意控制在较低水平，以免影响用户体验，因此发生此类错误的可能性也会降低。</li>
<li>更新包可以流式传输到 A/B 设备，因此在安装之前不需要先下载更新包。流式更新意味着用户没有必要在 <code>/data</code> 或 <code>/cache</code> 上留出足够的可用空间来存储更新包。</li>
<li>缓存分区不再用于存储 OTA 更新包，因此无需确保缓存分区的大小要足以应对日后的更新。</li>
<li><a href="https://source.android.google.cn/security/verifiedboot/dm-verity.html" target="_blank" rel="noopener">dm-verity</a> 可保证设备将使用未损坏的启动映像。如果设备因 OTA 错误或 dm-verity 问题而无法启动，则可以重新启动到旧映像。（Android <a href="https://source.android.google.cn/security/verifiedboot/" target="_blank" rel="noopener">验证启动</a>不需要 A/B 更新。）</li>
</ul>
<p><strong>关于 A/B 系统更新</strong></p>
<p>进行 A/B 更新时，客户端和系统都需要进行更改。不过，OTA 更新包服务器应该不需要进行更改：更新包仍通过 HTTPS 提供。对于使用 Google OTA 基础架构的设备，系统更改全部是在 AOSP 中进行，并且客户端代码由 Google Play 服务提供。不使用 Google OTA 基础架构的原始设备制造商 (OEM) 将能够重复使用 AOSP 系统代码，但需要自行提供客户端。</p>
<p>如果 OEM 自行提供客户端，客户端需要：</p>
<ul>
<li>确定何时进行更新。由于 A/B 更新是在后台进行，因此不再需要由用户启动。为了避免干扰用户，建议将更新安排在设备处于闲时维护模式（如夜间）并已连接到 WLAN 网络时进行。不过，客户端可以使用您希望使用的任何启发法。</li>
<li>向 OTA 更新包服务器进行核查，确定是否有可用的更新。这应与您现有的客户端代码大体相同，不过您需要表明相应设备支持 A/B 更新。（Google 的客户端还包含<strong>立即检查</strong>按钮，以便用户检查是否有最新更新。）</li>
<li>调用 <code>update_engine</code>（使用 HTTPS 网址），以获取更新包（假设有可用的更新包）。<code>update_engine</code> 将在流式传输更新包的同时，在当前未使用的分区上更新原始数据块。</li>
<li>根据 <code>update_engine</code> 结果代码向您的服务器报告安装是成功了还是失败了。如果更新已成功应用，<code>update_engine</code> 将会告知引导加载程序在下次重新启动时启动到新的操作系统。如果新的操作系统无法启动，引导加载程序将会回退到旧的操作系统，因此无需在客户端执行任何操作。如果更新失败，客户端将需要根据详细的错误代码确定何时（以及是否）重试。例如，优秀的客户端能够识别出是一部分（“diff”）OTA 更新包失败，并改为尝试完整的 OTA 更新包。</li>
</ul>
<p>客户端可能会：</p>
<ul>
<li>显示通知，以提醒用户重新启动系统。如果您想要实施鼓励用户定期更新的政策，则可以将该通知添加到客户端。如果客户端不提示用户，用户将会在下次重新启动系统时收到更新。（Google 的客户端会有延迟，该延迟可按每次更新进行配置。）</li>
<li>显示通知，以告知用户他们是启动到了新的操作系统版本，还是应启动到新的操作系统版本，但却回退到了旧的操作系统版本。（Google 的客户端通常不会显示此类通知。）</li>
</ul>
<p>在系统方面，A/B 系统更新会影响以下各项：</p>
<ul>
<li>分区选择（槽位）、<code>update_engine</code> 守护进程，以及引导加载程序交互（如下所述）</li>
<li>编译过程和 OTA 更新包生成（如<a href="https://source.android.google.cn/devices/tech/ota/ab/ab_implement.html" target="_blank" rel="noopener">实现 A/B 更新</a>中所述）</li>
</ul>
<p><strong>注意</strong>：只有对于新设备，才建议通过 OTA 实现 A/B 系统更新。</p>
<p>分区选择（槽位）</p>
<p>A/B 系统更新使用两组称为槽位（通常是槽位 A 和槽位 B）的分区。系统从“当前”槽位运行，但在正常操作期间，运行中的系统不会访问未使用的槽位中的分区。这种方法通过将未使用的槽位保留为后备槽位，来防范更新出现问题：如果在更新期间或更新刚刚完成后出现错误，系统可以回滚到原来的槽位并继续正常运行。为了实现这一目标，当前槽位使用的任何分区（包括只有一个副本的分区）都不应在 OTA 更新期间进行更新。</p>
<p>每个槽位都有一个“可启动”属性，该属性用于表明相应槽位存储的系统正确无误，设备可从相应槽位启动。系统运行时，当前槽位处于可启动状态，但另一个槽位则可能包含旧版本（仍然正确）的系统、包含更新版本的系统，或包含无效的数据。无论当前槽位是哪一个，都有一个槽位是活动槽位（引导加载程序在下次启动时将使用的槽位，也称为首选槽位）。</p>
<p>此外，每个槽位还都有一个由用户空间设置的“成功”属性，仅当相应槽位处于可启动状态时，该属性才具有相关性。被标记为成功的槽位应该能够自行启动、运行和更新。未被标记为成功的可启动槽位（多次尝试使用它启动之后）应由引导加载程序标记为不可启动，其中包括将活动槽位更改为另一个可启动的槽位（通常是更改为在尝试启动到新的活动槽位之前正在运行的槽位）。关于相应接口的具体详细信息在 <code>boot_control.h</code> 中进行了定义。</p>
<p>更新引擎守护进程</p>
<p>A/B 系统更新过程会使用名为 <code>update_engine</code> 的后台守护进程来使系统做好准备，以启动到更新后的新版本。该守护进程可以执行以下操作：</p>
<ul>
<li>按照 OTA 更新包的指示，从当前槽位 A/B 分区读取数据，然后将所有数据写入到未使用槽位 A/B 分区。</li>
<li>在预定义的工作流程中调用 <code>boot_control</code> 接口。</li>
<li>按照 OTA 更新包的指示，在将数据写入到所有未使用槽位分区之后，从新分区运行安装后程序。（有关详细信息，请参阅<a href="https://source.android.google.cn/devices/tech/ota/ab#post-installation" target="_blank" rel="noopener">安装后</a>）。</li>
</ul>
<p>由于 <code>update_engine</code> 守护进程本身不会参与到启动流程中，因此该守护进程在更新期间可执行的操作受限于当前槽位中的 <a href="https://source.android.google.cn/security/selinux/" target="_blank" rel="noopener">SELinux</a> 政策和功能（在系统启动到新版本之前，此类政策和功能无法更新）。为了维持一个稳定可靠的系统，更新流程<strong>不应</strong>修改分区表、当前槽位中各个分区的内容，以及无法通过恢复出厂设置擦除的非 A/B 分区的内容。</p>
<p>更新引擎源代码</p>
<p><code>update_engine</code> 源代码位于 <code>system/update_engine</code> 中。A/B OTA dexopt 文件分开放到了 <code>installd</code> 和一个程序包管理器中：</p>
<ul>
<li><code>frameworks/native/cmds/installd/</code>ota* 包括安装后脚本、用于 chroot 的二进制文件、负责调用 dex2oat 的已安装克隆、OTA 后 move-artifacts 脚本，以及 move 脚本的 rc 文件。</li>
<li><code>frameworks/base/services/core/java/com/android/server/pm/OtaDexoptService.java</code>（加上 <code>OtaDexoptShellCommand</code>）是负责为应用准备 dex2oat 命令的程序包管理器。</li>
</ul>
<p>如需实际示例，请参阅 <code>/device/google/marlin/device-common.mk</code>。</p>
<p>更新引擎日志</p>
<p>对于 Android 8.x 及更低版本，可在 <code>logcat</code> 及错误报告中找到 <code>update_engine</code> 日志。要使 <code>update_engine</code> 日志可在文件系统中使用，请将以下更改添加到您的细分版本中：</p>
<ul>
<li><a href="https://android-review.googlesource.com/c/platform/system/update_engine/+/486618" target="_blank" rel="noopener">更改 486618</a></li>
<li><a href="https://android-review.googlesource.com/c/platform/system/core/+/529080" target="_blank" rel="noopener">更改 529080</a></li>
<li><a href="https://android-review.googlesource.com/c/platform/system/update_engine/+/529081" target="_blank" rel="noopener">更改 529081</a></li>
<li><a href="https://android-review.googlesource.com/c/platform/system/sepolicy/+/534660" target="_blank" rel="noopener">更改 534660</a></li>
<li><a href="https://android-review.googlesource.com/c/platform/system/update_engine/+/594637" target="_blank" rel="noopener">更改 594637</a></li>
</ul>
<p>这些更改会将最新的 <code>update_engine</code> 日志的副本保存到 <code>/data/misc/update_engine_log/update_engine.YEAR-TIME</code>。除当前日志以外，最近的五个日志也会保存在 <code>/data/misc/update_engine_log/</code> 下。拥有<strong>日志</strong>组 ID 的用户将能够访问相应的文件系统日志。</p>
<p><strong>引导加载程序交互</strong></p>
<p><code>boot_control</code> HAL 供 <code>update_engine</code>（可能还有其他守护进程）用于指示引导加载程序从何处启动。常见的示例情况及其相关状态包括：</p>
<ul>
<li><strong>正常情况</strong>：系统正在从其当前槽位（槽位 A 或槽位 B）运行。到目前为止尚未应用任何更新。系统的当前槽位是可启动且被标记为成功的活动槽位。</li>
<li><strong>正在更新</strong>：系统正在从槽位 B 运行，因此，槽位 B 是可启动且被标记为成功的活动槽位。由于槽位 A 中的内容正在更新，但是尚未完成，因此槽位 A 被标记为不可启动。在此状态下，应继续从槽位 B 重新启动。</li>
<li><strong>已应用更新，正在等待重新启动</strong>：系统正在从槽位 B 运行，槽位 B 可启动且被标记为成功，但槽位 A 之前被标记为活动槽位（因此现在被标记为可启动）。槽位 A 尚未被标记为成功，引导加载程序应尝试从槽位 A 启动若干次。</li>
<li><strong>系统已重新启动到新的更新</strong>：系统正在首次从槽位 A 运行，槽位 B 仍可启动且被标记为成功，而槽位 A 仅可启动，且仍是活动槽位，但未被标记为成功。在进行一些检查之后，用户空间守护进程 <code>update_verifier</code> 应将槽位 A 标记为成功。</li>
</ul>
<p>流式更新支持</p>
<p>用户设备并非在 <code>/data</code> 上总是有足够的空间来下载更新包。由于 OEM 和用户都不想浪费 <code>/cache</code> 分区上的空间，因此有些用户会因为设备上没有空间来存储更新包而不进行更新。为了解决这个问题，Android 8.0 中添加了对流式 A/B 更新（下载数据块后直接将数据块写入 B 分区，而无需将数据块存储在 <code>/data</code> 上）的支持。流式 A/B 更新几乎不需要临时存储空间，并且只需要能够存储大约 100KiB 元数据的存储空间即可。</p>
<p>要在 Android 7.1 中实现流式更新，请选择以下补丁程序：</p>
<ul>
<li><a href="https://android-review.googlesource.com/333624" target="_blank" rel="noopener">允许取消代理解析请求</a></li>
<li><a href="https://android-review.googlesource.com/333625" target="_blank" rel="noopener">解决在解析代理时会终止传输的问题</a></li>
<li><a href="https://android-review.googlesource.com/333626" target="_blank" rel="noopener">针对范围之间的 TerminateTransfer 添加单元测试</a></li>
<li><a href="https://android-review.googlesource.com/333627" target="_blank" rel="noopener">清理 RetryTimeoutCallback()</a></li>
</ul>
<p>无论是使用 <a href="https://www.android.com/gms/" target="_blank" rel="noopener">Google 移动服务 (GMS)</a>，还是使用任何其他更新客户端，都需要安装这些补丁程序，才能在 Android 7.1 中支持流式传输 A/B 更新包。</p>
<p>A/B 更新过程</p>
<p>当有 OTA 更新包（在代码中称为有效负载）可供下载时，更新流程便开始了。设备中的政策可以根据电池电量、用户活动、充电状态或其他政策来延迟下载和应用有效负载。此外，由于更新是在后台运行，因此用户可能并不知道正在进行更新。所有这些都意味着，更新流程可能随时会由于政策、意外重新启动或用户操作而中断。</p>
<p>OTA 更新包本身所含的元数据可能会指示可进行流式更新，在这种情况下，相应更新包也可采用非流式安装方式。服务器可以利用这些元数据告诉客户端正在进行流式更新，以便客户端正确地将 OTA 移交给 <code>update_engine</code>。如果设备制造商具有自己的服务器和客户端，便可以通过确保以下两项来实现流式更新：确保服务器能够识别出更新是流式更新（或假定所有更新都是流式更新），并确保客户端能够正确调用 <code>update_engine</code> 来进行流式更新。制造商可以根据更新包是流式更新变体这一事实向客户端发送一个标记，以便在进行流式更新时触发向框架端的移交工作。</p>
<p>有可用的有效负载后，更新流程将遵循如下步骤：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>通过 <code>markBootSuccessful()</code> 将当前槽位（或“源槽位”）标记为成功（如果尚未标记）。</td>
</tr>
<tr>
<td>2</td>
<td>调用函数 <code>setSlotAsUnbootable()</code>，将未使用的槽位（或“目标槽位”）标记为不可启动。当前槽位始终会在更新开始时被标记为成功，以防止引导加载程序回退到未使用的槽位（该槽位中很快将会有无效数据）。如果系统已做好准备，可以开始应用更新，那么即使其他主要组件出现损坏（例如界面陷入崩溃循环），当前槽位也会被标记为成功，因为可以通过推送新软件来解决这些问题。   更新有效负载是不透明的 Blob，其中包含更新到新版本的指示。更新有效负载由以下部分组成：元数据。元数据在更新有效负载中所占的比重相对较小，其中包含一系列用于在目标槽位上生成和验证新版本的操作。例如，某项操作可能会解压缩特定 Blob 并将其写入到目标分区中的特定块，或者从源分区读取数据、应用二进制补丁程序，然后写入到目标分区中的特定块。额外数据。与操作相关的额外数据在更新有效负载中占据了大部分比重，其中包含这些示例中的已压缩 Blob 或二进制补丁程序。</td>
</tr>
<tr>
<td>3</td>
<td>下载有效负载元数据。</td>
</tr>
<tr>
<td>4</td>
<td>对于元数据中定义的每项操作，都将按顺序发生以下行为：将相关数据（如果有）下载到内存中、应用操作，然后释放关联的内存。</td>
</tr>
<tr>
<td>5</td>
<td>对照预期的哈希重新读取并验证所有分区。</td>
</tr>
<tr>
<td>6</td>
<td>运行安装后步骤（如果有）。如果在执行任何步骤期间出现错误，则更新失败，系统可能会通过其他有效负载重新尝试更新。如果上述所有步骤均已成功完成，则更新成功，系统会执行最后一个步骤。</td>
</tr>
<tr>
<td>7</td>
<td>调用 <code>setActiveBootSlot()</code>，将未使用的槽位标记为活动槽位。将未使用的槽位标记为活动槽位并不意味着它将完成启动。如果引导加载程序（或系统本身）未读取到“成功”状态，则可以将活动槽位切换回来。</td>
</tr>
<tr>
<td>8</td>
<td>安装后步骤（如下所述）包括从“新更新”版本中运行仍在旧版本中运行的程序。如果此步骤已在 OTA 更新包中定义，则为<strong>强制性</strong>步骤，且程序必须返回并显示退出代码 <code>0</code>，否则更新会失败。</td>
</tr>
<tr>
<td>9</td>
<td>在系统足够深入地成功启动到新槽位并完成重新启动后检查之后，系统会调用 <code>markBootSuccessful()</code>，将现在的当前槽位（原“目标槽位”）标记为成功。</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：第 3 步和第 4 步占用了大部分更新时间，因为这两个步骤涉及写入和下载大量数据，并且可能会因政策或重新启动等原因而中断。</p>
<p>安装后</p>
<p>对于定义了安装后步骤的每个分区，<code>update_engine</code> 都会将新分区装载到特定位置，并执行与装载的分区相关的 OTA 中指定的程序。例如，如果安装后程序被定义为相应系统分区中的 <code>usr/bin/postinstall</code>，则系统会将未使用槽位中的这个分区装载到一个固定位置（例如 <code>/postinstall_mount</code>），然后执行 <code>/postinstall_mount/usr/bin/postinstall</code> 命令。</p>
<p>为确保成功执行安装后步骤，旧内核必须能够：</p>
<ul>
<li><strong>装载新的文件系统格式</strong>。文件系统类型不能更改（除非旧内核中支持这么做），包括使用的压缩算法（如果使用 SquashFS 等经过压缩的文件系统）等详细信息。</li>
<li><strong>理解新分区的安装后程序格式</strong>。如果使用可执行且可链接格式 (ELF) 的二进制文件，则该文件应该与旧内核兼容（例如，如果架构从 32 位细分版本改为使用 64 位细分版本，则 64 位的新程序应该可以在旧的 32 位内核上运行）。除非加载程序 (<code>ld</code>) 收到使用其他路径或编译静态二进制文件的指令，否则将会从旧系统映像而非新系统映像加载各种库。</li>
</ul>
<p>例如，您可以使用 shell 脚本作为安装后程序（由旧系统中顶部包含 <code>#!</code> 标记的 shell 二进制文件解析），然后从新环境设置库路径，以便执行更复杂的二进制安装后程序。或者，您可以从专用的较小分区执行安装后步骤，以便主系统分区中的文件系统格式可以得到更新，同时不会产生向后兼容问题或引发 stepping-stone 更新；这样一来，用户便可以从出厂映像直接更新到最新版本。</p>
<p>新的安装后程序将受旧系统中定义的 SELinux 政策限制。因此，安装后步骤适用于在指定设备上执行设计所要求的任务或其他需要尽可能完成的任务（例如，更新支持 A/B 更新的固件或引导加载程序、为新版本准备数据库副本，等等）。安装后步骤<strong>不适用于</strong>重新启动之前的一次性错误修复（此类修复需要无法预见的权限）。</p>
<p>所选的安装后程序在 <code>postinstall</code> SELinux 环境中运行。新装载的分区中的所有文件都将带有 <code>postinstall_file</code> 标记，无论在重新启动到新系统后它们的属性如何，都是如此。在新系统中对 SELinux 属性进行的更改不会影响安装后步骤。如果安装后程序需要额外的权限，则必须将这些权限添加到安装后环境中。</p>
<p>重新启动后</p>
<p>重新启动后，<code>update_verifier</code> 会触发利用 dm-verity 进行完整性检查。系统会先启动该检查，然后再启动 zygote，以避免 Java 服务进行任何无法撤消且会导致无法进行安全回滚的更改。在此过程中，如果验证启动功能或 dm-verity 检测到任何损坏，引导加载程序和内核还可能会触发重新启动。检查完成后，<code>update_verifier</code> 会将启动标记为成功。</p>
<p><code>update_verifier</code> 只会读取 <code>/data/ota_package/care_map.txt</code>（在使用 AOSP 代码时，该文件会包含在 A/B OTA 更新包中）中列出的数据块。Java 系统更新客户端（例如 GmsCore）会在重新启动设备前提取 <code>care_map.txt</code> 并设置访问权限，在系统成功启动到新版本后会删除所提取的文件。</p>

      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PackageManagerService/" rel="tag">#PackageManagerService</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/PKMS相关类分析/" rel="next" title="PKMS相关类分析">
                <i class="fa fa-chevron-left"></i> PKMS相关类分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/android系统编译/" rel="prev" title="android系统编译方法">
                android系统编译方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、PakageManagerService概述"><span class="nav-text">一、PakageManagerService概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-作用"><span class="nav-text">1.1  作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-PKMS类关系"><span class="nav-text">1.2 PKMS类关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-PKMS类成员"><span class="nav-text">1.3  PKMS类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-PKMS启动流程"><span class="nav-text">1.4 PKMS启动流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、PKMS-main"><span class="nav-text">二、PKMS.main</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-PMS-START"><span class="nav-text">2.1  PMS_START</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-new-Settings"><span class="nav-text">2.1.1 new Settings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-addSharedUserLPw"><span class="nav-text">2.1.2  addSharedUserLPw</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-SystemConfig-getInstance"><span class="nav-text">2.1.3  SystemConfig.getInstance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-readLPw"><span class="nav-text">2.1.4 readLPw</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-PMS-SYSTEM-SCAN-START"><span class="nav-text">2.2  PMS_SYSTEM_SCAN_START</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-PackageParser-Package"><span class="nav-text">2.2.1 PackageParser.Package</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-scanDirTracedLI"><span class="nav-text">2.2.2 scanDirTracedLI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-PMS-DATA-SCAN-START"><span class="nav-text">2.3 PMS_DATA_SCAN_START</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-PMS-SCAN-END"><span class="nav-text">2.4 PMS_SCAN_END</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-PMS-READY"><span class="nav-text">2.5  PMS_READY</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、PKMS操作"><span class="nav-text">三、PKMS操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-getPackageManager"><span class="nav-text">3.1 getPackageManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-updatePackagesIfNeeded"><span class="nav-text">3.2 updatePackagesIfNeeded</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-performFstrimIfNeeded"><span class="nav-text">3.3 performFstrimIfNeeded</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-systemReady"><span class="nav-text">3.4 systemReady</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-waitForAppDataPrepared"><span class="nav-text">3.5  waitForAppDataPrepared</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、PKMS总结"><span class="nav-text">四、PKMS总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后记"><span class="nav-text">后记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码路径"><span class="nav-text">源码路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LI、LIF、LPw、LPr的含义"><span class="nav-text">LI、LIF、LPw、LPr的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-B（无缝）系统更新"><span class="nav-text">A/B（无缝）系统更新</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2019/PackageManagerService启动流程分析/';
      var disqus_title = "PackageManagerService启动流程分析";
      var disqus_url = 'http://zproo.github.io/2019/PackageManagerService启动流程分析/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
