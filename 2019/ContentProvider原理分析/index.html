<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="ContentProvider,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="基于Android10.0，分析ContentProvider原理  一、概述ContentProvider用于提供数据的统一访问格式，封装具体的实现。对于数据的使用无需知道是数据库、文件、网络，只需要使用ContentProvider的数据操作接口，即增（insert）删（delete）改（update）查（query）。 1.1 ContentProviderContentProvider作">
<meta name="keywords" content="ContentProvider">
<meta property="og:type" content="article">
<meta property="og:title" content="ContentProvider原理分析">
<meta property="og:url" content="http://zproo.github.io/2019/ContentProvider原理分析/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="基于Android10.0，分析ContentProvider原理  一、概述ContentProvider用于提供数据的统一访问格式，封装具体的实现。对于数据的使用无需知道是数据库、文件、网络，只需要使用ContentProvider的数据操作接口，即增（insert）删（delete）改（update）查（query）。 1.1 ContentProviderContentProvider作">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2019/ContentProvider原理分析/contentprovider类图.jpg">
<meta property="og:image" content="http://zproo.github.io/2019/ContentProvider原理分析/ContentProvider.jpg">
<meta property="og:image" content="http://zproo.github.io/2019/ContentProvider原理分析/providerno.jpg">
<meta property="og:image" content="http://zproo.github.io/2019/ContentProvider原理分析/provideryes.jpg">
<meta property="og:updated_time" content="2019-12-28T06:30:13.606Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ContentProvider原理分析">
<meta name="twitter:description" content="基于Android10.0，分析ContentProvider原理  一、概述ContentProvider用于提供数据的统一访问格式，封装具体的实现。对于数据的使用无需知道是数据库、文件、网络，只需要使用ContentProvider的数据操作接口，即增（insert）删（delete）改（update）查（query）。 1.1 ContentProviderContentProvider作">
<meta name="twitter:image" content="http://zproo.github.io/2019/ContentProvider原理分析/contentprovider类图.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2019/ContentProvider原理分析/">

  <title> ContentProvider原理分析 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/ContentProvider/" rel="tag" title="ContentProvider">ContentProvider</a>
      
      </div>
      <h1>ContentProvider原理分析</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2019-09-10T21:25:23+08:00" content="2019-09-10" title="2019-09-10 21:25:23">
          2019-09-10
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ContentProvider原理分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-09-10T21:25:23+08:00" content="2019-09-10">
              2019-09-10
            </time>
          </span>

          

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/ContentProvider原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/ContentProvider原理分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>基于Android10.0，分析ContentProvider原理</p>
</blockquote>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>ContentProvider用于提供数据的统一访问格式，封装具体的实现。对于数据的使用无需知道是数据库、文件、网络，只需要使用ContentProvider的数据操作接口，即增（insert）删（delete）改（update）查（query）。</p>
<h3 id="1-1-ContentProvider"><a href="#1-1-ContentProvider" class="headerlink" title="1.1 ContentProvider"></a>1.1 ContentProvider</h3><p>ContentProvider作为四大组件之一，没有Activity复杂的生命周期，只有简单的onCreate过程。ContentProvider是一个抽象类，当实现自己的ContentProvider类，需要继承ContentProvider，并且实现下面6个抽象即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert(Uri, ContentValues)：插入新数据；</span><br><span class="line">delete(Uri, String, String[])：删除已有数据；</span><br><span class="line">update(Uri, ContentValues, String, String[])：更新数据；</span><br><span class="line">query(Uri, String[], String, String[], String)：查询数据；</span><br><span class="line">onCreate()：执行初始化工作；</span><br><span class="line">getType(Uri)：获取数据MIME类型。</span><br></pre></td></tr></table></figure>
<p>Uri数据格式如下：<code>content://com.skytoby.articles/android/1</code></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>对应项</th>
</tr>
</thead>
<tbody>
<tr>
<td>前缀</td>
<td>默认的固定开头格式</td>
<td>content://</td>
</tr>
<tr>
<td>授权</td>
<td>唯一表示provider</td>
<td>com.skytoby.articles</td>
</tr>
<tr>
<td>路径</td>
<td>数据类别以及数据项</td>
<td>/android/1</td>
</tr>
</tbody>
</table>
<h3 id="1-2-ContentResolver"><a href="#1-2-ContentResolver" class="headerlink" title="1.2 ContentResolver"></a>1.2 ContentResolver</h3><p>其他进程想要操作ContentProvider，需要获取其对应的ContentResolver，利用ContentResolver类完成对数据的增删改查操作，下面列举一个查询的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取ContentResolver</span><br><span class="line">ContentResolver cr = getContentResolver();  </span><br><span class="line">Uri uri = Uri.parse(&quot;content://com.skytoby.articles/android/1&quot;);</span><br><span class="line">Cursor cursor = cr.query(uri, null, null, null, null);  //执行查询操作</span><br><span class="line">...</span><br><span class="line">cursor.close(); //关闭</span><br></pre></td></tr></table></figure>
<h3 id="1-3-类图"><a href="#1-3-类图" class="headerlink" title="1.3  类图"></a>1.3  类图</h3><p><img src="/2019/ContentProvider原理分析/contentprovider类图.jpg" alt="contentprovider类图"></p>
<p>CPP和CPN是Binder通信的C/S两端</p>
<p>ACR（ApplicationContentResolver）继承于ContentResolver，是ContextImpl的内部类，ACR的实现通过调用其成员变量mMainThread来实现。</p>
<h3 id="1-4-重要成员变量"><a href="#1-4-重要成员变量" class="headerlink" title="1.4 重要成员变量"></a>1.4 重要成员变量</h3><table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">成员变量</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AMS</td>
<td style="text-align:left">CONTENT_PROVIDER_PUBLISH_TIMEOUT</td>
<td style="text-align:left">默认值为10s</td>
</tr>
<tr>
<td style="text-align:left">AMS</td>
<td style="text-align:left">mProviderMap</td>
<td style="text-align:left">记录所有contentProvider</td>
</tr>
<tr>
<td style="text-align:left">AMS</td>
<td style="text-align:left">mLaunchingProviders</td>
<td style="text-align:left">记录存在客户端等待publish的ContentProviderRecord</td>
</tr>
<tr>
<td style="text-align:left">PR</td>
<td style="text-align:left">pubProviders</td>
<td style="text-align:left">该进程创建的ContentProviderRecord</td>
</tr>
<tr>
<td style="text-align:left">PR</td>
<td style="text-align:left">conProviders</td>
<td style="text-align:left">该进程使用的ContentProviderConnection</td>
</tr>
<tr>
<td style="text-align:left">AT</td>
<td style="text-align:left">mLocalProviders</td>
<td style="text-align:left">记录所有本地的ContentProvider，以IBinder以key</td>
</tr>
<tr>
<td style="text-align:left">AT</td>
<td style="text-align:left">mLocalProvidersByName</td>
<td style="text-align:left">记录所有本地的ContentProvider，以组件名为key</td>
</tr>
<tr>
<td style="text-align:left">AT</td>
<td style="text-align:left">mProviderMap</td>
<td style="text-align:left">记录该进程的contentProvider</td>
</tr>
<tr>
<td style="text-align:left">AT</td>
<td style="text-align:left">mProviderRefCountMap</td>
<td style="text-align:left">记录所有对其他进程中的ContentProvider的引用计数</td>
</tr>
</tbody>
</table>
<ul>
<li><code>CONTENT_PROVIDER_PUBLISH_TIMEOUT</code>(10s): provider所在进程发布其ContentProvider的超时时长为10s，超过10s则会系统所杀;</li>
<li><code>mProviderMap</code>： AMS和AT都有一个同名的成员变量, AMS的数据类型为ProviderMap,而AT则是以ProviderKey为key的ArrayMap类型;</li>
<li><code>mLaunchingProviders</code>：记录的每一项是一个ContentProviderRecord对象, 所有的存在client等待其发布完成的contentProvider列表，一旦发布完成则相应的contentProvider便会从该列表移除；</li>
<li>PR:ProcessRecord, AT: ActivityThread；</li>
<li><code>mLocalProviders</code>和<code>mLocalProvidersByName</code>：都是用于记录所有本地的ContentProvider,不同的只是key。</li>
</ul>
<h3 id="1-5-query流程图"><a href="#1-5-query流程图" class="headerlink" title="1.5 query流程图"></a>1.5 query流程图</h3><p><img src="/2019/ContentProvider原理分析/ContentProvider.jpg" alt="ContentProvider"></p>
<h2 id="二、发布ContentProvider"><a href="#二、发布ContentProvider" class="headerlink" title="二、发布ContentProvider"></a>二、发布ContentProvider</h2><p>通过ContentProvider共享数据时，需要编写一个类继承ContentProvier，创建数据库，并在AndroidManifest声明该Provider，这样其他的进行就可以通过ContentResolver去查询共享的信息。先来看一下应用时如何发布ContentProvider，提供给其他应用使用。ContentProvider一般是在应用进程启动的时候启动，是四大组件中最早启动的。进程的启动在四大组件与进程启动那里有详细的分析。</p>
<p>发布ContentProvider分两种情况：Provider进程未启动，Provider进程已经启动但未发布。</p>
<ul>
<li><p>Provider进程未启动</p>
<p>systemserver进程调用startProcessLocked创建provider进程，并attach到systemserver后，通过binder机制到Provider进程执行bindApplication方法，见2.1节。</p>
</li>
<li><p>Provider进程已经启动但未发布</p>
<p>如果发现provider进程已经存在且attach到systemserver，但对应的provider还没有发布，</p>
<p>则通过binder机制到provider进程执行scheduleInstallProvider方法，见2.7节。</p>
<p>这两种情况最后都会走到installProvider这个方法。</p>
</li>
</ul>
<h3 id="2-1-Provider进程未启动"><a href="#2-1-Provider进程未启动" class="headerlink" title="2.1 Provider进程未启动"></a>2.1 Provider进程未启动</h3><h4 id="2-1-1-AT-bindApplication"><a href="#2-1-1-AT-bindApplication" class="headerlink" title="2.1.1  AT.bindApplication"></a>2.1.1  AT.bindApplication</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">              List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">              ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">              IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">              IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">              boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">              boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">              CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="line">              String buildSerial, boolean autofillCompatibilityEnabled) &#123;</span><br><span class="line">              </span><br><span class="line">          AppBindData data = new AppBindData();</span><br><span class="line">          data.processName = processName;</span><br><span class="line">          data.appInfo = appInfo;</span><br><span class="line">          //provider</span><br><span class="line">          data.providers = providers;</span><br><span class="line">          ...</span><br><span class="line">          sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>发送BIND_APPLICATION消息到主线程。</p>
<h4 id="2-1-2-AT-handleMessage"><a href="#2-1-2-AT-handleMessage" class="headerlink" title="2.1.2  AT.handleMessage"></a>2.1.2  AT.handleMessage</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">           if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">           switch (msg.what) &#123;</span><br><span class="line">               case BIND_APPLICATION:</span><br><span class="line">                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">                   AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                   handleBindApplication(data);</span><br><span class="line">                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>主线程收到BIND_APPLICATION后，执行handleBindApplication方法。</p>
<h4 id="2-1-3-AT-handleMessage"><a href="#2-1-3-AT-handleMessage" class="headerlink" title="2.1.3  AT.handleMessage"></a>2.1.3  AT.handleMessage</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">        </span><br><span class="line">       // send up app name; do this *before* waiting for debugger</span><br><span class="line">       //设置进程名</span><br><span class="line">       Process.setArgV0(data.processName);</span><br><span class="line">       android.ddm.DdmHandleAppName.setAppName(data.processName,</span><br><span class="line">                                               UserHandle.myUserId());</span><br><span class="line">       VMRuntime.setProcessPackageName(data.appInfo.packageName);</span><br><span class="line">       ...</span><br><span class="line">       // Allow disk access during application and provider setup. This could</span><br><span class="line">       // block processing ordered broadcasts, but later processing would</span><br><span class="line">       // probably end up doing the same disk access.</span><br><span class="line">       Application app;</span><br><span class="line">       final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">       final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();</span><br><span class="line">       try &#123;</span><br><span class="line">       </span><br><span class="line">           // If the app is being launched for full backup or restore, bring it up in</span><br><span class="line">           // a restricted environment with the base application class.</span><br><span class="line">           //实例化Application,会调用attachBaseContext方法</span><br><span class="line">           app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">           </span><br><span class="line">           // Propagate autofill compat state</span><br><span class="line">           app.setAutofillCompatibilityEnabled(data.autofillCompatibilityEnabled);</span><br><span class="line">           mInitialApplication = app;</span><br><span class="line">           //不是限制备份模式</span><br><span class="line">           // don&apos;t bring up providers in restricted mode; they may depend on the</span><br><span class="line">           // app&apos;s custom Application class</span><br><span class="line">           if (!data.restrictedBackupMode) &#123;</span><br><span class="line">               if (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                   //安装ContentProvider，见2.4节</span><br><span class="line">                   installContentProviders(app, data.providers);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           try &#123;</span><br><span class="line">               //调用Application的onCreate方法</span><br><span class="line">               mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                   throw new RuntimeException(</span><br><span class="line">                     &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                     + &quot;: &quot; + e.toString(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       // 加载字体资源</span><br><span class="line">       // Preload fonts resources</span><br><span class="line">       FontsContract.setApplicationContextForResources(appContext);</span><br><span class="line">       if (!Process.isIsolated()) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               final ApplicationInfo info =</span><br><span class="line">                       getPackageManager().getApplicationInfo(</span><br><span class="line">                               data.appInfo.packageName,</span><br><span class="line">                               PackageManager.GET_META_DATA /*flags*/,</span><br><span class="line">                               UserHandle.myUserId());</span><br><span class="line">               if (info.metaData != null) &#123;</span><br><span class="line">                   final int preloadedFontsResource = info.metaData.getInt(</span><br><span class="line">                           ApplicationInfo.METADATA_PRELOADED_FONTS, 0);</span><br><span class="line">                   if (preloadedFontsResource != 0) &#123;</span><br><span class="line">                       data.info.getResources().preloadFonts(preloadedFontsResource);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (RemoteException e) &#123;</span><br><span class="line">               throw e.rethrowFromSystemServer();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4-AT-installContentProviders"><a href="#2-1-4-AT-installContentProviders" class="headerlink" title="2.1.4  AT.installContentProviders"></a>2.1.4  AT.installContentProviders</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">    private void installContentProviders(</span><br><span class="line">            Context context, List&lt;ProviderInfo&gt; providers) &#123;</span><br><span class="line">        final ArrayList&lt;ContentProviderHolder&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (ProviderInfo cpi : providers) &#123;</span><br><span class="line">            if (DEBUG_PROVIDER) &#123;</span><br><span class="line">                StringBuilder buf = new StringBuilder(128);</span><br><span class="line">                buf.append(&quot;Pub &quot;);</span><br><span class="line">                buf.append(cpi.authority);</span><br><span class="line">                buf.append(&quot;: &quot;);</span><br><span class="line">                buf.append(cpi.name);</span><br><span class="line">                Log.i(TAG, buf.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            //安装provider，见2.1.5节</span><br><span class="line">            ContentProviderHolder cph = installProvider(context, null, cpi,</span><br><span class="line">                    false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</span><br><span class="line">            if (cph != null) &#123;</span><br><span class="line">                cph.noReleaseNeeded = true;</span><br><span class="line">                results.add(cph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //发布provider见2.2.1节</span><br><span class="line">            ActivityManager.getService().publishContentProviders(</span><br><span class="line">                getApplicationThread(), results);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-5-AT-installProvider"><a href="#2-1-5-AT-installProvider" class="headerlink" title="2.1.5  AT.installProvider"></a>2.1.5  AT.installProvider</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">private ContentProviderHolder installProvider(Context context,</span><br><span class="line">          ContentProviderHolder holder, ProviderInfo info,</span><br><span class="line">          boolean noisy, boolean noReleaseNeeded, boolean stable) &#123;</span><br><span class="line">      ContentProvider localProvider = null;</span><br><span class="line">      IContentProvider provider;</span><br><span class="line">      if (holder == null || holder.provider == null) &#123;</span><br><span class="line">          if (DEBUG_PROVIDER || noisy) &#123;</span><br><span class="line">              Slog.d(TAG, &quot;Loading provider &quot; + info.authority + &quot;: &quot;</span><br><span class="line">                      + info.name);</span><br><span class="line">          &#125;</span><br><span class="line">          Context c = null;</span><br><span class="line">          ApplicationInfo ai = info.applicationInfo;</span><br><span class="line">          //赋值context</span><br><span class="line">          if (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">              c = context;</span><br><span class="line">          &#125; else if (mInitialApplication != null &amp;&amp;</span><br><span class="line">                  mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">              c = mInitialApplication;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  c = context.createPackageContext(ai.packageName,</span><br><span class="line">                          Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">              &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                  // Ignore</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          //无法获取context则直接返回</span><br><span class="line">          if (c == null) &#123;</span><br><span class="line">              Slog.w(TAG, &quot;Unable to get context for package &quot; +</span><br><span class="line">                    ai.packageName +</span><br><span class="line">                    &quot; while loading content provider &quot; +</span><br><span class="line">                    info.name);</span><br><span class="line">              return null;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (info.splitName != null) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  c = c.createContextForSplit(info.splitName);</span><br><span class="line">              &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">                  throw new RuntimeException(e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              final java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">              LoadedApk packageInfo = peekPackageInfo(ai.packageName, true);</span><br><span class="line">              if (packageInfo == null) &#123;</span><br><span class="line">                  // System startup case.</span><br><span class="line">                  packageInfo = getSystemContext().mPackageInfo;</span><br><span class="line">              &#125;</span><br><span class="line">              //通过反射，创建目标ContentProvider对象</span><br><span class="line">              localProvider = packageInfo.getAppFactory()</span><br><span class="line">                      .instantiateProvider(cl, info.name);</span><br><span class="line">              //获取contentprovider        </span><br><span class="line">              provider = localProvider.getIContentProvider();</span><br><span class="line">              if (provider == null) &#123;</span><br><span class="line">                  Slog.e(TAG, &quot;Failed to instantiate class &quot; +</span><br><span class="line">                        info.name + &quot; from sourceDir &quot; +</span><br><span class="line">                        info.applicationInfo.sourceDir);</span><br><span class="line">                  return null;</span><br><span class="line">              &#125;</span><br><span class="line">              if (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">                  TAG, &quot;Instantiating local provider &quot; + info.name);</span><br><span class="line">              // XXX Need to create the correct context for this provider.</span><br><span class="line">              //回调目标 ContentProvider.this.onCreate()方法</span><br><span class="line">              localProvider.attachInfo(c, info);</span><br><span class="line">          &#125; catch (java.lang.Exception e) &#123;</span><br><span class="line">              if (!mInstrumentation.onException(null, e)) &#123;</span><br><span class="line">                  throw new RuntimeException(</span><br><span class="line">                          &quot;Unable to get provider &quot; + info.name</span><br><span class="line">                          + &quot;: &quot; + e.toString(), e);</span><br><span class="line">              &#125;</span><br><span class="line">              return null;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          provider = holder.provider;</span><br><span class="line">          if (DEBUG_PROVIDER) Slog.v(TAG, &quot;Installing external provider &quot; + info.authority + &quot;: &quot;</span><br><span class="line">                  + info.name);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      //retHolder赋值，用于将contentProvider放入缓存</span><br><span class="line">      ContentProviderHolder retHolder;</span><br><span class="line"></span><br><span class="line">      synchronized (mProviderMap) &#123;</span><br><span class="line">          if (DEBUG_PROVIDER) Slog.v(TAG, &quot;Checking to add &quot; + provider</span><br><span class="line">                  + &quot; / &quot; + info.name);</span><br><span class="line">          IBinder jBinder = provider.asBinder();</span><br><span class="line">          if (localProvider != null) &#123;</span><br><span class="line">              ComponentName cname = new ComponentName(info.packageName, info.name);</span><br><span class="line">              ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">              if (pr != null) &#123;</span><br><span class="line">                  if (DEBUG_PROVIDER) &#123;</span><br><span class="line">                      Slog.v(TAG, &quot;installProvider: lost the race, &quot;</span><br><span class="line">                              + &quot;using existing local provider&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">                  provider = pr.mProvider;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  holder = new ContentProviderHolder(info);</span><br><span class="line">                  holder.provider = provider;</span><br><span class="line">                  holder.noReleaseNeeded = true;</span><br><span class="line">                  pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">                  mLocalProviders.put(jBinder, pr);</span><br><span class="line">                  mLocalProvidersByName.put(cname, pr);</span><br><span class="line">              &#125;</span><br><span class="line">              retHolder = pr.mHolder;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">              if (prc != null) &#123;</span><br><span class="line">                  if (DEBUG_PROVIDER) &#123;</span><br><span class="line">                      Slog.v(TAG, &quot;installProvider: lost the race, updating ref count&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">                  // We need to transfer our new reference to the existing</span><br><span class="line">                  // ref count, releasing the old one...  but only if</span><br><span class="line">                  // release is needed (that is, it is not running in the</span><br><span class="line">                  // system process).</span><br><span class="line">                  //不再需要则remove</span><br><span class="line">                  if (!noReleaseNeeded) &#123;</span><br><span class="line">                      incProviderRefLocked(prc, stable);</span><br><span class="line">                      try &#123;</span><br><span class="line">                          ActivityManager.getService().removeContentProvider(</span><br><span class="line">                                  holder.connection, stable);</span><br><span class="line">                      &#125; catch (RemoteException e) &#123;</span><br><span class="line">                          //do nothing content provider object is dead any way</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  ProviderClientRecord client = installProviderAuthoritiesLocked(</span><br><span class="line">                          provider, localProvider, holder);</span><br><span class="line">                  if (noReleaseNeeded) &#123;</span><br><span class="line">                      prc = new ProviderRefCount(holder, client, 1000, 1000);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      prc = stable</span><br><span class="line">                              ? new ProviderRefCount(holder, client, 1, 0)</span><br><span class="line">                              : new ProviderRefCount(holder, client, 0, 1);</span><br><span class="line">                  &#125;</span><br><span class="line">                  mProviderRefCountMap.put(jBinder, prc);</span><br><span class="line">              &#125;</span><br><span class="line">              retHolder = prc.holder;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return retHolder;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是通过反射获取获取contentprovider，并回调其onCreate方法，最后对ContentProviderHolder进行赋值并返回。</p>
<h4 id="2-1-6-AMS-publishContentProviders"><a href="#2-1-6-AMS-publishContentProviders" class="headerlink" title="2.1.6  AMS.publishContentProviders"></a>2.1.6  AMS.publishContentProviders</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public final void publishContentProviders(IApplicationThread caller,</span><br><span class="line">            List&lt;ContentProviderHolder&gt; providers) &#123;</span><br><span class="line">        if (providers == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        enforceNotIsolatedCaller(&quot;publishContentProviders&quot;);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final ProcessRecord r = getRecordForAppLocked(caller);</span><br><span class="line">            if (DEBUG_MU) Slog.v(TAG_MU, &quot;ProcessRecord uid = &quot; + r.uid);</span><br><span class="line">            if (r == null) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                      + &quot; (pid=&quot; + Binder.getCallingPid()</span><br><span class="line">                      + &quot;) when publishing content providers&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final long origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            final int N = providers.size();</span><br><span class="line">            for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">                ContentProviderHolder src = providers.get(i);</span><br><span class="line">                if (src == null || src.info == null || src.provider == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line">                if (DEBUG_MU) Slog.v(TAG_MU, &quot;ContentProviderRecord uid = &quot; + dst.uid);</span><br><span class="line">                if (dst != null) &#123;</span><br><span class="line">                    ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line">                    //将该provider添加到mProviderMap</span><br><span class="line">                    mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">                    String names[] = dst.info.authority.split(&quot;;&quot;);</span><br><span class="line">                    for (int j = 0; j &lt; names.length; j++) &#123;</span><br><span class="line">                        mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    int launchingCount = mLaunchingProviders.size();</span><br><span class="line">                    int j;</span><br><span class="line">                    boolean wasInLaunchingProviders = false;</span><br><span class="line">                    for (j = 0; j &lt; launchingCount; j++) &#123;</span><br><span class="line">                        if (mLaunchingProviders.get(j) == dst) &#123;</span><br><span class="line">                            mLaunchingProviders.remove(j);</span><br><span class="line">                            wasInLaunchingProviders = true;</span><br><span class="line">                            j--;</span><br><span class="line">                            launchingCount--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (wasInLaunchingProviders) &#123;</span><br><span class="line">                        //移除超时消息</span><br><span class="line">                        mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);</span><br><span class="line">                    &#125;</span><br><span class="line">                    synchronized (dst) &#123;</span><br><span class="line">                        dst.provider = src.provider;</span><br><span class="line">                        dst.proc = r;</span><br><span class="line">                        //唤醒客户端的wait等待方法</span><br><span class="line">                        dst.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //更新adj</span><br><span class="line">                    updateOomAdjLocked(r, true);</span><br><span class="line">                    maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                            src.info.authority);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ContentProviders一旦publish成功，则会移除超时发布的消息，并调用notifyAll来唤醒所有等待client端进程。</p>
<h3 id="2-2-Provider进程启动但未发布"><a href="#2-2-Provider进程启动但未发布" class="headerlink" title="2.2 Provider进程启动但未发布"></a>2.2 Provider进程启动但未发布</h3><p>下面在看下Provider进程未发布的情况，。。。。。。。。。。。。。。。。。。。。。。</p>
<h4 id="2-2-1-AT-scheduleInstallProvider"><a href="#2-2-1-AT-scheduleInstallProvider" class="headerlink" title="2.2.1  AT.scheduleInstallProvider"></a>2.2.1  AT.scheduleInstallProvider</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void scheduleInstallProvider(ProviderInfo provider) &#123;</span><br><span class="line">    sendMessage(H.INSTALL_PROVIDER, provider);</span><br><span class="line">&#125;</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">      ...</span><br><span class="line">      case INSTALL_PROVIDER:</span><br><span class="line">            handleInstallProvider((ProviderInfo) msg.obj);</span><br><span class="line">            break;</span><br><span class="line">      ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-AT-handleInstallProvider"><a href="#2-2-2-AT-handleInstallProvider" class="headerlink" title="2.2.2  AT.handleInstallProvider"></a>2.2.2  AT.handleInstallProvider</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void handleInstallProvider(ProviderInfo info) &#123;</span><br><span class="line">       final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">       try &#123;</span><br><span class="line">           installContentProviders(mInitialApplication, Arrays.asList(info));</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法之后就是2.1.4节的流程installContentProviders</p>
<h2 id="三、查询ContentResolver"><a href="#三、查询ContentResolver" class="headerlink" title="三、查询ContentResolver"></a>三、查询ContentResolver</h2><p>一般用ContentProvider的时候，会先得到ContentResolver，之后通过uri可以获取相应的信息，下面就从查询方法开始，分析这个过程的源码流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver contentResolver = getContentResolver();</span><br><span class="line">Uri uri = Uri.parse(&quot;content://com.skytoby.articles/android/1&quot;);</span><br><span class="line">Cursor cursor = contentResolver.query(uri, null, null, null, null);</span><br></pre></td></tr></table></figure>
<h3 id="3-1-CI-getContentResolver"><a href="#3-1-CI-getContentResolver" class="headerlink" title="3.1 CI.getContentResolver"></a>3.1 CI.getContentResolver</h3><p>[-&gt;ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ContentResolver getContentResolver() &#123;</span><br><span class="line">    return mContentResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ContextImpl(@Nullable ContextImpl container, @NonNull ActivityThread mainThread,</span><br><span class="line">        @NonNull LoadedApk packageInfo, @Nullable String splitName,</span><br><span class="line">        @Nullable IBinder activityToken, @Nullable UserHandle user, int flags,</span><br><span class="line">        @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mContentResolver = new ApplicationContentResolver(this, mainThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Context中调用getContentResolver，经过层层调用到ContextImpl，返回是在ContextImpl对象创建过程中完成赋值的。下面看下查询的操作。</p>
<h3 id="3-2-CR-query"><a href="#3-2-CR-query" class="headerlink" title="3.2 CR.query"></a>3.2 CR.query</h3><p>[-&gt;ContentResolver.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public final @Nullable Cursor query(@RequiresPermission.Read @NonNull Uri uri,</span><br><span class="line">        @Nullable String[] projection, @Nullable String selection,</span><br><span class="line">        @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123;</span><br><span class="line">    return query(uri, projection, selection, selectionArgs, sortOrder, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri,</span><br><span class="line">        @Nullable String[] projection, @Nullable Bundle queryArgs,</span><br><span class="line">        @Nullable CancellationSignal cancellationSignal) &#123;</span><br><span class="line">    Preconditions.checkNotNull(uri, &quot;uri&quot;);</span><br><span class="line">    //获取unstableProvider见3.3节</span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    if (unstableProvider == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IContentProvider stableProvider = null;</span><br><span class="line">    Cursor qCursor = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        long startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        ICancellationSignal remoteCancellationSignal = null;</span><br><span class="line">        if (cancellationSignal != null) &#123;</span><br><span class="line">            cancellationSignal.throwIfCanceled();</span><br><span class="line">            remoteCancellationSignal = unstableProvider.createCancellationSignal();</span><br><span class="line">            cancellationSignal.setRemote(remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            //执行查询操作</span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    queryArgs, remoteCancellationSignal);</span><br><span class="line">        &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">            // The remote process has died...  but we only hold an unstable</span><br><span class="line">            // reference though, so we might recover!!!  Let&apos;s try!!!!</span><br><span class="line">            // This is exciting!!1!!1!!!!1</span><br><span class="line">            //远程进程死亡，处理unstableProvider死亡过程</span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            //unstable类型死亡后，在创建stable类型的provider，见3.5节</span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            if (stableProvider == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //再次执行查询操作</span><br><span class="line">            qCursor = stableProvider.query(</span><br><span class="line">                    mPackageName, uri, projection, queryArgs, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        if (qCursor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //强制执行操作，可能会失败并抛出RuntimeException</span><br><span class="line">        // Force query execution.  Might fail and throw a runtime exception here.</span><br><span class="line">        qCursor.getCount();</span><br><span class="line">        long durationMillis = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">        maybeLogQueryToEventLog(durationMillis, uri, projection, queryArgs);</span><br><span class="line">      </span><br><span class="line">        //创建CursorWrapperInner对象</span><br><span class="line">        // Wrap the cursor object into CursorWrapperInner object.</span><br><span class="line">        final IContentProvider provider = (stableProvider != null) ? stableProvider</span><br><span class="line">                : acquireProvider(uri);</span><br><span class="line">        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);</span><br><span class="line">        stableProvider = null;</span><br><span class="line">        qCursor = null;</span><br><span class="line">        return wrapper;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // Arbitrary and not worth documenting, as Activity</span><br><span class="line">        // Manager will kill this process shortly anyway.</span><br><span class="line">        return null;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (qCursor != null) &#123;</span><br><span class="line">            qCursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        if (cancellationSignal != null) &#123;</span><br><span class="line">            cancellationSignal.setRemote(null);</span><br><span class="line">        &#125;</span><br><span class="line">        if (unstableProvider != null) &#123;</span><br><span class="line">            releaseUnstableProvider(unstableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">        if (stableProvider != null) &#123;</span><br><span class="line">            releaseProvider(stableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般获取unstable的Provider：调用acquireUnstableProvider，尝试获取unstable的ContentProvider；然后执行query操作</p>
<p>当执行query操作过程中抛出DeadObjectException，即ContentProvider所在的进程死亡，则尝试获取stable的ContentProvider:</p>
<p>1.先调用unstableProviderDied，清理刚创建的unstable的ContentProvider</p>
<p>2.调用acquireProvider，尝试获取stable的ContentProvider，此时当ContentProvider进程死亡，则会杀掉该ContentProvider的客户端进程；</p>
<p>3.执行query操作。</p>
<p>stable和unstable的区别：</p>
<p>采用unstable类型的ContentProvider的应用不会因为远程ContentProvider进程的死亡而被杀。</p>
<p>采用stable类型的ContentProvider的应用会因为远程ContentProvider进程的死亡而被杀。</p>
<p>对于应用无法决定创建的ContentProvider是stable还是unstable的，也无法知道自己的进程是否依赖于远程进程的生死。</p>
<h3 id="3-3-CR-acquireUnstableProvider"><a href="#3-3-CR-acquireUnstableProvider" class="headerlink" title="3.3 CR.acquireUnstableProvider"></a>3.3 CR.acquireUnstableProvider</h3><p>[-&gt;ContentResolver.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns the content provider for the given content URI.</span><br><span class="line">    *</span><br><span class="line">    * @param uri The URI to a content provider</span><br><span class="line">    * @return The ContentProvider for the given URI, or null if no content provider is found.</span><br><span class="line">    * @hide</span><br><span class="line">    */</span><br><span class="line">   public final IContentProvider acquireUnstableProvider(Uri uri) &#123;</span><br><span class="line">       if (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       String auth = uri.getAuthority();</span><br><span class="line">       if (auth != null) &#123;</span><br><span class="line">           //获取UnstableProvider,见3.4节</span><br><span class="line">           return acquireUnstableProvider(mContext, uri.getAuthority());</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-ACR-acquireUnstableProvider"><a href="#3-4-ACR-acquireUnstableProvider" class="headerlink" title="3.4 ACR.acquireUnstableProvider"></a>3.4 ACR.acquireUnstableProvider</h3><p>[-&gt;ContextImpl.java::ApplicationContentResolver]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static final class ApplicationContentResolver extends ContentResolver &#123;</span><br><span class="line">     ...</span><br><span class="line">    private static final class ApplicationContentResolver extends ContentResolver &#123;</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        private final ActivityThread mMainThread;</span><br><span class="line">        ...</span><br><span class="line">        //stable provider</span><br><span class="line">        @Override</span><br><span class="line">        @UnsupportedAppUsage</span><br><span class="line">        protected IContentProvider acquireProvider(Context context, String auth) &#123;</span><br><span class="line">            return mMainThread.acquireProvider(context,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), true);</span><br><span class="line">        &#125;</span><br><span class="line">        //unstable provider</span><br><span class="line">        @Override</span><br><span class="line">        protected IContentProvider acquireUnstableProvider(Context c, String auth) &#123;</span><br><span class="line">            return mMainThread.acquireProvider(c,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，无论是acquireProvider还是acquireUnstableProvider方法，最后调用的都市ActivityThread的同一个方法的acquireProvider。getAuthorityWithoutUserId是字符截断过程，即去掉auth中的userid信息，比如com.skytoby.article@666,经过该方法则变成了com.skytoby.article。</p>
<h3 id="3-5-AT-acquireProvider"><a href="#3-5-AT-acquireProvider" class="headerlink" title="3.5 AT.acquireProvider"></a>3.5 AT.acquireProvider</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public final IContentProvider acquireProvider(</span><br><span class="line">          Context c, String auth, int userId, boolean stable) &#123;</span><br><span class="line">      //获取已经存在的provider    </span><br><span class="line">      final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">      if (provider != null) &#123;</span><br><span class="line">          //成功则返回</span><br><span class="line">          return provider;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // There is a possible race here.  Another thread may try to acquire</span><br><span class="line">      // the same provider at the same time.  When this happens, we want to ensure</span><br><span class="line">      // that the first one wins.</span><br><span class="line">      // Note that we cannot hold the lock while acquiring and installing the</span><br><span class="line">      // provider since it might take a long time to run and it could also potentially</span><br><span class="line">      // be re-entrant in the case where the provider is in the same process.</span><br><span class="line">      ContentProviderHolder holder = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          synchronized (getGetProviderLock(auth, userId)) &#123;</span><br><span class="line">              //见3.6节</span><br><span class="line">              holder = ActivityManager.getService().getContentProvider(</span><br><span class="line">                      getApplicationThread(), auth, userId, stable);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (RemoteException ex) &#123;</span><br><span class="line">          throw ex.rethrowFromSystemServer();</span><br><span class="line">      &#125;</span><br><span class="line">      if (holder == null) &#123;</span><br><span class="line">          Slog.e(TAG, &quot;Failed to find provider info for &quot; + auth);</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 安装provider将会增加引用计数，见3.8节</span><br><span class="line">      // Install provider will increment the reference count for us, and break</span><br><span class="line">      // any ties in the race.</span><br><span class="line">      holder = installProvider(c, holder, holder.info,</span><br><span class="line">              true /*noisy*/, holder.noReleaseNeeded, stable);</span><br><span class="line">      return holder.provider;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>主要过程：1.获取已经存在的provider,如果存在则返回，否则继续执行；</p>
<p>​                  2.通过AMS获取provider，无法获取则返回，否则继续执行；</p>
<p>​                  3.通过installProvider方法安装provider，并增加该provider的引用计数。                </p>
<h4 id="3-5-1-AT-acquireExistingProvider"><a href="#3-5-1-AT-acquireExistingProvider" class="headerlink" title="3.5.1 AT.acquireExistingProvider"></a>3.5.1 AT.acquireExistingProvider</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">public final IContentProvider acquireExistingProvider(</span><br><span class="line">        Context c, String auth, int userId, boolean stable) &#123;</span><br><span class="line">    synchronized (mProviderMap) &#123;</span><br><span class="line">        final ProviderKey key = new ProviderKey(auth, userId);</span><br><span class="line">        //从mProviderMap中查询是否存在，在2.1.6节发布时将provider添加到了mProviderMap</span><br><span class="line">        final ProviderClientRecord pr = mProviderMap.get(key);</span><br><span class="line">        if (pr == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IContentProvider provider = pr.mProvider;</span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        if (!jBinder.isBinderAlive()) &#123;</span><br><span class="line">            // The hosting process of the provider has died; we can&apos;t</span><br><span class="line">            // use this one.</span><br><span class="line">            Log.i(TAG, &quot;Acquiring provider &quot; + auth + &quot; for user &quot; + userId</span><br><span class="line">                    + &quot;: existing object&apos;s process dead&quot;);</span><br><span class="line">            //当provider所在的进程已经死亡则返回        </span><br><span class="line">            handleUnstableProviderDiedLocked(jBinder, true);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Only increment the ref count if we have one.  If we don&apos;t then the</span><br><span class="line">        // provider is not reference counted and never needs to be released.</span><br><span class="line">        ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        if (prc != null) &#123;</span><br><span class="line">            //增加引用计数</span><br><span class="line">            incProviderRefLocked(prc, stable);</span><br><span class="line">        &#125;</span><br><span class="line">        return provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询mProviderMap是否存在provider，如果不存在则直接返回。如果存在判断provider的进程是否死亡，死亡则返回null。如果provider所在的进程还在，则增加引用计数。</p>
<h3 id="3-6-AMS-getContentProvider"><a href="#3-6-AMS-getContentProvider" class="headerlink" title="3.6  AMS.getContentProvider"></a>3.6  AMS.getContentProvider</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public final ContentProviderHolder getContentProvider(</span><br><span class="line">           IApplicationThread caller, String name, int userId, boolean stable) &#123;</span><br><span class="line">       enforceNotIsolatedCaller(&quot;getContentProvider&quot;);</span><br><span class="line">       if (caller == null) &#123;</span><br><span class="line">           String msg = &quot;null IApplicationThread when getting content provider &quot;</span><br><span class="line">                   + name;</span><br><span class="line">           Slog.w(TAG, msg);</span><br><span class="line">           throw new SecurityException(msg);</span><br><span class="line">       &#125;</span><br><span class="line">       // The incoming user check is now handled in checkContentProviderPermissionLocked() to deal</span><br><span class="line">       // with cross-user grant.</span><br><span class="line">       return getContentProviderImpl(caller, name, null, stable, userId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-AMS-getContentProviderImpl"><a href="#3-7-AMS-getContentProviderImpl" class="headerlink" title="3.7  AMS.getContentProviderImpl"></a>3.7  AMS.getContentProviderImpl</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">private ContentProviderHolder getContentProviderImpl(IApplicationThread caller,</span><br><span class="line">          String name, IBinder token, boolean stable, int userId) &#123;</span><br><span class="line">      ContentProviderRecord cpr;</span><br><span class="line">      ContentProviderConnection conn = null;</span><br><span class="line">      ProviderInfo cpi = null;</span><br><span class="line">      boolean providerRunning = false;</span><br><span class="line"></span><br><span class="line">      synchronized(this) &#123;</span><br><span class="line">          long startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">          ProcessRecord r = null;</span><br><span class="line">          if (caller != null) &#123;</span><br><span class="line">              //获取调用者的进程记录</span><br><span class="line">              r = getRecordForAppLocked(caller);</span><br><span class="line">              if (r == null) &#123;</span><br><span class="line">                  throw new SecurityException(</span><br><span class="line">                          &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                        + &quot; (pid=&quot; + Binder.getCallingPid()</span><br><span class="line">                        + &quot;) when getting content provider &quot; + name);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          boolean checkCrossUser = true;</span><br><span class="line"></span><br><span class="line">          checkTime(startTime, &quot;getContentProviderImpl: getProviderByName&quot;);</span><br><span class="line">          </span><br><span class="line">          //从mProviderMap中获取ContentProviderRecord</span><br><span class="line">          // First check if this content provider has been published...</span><br><span class="line">          cpr = mProviderMap.getProviderByName(name, userId);</span><br><span class="line">          // If that didn&apos;t work, check if it exists for user 0 and then</span><br><span class="line">          // verify that it&apos;s a singleton provider before using it.</span><br><span class="line">          if (cpr == null &amp;&amp; userId != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">              //从USER_SYSTEM获取，这里的name是componentName</span><br><span class="line">              cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM);</span><br><span class="line">              if (cpr != null) &#123;</span><br><span class="line">                  cpi = cpr.info;</span><br><span class="line">                  if (isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                          cpi.name, cpi.flags)</span><br><span class="line">                          &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid)) &#123;</span><br><span class="line">                      userId = UserHandle.USER_SYSTEM;</span><br><span class="line">                      checkCrossUser = false;</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      cpr = null;</span><br><span class="line">                      cpi = null;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (cpr != null &amp;&amp; cpr.proc != null) &#123;</span><br><span class="line">              providerRunning = !cpr.proc.killed;</span><br><span class="line"></span><br><span class="line">              // Note if killedByAm is also set, this means the provider process has just been</span><br><span class="line">              // killed by AM (in ProcessRecord.kill()), but appDiedLocked() hasn&apos;t been called</span><br><span class="line">              // yet. So we need to call appDiedLocked() here and let it clean up.</span><br><span class="line">              // (See the commit message on I2c4ba1e87c2d47f2013befff10c49b3dc337a9a7 to see</span><br><span class="line">              // how to test this case.)</span><br><span class="line">              //目标provider进程死亡</span><br><span class="line">              if (cpr.proc.killed &amp;&amp; cpr.proc.killedByAm) &#123;</span><br><span class="line">                  checkTime(startTime, &quot;getContentProviderImpl: before appDied (killedByAm)&quot;);</span><br><span class="line">                  final long iden = Binder.clearCallingIdentity();</span><br><span class="line">                  try &#123;</span><br><span class="line">                      appDiedLocked(cpr.proc);</span><br><span class="line">                  &#125; finally &#123;</span><br><span class="line">                      Binder.restoreCallingIdentity(iden);</span><br><span class="line">                  &#125;</span><br><span class="line">                  checkTime(startTime, &quot;getContentProviderImpl: after appDied (killedByAm)&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">         //目标provider存在的情况，见3.7.1</span><br><span class="line">         if (providerRunning) &#123;</span><br><span class="line">            ....</span><br><span class="line">         &#125;</span><br><span class="line">         //目标provider不存在的情况，见3.7.2</span><br><span class="line">         if (!providerRunning) &#123;</span><br><span class="line">            ....</span><br><span class="line">         &#125;</span><br><span class="line">        //循环等待provider发布完成，见3.7.3</span><br><span class="line">         synchronized (cpr) &#123;</span><br><span class="line">             while (cpr.provider == null) &#123;</span><br><span class="line">                 ....</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     return super.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较长，主要分为三个部分：</p>
<p>目标provider存在的情况；目标provider不存在的情况；循环等待目标provider发布完成。</p>
<h4 id="3-7-1-目标provider存在"><a href="#3-7-1-目标provider存在" class="headerlink" title="3.7.1 目标provider存在"></a>3.7.1 目标provider存在</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">if (providerRunning) &#123;</span><br><span class="line">           cpi = cpr.info;</span><br><span class="line">           String msg;</span><br><span class="line">           checkTime(startTime, &quot;getContentProviderImpl: before checkContentProviderPermission&quot;);</span><br><span class="line">           //检查权限</span><br><span class="line">           if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, checkCrossUser))</span><br><span class="line">                   != null) &#123;</span><br><span class="line">               throw new SecurityException(msg);</span><br><span class="line">           &#125;</span><br><span class="line">           checkTime(startTime, &quot;getContentProviderImpl: after checkContentProviderPermission&quot;);</span><br><span class="line"></span><br><span class="line">           if (r != null &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">               //当允许运行在调用者进程，且已经发布，则直接返回</span><br><span class="line">               // This provider has been published or is in the process</span><br><span class="line">               // of being published...  but it is also allowed to run</span><br><span class="line">               // in the caller&apos;s process, so don&apos;t make a connection</span><br><span class="line">               // and just let the caller instantiate its own instance.</span><br><span class="line">               ContentProviderHolder holder = cpr.newHolder(null);</span><br><span class="line">               // don&apos;t give caller the provider object, it needs</span><br><span class="line">               // to make its own.</span><br><span class="line">               holder.provider = null;</span><br><span class="line">               return holder;</span><br><span class="line">           &#125;</span><br><span class="line">           // Don&apos;t expose providers between normal apps and instant apps</span><br><span class="line">           try &#123;</span><br><span class="line">               if (AppGlobals.getPackageManager()</span><br><span class="line">                       .resolveContentProvider(name, 0 /*flags*/, userId) == null) &#123;</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (RemoteException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           final long origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">           checkTime(startTime, &quot;getContentProviderImpl: incProviderCountLocked&quot;);</span><br><span class="line">           // 增加引用计数，见3.8.1节</span><br><span class="line">           // In this case the provider instance already exists, so we can</span><br><span class="line">           // return it right away.</span><br><span class="line">           conn = incProviderCountLocked(r, cpr, token, stable);</span><br><span class="line">           if (conn != null &amp;&amp; (conn.stableCount+conn.unstableCount) == 1) &#123;</span><br><span class="line">               if (cpr.proc != null &amp;&amp; r.setAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                   // If this is a perceptible app accessing the provider,</span><br><span class="line">                   // make sure to count it as being accessed and thus</span><br><span class="line">                   // back up on the LRU list.  This is good because</span><br><span class="line">                   // content providers are often expensive to start.</span><br><span class="line">                   //更新进程LRU队列</span><br><span class="line">                   checkTime(startTime, &quot;getContentProviderImpl: before updateLruProcess&quot;);</span><br><span class="line">                   updateLruProcessLocked(cpr.proc, false, null);</span><br><span class="line">                   checkTime(startTime, &quot;getContentProviderImpl: after updateLruProcess&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           checkTime(startTime, &quot;getContentProviderImpl: before updateOomAdj&quot;);</span><br><span class="line">           final int verifiedAdj = cpr.proc.verifiedAdj;</span><br><span class="line">           //更新进程adj</span><br><span class="line">           boolean success = updateOomAdjLocked(cpr.proc, true);</span><br><span class="line">           // XXX things have changed so updateOomAdjLocked doesn&apos;t actually tell us</span><br><span class="line">           // if the process has been successfully adjusted.  So to reduce races with</span><br><span class="line">           // it, we will check whether the process still exists.  Note that this doesn&apos;t</span><br><span class="line">           // completely get rid of races with LMK killing the process, but should make</span><br><span class="line">           // them much smaller.</span><br><span class="line">           if (success &amp;&amp; verifiedAdj != cpr.proc.setAdj &amp;&amp; !isProcessAliveLocked(cpr.proc)) &#123;</span><br><span class="line">               success = false;</span><br><span class="line">           &#125;</span><br><span class="line">           maybeUpdateProviderUsageStatsLocked(r, cpr.info.packageName, name);</span><br><span class="line">           checkTime(startTime, &quot;getContentProviderImpl: after updateOomAdj&quot;);</span><br><span class="line">           if (DEBUG_PROVIDER) Slog.i(TAG_PROVIDER, &quot;Adjust success: &quot; + success);</span><br><span class="line">           // NOTE: there is still a race here where a signal could be</span><br><span class="line">           // pending on the process even though we managed to update its</span><br><span class="line">           // adj level.  Not sure what to do about this, but at least</span><br><span class="line">           // the race is now smaller.</span><br><span class="line">           if (!success) &#123;</span><br><span class="line">               //provider进程被杀死，则减少应用计数，见3.8.3节</span><br><span class="line">               // Uh oh...  it looks like the provider&apos;s process</span><br><span class="line">               // has been killed on us.  We need to wait for a new</span><br><span class="line">               // process to be started, and make sure its death</span><br><span class="line">               // doesn&apos;t kill our process.</span><br><span class="line">               Slog.i(TAG, &quot;Existing provider &quot; + cpr.name.flattenToShortString()</span><br><span class="line">                       + &quot; is crashing; detaching &quot; + r);</span><br><span class="line">               boolean lastRef = decProviderCountLocked(conn, cpr, token, stable);</span><br><span class="line">               checkTime(startTime, &quot;getContentProviderImpl: before appDied&quot;);</span><br><span class="line">               appDiedLocked(cpr.proc);</span><br><span class="line">               checkTime(startTime, &quot;getContentProviderImpl: after appDied&quot;);</span><br><span class="line">               if (!lastRef) &#123;</span><br><span class="line">                   // This wasn&apos;t the last ref our process had on</span><br><span class="line">                   // the provider...  we have now been killed, bail.</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">               providerRunning = false;</span><br><span class="line">               conn = null;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               cpr.proc.verifiedAdj = cpr.proc.setAdj;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>当ContentProvider所在的进程已经存在：</p>
<p>检查权限；当允许运行在调用者进程且已经发布，则直接返回</p>
<p>增加引用计数；更新进程LRU队列；更新adj</p>
<p>当provider进程被杀时，则奸商引用计数并调用appDiedLocked，设置provider为未发布状态。</p>
<h4 id="3-7-2-目标provider不存在"><a href="#3-7-2-目标provider不存在" class="headerlink" title="3.7.2  目标provider不存在"></a>3.7.2  目标provider不存在</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">  if (!providerRunning) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            checkTime(startTime, &quot;getContentProviderImpl: before resolveContentProvider&quot;);</span><br><span class="line">            //获取ProviderInfo对象</span><br><span class="line">            cpi = AppGlobals.getPackageManager().</span><br><span class="line">                resolveContentProvider(name,</span><br><span class="line">                    STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);</span><br><span class="line">            checkTime(startTime, &quot;getContentProviderImpl: after resolveContentProvider&quot;);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cpi == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //provider是否是单例</span><br><span class="line">        // If the provider is a singleton AND</span><br><span class="line">        // (it&apos;s a call within the same user || the provider is a</span><br><span class="line">        // privileged app)</span><br><span class="line">        // Then allow connecting to the singleton provider</span><br><span class="line">        boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                cpi.name, cpi.flags)</span><br><span class="line">                &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid);</span><br><span class="line">        if (singleton) &#123;</span><br><span class="line">            userId = UserHandle.USER_SYSTEM;</span><br><span class="line">        &#125;</span><br><span class="line">        cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId);</span><br><span class="line">        checkTime(startTime, &quot;getContentProviderImpl: got app info for user&quot;);</span><br><span class="line"></span><br><span class="line">        String msg;</span><br><span class="line">        checkTime(startTime, &quot;getContentProviderImpl: before checkContentProviderPermission&quot;);</span><br><span class="line">        //权限检查</span><br><span class="line">        if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, !singleton))</span><br><span class="line">                != null) &#123;</span><br><span class="line">            throw new SecurityException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        checkTime(startTime, &quot;getContentProviderImpl: after checkContentProviderPermission&quot;);</span><br><span class="line"></span><br><span class="line">        if (!mProcessesReady</span><br><span class="line">                &amp;&amp; !cpi.processName.equals(&quot;system&quot;)) &#123;</span><br><span class="line">            // If this content provider does not run in the system</span><br><span class="line">            // process, and the system is not yet ready to run other</span><br><span class="line">            // processes, then fail fast instead of hanging.</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;Attempt to launch content provider before system ready&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If system providers are not installed yet we aggressively crash to avoid</span><br><span class="line">        // creating multiple instance of these providers and then bad things happen!</span><br><span class="line">        if (!mSystemProvidersInstalled &amp;&amp; cpi.applicationInfo.isSystemApp()</span><br><span class="line">                &amp;&amp; &quot;system&quot;.equals(cpi.processName)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Cannot access system provider: &apos;&quot;</span><br><span class="line">                    + cpi.authority + &quot;&apos; before system providers are installed!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //拥有该provider的用户没有运行，则直接返回</span><br><span class="line">        // Make sure that the user who owns this provider is running.  If not,</span><br><span class="line">        // we don&apos;t want to allow it to run.</span><br><span class="line">        if (!mUserController.isUserRunning(userId, 0)) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Unable to launch app &quot;</span><br><span class="line">                    + cpi.applicationInfo.packageName + &quot;/&quot;</span><br><span class="line">                    + cpi.applicationInfo.uid + &quot; for provider &quot;</span><br><span class="line">                    + name + &quot;: user &quot; + userId + &quot; is stopped&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ComponentName comp = new ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">        checkTime(startTime, &quot;getContentProviderImpl: before getProviderByClass&quot;);</span><br><span class="line">        cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line">        checkTime(startTime, &quot;getContentProviderImpl: after getProviderByClass&quot;);</span><br><span class="line">        final boolean firstClass = cpr == null;</span><br><span class="line">        if (firstClass) &#123;</span><br><span class="line">            final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            // If permissions need a review before any of the app components can run,</span><br><span class="line">            // we return no provider and launch a review activity if the calling app</span><br><span class="line">            // is in the foreground.</span><br><span class="line">            if (mPermissionReviewRequired) &#123;</span><br><span class="line">                if (!requestTargetProviderPermissionsReviewIfNeededLocked(cpi, r, userId)) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                checkTime(startTime, &quot;getContentProviderImpl: before getApplicationInfo&quot;);</span><br><span class="line">                ApplicationInfo ai =</span><br><span class="line">                    AppGlobals.getPackageManager().</span><br><span class="line">                        getApplicationInfo(</span><br><span class="line">                                cpi.applicationInfo.packageName,</span><br><span class="line">                                STOCK_PM_FLAGS, userId);</span><br><span class="line">                checkTime(startTime, &quot;getContentProviderImpl: after getApplicationInfo&quot;);</span><br><span class="line">                if (ai == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;No package info for content provider &quot;</span><br><span class="line">                            + cpi.name);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                ai = getAppInfoForUser(ai, userId);</span><br><span class="line">                cpr = new ContentProviderRecord(this, cpi, ai, comp, singleton);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                // pm is in same process, this will never happen.</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(ident);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkTime(startTime, &quot;getContentProviderImpl: now have ContentProviderRecord&quot;);</span><br><span class="line">        //见3.7.4节</span><br><span class="line">        if (r != null &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">            // If this is a multiprocess provider, then just return its</span><br><span class="line">            // info and allow the caller to instantiate it.  Only do</span><br><span class="line">            // this if the provider is the same user as the caller&apos;s</span><br><span class="line">            // process, or can run as root (so can be in any process).</span><br><span class="line">            return cpr.newHolder(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_PROVIDER) Slog.w(TAG_PROVIDER, &quot;LAUNCHING REMOTE PROVIDER (myuid &quot;</span><br><span class="line">                    + (r != null ? r.uid : null) + &quot; pruid &quot; + cpr.appInfo.uid + &quot;): &quot;</span><br><span class="line">                    + cpr.info.name + &quot; callers=&quot; + Debug.getCallers(6));</span><br><span class="line">        </span><br><span class="line">        //从mLaunchingProviders中查询</span><br><span class="line">        // This is single process, and our app is now connecting to it.</span><br><span class="line">        // See if we are already in the process of launching this</span><br><span class="line">        // provider.</span><br><span class="line">        final int N = mLaunchingProviders.size();</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            if (mLaunchingProviders.get(i) == cpr) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       //如果mLaunchingProviders中没有该provider，则启动它</span><br><span class="line">        // If the provider is not already being launched, then get it</span><br><span class="line">        // started.</span><br><span class="line">        if (i &gt;= N) &#123;</span><br><span class="line">            final long origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                // Content provider is now in use, its package can&apos;t be stopped.</span><br><span class="line">                try &#123;</span><br><span class="line">                    checkTime(startTime, &quot;getContentProviderImpl: before set stopped state&quot;);</span><br><span class="line">                    AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                            cpr.appInfo.packageName, false, userId);</span><br><span class="line">                    checkTime(startTime, &quot;getContentProviderImpl: after set stopped state&quot;);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Failed trying to unstop package &quot;</span><br><span class="line">                            + cpr.appInfo.packageName + &quot;: &quot; + e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Use existing process if already started</span><br><span class="line">                checkTime(startTime, &quot;getContentProviderImpl: looking for process record&quot;);</span><br><span class="line">                //查询进程记录</span><br><span class="line">                ProcessRecord proc = getProcessRecordLocked(</span><br><span class="line">                        cpi.processName, cpr.appInfo.uid, false);</span><br><span class="line">                if (proc != null &amp;&amp; proc.thread != null &amp;&amp; !proc.killed) &#123;</span><br><span class="line">                    if (DEBUG_PROVIDER) Slog.d(TAG_PROVIDER,</span><br><span class="line">                            &quot;Installing in existing process &quot; + proc);</span><br><span class="line">                    if (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">                        checkTime(startTime, &quot;getContentProviderImpl: scheduling install&quot;);</span><br><span class="line">                        proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">                        try &#123;</span><br><span class="line">                             //发布provider，见2.2.1节</span><br><span class="line">                            proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    checkTime(startTime, &quot;getContentProviderImpl: before start process&quot;);</span><br><span class="line">                    //启动进程</span><br><span class="line">                    proc = startProcessLocked(cpi.processName,</span><br><span class="line">                            cpr.appInfo, false, 0, &quot;content provider&quot;,</span><br><span class="line">                            new ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                    cpi.name), false, false, false);</span><br><span class="line">                    checkTime(startTime, &quot;getContentProviderImpl: after start process&quot;);</span><br><span class="line">                    if (proc == null) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Unable to launch app &quot;</span><br><span class="line">                                + cpi.applicationInfo.packageName + &quot;/&quot;</span><br><span class="line">                                + cpi.applicationInfo.uid + &quot; for provider &quot;</span><br><span class="line">                                + name + &quot;: process is bad&quot;);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cpr.launchingApp = proc;</span><br><span class="line">                //将cpr添加到mLaunchingProviders</span><br><span class="line">                mLaunchingProviders.add(cpr);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkTime(startTime, &quot;getContentProviderImpl: updating data structures&quot;);</span><br><span class="line"></span><br><span class="line">        // Make sure the provider is published (the same provider class</span><br><span class="line">        // may be published under multiple names).</span><br><span class="line">        if (firstClass) &#123;</span><br><span class="line">            mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mProviderMap.putProviderByName(name, cpr);</span><br><span class="line">        conn = incProviderCountLocked(r, cpr, token, stable);</span><br><span class="line">        if (conn != null) &#123;</span><br><span class="line">            conn.waiting = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    checkTime(startTime, &quot;getContentProviderImpl: done!&quot;);</span><br><span class="line"></span><br><span class="line">    grantEphemeralAccessLocked(userId, null /*intent*/,</span><br><span class="line">            cpi.applicationInfo.uid, UserHandle.getAppId(Binder.getCallingUid()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当ContentProvider所在的进程不存在：</p>
<p>根据authority获取ProviderInfo对象；权限检查；</p>
<p>当系统不是运行在system进程，且系统未准备好，则抛出异常；</p>
<p>当拥有该provider的用户没有运行，则直接返回；</p>
<p>当允许运行在调用者进程且ProcessRecord不为空，则直接返回；</p>
<p>当provider并没有在mLaunchingProviders队列，则启动它：</p>
<ul>
<li><p>当ProcessRecord不为空，则直接加入到pubProviders队列，并安装provider</p>
</li>
<li><p>当ProcessRecord为空，则启动进程</p>
</li>
</ul>
<p>增加引用计数</p>
<h4 id="3-7-3-等待目标provider发布"><a href="#3-7-3-等待目标provider发布" class="headerlink" title="3.7.3  等待目标provider发布"></a>3.7.3  等待目标provider发布</h4><p>【ContentProviderRecord</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static final int CONTENT_PROVIDER_WAIT_TIMEOUT = 20 * 1000;</span><br><span class="line">// Wait for the provider to be published...</span><br><span class="line">final long timeout = SystemClock.uptimeMillis() + CONTENT_PROVIDER_WAIT_TIMEOUT;</span><br><span class="line">synchronized (cpr) &#123;</span><br><span class="line">    //</span><br><span class="line">    while (cpr.provider == null) &#123;</span><br><span class="line">        if (cpr.launchingApp == null) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Unable to launch app &quot;</span><br><span class="line">                    + cpi.applicationInfo.packageName + &quot;/&quot;</span><br><span class="line">                    + cpi.applicationInfo.uid + &quot; for provider &quot;</span><br><span class="line">                    + name + &quot;: launching app became null&quot;);</span><br><span class="line">            EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,</span><br><span class="line">                    UserHandle.getUserId(cpi.applicationInfo.uid),</span><br><span class="line">                    cpi.applicationInfo.packageName,</span><br><span class="line">                    cpi.applicationInfo.uid, name);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            final long wait = Math.max(0L, timeout - SystemClock.uptimeMillis());</span><br><span class="line">            if (DEBUG_MU) Slog.v(TAG_MU,</span><br><span class="line">                    &quot;Waiting to start provider &quot; + cpr</span><br><span class="line">                    + &quot; launchingApp=&quot; + cpr.launchingApp + &quot; for &quot; + wait + &quot; ms&quot;);</span><br><span class="line">            if (conn != null) &#123;</span><br><span class="line">                conn.waiting = true;</span><br><span class="line">            &#125;</span><br><span class="line">            cpr.wait(wait);</span><br><span class="line">            if (cpr.provider == null) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Timeout waiting for provider &quot;</span><br><span class="line">                        + cpi.applicationInfo.packageName + &quot;/&quot;</span><br><span class="line">                        + cpi.applicationInfo.uid + &quot; for provider &quot;</span><br><span class="line">                        + name</span><br><span class="line">                        + &quot; providerRunning=&quot; + providerRunning);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (conn != null) &#123;</span><br><span class="line">                conn.waiting = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return cpr != null ? cpr.newHolder(conn) : null;</span><br></pre></td></tr></table></figure>
<p>循环等待20s，直到发布完成才退出。</p>
<h4 id="3-7-4-CPR-canRunHere"><a href="#3-7-4-CPR-canRunHere" class="headerlink" title="3.7.4  CPR.canRunHere"></a>3.7.4  CPR.canRunHere</h4><p>[-&gt;ContentProviderRecord.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean canRunHere(ProcessRecord app) &#123;</span><br><span class="line">      return (info.multiprocess || info.processName.equals(app.processName))</span><br><span class="line">              &amp;&amp; uid == app.info.uid;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ContentProvider是否能运行在调用者所在的进程需要满足以下条件</p>
<p>1.ContentProvider在AndroidManifest.xml文件配置中multiprocess=true；或者调用者进程和ContentProvider在同一进程</p>
<p>2.ContentProvider进程跟调用者所在的进程是同一个uid。</p>
<h3 id="3-8-AT-installProvider"><a href="#3-8-AT-installProvider" class="headerlink" title="3.8 AT.installProvider"></a>3.8 AT.installProvider</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">private ContentProviderHolder installProvider(Context context,</span><br><span class="line">            ContentProviderHolder holder, ProviderInfo info,</span><br><span class="line">            boolean noisy, boolean noReleaseNeeded, boolean stable) &#123;</span><br><span class="line">        ContentProvider localProvider = null;</span><br><span class="line">        IContentProvider provider;</span><br><span class="line">        if (holder == null || holder.provider == null) &#123;</span><br><span class="line">            //从packageInfo中获取provider</span><br><span class="line">            if (DEBUG_PROVIDER || noisy) &#123;</span><br><span class="line">                Slog.d(TAG, &quot;Loading provider &quot; + info.authority + &quot;: &quot;</span><br><span class="line">                        + info.name);</span><br><span class="line">            &#125;</span><br><span class="line">            Context c = null;</span><br><span class="line">            ApplicationInfo ai = info.applicationInfo;</span><br><span class="line">            if (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">                c = context;</span><br><span class="line">            &#125; else if (mInitialApplication != null &amp;&amp;</span><br><span class="line">                    mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">                c = mInitialApplication;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    c = context.createPackageContext(ai.packageName,</span><br><span class="line">                            Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">                &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                    // Ignore</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Unable to get context for package &quot; +</span><br><span class="line">                      ai.packageName +</span><br><span class="line">                      &quot; while loading content provider &quot; +</span><br><span class="line">                      info.name);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (info.splitName != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    c = c.createContextForSplit(info.splitName);</span><br><span class="line">                &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                final java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">                LoadedApk packageInfo = peekPackageInfo(ai.packageName, true);</span><br><span class="line">                if (packageInfo == null) &#123;</span><br><span class="line">                    // System startup case.</span><br><span class="line">                    packageInfo = getSystemContext().mPackageInfo;</span><br><span class="line">                &#125;</span><br><span class="line">                localProvider = packageInfo.getAppFactory()</span><br><span class="line">                        .instantiateProvider(cl, info.name);</span><br><span class="line">                provider = localProvider.getIContentProvider();</span><br><span class="line">                if (provider == null) &#123;</span><br><span class="line">                    Slog.e(TAG, &quot;Failed to instantiate class &quot; +</span><br><span class="line">                          info.name + &quot; from sourceDir &quot; +</span><br><span class="line">                          info.applicationInfo.sourceDir);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">                    TAG, &quot;Instantiating local provider &quot; + info.name);</span><br><span class="line">                // XXX Need to create the correct context for this provider.</span><br><span class="line">                localProvider.attachInfo(c, info);</span><br><span class="line">            &#125; catch (java.lang.Exception e) &#123;</span><br><span class="line">                if (!mInstrumentation.onException(null, e)) &#123;</span><br><span class="line">                    throw new RuntimeException(</span><br><span class="line">                            &quot;Unable to get provider &quot; + info.name</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            provider = holder.provider;</span><br><span class="line">            if (DEBUG_PROVIDER) Slog.v(TAG, &quot;Installing external provider &quot; + info.authority + &quot;: &quot;</span><br><span class="line">                    + info.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ContentProviderHolder retHolder;</span><br><span class="line"></span><br><span class="line">        synchronized (mProviderMap) &#123;</span><br><span class="line">            if (DEBUG_PROVIDER) Slog.v(TAG, &quot;Checking to add &quot; + provider</span><br><span class="line">                    + &quot; / &quot; + info.name);</span><br><span class="line">            IBinder jBinder = provider.asBinder();</span><br><span class="line">            if (localProvider != null) &#123;</span><br><span class="line">                ComponentName cname = new ComponentName(info.packageName, info.name);</span><br><span class="line">                ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">                if (pr != null) &#123;</span><br><span class="line">                    if (DEBUG_PROVIDER) &#123;</span><br><span class="line">                        Slog.v(TAG, &quot;installProvider: lost the race, &quot;</span><br><span class="line">                                + &quot;using existing local provider&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    provider = pr.mProvider;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    holder = new ContentProviderHolder(info);</span><br><span class="line">                    holder.provider = provider;</span><br><span class="line">                    holder.noReleaseNeeded = true;</span><br><span class="line">                    pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">                    mLocalProviders.put(jBinder, pr);</span><br><span class="line">                    mLocalProvidersByName.put(cname, pr);</span><br><span class="line">                &#125;</span><br><span class="line">                retHolder = pr.mHolder;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //查询ProviderRefCount</span><br><span class="line">                ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">                if (prc != null) &#123;</span><br><span class="line">                    if (DEBUG_PROVIDER) &#123;</span><br><span class="line">                        Slog.v(TAG, &quot;installProvider: lost the race, updating ref count&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // We need to transfer our new reference to the existing</span><br><span class="line">                    // ref count, releasing the old one...  but only if</span><br><span class="line">                    // release is needed (that is, it is not running in the</span><br><span class="line">                    // system process).</span><br><span class="line">                    if (!noReleaseNeeded) &#123;</span><br><span class="line">                        //增加引用计数,通过AMS，见3.8.4</span><br><span class="line">                        incProviderRefLocked(prc, stable);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            </span><br><span class="line">                            ActivityManager.getService().removeContentProvider(</span><br><span class="line">                                    holder.connection, stable);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            //do nothing content provider object is dead any way</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //见3.8.5节</span><br><span class="line">                    ProviderClientRecord client = installProviderAuthoritiesLocked(</span><br><span class="line">                            provider, localProvider, holder);</span><br><span class="line">                    if (noReleaseNeeded) &#123;</span><br><span class="line">                       //见3.8.6节</span><br><span class="line">                        prc = new ProviderRefCount(holder, client, 1000, 1000);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        prc = stable</span><br><span class="line">                                ? new ProviderRefCount(holder, client, 1, 0)</span><br><span class="line">                                : new ProviderRefCount(holder, client, 0, 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mProviderRefCountMap.put(jBinder, prc);</span><br><span class="line">                &#125;</span><br><span class="line">                retHolder = prc.holder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return retHolder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-1-AMS-incProviderCountLocked"><a href="#3-8-1-AMS-incProviderCountLocked" class="headerlink" title="3.8.1  AMS.incProviderCountLocked"></a>3.8.1  AMS.incProviderCountLocked</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ContentProviderConnection incProviderCountLocked(ProcessRecord r,</span><br><span class="line">           final ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) &#123;</span><br><span class="line">       if (r != null) &#123;</span><br><span class="line">           for (int i=0; i&lt;r.conProviders.size(); i++) &#123;</span><br><span class="line">               //从当前进程所使用的provider中查询与目标provider一致的信息</span><br><span class="line">               ContentProviderConnection conn = r.conProviders.get(i);</span><br><span class="line">               if (conn.provider == cpr) &#123;</span><br><span class="line">                   if (DEBUG_PROVIDER) Slog.v(TAG_PROVIDER,</span><br><span class="line">                           &quot;Adding provider requested by &quot;</span><br><span class="line">                           + r.processName + &quot; from process &quot;</span><br><span class="line">                           + cpr.info.processName + &quot;: &quot; + cpr.name.flattenToShortString()</span><br><span class="line">                           + &quot; scnt=&quot; + conn.stableCount + &quot; uscnt=&quot; + conn.unstableCount);</span><br><span class="line">                   if (stable) &#123;</span><br><span class="line">                       conn.stableCount++;</span><br><span class="line">                       conn.numStableIncs++;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       conn.unstableCount++;</span><br><span class="line">                       conn.numUnstableIncs++;</span><br><span class="line">                   &#125;</span><br><span class="line">                   return conn;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //查不到则新建provider连接对象</span><br><span class="line">           ContentProviderConnection conn = new ContentProviderConnection(cpr, r);</span><br><span class="line">           if (stable) &#123;</span><br><span class="line">               conn.stableCount = 1;</span><br><span class="line">               conn.numStableIncs = 1;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               conn.unstableCount = 1;</span><br><span class="line">               conn.numUnstableIncs = 1;</span><br><span class="line">           &#125;</span><br><span class="line">           cpr.connections.add(conn);</span><br><span class="line">           r.conProviders.add(conn);</span><br><span class="line">           startAssociationLocked(r.uid, r.processName, r.curProcState,</span><br><span class="line">                   cpr.uid, cpr.name, cpr.info.processName);</span><br><span class="line">           return conn;</span><br><span class="line">       &#125;</span><br><span class="line">       cpr.addExternalProcessHandleLocked(externalProcessToken);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-2-AMS-removeContentProvider"><a href="#3-8-2-AMS-removeContentProvider" class="headerlink" title="3.8.2  AMS.removeContentProvider"></a>3.8.2  AMS.removeContentProvider</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Drop a content provider from a ProcessRecord&apos;s bookkeeping</span><br><span class="line">    */</span><br><span class="line">   public void removeContentProvider(IBinder connection, boolean stable) &#123;</span><br><span class="line">       enforceNotIsolatedCaller(&quot;removeContentProvider&quot;);</span><br><span class="line">       long ident = Binder.clearCallingIdentity();</span><br><span class="line">       try &#123;</span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               ContentProviderConnection conn;</span><br><span class="line">               try &#123;</span><br><span class="line">                   conn = (ContentProviderConnection)connection;</span><br><span class="line">               &#125; catch (ClassCastException e) &#123;</span><br><span class="line">                   String msg =&quot;removeContentProvider: &quot; + connection</span><br><span class="line">                           + &quot; not a ContentProviderConnection&quot;;</span><br><span class="line">                   Slog.w(TAG, msg);</span><br><span class="line">                   throw new IllegalArgumentException(msg);</span><br><span class="line">               &#125;</span><br><span class="line">               if (conn == null) &#123;</span><br><span class="line">                   throw new NullPointerException(&quot;connection is null&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               //见3.8.3节</span><br><span class="line">               if (decProviderCountLocked(conn, null, null, stable)) &#123;</span><br><span class="line">                   updateOomAdjLocked();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Binder.restoreCallingIdentity(ident);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-3-AMS-decProviderCountLocked"><a href="#3-8-3-AMS-decProviderCountLocked" class="headerlink" title="3.8.3  AMS.decProviderCountLocked"></a>3.8.3  AMS.decProviderCountLocked</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">boolean decProviderCountLocked(ContentProviderConnection conn,</span><br><span class="line">            ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) &#123;</span><br><span class="line">        if (conn != null) &#123;</span><br><span class="line">            cpr = conn.provider;</span><br><span class="line">            if (DEBUG_PROVIDER) Slog.v(TAG_PROVIDER,</span><br><span class="line">                    &quot;Removing provider requested by &quot;</span><br><span class="line">                    + conn.client.processName + &quot; from process &quot;</span><br><span class="line">                    + cpr.info.processName + &quot;: &quot; + cpr.name.flattenToShortString()</span><br><span class="line">                    + &quot; scnt=&quot; + conn.stableCount + &quot; uscnt=&quot; + conn.unstableCount);</span><br><span class="line">            if (stable) &#123;</span><br><span class="line">                conn.stableCount--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                conn.unstableCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            //当provider连接的stable和unstable的引用次数为01时，则移除连接对象信息</span><br><span class="line">            if (conn.stableCount == 0 &amp;&amp; conn.unstableCount == 0) &#123;</span><br><span class="line">                cpr.connections.remove(conn);</span><br><span class="line">                conn.client.conProviders.remove(conn);</span><br><span class="line">                if (conn.client.setProcState &lt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">                    // The client is more important than last activity -- note the time this</span><br><span class="line">                    // is happening, so we keep the old provider process around a bit as last</span><br><span class="line">                    // activity to avoid thrashing it.</span><br><span class="line">                    if (cpr.proc != null) &#123;</span><br><span class="line">                        cpr.proc.lastProviderTime = SystemClock.uptimeMillis();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stopAssociationLocked(conn.client.uid, conn.client.processName, cpr.uid, cpr.name);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        cpr.removeExternalProcessHandleLocked(externalProcessToken);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-4-AT-incProviderRefLocked"><a href="#3-8-4-AT-incProviderRefLocked" class="headerlink" title="3.8.4  AT.incProviderRefLocked"></a>3.8.4  AT.incProviderRefLocked</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">private final void incProviderRefLocked(ProviderRefCount prc, boolean stable) &#123;</span><br><span class="line">       //stable provider</span><br><span class="line">       if (stable) &#123;</span><br><span class="line">           prc.stableCount += 1;</span><br><span class="line">           if (prc.stableCount == 1) &#123;</span><br><span class="line">               //数量为1，状态为removePending，发送REMOVE_PROVIDER信息</span><br><span class="line">               // We are acquiring a new stable reference on the provider.</span><br><span class="line">               int unstableDelta;</span><br><span class="line">               if (prc.removePending) &#123;</span><br><span class="line">                   // We have a pending remove operation, which is holding the</span><br><span class="line">                   // last unstable reference.  At this point we are converting</span><br><span class="line">                   // that unstable reference to our new stable reference.</span><br><span class="line">                   unstableDelta = -1;</span><br><span class="line">                   // Cancel the removal of the provider.</span><br><span class="line">                   if (DEBUG_PROVIDER) &#123;</span><br><span class="line">                       Slog.v(TAG, &quot;incProviderRef: stable &quot;</span><br><span class="line">                               + &quot;snatched provider from the jaws of death&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line">                   prc.removePending = false;</span><br><span class="line">                   // There is a race! It fails to remove the message, which</span><br><span class="line">                   // will be handled in completeRemoveProvider().</span><br><span class="line">                   mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   unstableDelta = 0;</span><br><span class="line">               &#125;</span><br><span class="line">               try &#123;</span><br><span class="line">                   if (DEBUG_PROVIDER) &#123;</span><br><span class="line">                       Slog.v(TAG, &quot;incProviderRef Now stable - &quot;</span><br><span class="line">                               + prc.holder.info.name + &quot;: unstableDelta=&quot;</span><br><span class="line">                               + unstableDelta);</span><br><span class="line">                   &#125;</span><br><span class="line">                   //调用AMS方法</span><br><span class="line">                   ActivityManager.getService().refContentProvider(</span><br><span class="line">                           prc.holder.connection, 1, unstableDelta);</span><br><span class="line">               &#125; catch (RemoteException e) &#123;</span><br><span class="line">                   //do nothing content provider object is dead any way</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           prc.unstableCount += 1;</span><br><span class="line">           if (prc.unstableCount == 1) &#123;</span><br><span class="line">               // We are acquiring a new unstable reference on the provider.</span><br><span class="line">               if (prc.removePending) &#123;</span><br><span class="line">                   // Oh look, we actually have a remove pending for the</span><br><span class="line">                   // provider, which is still holding the last unstable</span><br><span class="line">                   // reference.  We just need to cancel that to take new</span><br><span class="line">                   // ownership of the reference.</span><br><span class="line">                   if (DEBUG_PROVIDER) &#123;</span><br><span class="line">                       Slog.v(TAG, &quot;incProviderRef: unstable &quot;</span><br><span class="line">                               + &quot;snatched provider from the jaws of death&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line">                   prc.removePending = false;</span><br><span class="line">                   mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // First unstable ref, increment our count in the</span><br><span class="line">                   // activity manager.</span><br><span class="line">                   try &#123;</span><br><span class="line">                       if (DEBUG_PROVIDER) &#123;</span><br><span class="line">                           Slog.v(TAG, &quot;incProviderRef: Now unstable - &quot;</span><br><span class="line">                                   + prc.holder.info.name);</span><br><span class="line">                       &#125;</span><br><span class="line">                       ActivityManager.getService().refContentProvider(</span><br><span class="line">                               prc.holder.connection, 0, 1);</span><br><span class="line">                   &#125; catch (RemoteException e) &#123;</span><br><span class="line">                       //do nothing content provider object is dead any way</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-5-AT-installProviderAuthoritiesLocked"><a href="#3-8-5-AT-installProviderAuthoritiesLocked" class="headerlink" title="3.8.5  AT.installProviderAuthoritiesLocked"></a>3.8.5  AT.installProviderAuthoritiesLocked</h4><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private ProviderClientRecord installProviderAuthoritiesLocked(IContentProvider provider,</span><br><span class="line">           ContentProvider localProvider, ContentProviderHolder holder) &#123;</span><br><span class="line">       final String auths[] = holder.info.authority.split(&quot;;&quot;);</span><br><span class="line">       final int userId = UserHandle.getUserId(holder.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">       if (provider != null) &#123;</span><br><span class="line">           // If this provider is hosted by the core OS and cannot be upgraded,</span><br><span class="line">           // then I guess we&apos;re okay doing blocking calls to it.</span><br><span class="line">           for (String auth : auths) &#123;</span><br><span class="line">               switch (auth) &#123;</span><br><span class="line">                   case ContactsContract.AUTHORITY:</span><br><span class="line">                   case CallLog.AUTHORITY:</span><br><span class="line">                   case CallLog.SHADOW_AUTHORITY:</span><br><span class="line">                   case BlockedNumberContract.AUTHORITY:</span><br><span class="line">                   case CalendarContract.AUTHORITY:</span><br><span class="line">                   case Downloads.Impl.AUTHORITY:</span><br><span class="line">                   case &quot;telephony&quot;:</span><br><span class="line">                       Binder.allowBlocking(provider.asBinder());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final ProviderClientRecord pcr = new ProviderClientRecord(</span><br><span class="line">               auths, provider, localProvider, holder);</span><br><span class="line">       for (String auth : auths) &#123;</span><br><span class="line">           final ProviderKey key = new ProviderKey(auth, userId);</span><br><span class="line">           final ProviderClientRecord existing = mProviderMap.get(key);</span><br><span class="line">           if (existing != null) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Content provider &quot; + pcr.mHolder.info.name</span><br><span class="line">                       + &quot; already published as &quot; + auth);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //发布</span><br><span class="line">               mProviderMap.put(key, pcr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return pcr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-6-ProviderRefCount"><a href="#3-8-6-ProviderRefCount" class="headerlink" title="3.8.6 ProviderRefCount"></a>3.8.6 ProviderRefCount</h4><p>[-&gt;ActivityThread.java::ProviderRefCount]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProviderRefCount &#123;</span><br><span class="line">      public final ContentProviderHolder holder;</span><br><span class="line">      public final ProviderClientRecord client;</span><br><span class="line">      public int stableCount;</span><br><span class="line">      public int unstableCount;</span><br><span class="line">      </span><br><span class="line">      //当该标记设置时，stableCount和unstableCount引用都会设置为0</span><br><span class="line">      // When this is set, the stable and unstable ref counts are 0 and</span><br><span class="line">      // we have a pending operation scheduled to remove the ref count</span><br><span class="line">      // from the activity manager.  On the activity manager we are still</span><br><span class="line">      // holding an unstable ref, though it is not reflected in the counts</span><br><span class="line">      // here.</span><br><span class="line">      public boolean removePending;</span><br><span class="line"></span><br><span class="line">      ProviderRefCount(ContentProviderHolder inHolder,</span><br><span class="line">              ProviderClientRecord inClient, int sCount, int uCount) &#123;</span><br><span class="line">          holder = inHolder;</span><br><span class="line">          client = inClient;</span><br><span class="line">          stableCount = sCount;</span><br><span class="line">          unstableCount = uCount;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>获取到Provider后，就可以进行查询操作了。</p>
<h3 id="3-9-CPP-query"><a href="#3-9-CPP-query" class="headerlink" title="3.9 CPP.query"></a>3.9 CPP.query</h3><p>[-&gt;ContentProviderNative.java::ContentProviderProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public Cursor query(String callingPkg, Uri url, @Nullable String[] projection,</span><br><span class="line">          @Nullable Bundle queryArgs, @Nullable ICancellationSignal cancellationSignal)</span><br><span class="line">          throws RemoteException &#123;</span><br><span class="line">      BulkCursorToCursorAdaptor adaptor = new BulkCursorToCursorAdaptor();</span><br><span class="line">      Parcel data = Parcel.obtain();</span><br><span class="line">      Parcel reply = Parcel.obtain();</span><br><span class="line">      try &#123;</span><br><span class="line">          data.writeInterfaceToken(IContentProvider.descriptor);</span><br><span class="line"></span><br><span class="line">          data.writeString(callingPkg);</span><br><span class="line">          url.writeToParcel(data, 0);</span><br><span class="line">          int length = 0;</span><br><span class="line">          if (projection != null) &#123;</span><br><span class="line">              length = projection.length;</span><br><span class="line">          &#125;</span><br><span class="line">          data.writeInt(length);</span><br><span class="line">          for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">              data.writeString(projection[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          data.writeBundle(queryArgs);</span><br><span class="line">          data.writeStrongBinder(adaptor.getObserver().asBinder());</span><br><span class="line">          data.writeStrongBinder(</span><br><span class="line">                  cancellationSignal != null ? cancellationSignal.asBinder() : null);</span><br><span class="line">          //发送给binder服务</span><br><span class="line">          mRemote.transact(IContentProvider.QUERY_TRANSACTION, data, reply, 0);</span><br><span class="line"></span><br><span class="line">          DatabaseUtils.readExceptionFromParcel(reply);</span><br><span class="line"></span><br><span class="line">          if (reply.readInt() != 0) &#123;</span><br><span class="line">              BulkCursorDescriptor d = BulkCursorDescriptor.CREATOR.createFromParcel(reply);</span><br><span class="line">              Binder.copyAllowBlocking(mRemote, (d.cursor != null) ? d.cursor.asBinder() : null);</span><br><span class="line">              adaptor.initialize(d);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              adaptor.close();</span><br><span class="line">              adaptor = null;</span><br><span class="line">          &#125;</span><br><span class="line">          return adaptor;</span><br><span class="line">      &#125; catch (RemoteException ex) &#123;</span><br><span class="line">          adaptor.close();</span><br><span class="line">          throw ex;</span><br><span class="line">      &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">          adaptor.close();</span><br><span class="line">          throw ex;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          data.recycle();</span><br><span class="line">          reply.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-CPN-onTransact"><a href="#3-10-CPN-onTransact" class="headerlink" title="3.10 CPN.onTransact"></a>3.10 CPN.onTransact</h3><p>[-&gt;ContentProviderNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public boolean onTransact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">         throws RemoteException &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         switch (code) &#123;</span><br><span class="line">             case QUERY_TRANSACTION:</span><br><span class="line">             &#123;</span><br><span class="line">                 data.enforceInterface(IContentProvider.descriptor);</span><br><span class="line"></span><br><span class="line">                 String callingPkg = data.readString();</span><br><span class="line">                 Uri url = Uri.CREATOR.createFromParcel(data);</span><br><span class="line"></span><br><span class="line">                 // String[] projection</span><br><span class="line">                 int num = data.readInt();</span><br><span class="line">                 String[] projection = null;</span><br><span class="line">                 if (num &gt; 0) &#123;</span><br><span class="line">                     projection = new String[num];</span><br><span class="line">                     for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">                         projection[i] = data.readString();</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 Bundle queryArgs = data.readBundle();</span><br><span class="line">                 IContentObserver observer = IContentObserver.Stub.asInterface(</span><br><span class="line">                         data.readStrongBinder());</span><br><span class="line">                 ICancellationSignal cancellationSignal = ICancellationSignal.Stub.asInterface(</span><br><span class="line">                         data.readStrongBinder());</span><br><span class="line">                 //见3.11节      </span><br><span class="line">                 Cursor cursor = query(callingPkg, url, projection, queryArgs, cancellationSignal);</span><br><span class="line">                 if (cursor != null) &#123;</span><br><span class="line">                     CursorToBulkCursorAdaptor adaptor = null;</span><br><span class="line"></span><br><span class="line">                     try &#123;</span><br><span class="line">                         adaptor = new CursorToBulkCursorAdaptor(cursor, observer,</span><br><span class="line">                                 getProviderName());</span><br><span class="line">                         cursor = null;</span><br><span class="line"></span><br><span class="line">                         BulkCursorDescriptor d = adaptor.getBulkCursorDescriptor();</span><br><span class="line">                         adaptor = null;</span><br><span class="line"></span><br><span class="line">                         reply.writeNoException();</span><br><span class="line">                         reply.writeInt(1);</span><br><span class="line">                         d.writeToParcel(reply, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                     &#125; finally &#123;</span><br><span class="line">                         // Close cursor if an exception was thrown while constructing the adaptor.</span><br><span class="line">                         if (adaptor != null) &#123;</span><br><span class="line">                             adaptor.close();</span><br><span class="line">                         &#125;</span><br><span class="line">                         if (cursor != null) &#123;</span><br><span class="line">                             cursor.close();</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     reply.writeNoException();</span><br><span class="line">                     reply.writeInt(0);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 return true;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             case GET_TYPE_TRANSACTION:</span><br><span class="line">             case INSERT_TRANSACTION:</span><br><span class="line">             case BULK_INSERT_TRANSACTION： </span><br><span class="line">             case APPLY_BATCH_TRANSACTION:</span><br><span class="line">             case DELETE_TRANSACTION:</span><br><span class="line">             case UPDATE_TRANSACTION:</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         DatabaseUtils.writeExceptionToParcel(reply, e);</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-11-Transport-query"><a href="#3-11-Transport-query" class="headerlink" title="3.11 Transport.query"></a>3.11 Transport.query</h3><p>[-&gt;ContentProvider.java::Transport]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public Cursor query(String callingPkg, Uri uri, @Nullable String[] projection,</span><br><span class="line">              @Nullable Bundle queryArgs, @Nullable ICancellationSignal cancellationSignal) &#123;</span><br><span class="line">          uri = validateIncomingUri(uri);</span><br><span class="line">          uri = maybeGetUriWithoutUserId(uri);</span><br><span class="line">          if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">              // The caller has no access to the data, so return an empty cursor with</span><br><span class="line">              // the columns in the requested order. The caller may ask for an invalid</span><br><span class="line">              // column and we would not catch that but this is not a problem in practice.</span><br><span class="line">              // We do not call ContentProvider#query with a modified where clause since</span><br><span class="line">              // the implementation is not guaranteed to be backed by a SQL database, hence</span><br><span class="line">              // it may not handle properly the tautology where clause we would have created.</span><br><span class="line">              if (projection != null) &#123;</span><br><span class="line">                  return new MatrixCursor(projection, 0);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // Null projection means all columns but we have no idea which they are.</span><br><span class="line">              // However, the caller may be expecting to access them my index. Hence,</span><br><span class="line">              // we have to execute the query as if allowed to get a cursor with the</span><br><span class="line">              // columns. We then use the column names to return an empty cursor.</span><br><span class="line">              Cursor cursor = ContentProvider.this.query(</span><br><span class="line">                      uri, projection, queryArgs,</span><br><span class="line">                      CancellationSignal.fromTransport(cancellationSignal));</span><br><span class="line">              if (cursor == null) &#123;</span><br><span class="line">                  return null;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // Return an empty cursor for all columns.</span><br><span class="line">              return new MatrixCursor(cursor.getColumnNames(), 0);</span><br><span class="line">          &#125;</span><br><span class="line">          final String original = setCallingPackage(callingPkg);</span><br><span class="line">          try &#123;</span><br><span class="line">              //调用目标provider的query方法</span><br><span class="line">              return ContentProvider.this.query(</span><br><span class="line">                      uri, projection, queryArgs,</span><br><span class="line">                      CancellationSignal.fromTransport(cancellationSignal));</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              setCallingPackage(original);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文通过分析了发布ContentProvider的过程，并分析query过程，先获取provider在安装provider信息，最后才查询。而查询操作主要分为两种情况：</p>
<h3 id="4-1-进程未启动"><a href="#4-1-进程未启动" class="headerlink" title="4.1 进程未启动"></a>4.1 进程未启动</h3><p>provider进程不存在，需要创建进程并发布相关的provider</p>
<p><img src="/2019/ContentProvider原理分析/providerno.jpg" alt="providerno"></p>
<p>1.client进程：通过Binder向systemserver进程请求相应的provider</p>
<p>2.systemserver进程：如果目标进程未启动，则调用startProcessLocked启动进程，当启动完成，当cpr.provider ==null，则systemserver进入wait阶段，等待目标provider发布；</p>
<p>3.provider进程：进程启动后执行attach到systemserver，而后bindApplication，在这个过程会installProvider和PublishContentProviders,再binder到systemserver进程；</p>
<p>4.systemserver进程：回到systemserver发布provider信息，并且通过notify机制唤醒当前处于wait状态的binder线程，并将结果返回给client进程；</p>
<p>5.client进程：回到client进程，执行installProvider操作，安装provider</p>
<p>关于<code>CONTENT_PROVIDER_PUBLISH_TIMEOUT</code>超时机制所统计的时机区间是指在startProcessLocked之后会调用AMS.attachApplicationLocked为起点，一直到AMS.publishContentProviders的过程。</p>
<h3 id="4-2-进程已启动"><a href="#4-2-进程已启动" class="headerlink" title="4.2 进程已启动"></a>4.2 进程已启动</h3><p>provider进程已启动但未发布，需要发布相关的provider</p>
<p><img src="/2019/ContentProvider原理分析/provideryes.jpg" alt="provideryes"></p>
<p>Client进程：获取provider发现cpr为空，则调用scheduleInstallProvider来向provider所在的进程发出一个oneway的binder请求，进入wait状态；</p>
<p>provider进程：安装完成provider信息后，通过notify机制唤醒当前处于wait状态的binder线程。</p>
<p>如果provider在publish之后，这是在请求provider则没用最右边的过程，直接AMS.getContentProvierImpl之后便进入AT.installProvider的过程，而不会再进入wait过程。</p>
<h3 id="4-3-引用计数"><a href="#4-3-引用计数" class="headerlink" title="4.3 引用计数"></a>4.3 引用计数</h3><p>provider分为stable provider和unstable provider,主要在于引用计数的不同。</p>
<p>provider引用计数的增加与减少关系，removePending是指即将被移除的引用，lastRef表示当前引用为0。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">stableCount</th>
<th style="text-align:left">unstableCount</th>
<th style="text-align:left">条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">acquireProvider</td>
<td style="text-align:left">+1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">removePending=false</td>
</tr>
<tr>
<td style="text-align:left">acquireProvider</td>
<td style="text-align:left">+1</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">removePending=true</td>
</tr>
<tr>
<td style="text-align:left">acquireUnstableProvider</td>
<td style="text-align:left">0</td>
<td style="text-align:left">+1</td>
<td style="text-align:left">removePending=false</td>
</tr>
<tr>
<td style="text-align:left">acquireUnstableProvider</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">removePending=true</td>
</tr>
<tr>
<td style="text-align:left">releaseProvider</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">lastRef=false</td>
</tr>
<tr>
<td style="text-align:left">releaseProvider</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">lastRef=true</td>
</tr>
<tr>
<td style="text-align:left">releaseUnstableProvider</td>
<td style="text-align:left">0</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">lastRef=false</td>
</tr>
<tr>
<td style="text-align:left">releaseUnstableProvider</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">lastRef=true</td>
</tr>
</tbody>
</table>
<p>当Client进程存在对某个provider的引用时，Provider进程死亡则会根据provider类型进行不同的处理：</p>
<ul>
<li><p>对于stable provider,会杀掉所有和该provider建立stable连接的非persistent进程；</p>
</li>
<li><p>对于unstable provider，不会导致client进程被级联所杀，会回调unstableProviderDied来清理相关信息。</p>
</li>
</ul>
<p>当stable和unstable引用计数都为0则移除connection信息</p>
<ul>
<li>AMS.removeContentProvider过程移除connection相关所有信息。</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>源码路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/core/java/android/content/ContentResolver.java</span><br><span class="line">frameworks/base/core/java/android/content/ContentProviderNative.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ContentProviderRecord.java</span><br></pre></td></tr></table></figure>
      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ContentProvider/" rel="tag">#ContentProvider</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/startService启动过程/" rel="next" title="startServie启动过程">
                <i class="fa fa-chevron-left"></i> startServie启动过程
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/BroadcastCast广播机制原理/" rel="prev" title="BroadcastCast广播机制原理">
                BroadcastCast广播机制原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">34</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-ContentProvider"><span class="nav-text">1.1 ContentProvider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-ContentResolver"><span class="nav-text">1.2 ContentResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-类图"><span class="nav-text">1.3  类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-重要成员变量"><span class="nav-text">1.4 重要成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-query流程图"><span class="nav-text">1.5 query流程图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、发布ContentProvider"><span class="nav-text">二、发布ContentProvider</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Provider进程未启动"><span class="nav-text">2.1 Provider进程未启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-AT-bindApplication"><span class="nav-text">2.1.1  AT.bindApplication</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-AT-handleMessage"><span class="nav-text">2.1.2  AT.handleMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-AT-handleMessage"><span class="nav-text">2.1.3  AT.handleMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-AT-installContentProviders"><span class="nav-text">2.1.4  AT.installContentProviders</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-AT-installProvider"><span class="nav-text">2.1.5  AT.installProvider</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-6-AMS-publishContentProviders"><span class="nav-text">2.1.6  AMS.publishContentProviders</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Provider进程启动但未发布"><span class="nav-text">2.2 Provider进程启动但未发布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-AT-scheduleInstallProvider"><span class="nav-text">2.2.1  AT.scheduleInstallProvider</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-AT-handleInstallProvider"><span class="nav-text">2.2.2  AT.handleInstallProvider</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、查询ContentResolver"><span class="nav-text">三、查询ContentResolver</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-CI-getContentResolver"><span class="nav-text">3.1 CI.getContentResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-CR-query"><span class="nav-text">3.2 CR.query</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-CR-acquireUnstableProvider"><span class="nav-text">3.3 CR.acquireUnstableProvider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-ACR-acquireUnstableProvider"><span class="nav-text">3.4 ACR.acquireUnstableProvider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-AT-acquireProvider"><span class="nav-text">3.5 AT.acquireProvider</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-AT-acquireExistingProvider"><span class="nav-text">3.5.1 AT.acquireExistingProvider</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-AMS-getContentProvider"><span class="nav-text">3.6  AMS.getContentProvider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-AMS-getContentProviderImpl"><span class="nav-text">3.7  AMS.getContentProviderImpl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1-目标provider存在"><span class="nav-text">3.7.1 目标provider存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-2-目标provider不存在"><span class="nav-text">3.7.2  目标provider不存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-3-等待目标provider发布"><span class="nav-text">3.7.3  等待目标provider发布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-4-CPR-canRunHere"><span class="nav-text">3.7.4  CPR.canRunHere</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-AT-installProvider"><span class="nav-text">3.8 AT.installProvider</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1-AMS-incProviderCountLocked"><span class="nav-text">3.8.1  AMS.incProviderCountLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-2-AMS-removeContentProvider"><span class="nav-text">3.8.2  AMS.removeContentProvider</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-3-AMS-decProviderCountLocked"><span class="nav-text">3.8.3  AMS.decProviderCountLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-4-AT-incProviderRefLocked"><span class="nav-text">3.8.4  AT.incProviderRefLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-5-AT-installProviderAuthoritiesLocked"><span class="nav-text">3.8.5  AT.installProviderAuthoritiesLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-6-ProviderRefCount"><span class="nav-text">3.8.6 ProviderRefCount</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-CPP-query"><span class="nav-text">3.9 CPP.query</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-CPN-onTransact"><span class="nav-text">3.10 CPN.onTransact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-Transport-query"><span class="nav-text">3.11 Transport.query</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、总结"><span class="nav-text">四、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-进程未启动"><span class="nav-text">4.1 进程未启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-进程已启动"><span class="nav-text">4.2 进程已启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-引用计数"><span class="nav-text">4.3 引用计数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2019/ContentProvider原理分析/';
      var disqus_title = "ContentProvider原理分析";
      var disqus_url = 'http://zproo.github.io/2019/ContentProvider原理分析/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
