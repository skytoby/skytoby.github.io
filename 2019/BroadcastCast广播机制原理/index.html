<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="BroadcastCast,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="基于Android10.0，分析广播机制的原理  一、概述广播（BroadcastCast）用于进程/线程间的通信，广播有发送广播和接收广播两部分组成，其中广播接收者BroadcastReceiver是四大组件之一。 BroadcastReceiver分为两类：  静态广播：通过AndroidManifeset.xml的标签来注册BroadcastReceiver。  动态广播：通过AMS.re">
<meta name="keywords" content="BroadcastCast">
<meta property="og:type" content="article">
<meta property="og:title" content="BroadcastCast广播机制原理">
<meta property="og:url" content="http://zproo.github.io/2019/BroadcastCast广播机制原理/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="基于Android10.0，分析广播机制的原理  一、概述广播（BroadcastCast）用于进程/线程间的通信，广播有发送广播和接收广播两部分组成，其中广播接收者BroadcastReceiver是四大组件之一。 BroadcastReceiver分为两类：  静态广播：通过AndroidManifeset.xml的标签来注册BroadcastReceiver。  动态广播：通过AMS.re">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2019/BroadcastCast广播机制原理/broadcast.jpg">
<meta property="og:updated_time" content="2019-12-28T06:26:27.158Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BroadcastCast广播机制原理">
<meta name="twitter:description" content="基于Android10.0，分析广播机制的原理  一、概述广播（BroadcastCast）用于进程/线程间的通信，广播有发送广播和接收广播两部分组成，其中广播接收者BroadcastReceiver是四大组件之一。 BroadcastReceiver分为两类：  静态广播：通过AndroidManifeset.xml的标签来注册BroadcastReceiver。  动态广播：通过AMS.re">
<meta name="twitter:image" content="http://zproo.github.io/2019/BroadcastCast广播机制原理/broadcast.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2019/BroadcastCast广播机制原理/">

  <title> BroadcastCast广播机制原理 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/BroadcastCast/" rel="tag" title="BroadcastCast">BroadcastCast</a>
      
      </div>
      <h1>BroadcastCast广播机制原理</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2019-09-22T21:40:23+08:00" content="2019-09-22" title="2019-09-22 21:40:23">
          2019-09-22
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                BroadcastCast广播机制原理
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-09-22T21:40:23+08:00" content="2019-09-22">
              2019-09-22
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/BroadcastCast广播机制原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/BroadcastCast广播机制原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>基于Android10.0，分析广播机制的原理</p>
</blockquote>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>广播（BroadcastCast）用于进程/线程间的通信，广播有发送广播和接收广播两部分组成，其中广播接收者BroadcastReceiver是四大组件之一。</p>
<p>BroadcastReceiver分为两类：</p>
<ul>
<li><p>静态广播：通过AndroidManifeset.xml的标签来注册BroadcastReceiver。</p>
</li>
<li><p>动态广播：通过AMS.registeredReceiver方式注册BroadcastReceiver，动态注册相对静态注册更加的灵活，在不需要时通过unregisteredReceiver来取消注册。</p>
</li>
</ul>
<p>从广播的发送方式分为四种：</p>
<ul>
<li><p>普通广播：完全异步的广播，在广播发出之后，所有的广播接收器几乎在同一时刻接收到这条广播消息，接收的先后顺序是随机的。通过Context.sendBroadcast发送。</p>
</li>
<li><p>有序广播：同步执行的广播。在广播发出去之后，同一时刻只有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑处理完成后，广播才可以继续传递。这种广播的接收顺序通过优先级(priority)设置，高的优先级先会收到广播。有序广播可以被接收者截断，使得后面的广播无法收到它。通过Context.sendOrderedBroadcast发送。</p>
</li>
<li><p>粘性广播：这种广播会一直滞留，当有匹配该广播的接收器被注册后，该接收器就会收到这个广播。粘性广播如果被销毁，下一次重建时会重新接收到消息数据。这种方式一般用来确保重要状态改变后的信息被持久的保存，并且能随时广播给新的广播接收器，比如：耗电量的改变。通过Context.sendStickyBroadcast发送。Android系统已经 @Deprecated该广播方式。</p>
</li>
<li><p>本地广播：发送处理的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收本应用程序发出的广播。通过LocalBroadcastManager.sendBroadcast发送。（基本原理是Handler，所以在AMS中没有本地广播的处理）</p>
</li>
</ul>
<p>广播在系统中通过BroadcastRecord来记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An active intent broadcast.</span><br><span class="line"> */</span><br><span class="line">final class BroadcastRecord extends Binder &#123;</span><br><span class="line">    final Intent intent;    // the original intent that generated us</span><br><span class="line">    final ComponentName targetComp; // original component name set on the intent</span><br><span class="line">    final ProcessRecord callerApp; // process that sent this</span><br><span class="line">    final String callerPackage; // who sent this</span><br><span class="line">    final int callingPid;   // the pid of who sent this</span><br><span class="line">    final int callingUid;   // the uid of who sent this</span><br><span class="line">    final boolean callerInstantApp; // caller is an Instant App?</span><br><span class="line">    final boolean ordered;  // serialize the send to receivers?</span><br><span class="line">    final boolean sticky;   // originated from existing sticky data?</span><br><span class="line">    final boolean initialSticky; // initial broadcast from register to sticky?</span><br><span class="line">    final int userId;       // user id this broadcast was for</span><br><span class="line">    final String resolvedType; // the resolved data type</span><br><span class="line">    final String[] requiredPermissions; // permissions the caller has required</span><br><span class="line">    final int appOp;        // an app op that is associated with this broadcast</span><br><span class="line">    final BroadcastOptions options; // BroadcastOptions supplied by caller</span><br><span class="line">    //包括动态注册的BroadcastFilter和静态注册的ResolveInfo</span><br><span class="line">    final List receivers;   // contains BroadcastFilter and ResolveInfo</span><br><span class="line">    //广播的分发状态</span><br><span class="line">    final int[] delivery;   // delivery state of each receiver</span><br><span class="line">    IIntentReceiver resultTo; // who receives final result if non-null</span><br><span class="line">    </span><br><span class="line">    //入队列时间</span><br><span class="line">    long enqueueClockTime;  // the clock time the broadcast was enqueued</span><br><span class="line">    //分发时间</span><br><span class="line">    long dispatchTime;      // when dispatch started on this set of receivers</span><br><span class="line">    //分发时间</span><br><span class="line">    long dispatchClockTime; // the clock time the dispatch started</span><br><span class="line">    //接收时间</span><br><span class="line">    long receiverTime;      // when current receiver started for timeouts.</span><br><span class="line">    //广播完成时间</span><br><span class="line">    long finishTime;        // when we finished the broadcast.</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、注册广播"><a href="#二、注册广播" class="headerlink" title="二、注册广播"></a>二、注册广播</h2><p>注册广播一般可以在Activity/Service中调用registerReceiver方法，而这两者间接集成Context，其实现是ContextImpl。</p>
<h3 id="2-1-CI-registerReceiver"><a href="#2-1-CI-registerReceiver" class="headerlink" title="2.1 CI.registerReceiver"></a>2.1 CI.registerReceiver</h3><p>[-&gt;ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">    return registerReceiver(receiver, filter, null, null);</span><br><span class="line">&#125;</span><br><span class="line"> @Override</span><br><span class="line">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,</span><br><span class="line">        String broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">    return registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            filter, broadcastPermission, scheduler, getOuterContext(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中broadcastPermission表示广播的权限，scheduler表示接收广播时onReceive执行的线程，当scheduler==null时代表在主线程中执行，大部分情况是不会指令scheduler。getOuterContext可以获取最外层调用者。</p>
<h3 id="2-2-CI-registerReceiverInternal"><a href="#2-2-CI-registerReceiverInternal" class="headerlink" title="2.2 CI.registerReceiverInternal"></a>2.2 CI.registerReceiverInternal</h3><p>[-&gt;ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</span><br><span class="line">           IntentFilter filter, String broadcastPermission,</span><br><span class="line">           Handler scheduler, Context context, int flags) &#123;</span><br><span class="line">       IIntentReceiver rd = null;</span><br><span class="line">       if (receiver != null) &#123;</span><br><span class="line">           if (mPackageInfo != null &amp;&amp; context != null) &#123;</span><br><span class="line">               if (scheduler == null) &#123;</span><br><span class="line">                   //主线程Handler赋予scheduler</span><br><span class="line">                   scheduler = mMainThread.getHandler();</span><br><span class="line">               &#125;</span><br><span class="line">               //见2.3节，获取IIntentReceiver</span><br><span class="line">               rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                   receiver, context, scheduler,</span><br><span class="line">                   mMainThread.getInstrumentation(), true);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (scheduler == null) &#123;</span><br><span class="line">                   scheduler = mMainThread.getHandler();</span><br><span class="line">               &#125;</span><br><span class="line">               //context为空，新建ReceiverDispatcher对象（见2.3.1节），并获取IIntentReceiver</span><br><span class="line">               rd = new LoadedApk.ReceiverDispatcher(</span><br><span class="line">                       receiver, context, scheduler, null, true).getIIntentReceiver();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           //通过Binder调用AMS.registerReceiver</span><br><span class="line">           final Intent intent = ActivityManager.getService().registerReceiver(</span><br><span class="line">                   mMainThread.getApplicationThread(), mBasePackageName, rd, filter,</span><br><span class="line">                   broadcastPermission, userId, flags);</span><br><span class="line">           if (intent != null) &#123;</span><br><span class="line">               intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">               intent.prepareToEnterProcess();</span><br><span class="line">           &#125;</span><br><span class="line">           return intent;</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           throw e.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-LA-getReceiverDispatcher"><a href="#2-3-LA-getReceiverDispatcher" class="headerlink" title="2.3 LA.getReceiverDispatcher"></a>2.3 LA.getReceiverDispatcher</h3><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r,</span><br><span class="line">           Context context, Handler handler,</span><br><span class="line">           Instrumentation instrumentation, boolean registered) &#123;</span><br><span class="line">       synchronized (mReceivers) &#123;</span><br><span class="line">           LoadedApk.ReceiverDispatcher rd = null;</span><br><span class="line">           ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null;</span><br><span class="line">           //已经注册</span><br><span class="line">           if (registered) &#123;</span><br><span class="line">               map = mReceivers.get(context);</span><br><span class="line">               if (map != null) &#123;</span><br><span class="line">                   rd = map.get(r);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (rd == null) &#123;</span><br><span class="line">               //广播分发者为空，创建ReceiverDispatcher</span><br><span class="line">               rd = new ReceiverDispatcher(r, context, handler,</span><br><span class="line">                       instrumentation, registered);</span><br><span class="line">               if (registered) &#123;</span><br><span class="line">                   if (map == null) &#123;</span><br><span class="line">                       map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                       mReceivers.put(context, map);</span><br><span class="line">                   &#125;</span><br><span class="line">                   map.put(r, rd);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //验证广播分发者的context和handler是否一致</span><br><span class="line">               rd.validate(context, handler);</span><br><span class="line">           &#125;</span><br><span class="line">           rd.mForgotten = false;</span><br><span class="line">           return rd.getIIntentReceiver();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>mReceivers定义为final ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, ReceiverDispatcher&gt;&gt; mReceivers；</p>
<p>mReceivers是以Context为key,以ArrayMap为value的ArrayMap。</p>
<h4 id="2-3-1-创建ReceiverDispatcher"><a href="#2-3-1-创建ReceiverDispatcher" class="headerlink" title="2.3.1 创建ReceiverDispatcher"></a>2.3.1 创建ReceiverDispatcher</h4><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ReceiverDispatcher(BroadcastReceiver receiver, Context context,</span><br><span class="line">               Handler activityThread, Instrumentation instrumentation,</span><br><span class="line">               boolean registered) &#123;</span><br><span class="line">           if (activityThread == null) &#123;</span><br><span class="line">               throw new NullPointerException(&quot;Handler must not be null&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mIIntentReceiver = new InnerReceiver(this, !registered);</span><br><span class="line">           mReceiver = receiver;</span><br><span class="line">           mContext = context;</span><br><span class="line">           mActivityThread = activityThread;</span><br><span class="line">           mInstrumentation = instrumentation;</span><br><span class="line">           mRegistered = registered;</span><br><span class="line">           mLocation = new IntentReceiverLeaked(null);</span><br><span class="line">           mLocation.fillInStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>mActivityThread为前面传过来的Handler。</p>
<h4 id="2-3-2-创建InnerReceiver"><a href="#2-3-2-创建InnerReceiver" class="headerlink" title="2.3.2 创建InnerReceiver"></a>2.3.2 创建InnerReceiver</h4><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  final static class InnerReceiver extends IIntentReceiver.Stub &#123;</span><br><span class="line">            final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;</span><br><span class="line">            final LoadedApk.ReceiverDispatcher mStrongRef;</span><br><span class="line"></span><br><span class="line">            InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123;</span><br><span class="line">                //弱引用</span><br><span class="line">                mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);</span><br><span class="line">                mStrongRef = strong ? rd : null;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InnerReceiver继承于IIntentReceiver.Stub，是一个服务器端，广播分发者通过getReceiverDispatcher可以获取该Binder服务端对象InnerReceiver，用于IPC通信。</p>
<h3 id="2-4-AMS-registerReceiver"><a href="#2-4-AMS-registerReceiver" class="headerlink" title="2.4 AMS.registerReceiver"></a>2.4 AMS.registerReceiver</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage,</span><br><span class="line">           IIntentReceiver receiver, IntentFilter filter, String permission, int userId,</span><br><span class="line">           int flags) &#123;</span><br><span class="line">       enforceNotIsolatedCaller(&quot;registerReceiver&quot;);</span><br><span class="line">       ArrayList&lt;Intent&gt; stickyIntents = null;</span><br><span class="line">       ProcessRecord callerApp = null;</span><br><span class="line">       final boolean visibleToInstantApps</span><br><span class="line">               = (flags &amp; Context.RECEIVER_VISIBLE_TO_INSTANT_APPS) != 0;</span><br><span class="line">       int callingUid;</span><br><span class="line">       int callingPid;</span><br><span class="line">       boolean instantApp;</span><br><span class="line">       synchronized(this) &#123;</span><br><span class="line">           if (caller != null) &#123;</span><br><span class="line">               //查询调用者的进程信息</span><br><span class="line">               callerApp = getRecordForAppLocked(caller);</span><br><span class="line">               if (callerApp == null) &#123;</span><br><span class="line">                   throw new SecurityException(</span><br><span class="line">                           &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                           + &quot; (pid=&quot; + Binder.getCallingPid()</span><br><span class="line">                           + &quot;) when registering receiver &quot; + receiver);</span><br><span class="line">               &#125;</span><br><span class="line">               if (callerApp.info.uid != SYSTEM_UID &amp;&amp;</span><br><span class="line">                       !callerApp.pkgList.containsKey(callerPackage) &amp;&amp;</span><br><span class="line">                       !&quot;android&quot;.equals(callerPackage)) &#123;</span><br><span class="line">                   throw new SecurityException(&quot;Given caller package &quot; + callerPackage</span><br><span class="line">                           + &quot; is not running in process &quot; + callerApp);</span><br><span class="line">               &#125;</span><br><span class="line">               callingUid = callerApp.info.uid;</span><br><span class="line">               callingPid = callerApp.pid;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               callerPackage = null;</span><br><span class="line">               callingUid = Binder.getCallingUid();</span><br><span class="line">               callingPid = Binder.getCallingPid();</span><br><span class="line">           &#125;</span><br><span class="line">           //是否是即时应用</span><br><span class="line">           instantApp = isInstantApp(callerApp, callerPackage, callingUid);</span><br><span class="line">           userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, true,</span><br><span class="line">                   ALLOW_FULL_ONLY, &quot;registerReceiver&quot;, callerPackage);</span><br><span class="line">           //获取InterFilter中的Action</span><br><span class="line">           Iterator&lt;String&gt; actions = filter.actionsIterator();</span><br><span class="line">           if (actions == null) &#123;</span><br><span class="line">               ArrayList&lt;String&gt; noAction = new ArrayList&lt;String&gt;(1);</span><br><span class="line">               noAction.add(null);</span><br><span class="line">               actions = noAction.iterator();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Collect stickies of users</span><br><span class="line">           int[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class="line">           while (actions.hasNext()) &#123;</span><br><span class="line">               String action = actions.next();</span><br><span class="line">               for (int id : userIds) &#123;</span><br><span class="line">                   //从mStickyBroadcasts中查看用户的sticky intent</span><br><span class="line">                   ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);</span><br><span class="line">                   if (stickies != null) &#123;</span><br><span class="line">                       ArrayList&lt;Intent&gt; intents = stickies.get(action);</span><br><span class="line">                       if (intents != null) &#123;</span><br><span class="line">                           if (stickyIntents == null) &#123;</span><br><span class="line">                               stickyIntents = new ArrayList&lt;Intent&gt;();</span><br><span class="line">                           &#125;</span><br><span class="line">                           //将sticky intent加入队列</span><br><span class="line">                           stickyIntents.addAll(intents);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Intent&gt; allSticky = null;</span><br><span class="line">       if (stickyIntents != null) &#123;</span><br><span class="line">           final ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">           // Look for any matching sticky broadcasts...</span><br><span class="line">           for (int i = 0, N = stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class="line">               Intent intent = stickyIntents.get(i);</span><br><span class="line">               //即时应用跳过</span><br><span class="line">               // Don&apos;t provided intents that aren&apos;t available to instant apps.</span><br><span class="line">               if (instantApp &amp;&amp;</span><br><span class="line">                       (intent.getFlags() &amp; Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS) == 0) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               //查询匹配到的sticky广播，见2.4.2节</span><br><span class="line">               // If intent has scheme &quot;content&quot;, it will need to acccess</span><br><span class="line">               // provider that needs to lock mProviderMap in ActivityThread</span><br><span class="line">               // and also it may need to wait application response, so we</span><br><span class="line">               // cannot lock ActivityManagerService here.</span><br><span class="line">               if (filter.match(resolver, intent, true, TAG) &gt;= 0) &#123;</span><br><span class="line">                   if (allSticky == null) &#123;</span><br><span class="line">                       allSticky = new ArrayList&lt;Intent&gt;();</span><br><span class="line">                   &#125;</span><br><span class="line">                   //匹配成功，则将该intent添加到allSticky队列</span><br><span class="line">                   allSticky.add(intent);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //返回第一个stick intent</span><br><span class="line">       // The first sticky in the list is returned directly back to the client.</span><br><span class="line">       Intent sticky = allSticky != null ? allSticky.get(0) : null;</span><br><span class="line">       if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Register receiver &quot; + filter + &quot;: &quot; + sticky);</span><br><span class="line">       if (receiver == null) &#123;</span><br><span class="line">           return sticky;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           if (callerApp != null &amp;&amp; (callerApp.thread == null</span><br><span class="line">                   || callerApp.thread.asBinder() != caller.asBinder())) &#123;</span><br><span class="line">               // Original caller already died</span><br><span class="line">               //调用者已经死亡</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">           if (rl == null) &#123;</span><br><span class="line">               //对于没有注册的广播，则创建接收者队列</span><br><span class="line">               rl = new ReceiverList(this, callerApp, callingPid, callingUid,</span><br><span class="line">                       userId, receiver);</span><br><span class="line">               if (rl.app != null) &#123;</span><br><span class="line">                   //每个应用最多只能注册1000个接收者</span><br><span class="line">                   final int totalReceiversForApp = rl.app.receivers.size();</span><br><span class="line">                   if (totalReceiversForApp &gt;= MAX_RECEIVERS_ALLOWED_PER_APP) &#123;</span><br><span class="line">                       throw new IllegalStateException(&quot;Too many receivers, total of &quot;</span><br><span class="line">                               + totalReceiversForApp + &quot;, registered for pid: &quot;</span><br><span class="line">                               + rl.pid + &quot;, callerPackage: &quot; + callerPackage);</span><br><span class="line">                   &#125;</span><br><span class="line">                   //新创建的接收者队列，添加到已注册队列</span><br><span class="line">                   rl.app.receivers.add(rl);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       //服务停止后重连</span><br><span class="line">                       receiver.asBinder().linkToDeath(rl, 0);</span><br><span class="line">                   &#125; catch (RemoteException e) &#123;</span><br><span class="line">                       return sticky;</span><br><span class="line">                   &#125;</span><br><span class="line">                   rl.linkedToDeath = true;</span><br><span class="line">               &#125;</span><br><span class="line">               mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">           &#125; else if (rl.uid != callingUid) &#123;</span><br><span class="line">               throw new IllegalArgumentException(</span><br><span class="line">                       &quot;Receiver requested to register for uid &quot; + callingUid</span><br><span class="line">                       + &quot; was previously registered for uid &quot; + rl.uid</span><br><span class="line">                       + &quot; callerPackage is &quot; + callerPackage);</span><br><span class="line">           &#125; else if (rl.pid != callingPid) &#123;</span><br><span class="line">               throw new IllegalArgumentException(</span><br><span class="line">                       &quot;Receiver requested to register for pid &quot; + callingPid</span><br><span class="line">                       + &quot; was previously registered for pid &quot; + rl.pid</span><br><span class="line">                       + &quot; callerPackage is &quot; + callerPackage);</span><br><span class="line">           &#125; else if (rl.userId != userId) &#123;</span><br><span class="line">               throw new IllegalArgumentException(</span><br><span class="line">                       &quot;Receiver requested to register for user &quot; + userId</span><br><span class="line">                       + &quot; was previously registered for user &quot; + rl.userId</span><br><span class="line">                       + &quot; callerPackage is &quot; + callerPackage);</span><br><span class="line">           &#125;</span><br><span class="line">           //创建BroadcastFilter队列，并添加到接收者队列</span><br><span class="line">           BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                   permission, callingUid, userId, instantApp, visibleToInstantApps);</span><br><span class="line">           if (rl.containsFilter(filter)) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Receiver with filter &quot; + filter</span><br><span class="line">                       + &quot; already registered for pid &quot; + rl.pid</span><br><span class="line">                       + &quot;, callerPackage is &quot; + callerPackage);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               rl.add(bf);</span><br><span class="line">               if (!bf.debugCheck()) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;==&gt; For Dynamic broadcast&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               //新创建的广播过滤对象，添加到mReceiverResolver队列</span><br><span class="line">               mReceiverResolver.addFilter(bf);</span><br><span class="line">           &#125;</span><br><span class="line">           //所有匹配该filter的stick广播执行入队操作</span><br><span class="line">           // Enqueue broadcasts for all existing stickies that match</span><br><span class="line">           // this filter.</span><br><span class="line">           if (allSticky != null) &#123;</span><br><span class="line">               ArrayList receivers = new ArrayList();</span><br><span class="line">               receivers.add(bf);</span><br><span class="line"></span><br><span class="line">               final int stickyCount = allSticky.size();</span><br><span class="line">               for (int i = 0; i &lt; stickyCount; i++) &#123;</span><br><span class="line">                   Intent intent = allSticky.get(i);</span><br><span class="line">                   //根据intent返回前台或者后台广播队列，见2.4.3节</span><br><span class="line">                   BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">                   BroadcastRecord r = new BroadcastRecord(queue, intent, null,</span><br><span class="line">                           null, -1, -1, false, null, null, OP_NONE, null, receivers,</span><br><span class="line">                           null, 0, null, null, false, true, true, -1);</span><br><span class="line">                   //该广播加入到并行队列</span><br><span class="line">                   queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">                   //调度广播，发送BROADCAST_INTENT_MSG消息，触发处理广播</span><br><span class="line">                   queue.scheduleBroadcastsLocked();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return sticky;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>mReceiverResolver记录着所有已经注册的广播，是以receiver IBinder为key， ReceiverList为value的ArrayMap。</p>
<p>在BroadcastQueue中有两个广播队列mParallelBroadcasts、mOrderedBroadcasts，类型为ArrayList</p>
<ul>
<li><p>mParallelBroadcasts：并行广播队列，可以立刻执行，而无需等待另一个广播运行完成，该队列只允许动态已注册的广播，从而避免发生同时拉起大量进程来执行广播，前台和后台的广播分别位于独立的队列。</p>
</li>
<li><p>mOrderedBroadcasts：有序广播，同一时间只允许执行一个广播，该队列头部的广播就是活动广播，其他广播必须等待该广播结束才能运行，也是独立区别前台和后台的广播。</p>
</li>
</ul>
<h4 id="2-4-1-AMS-getRecordForAppLocked"><a href="#2-4-1-AMS-getRecordForAppLocked" class="headerlink" title="2.4.1 AMS.getRecordForAppLocked"></a>2.4.1 AMS.getRecordForAppLocked</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ProcessRecord getRecordForAppLocked(IApplicationThread thread) &#123;</span><br><span class="line">      if (thread == null) &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      //从mLruProcesses队列中获取</span><br><span class="line">      int appIndex = getLRURecordIndexForAppLocked(thread);</span><br><span class="line">      if (appIndex &gt;= 0) &#123;</span><br><span class="line">          return mLruProcesses.get(appIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      //mLruProcesses不存在，再检查一遍</span><br><span class="line">      // Validation: if it isn&apos;t in the LRU list, it shouldn&apos;t exist, but let&apos;s</span><br><span class="line">      // double-check that.</span><br><span class="line">      final IBinder threadBinder = thread.asBinder();</span><br><span class="line">      final ArrayMap&lt;String, SparseArray&lt;ProcessRecord&gt;&gt; pmap = mProcessNames.getMap();</span><br><span class="line">      for (int i = pmap.size()-1; i &gt;= 0; i--) &#123;</span><br><span class="line">          final SparseArray&lt;ProcessRecord&gt; procs = pmap.valueAt(i);</span><br><span class="line">          for (int j = procs.size()-1; j &gt;= 0; j--) &#123;</span><br><span class="line">              final ProcessRecord proc = procs.valueAt(j);</span><br><span class="line">              if (proc.thread != null &amp;&amp; proc.thread.asBinder() == threadBinder) &#123;</span><br><span class="line">                  Slog.wtf(TAG, &quot;getRecordForApp: exists in name list but not in LRU list: &quot;</span><br><span class="line">                          + proc);</span><br><span class="line">                  return proc;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>mLruProcesses 定义为ArrayList<processrecord> mLruProcesses ，ProcessRecord对象中有一个IApplicationThread字段，根据该字段来查找对应的ProcessRecord。</processrecord></p>
<h4 id="2-4-3-IntentFilter-match"><a href="#2-4-3-IntentFilter-match" class="headerlink" title="2.4.3 IntentFilter.match"></a>2.4.3 IntentFilter.match</h4><p>[-&gt;IntentFilter.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public final int match(ContentResolver resolver, Intent intent,</span><br><span class="line">        boolean resolve, String logTag) &#123;</span><br><span class="line">    String type = resolve ? intent.resolveType(resolver) : intent.getType();</span><br><span class="line">    return match(intent.getAction(), type, intent.getScheme(),</span><br><span class="line">                 intent.getData(), intent.getCategories(), logTag);</span><br><span class="line">&#125;</span><br><span class="line"> public final int match(String action, String type, String scheme,</span><br><span class="line">        Uri data, Set&lt;String&gt; categories, String logTag) &#123;</span><br><span class="line">    //不存在匹配的action，存在即可以</span><br><span class="line">    if (action != null &amp;&amp; !matchAction(action)) &#123;</span><br><span class="line">        if (false) Log.v(</span><br><span class="line">            logTag, &quot;No matching action &quot; + action + &quot; for &quot; + this);</span><br><span class="line">        return NO_MATCH_ACTION;</span><br><span class="line">    &#125;</span><br><span class="line">    //不存在匹配的type或data</span><br><span class="line">    int dataMatch = matchData(type, scheme, data);</span><br><span class="line">    if (dataMatch &lt; 0) &#123;</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            if (dataMatch == NO_MATCH_TYPE) &#123;</span><br><span class="line">                Log.v(logTag, &quot;No matching type &quot; + type</span><br><span class="line">                      + &quot; for &quot; + this);</span><br><span class="line">            &#125;</span><br><span class="line">            if (dataMatch == NO_MATCH_DATA) &#123;</span><br><span class="line">                Log.v(logTag, &quot;No matching scheme/path &quot; + data</span><br><span class="line">                      + &quot; for &quot; + this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dataMatch;</span><br><span class="line">    &#125;</span><br><span class="line">    //不存在匹配的category，需要全部匹配</span><br><span class="line">    String categoryMismatch = matchCategories(categories);</span><br><span class="line">    if (categoryMismatch != null) &#123;</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Log.v(logTag, &quot;No matching category &quot; + categoryMismatch + &quot; for &quot; + this);</span><br><span class="line">        &#125;</span><br><span class="line">        return NO_MATCH_CATEGORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // It would be nice to treat container activities as more</span><br><span class="line">    // important than ones that can be embedded, but this is not the way...</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        if (categories != null) &#123;</span><br><span class="line">            dataMatch -= mCategories.size() - categories.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dataMatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法用于匹配Intent的数据是否成功，匹配的数据包括action,type,data,category四项，任何一项匹配不成功都会失败。</p>
<h4 id="2-4-3-AMS-broadcastQueueForIntent"><a href="#2-4-3-AMS-broadcastQueueForIntent" class="headerlink" title="2.4.3 AMS.broadcastQueueForIntent"></a>2.4.3 AMS.broadcastQueueForIntent</h4><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue broadcastQueueForIntent(Intent intent) &#123;</span><br><span class="line">        final boolean isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0;</span><br><span class="line">        if (DEBUG_BROADCAST_BACKGROUND) Slog.i(TAG_BROADCAST,</span><br><span class="line">                &quot;Broadcast intent &quot; + intent + &quot; on &quot;</span><br><span class="line">                + (isFg ? &quot;foreground&quot; : &quot;background&quot;) + &quot; queue&quot;);</span><br><span class="line">        return (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>broadcastQueueForIntent通过判断intent中是否包含FLAG_RECEIVER_FOREGROUND来决定是前台广播还是后台广播</p>
<h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5  小结"></a>2.5  小结</h3><p>注册广播：</p>
<p>1.注册广播的参数为广播BroadcastReceiver和过滤添加IntentFilter；</p>
<p>2.创建对象LoadedApk.ReceiverDispatcher.InnerReceiver,该对象集成于IIntentReceiver.Stub；</p>
<p>3.通过AMS把当前进程的ApplicationThread和InnerReceiver对象的代理类，注册到systemserver进程；</p>
<p>4.当广播receiver没有注册时，则创建广播接收者队列ReceiverList,该对象集成于ArrayList，并添加到AMS.mRegisteredReceivers(已注册广播队列)；</p>
<p>5.创建BroadcastFilter队列，并添加到AMS.mReceiverResolver</p>
<p>6.将BroadcastFilter添加到广播接收者的ReceiverList</p>
<p>当注册的广播为Sticky广播：</p>
<p>1.创建BroadcastRecord，并添加到BroadcastQueue中的mParallelBroadcasts，注册后，调用AMS处理该广播</p>
<p>2.根据注册的intent中是否包含FLAG_RECEIVER_FOREGROUND,包含则是mFgBroadcastQueue队列，否则为mBgBroadcastQueue队列。</p>
<h2 id="三、发送广播"><a href="#三、发送广播" class="headerlink" title="三、发送广播"></a>三、发送广播</h2><p>和注册广播一样，最后调用的是ContextImpl.sendBroadcast</p>
<h3 id="3-1-CI-sendBroadcast"><a href="#3-1-CI-sendBroadcast" class="headerlink" title="3.1 CI.sendBroadcast"></a>3.1 CI.sendBroadcast</h3><p>[-&gt;ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">      //UID如果是SYSTEM_UID则提示警告信息</span><br><span class="line">      //&quot;Calling a method in the system process without a qualified user:&quot;&quot;</span><br><span class="line">      warnIfCallingFromSystemProcess();</span><br><span class="line">      String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">      try &#123;</span><br><span class="line">          intent.prepareToLeaveProcess(this);</span><br><span class="line">          //通过binder方式调用AMS.broadcastIntent</span><br><span class="line">          ActivityManager.getService().broadcastIntent(</span><br><span class="line">                  mMainThread.getApplicationThread(), intent, resolvedType, null,</span><br><span class="line">                  Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                  getUserId());</span><br><span class="line">      &#125; catch (RemoteException e) &#123;</span><br><span class="line">          throw e.rethrowFromSystemServer();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-AMS-broadcastIntent"><a href="#3-2-AMS-broadcastIntent" class="headerlink" title="3.2  AMS.broadcastIntent"></a>3.2  AMS.broadcastIntent</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final int broadcastIntent(IApplicationThread caller,</span><br><span class="line">           Intent intent, String resolvedType, IIntentReceiver resultTo,</span><br><span class="line">           int resultCode, String resultData, Bundle resultExtras,</span><br><span class="line">           String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">           boolean serialized, boolean sticky, int userId) &#123;</span><br><span class="line">       enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);</span><br><span class="line">       synchronized(this) &#123;</span><br><span class="line">           //验证广播intent是否有效</span><br><span class="line">           intent = verifyBroadcastLocked(intent);</span><br><span class="line">           //获取调用者进程记录对象</span><br><span class="line">           final ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">           final int callingPid = Binder.getCallingPid();</span><br><span class="line">           final int callingUid = Binder.getCallingUid();</span><br><span class="line">           final long origId = Binder.clearCallingIdentity();</span><br><span class="line">           //见3.2节</span><br><span class="line">           int res = broadcastIntentLocked(callerApp,</span><br><span class="line">                   callerApp != null ? callerApp.info.packageName : null,</span><br><span class="line">                   intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                   requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                   callingPid, callingUid, userId);</span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">           return res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>broadcastIntent有两个boolean值参数serialized、sticky共同决定是普通广播，有效广播，还是sticky广播。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th>serialized</th>
<th>sticky</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sendBroadcast</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td style="text-align:left">sendOrderedBroadcast</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td style="text-align:left">sendStickyBroadcast</td>
<td>false</td>
<td>true</td>
</tr>
</tbody>
</table>
<h3 id="3-3-AMS-broadcastIntentLocked"><a href="#3-3-AMS-broadcastIntentLocked" class="headerlink" title="3.3  AMS.broadcastIntentLocked"></a>3.3  AMS.broadcastIntentLocked</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">   final int broadcastIntentLocked(ProcessRecord callerApp,</span><br><span class="line">           String callerPackage, Intent intent, String resolvedType,</span><br><span class="line">           IIntentReceiver resultTo, int resultCode, String resultData,</span><br><span class="line">           Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">           boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123;</span><br><span class="line">           </span><br><span class="line">        //setp1：设置广播flags</span><br><span class="line">        //setp2：广播权限验证</span><br><span class="line">        //setp3：处理系统相关广播</span><br><span class="line">        //setp4：增加sticky广播</span><br><span class="line">        //setp5：查询receivers和registeredReceivers</span><br><span class="line">        //setp6：处理并行广播</span><br><span class="line">        //setp7：合并registeredReceivers到receivers</span><br><span class="line">        //setp8：处理串行广播</span><br><span class="line">       </span><br><span class="line">       return ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法比较长，这里分为8部分进行分析。</p>
<h4 id="3-3-1-设置广播flags"><a href="#3-3-1-设置广播flags" class="headerlink" title="3.3.1 设置广播flags"></a>3.3.1 设置广播flags</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">intent = new Intent(intent);</span><br><span class="line">//判断是否是即时应用</span><br><span class="line">final boolean callerInstantApp = isInstantApp(callerApp, callerPackage, callingUid);</span><br><span class="line">//即时应用如果没有设置FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS则不会收到广播</span><br><span class="line">// Instant Apps cannot use FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS</span><br><span class="line">if (callerInstantApp) &#123;</span><br><span class="line">    intent.setFlags(intent.getFlags() &amp; ~Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);</span><br><span class="line">&#125;</span><br><span class="line">//增加flag,广播不会发送给已经停止的package</span><br><span class="line">// By default broadcasts do not go to stopped apps.</span><br><span class="line">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line"></span><br><span class="line">//系统没有启动完成，不允许启动新进程</span><br><span class="line">// If we have not finished booting, don&apos;t allow this to launch new processes.</span><br><span class="line">if (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123;</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">        (sticky ? &quot;Broadcast sticky: &quot;: &quot;Broadcast: &quot;) + intent</span><br><span class="line">        + &quot; ordered=&quot; + ordered + &quot; userid=&quot; + userId);</span><br><span class="line">if ((resultTo != null) &amp;&amp; !ordered) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;Broadcast &quot; + intent + &quot; not ordered but result callback requested!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, true,</span><br><span class="line">        ALLOW_NON_FULL, &quot;broadcast&quot;, callerPackage);</span><br><span class="line">//检查发送广播时的用户状态</span><br><span class="line">// Make sure that the user who is receiving this broadcast or its parent is running.</span><br><span class="line">// If not, we will just skip it. Make an exception for shutdown broadcasts, upgrade steps.</span><br><span class="line">if (userId != UserHandle.USER_ALL &amp;&amp; !mUserController.isUserOrItsParentRunning(userId)) &#123;</span><br><span class="line">    if ((callingUid != SYSTEM_UID</span><br><span class="line">            || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0)</span><br><span class="line">            &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Skipping broadcast of &quot; + intent</span><br><span class="line">                + &quot;: user &quot; + userId + &quot; and its parent (if any) are stopped&quot;);</span><br><span class="line">        return ActivityManager.BROADCAST_FAILED_USER_STOPPED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程主要的工作如下：</p>
<p>1.是否设置FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS标志，如果设置广播对即时应用可见；</p>
<p>2.添加flagFLAG_EXCLUDE_STOPPED_PACKAGES,保证已经停止的app不会收到广播；</p>
<p>3.当系统还没有启动完成，不允许启动新进程；</p>
<p>4.非USER_ALL广播且接收广播的用户没有处于Running的情况下，除非是系统升级广播和关键广播，否则直接返回。</p>
<p>BroadcastReceiver还有其他flag，位于Intent.java常量中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FLAG_RECEIVER_REGISTERED_ONLY  //只允许已经注册的receiver接收广播</span><br><span class="line">FLAG_RECEIVER_REPLACE_PENDING //新广播会替代相同广播</span><br><span class="line">FLAG_RECEIVER_FOREGROUND  //只允许前台receiver接收广播</span><br><span class="line">FLAG_RECEIVER_NO_ABORT  //对于有序广播，先接收到的receiver无权抛弃广播</span><br><span class="line">FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT  //boot完成之前，只允许已注册的receiver接收广播</span><br><span class="line">FLAG_RECEIVER_BOOT_UPGRADE //升级模式下，允许系统准备就绪前发送广播</span><br><span class="line">FLAG_RECEIVER_INCLUDE_BACKGROUND  //允许后台台receiver接收广播</span><br><span class="line">FLAG_RECEIVER_EXCLUDE_BACKGROUND //不允许后台台receiver接收广播</span><br><span class="line">FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS //广播对即时应用可见</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-广播权限验证"><a href="#3-3-2-广播权限验证" class="headerlink" title="3.3.2 广播权限验证"></a>3.3.2 广播权限验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">final String action = intent.getAction();</span><br><span class="line">     BroadcastOptions brOptions = null;</span><br><span class="line">     if (bOptions != null) &#123;</span><br><span class="line">         brOptions = new BroadcastOptions(bOptions);</span><br><span class="line">         if (brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123;</span><br><span class="line">             //如果AppWhitelistDuration&gt;0,检查是否有CHANGE_DEVICE_IDLE_TEMP_WHITELIST权限</span><br><span class="line">             // See if the caller is allowed to do this.  Note we are checking against</span><br><span class="line">             // the actual real caller (not whoever provided the operation as say a</span><br><span class="line">             // PendingIntent), because that who is actually supplied the arguments.</span><br><span class="line">             if (checkComponentPermission(</span><br><span class="line">                     android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,</span><br><span class="line">                     Binder.getCallingPid(), Binder.getCallingUid(), -1, true)</span><br><span class="line">                     != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                 String msg = &quot;Permission Denial: &quot; + intent.getAction()</span><br><span class="line">                         + &quot; broadcast from &quot; + callerPackage + &quot; (pid=&quot; + callingPid</span><br><span class="line">                         + &quot;, uid=&quot; + callingUid + &quot;)&quot;</span><br><span class="line">                         + &quot; requires &quot;</span><br><span class="line">                         + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;</span><br><span class="line">                 Slog.w(TAG, msg);</span><br><span class="line">                 throw new SecurityException(msg);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //检查是否有后台限制</span><br><span class="line">         if (brOptions.isDontSendToRestrictedApps()</span><br><span class="line">                 &amp;&amp; !isUidActiveLocked(callingUid)</span><br><span class="line">                 &amp;&amp; isBackgroundRestrictedNoCheck(callingUid, callerPackage)) &#123;</span><br><span class="line">             Slog.i(TAG, &quot;Not sending broadcast &quot; + action + &quot; - app &quot; + callerPackage</span><br><span class="line">                     + &quot; has background restrictions&quot;);</span><br><span class="line">             return ActivityManager.START_CANCELED;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     //检查受保护的广播只允许系统使用</span><br><span class="line">     // Verify that protected broadcasts are only being sent by system code,</span><br><span class="line">     // and that system code is only sending protected broadcasts.</span><br><span class="line">     final boolean isProtectedBroadcast;</span><br><span class="line">     try &#123;</span><br><span class="line">         isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br><span class="line">     &#125; catch (RemoteException e) &#123;</span><br><span class="line">         Slog.w(TAG, &quot;Remote exception&quot;, e);</span><br><span class="line">         return ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     final boolean isCallerSystem;</span><br><span class="line">     switch (UserHandle.getAppId(callingUid)) &#123;</span><br><span class="line">         case ROOT_UID:</span><br><span class="line">         case SYSTEM_UID:</span><br><span class="line">         case PHONE_UID:</span><br><span class="line">         case BLUETOOTH_UID:</span><br><span class="line">         case NFC_UID:</span><br><span class="line">         case SE_UID:</span><br><span class="line">         case NETWORK_STACK_UID:</span><br><span class="line">             isCallerSystem = true;</span><br><span class="line">             break;</span><br><span class="line">         default:</span><br><span class="line">             isCallerSystem = (callerApp != null) &amp;&amp; callerApp.persistent;</span><br><span class="line">             break;</span><br><span class="line">     &#125;</span><br><span class="line">     //非系统发送的广播</span><br><span class="line">     // First line security check before anything else: stop non-system apps from</span><br><span class="line">     // sending protected broadcasts.</span><br><span class="line">     if (!isCallerSystem) &#123;</span><br><span class="line">         //是保护广播，则抛出异常</span><br><span class="line">         if (isProtectedBroadcast) &#123;</span><br><span class="line">             String msg = &quot;Permission Denial: not allowed to send broadcast &quot;</span><br><span class="line">                     + action + &quot; from pid=&quot;</span><br><span class="line">                     + callingPid + &quot;, uid=&quot; + callingUid;</span><br><span class="line">             Slog.w(TAG, msg);</span><br><span class="line">             throw new SecurityException(msg);</span><br><span class="line"></span><br><span class="line">         &#125; else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">                 || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;</span><br><span class="line">             //限制广播只发送自己    </span><br><span class="line">             // Special case for compatibility: we don&apos;t want apps to send this,</span><br><span class="line">             // but historically it has not been protected and apps may be using it</span><br><span class="line">             // to poke their own app widget.  So, instead of making it protected,</span><br><span class="line">             // just limit it to the caller.</span><br><span class="line">             if (callerPackage == null) &#123;</span><br><span class="line">                 String msg = &quot;Permission Denial: not allowed to send broadcast &quot;</span><br><span class="line">                         + action + &quot; from unknown caller.&quot;;</span><br><span class="line">                 Slog.w(TAG, msg);</span><br><span class="line">                 throw new SecurityException(msg);</span><br><span class="line">             &#125; else if (intent.getComponent() != null) &#123;</span><br><span class="line">                 // They are good enough to send to an explicit component...  verify</span><br><span class="line">                 // it is being sent to the calling app.</span><br><span class="line">                 if (!intent.getComponent().getPackageName().equals(</span><br><span class="line">                         callerPackage)) &#123;</span><br><span class="line">                     String msg = &quot;Permission Denial: not allowed to send broadcast &quot;</span><br><span class="line">                             + action + &quot; to &quot;</span><br><span class="line">                             + intent.getComponent().getPackageName() + &quot; from &quot;</span><br><span class="line">                             + callerPackage;</span><br><span class="line">                     Slog.w(TAG, msg);</span><br><span class="line">                     throw new SecurityException(msg);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 // Limit broadcast to their own package.</span><br><span class="line">                 intent.setPackage(callerPackage);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">      if (action != null) &#123;</span><br><span class="line">         //如果允许后台应用接收广播，则添加FLAG_RECEIVER_INCLUDE_BACKGROUND</span><br><span class="line">         if (getBackgroundLaunchBroadcasts().contains(action)) &#123;</span><br><span class="line">             if (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">                 Slog.i(TAG, &quot;Broadcast action &quot; + action + &quot; forcing include-background&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>主要工作如下：</p>
<p>1.如果TemporaryAppWhitelistDuration&gt;0,检查是否有CHANGE_DEVICE_IDLE_TEMP_WHITELIST权限，没有抛出异常</p>
<p>2.检查是否后台限制发送广播，如果限制，则后台应用将不能发送广播</p>
<p>3.callingUid为 ROOT_UID， SYSTEM_UID，PHONE_UID，BLUETOOTH_UID，NFC_UID，SE_UID，NETWORK_STACK_UID和persistent进程时，可以发送受保护广播</p>
<p>4.为非系统应用发送广播时：当发送的是受保护的广播，则抛出异常；当action为ACTION_APPWIDGET_CONFIGURE或ACTION_APPWIDGET_UPDATE时，限制该广播只发送给自己，否则抛出异常。</p>
<p>5.如果允许后台应用接收广播，则添加FLAG_RECEIVER_INCLUDE_BACKGROUND</p>
<h4 id="3-3-3-处理系统相关广播"><a href="#3-3-3-处理系统相关广播" class="headerlink" title="3.3.3 处理系统相关广播"></a>3.3.3 处理系统相关广播</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">switch (action) &#123;</span><br><span class="line">             case Intent.ACTION_UID_REMOVED://uid移除</span><br><span class="line">             case Intent.ACTION_PACKAGE_REMOVED://package移除</span><br><span class="line">             case Intent.ACTION_PACKAGE_CHANGED://改变package</span><br><span class="line">             case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE://外部设备不可用</span><br><span class="line">             case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">             case Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line">             case Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">                 // Handle special intents: if this broadcast is from the package</span><br><span class="line">                 // manager about a package being removed, we need to remove all of</span><br><span class="line">                 // its activities from the history stack.</span><br><span class="line">                 if (checkComponentPermission(</span><br><span class="line">                         android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,</span><br><span class="line">                         callingPid, callingUid, -1, true)</span><br><span class="line">                         != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                     String msg = &quot;Permission Denial: &quot; + intent.getAction()</span><br><span class="line">                             + &quot; broadcast from &quot; + callerPackage + &quot; (pid=&quot; + callingPid</span><br><span class="line">                             + &quot;, uid=&quot; + callingUid + &quot;)&quot;</span><br><span class="line">                             + &quot; requires &quot;</span><br><span class="line">                             + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;</span><br><span class="line">                     Slog.w(TAG, msg);</span><br><span class="line">                     throw new SecurityException(msg);</span><br><span class="line">                 &#125;</span><br><span class="line">                 switch (action) &#123;</span><br><span class="line">                     case Intent.ACTION_UID_REMOVED:</span><br><span class="line">                         final int uid = getUidFromIntent(intent);</span><br><span class="line">                         if (uid &gt;= 0) &#123;</span><br><span class="line">                             mBatteryStatsService.removeUid(uid);</span><br><span class="line">                             mAppOpsService.uidRemoved(uid);</span><br><span class="line">                         &#125;</span><br><span class="line">                         break;</span><br><span class="line">                     case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:</span><br><span class="line">                         // If resources are unavailable just force stop all those packages</span><br><span class="line">                         // and flush the attribute cache as well.</span><br><span class="line">                         String list[] =</span><br><span class="line">                                 intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">                         if (list != null &amp;&amp; list.length &gt; 0) &#123;</span><br><span class="line">                             for (int i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">                                 forceStopPackageLocked(list[i], -1, false, true, true,</span><br><span class="line">                                         false, false, userId, &quot;storage unmount&quot;);</span><br><span class="line">                             &#125;</span><br><span class="line">                             mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">                             sendPackageBroadcastLocked(</span><br><span class="line">                                     ApplicationThreadConstants.EXTERNAL_STORAGE_UNAVAILABLE,</span><br><span class="line">                                     list, userId);</span><br><span class="line">                         &#125;</span><br><span class="line">                         break;</span><br><span class="line">                     case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">                         mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">                         break;</span><br><span class="line">                     case Intent.ACTION_PACKAGE_REMOVED:</span><br><span class="line">                     case Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">                         Uri data = intent.getData();</span><br><span class="line">                         String ssp;</span><br><span class="line">                         if (data != null &amp;&amp; (ssp=data.getSchemeSpecificPart()) != null) &#123;</span><br><span class="line">                             boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);</span><br><span class="line">                             final boolean replacing =</span><br><span class="line">                                     intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span><br><span class="line">                             final boolean killProcess =</span><br><span class="line">                                     !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);</span><br><span class="line">                             final boolean fullUninstall = removed &amp;&amp; !replacing;</span><br><span class="line">                             if (removed) &#123;</span><br><span class="line">                                 if (killProcess) &#123;</span><br><span class="line">                                     forceStopPackageLocked(ssp, UserHandle.getAppId(</span><br><span class="line">                                             intent.getIntExtra(Intent.EXTRA_UID, -1)),</span><br><span class="line">                                             false, true, true, false, fullUninstall, userId,</span><br><span class="line">                                             removed ? &quot;pkg removed&quot; : &quot;pkg changed&quot;);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 final int cmd = killProcess</span><br><span class="line">                                         ? ApplicationThreadConstants.PACKAGE_REMOVED</span><br><span class="line">                                         : ApplicationThreadConstants.PACKAGE_REMOVED_DONT_KILL;</span><br><span class="line">                                 sendPackageBroadcastLocked(cmd,</span><br><span class="line">                                         new String[] &#123;ssp&#125;, userId);</span><br><span class="line">                                 if (fullUninstall) &#123;</span><br><span class="line">                                     mAppOpsService.packageRemoved(</span><br><span class="line">                                             intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);</span><br><span class="line"></span><br><span class="line">                                     // Remove all permissions granted from/to this package</span><br><span class="line">                                     removeUriPermissionsForPackageLocked(ssp, userId, true,</span><br><span class="line">                                             false);</span><br><span class="line"></span><br><span class="line">                                     mRecentTasks.removeTasksByPackageName(ssp, userId);</span><br><span class="line"></span><br><span class="line">                                     mServices.forceStopPackageLocked(ssp, userId);</span><br><span class="line">                                     mAppWarnings.onPackageUninstalled(ssp);</span><br><span class="line">                                     mCompatModePackages.handlePackageUninstalledLocked(ssp);</span><br><span class="line">                                     mBatteryStatsService.notePackageUninstalled(ssp);</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125; else &#123;</span><br><span class="line">                                 if (killProcess) &#123;</span><br><span class="line">                                     killPackageProcessesLocked(ssp, UserHandle.getAppId(</span><br><span class="line">                                             intent.getIntExtra(Intent.EXTRA_UID, -1)),</span><br><span class="line">                                             userId, ProcessList.INVALID_ADJ,</span><br><span class="line">                                             false, true, true, false, &quot;change &quot; + ssp);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess,</span><br><span class="line">                                         intent.getStringArrayExtra(</span><br><span class="line">                                                 Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                         break;</span><br><span class="line">                     case Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line">                     case Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">                         final boolean suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals(</span><br><span class="line">                                 intent.getAction());</span><br><span class="line">                         final String[] packageNames = intent.getStringArrayExtra(</span><br><span class="line">                                 Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">                         final int userHandle = intent.getIntExtra(</span><br><span class="line">                                 Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);</span><br><span class="line"></span><br><span class="line">                         synchronized(ActivityManagerService.this) &#123;</span><br><span class="line">                             mRecentTasks.onPackagesSuspendedChanged(</span><br><span class="line">                                     packageNames, suspended, userHandle);</span><br><span class="line">                         &#125;</span><br><span class="line">                         break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">             case Intent.ACTION_PACKAGE_REPLACED:</span><br><span class="line">             &#123;</span><br><span class="line">                 final Uri data = intent.getData();</span><br><span class="line">                 final String ssp;</span><br><span class="line">                 if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123;</span><br><span class="line">                     ApplicationInfo aInfo = null;</span><br><span class="line">                     try &#123;</span><br><span class="line">                         aInfo = AppGlobals.getPackageManager()</span><br><span class="line">                                 .getApplicationInfo(ssp, STOCK_PM_FLAGS, userId);</span><br><span class="line">                     &#125; catch (RemoteException ignore) &#123;&#125;</span><br><span class="line">                     if (aInfo == null) &#123;</span><br><span class="line">                         Slog.w(TAG, &quot;Dropping ACTION_PACKAGE_REPLACED for non-existent pkg:&quot;</span><br><span class="line">                                 + &quot; ssp=&quot; + ssp + &quot; data=&quot; + data);</span><br><span class="line">                         return ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">                     &#125;</span><br><span class="line">                     mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);</span><br><span class="line">                     mServices.updateServiceApplicationInfoLocked(aInfo);</span><br><span class="line">                     sendPackageBroadcastLocked(ApplicationThreadConstants.PACKAGE_REPLACED,</span><br><span class="line">                             new String[] &#123;ssp&#125;, userId);</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             case Intent.ACTION_PACKAGE_ADDED:</span><br><span class="line">             &#123;</span><br><span class="line">                 // Special case for adding a package: by default turn on compatibility mode.</span><br><span class="line">                 Uri data = intent.getData();</span><br><span class="line">                 String ssp;</span><br><span class="line">                 if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123;</span><br><span class="line">                     final boolean replacing =</span><br><span class="line">                             intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span><br><span class="line">                     mCompatModePackages.handlePackageAddedLocked(ssp, replacing);</span><br><span class="line"></span><br><span class="line">                     try &#123;</span><br><span class="line">                         ApplicationInfo ai = AppGlobals.getPackageManager().</span><br><span class="line">                                 getApplicationInfo(ssp, STOCK_PM_FLAGS, 0);</span><br><span class="line">                         mBatteryStatsService.notePackageInstalled(ssp,</span><br><span class="line">                                 ai != null ? ai.versionCode : 0);</span><br><span class="line">                     &#125; catch (RemoteException e) &#123;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             case Intent.ACTION_PACKAGE_DATA_CLEARED:</span><br><span class="line">             &#123;</span><br><span class="line">                 Uri data = intent.getData();</span><br><span class="line">                 String ssp;</span><br><span class="line">                 if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123;</span><br><span class="line">                     mCompatModePackages.handlePackageDataClearedLocked(ssp);</span><br><span class="line">                     mAppWarnings.onPackageDataCleared(ssp);</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             case Intent.ACTION_TIMEZONE_CHANGED:</span><br><span class="line">                 // If this is the time zone changed action, queue up a message that will reset</span><br><span class="line">                 // the timezone of all currently running processes. This message will get</span><br><span class="line">                 // queued up before the broadcast happens.</span><br><span class="line">                 mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);</span><br><span class="line">                 break;</span><br><span class="line">             case Intent.ACTION_TIME_CHANGED:</span><br><span class="line">                 // EXTRA_TIME_PREF_24_HOUR_FORMAT is optional so we must distinguish between</span><br><span class="line">                 // the tri-state value it may contain and &quot;unknown&quot;.</span><br><span class="line">                 // For convenience we re-use the Intent extra values.</span><br><span class="line">                 final int NO_EXTRA_VALUE_FOUND = -1;</span><br><span class="line">                 final int timeFormatPreferenceMsgValue = intent.getIntExtra(</span><br><span class="line">                         Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,</span><br><span class="line">                         NO_EXTRA_VALUE_FOUND /* defaultValue */);</span><br><span class="line">                 // Only send a message if the time preference is available.</span><br><span class="line">                 if (timeFormatPreferenceMsgValue != NO_EXTRA_VALUE_FOUND) &#123;</span><br><span class="line">                     Message updateTimePreferenceMsg =</span><br><span class="line">                             mHandler.obtainMessage(UPDATE_TIME_PREFERENCE_MSG,</span><br><span class="line">                                     timeFormatPreferenceMsgValue, 0);</span><br><span class="line">                     mHandler.sendMessage(updateTimePreferenceMsg);</span><br><span class="line">                 &#125;</span><br><span class="line">                 BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">                 synchronized (stats) &#123;</span><br><span class="line">                     stats.noteCurrentTimeChangedLocked();</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">             case Intent.ACTION_CLEAR_DNS_CACHE:  //清除DNS cache</span><br><span class="line">                 mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);</span><br><span class="line">                 break;</span><br><span class="line">             case Proxy.PROXY_CHANGE_ACTION: //网络代理改变</span><br><span class="line">                 mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG));</span><br><span class="line">                 break;</span><br><span class="line">             case android.hardware.Camera.ACTION_NEW_PICTURE:</span><br><span class="line">             case android.hardware.Camera.ACTION_NEW_VIDEO:</span><br><span class="line">                 // In N we just turned these off; in O we are turing them back on partly,</span><br><span class="line">                 // only for registered receivers.  This will still address the main problem</span><br><span class="line">                 // (a spam of apps waking up when a picture is taken putting significant</span><br><span class="line">                 // memory pressure on the system at a bad point), while still allowing apps</span><br><span class="line">                 // that are already actively running to know about this happening.</span><br><span class="line">                 intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">                 break;</span><br><span class="line">             case android.security.KeyChain.ACTION_TRUST_STORE_CHANGED:</span><br><span class="line">                 mHandler.sendEmptyMessage(HANDLE_TRUST_STORAGE_UPDATE_MSG);</span><br><span class="line">                 break;</span><br><span class="line">             case &quot;com.android.launcher.action.INSTALL_SHORTCUT&quot;:</span><br><span class="line">                 // As of O, we no longer support this broadcasts, even for pre-O apps.</span><br><span class="line">                 // Apps should now be using ShortcutManager.pinRequestShortcut().</span><br><span class="line">                 Log.w(TAG, &quot;Broadcast &quot; + action</span><br><span class="line">                         + &quot; no longer supported. It will not be delivered.&quot;);</span><br><span class="line">                 return ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (Intent.ACTION_PACKAGE_ADDED.equals(action) ||</span><br><span class="line">                 Intent.ACTION_PACKAGE_REMOVED.equals(action) ||</span><br><span class="line">                 Intent.ACTION_PACKAGE_REPLACED.equals(action)) &#123;</span><br><span class="line">             final int uid = getUidFromIntent(intent);</span><br><span class="line">             if (uid != -1) &#123;</span><br><span class="line">                 final UidRecord uidRec = mActiveUids.get(uid);</span><br><span class="line">                 if (uidRec != null) &#123;</span><br><span class="line">                     uidRec.updateHasInternetPermission();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>该过程主要系统广播，主要是package、时间、网络相关的广播，并对这些广播进行相应的处理。</p>
<h4 id="3-3-4-增加sticky广播"><a href="#3-3-4-增加sticky广播" class="headerlink" title="3.3.4 增加sticky广播"></a>3.3.4 增加sticky广播</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// Add to the sticky list if requested.</span><br><span class="line">  if (sticky) &#123;</span><br><span class="line">      //检查是否有BROADCAST_STICKY权限</span><br><span class="line">      if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,</span><br><span class="line">              callingPid, callingUid)</span><br><span class="line">              != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">          String msg = &quot;Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=&quot;</span><br><span class="line">                  + callingPid + &quot;, uid=&quot; + callingUid</span><br><span class="line">                  + &quot; requires &quot; + android.Manifest.permission.BROADCAST_STICKY;</span><br><span class="line">          Slog.w(TAG, msg);</span><br><span class="line">          throw new SecurityException(msg);</span><br><span class="line">      &#125;</span><br><span class="line">      if (requiredPermissions != null &amp;&amp; requiredPermissions.length &gt; 0) &#123;</span><br><span class="line">          Slog.w(TAG, &quot;Can&apos;t broadcast sticky intent &quot; + intent</span><br><span class="line">                  + &quot; and enforce permissions &quot; + Arrays.toString(requiredPermissions));</span><br><span class="line">          return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;</span><br><span class="line">      &#125;</span><br><span class="line">      //发送指定组件，抛出异常</span><br><span class="line">      if (intent.getComponent() != null) &#123;</span><br><span class="line">          throw new SecurityException(</span><br><span class="line">                  &quot;Sticky broadcasts can&apos;t target a specific component&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //当非USER_ALL广播和USER_ALL冲突</span><br><span class="line">      // We use userId directly here, since the &quot;all&quot; target is maintained</span><br><span class="line">      // as a separate set of sticky broadcasts.</span><br><span class="line">      if (userId != UserHandle.USER_ALL) &#123;</span><br><span class="line">          // But first, if this is not a broadcast to all users, then</span><br><span class="line">          // make sure it doesn&apos;t conflict with an existing broadcast to</span><br><span class="line">          // all users.</span><br><span class="line">          ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(</span><br><span class="line">                  UserHandle.USER_ALL);</span><br><span class="line">          if (stickies != null) &#123;</span><br><span class="line">              ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">              if (list != null) &#123;</span><br><span class="line">                  int N = list.size();</span><br><span class="line">                  int i;</span><br><span class="line">                  for (i=0; i&lt;N; i++) &#123;</span><br><span class="line">                      if (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                          throw new IllegalArgumentException(</span><br><span class="line">                                  &quot;Sticky broadcast &quot; + intent + &quot; for user &quot;</span><br><span class="line">                                  + userId + &quot; conflicts with existing global broadcast&quot;);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">      if (stickies == null) &#123;</span><br><span class="line">          stickies = new ArrayMap&lt;&gt;();</span><br><span class="line">          mStickyBroadcasts.put(userId, stickies);</span><br><span class="line">      &#125;</span><br><span class="line">      ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">      if (list == null) &#123;</span><br><span class="line">          list = new ArrayList&lt;&gt;();</span><br><span class="line">          stickies.put(intent.getAction(), list);</span><br><span class="line">      &#125;</span><br><span class="line">      final int stickiesCount = list.size();</span><br><span class="line">      int i;</span><br><span class="line">      for (i = 0; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">          if (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">              // This sticky already exists, replace it.</span><br><span class="line">              list.set(i, new Intent(intent));</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (i &gt;= stickiesCount) &#123;</span><br><span class="line">          list.add(new Intent(intent));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个过程主要是检查sticky广播，将sticky广播放入到mStickyBroadcasts，并增加到list</p>
<h4 id="3-3-5-查询receivers和registeredReceivers"><a href="#3-3-5-查询receivers和registeredReceivers" class="headerlink" title="3.3.5 查询receivers和registeredReceivers"></a>3.3.5 查询receivers和registeredReceivers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//发送广播的user</span><br><span class="line">int[] users;</span><br><span class="line">if (userId == UserHandle.USER_ALL) &#123;</span><br><span class="line">    // Caller wants broadcast to go to all started users.</span><br><span class="line">    users = mUserController.getStartedUserArray();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Caller wants broadcast to go to one specific user.</span><br><span class="line">    users = new int[] &#123;userId&#125;;</span><br><span class="line">&#125;</span><br><span class="line">//查询哪些广播将会接受广播</span><br><span class="line">// Figure out who all will receive this broadcast.</span><br><span class="line">List receivers = null;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = null;</span><br><span class="line">// Need to resolve the intent to interested receivers...</span><br><span class="line">//当允许静态接收者处理广播时，则通过PKMS根据intent查询静态receivers</span><br><span class="line">if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">         == 0) &#123;</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line">if (intent.getComponent() == null) &#123;</span><br><span class="line">    if (userId == UserHandle.USER_ALL &amp;&amp; callingUid == SHELL_UID) &#123;</span><br><span class="line">        // Query one target user at a time, excluding shell-restricted users</span><br><span class="line">        for (int i = 0; i &lt; users.length; i++) &#123;</span><br><span class="line">            if (mUserController.hasUserRestriction(</span><br><span class="line">                    UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //查询动态注册广播</span><br><span class="line">            List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                    mReceiverResolver.queryIntent(intent,</span><br><span class="line">                            resolvedType, false /*defaultOnly*/, users[i]);</span><br><span class="line">            if (registeredReceivers == null) &#123;</span><br><span class="line">                registeredReceivers = registeredReceiversForUser;</span><br><span class="line">            &#125; else if (registeredReceiversForUser != null) &#123;</span><br><span class="line">                registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                resolvedType, false /*defaultOnly*/, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要工作如下：</p>
<p>1.根据userId判断发送的是全部的接收者还是指定的userId</p>
<p>2.查询广播，并将其放入到两个列表：</p>
<p>registeredReceivers：来匹配当前intent的所有动态注册的广播接收者（mReceiverResolver见2.4节）</p>
<p>receivers：记录当前intent的所有静态注册的广播接收者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;ResolveInfo&gt; collectReceiverComponents(Intent intent, String resolvedType,</span><br><span class="line">         int callingUid, int[] users) &#123;</span><br><span class="line">    ...</span><br><span class="line">   //调用PKMS的queryIntentReceivers，可以获取AndroidManifeset中注册的接收信息</span><br><span class="line">    List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()</span><br><span class="line">                     .queryIntentReceivers(intent, resolvedType, pmFlags, user).getList();</span><br><span class="line">    ...        </span><br><span class="line">    return receivers;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-6-处理并行广播"><a href="#3-3-6-处理并行广播" class="headerlink" title="3.3.6 处理并行广播"></a>3.3.6 处理并行广播</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//用于标识是否需要用新的intent替换旧的intent</span><br><span class="line">final boolean replacePending =</span><br><span class="line">        (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;</span><br><span class="line"></span><br><span class="line">if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing broadcast: &quot; + intent.getAction()</span><br><span class="line">        + &quot; replacePending=&quot; + replacePending);</span><br><span class="line">//处理并行广播</span><br><span class="line">int NR = registeredReceivers != null ? registeredReceivers.size() : 0;</span><br><span class="line">//发送的不是有序广播</span><br><span class="line">if (!ordered &amp;&amp; NR &gt; 0) &#123;</span><br><span class="line">    // If we are not serializing this broadcast, then send the</span><br><span class="line">    // registered receivers separately so they don&apos;t wait for the</span><br><span class="line">    // components to be launched.</span><br><span class="line">    //检查系统发送的广播</span><br><span class="line">    if (isCallerSystem) &#123;</span><br><span class="line">        checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                isProtectedBroadcast, registeredReceivers);</span><br><span class="line">    &#125;</span><br><span class="line">    //根据intent的flag来判断前台队列还是后台队列，见2.4.3节</span><br><span class="line">    final BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">    //创建BroadcastRecord</span><br><span class="line">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, registeredReceivers, resultTo,</span><br><span class="line">            resultCode, resultData, resultExtras, ordered, sticky, false, userId);</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</span><br><span class="line">    final boolean replaced = replacePending</span><br><span class="line">            &amp;&amp; (queue.replaceParallelBroadcastLocked(r) != null);</span><br><span class="line">    // Note: We assume resultTo is null for non-ordered broadcasts.</span><br><span class="line">    if (!replaced) &#123;</span><br><span class="line">        //将BroadcastRecord加入到并行广播队列</span><br><span class="line">        queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">        //处理广播，见4.1节</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    //动态注册的广播接收者处理完成，则将该变量设置为空</span><br><span class="line">    registeredReceivers = null;</span><br><span class="line">    NR = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广播队列中有一个mParallelBroadcasts变量，类型为ArrayList，记录所有的并行广播</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void enqueueParallelBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">      mParallelBroadcasts.add(r);</span><br><span class="line">      enqueueBroadcastHelper(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-7-合并registeredReceivers到receivers"><a href="#3-3-7-合并registeredReceivers到receivers" class="headerlink" title="3.3.7 合并registeredReceivers到receivers"></a>3.3.7 合并registeredReceivers到receivers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// Merge into one list.</span><br><span class="line">int ir = 0;</span><br><span class="line">if (receivers != null) &#123;</span><br><span class="line">    //防止应用监听广播，在安装时直接运行</span><br><span class="line">    // A special case for PACKAGE_ADDED: do not allow the package</span><br><span class="line">    // being added to see this broadcast.  This prevents them from</span><br><span class="line">    // using this as a back door to get run as soon as they are</span><br><span class="line">    // installed.  Maybe in the future we want to have a special install</span><br><span class="line">    // broadcast or such for apps, but we&apos;d like to deliberately make</span><br><span class="line">    // this decision.</span><br><span class="line">    String skipPackages[] = null;</span><br><span class="line">    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())</span><br><span class="line">            || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())</span><br><span class="line">            || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;</span><br><span class="line">        Uri data = intent.getData();</span><br><span class="line">        if (data != null) &#123;</span><br><span class="line">            String pkgName = data.getSchemeSpecificPart();</span><br><span class="line">            if (pkgName != null) &#123;</span><br><span class="line">                skipPackages = new String[] &#123; pkgName &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;</span><br><span class="line">        skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">    &#125;</span><br><span class="line">    //将skipPackages相关的广播接收者从receivers列表中移除。</span><br><span class="line">    if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123;</span><br><span class="line">        for (String skipPackage : skipPackages) &#123;</span><br><span class="line">            if (skipPackage != null) &#123;</span><br><span class="line">                int NT = receivers.size();</span><br><span class="line">                for (int it=0; it&lt;NT; it++) &#123;</span><br><span class="line">                    ResolveInfo curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">                    if (curt.activityInfo.packageName.equals(skipPackage)) &#123;</span><br><span class="line">                        receivers.remove(it);</span><br><span class="line">                        it--;</span><br><span class="line">                        NT--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //3.4.6节有处理动态广播的过程，处理完成后再执行将动态注册的registeredReceivers合并到receivers中</span><br><span class="line">    int NT = receivers != null ? receivers.size() : 0;</span><br><span class="line">    int it = 0;</span><br><span class="line">    ResolveInfo curt = null;</span><br><span class="line">    BroadcastFilter curr = null;</span><br><span class="line">    while (it &lt; NT &amp;&amp; ir &lt; NR) &#123;</span><br><span class="line">        if (curt == null) &#123;</span><br><span class="line">            curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">        &#125;</span><br><span class="line">        if (curr == null) &#123;</span><br><span class="line">            curr = registeredReceivers.get(ir);</span><br><span class="line">        &#125;</span><br><span class="line">        //优先级大的，则插到前面</span><br><span class="line">        if (curr.getPriority() &gt;= curt.priority) &#123;</span><br><span class="line">            // Insert this broadcast record into the final list.</span><br><span class="line">            receivers.add(it, curr);</span><br><span class="line">            ir++;</span><br><span class="line">            curr = null;</span><br><span class="line">            it++;</span><br><span class="line">            NT++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Skip to the next ResolveInfo in the final list.</span><br><span class="line">            it++;</span><br><span class="line">            curt = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">while (ir &lt; NR) &#123;</span><br><span class="line">    if (receivers == null) &#123;</span><br><span class="line">        receivers = new ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    receivers.add(registeredReceivers.get(ir));</span><br><span class="line">    ir++;</span><br><span class="line">&#125;</span><br><span class="line">//检查系统发送的广播</span><br><span class="line">if (isCallerSystem) &#123;</span><br><span class="line">    checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">            isProtectedBroadcast, receivers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是将动态注册的registeredReceivers（如果发送的广播不是有序广播则registeredReceivers = null）全部合并到receivers，再统一按照串行方式处理。</p>
<h4 id="3-3-8-处理串行广播"><a href="#3-3-8-处理串行广播" class="headerlink" title="3.3.8 处理串行广播"></a>3.3.8 处理串行广播</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">if ((receivers != null &amp;&amp; receivers.size() &gt; 0)</span><br><span class="line">             || resultTo != null) &#123;</span><br><span class="line">         //根据intent的flag判断是前台队列还是后台队列，见2.4.3节    </span><br><span class="line">         BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">         //创建BroadcastRecord</span><br><span class="line">         BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                 callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">                 requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                 resultData, resultExtras, ordered, sticky, false, userId);</span><br><span class="line"></span><br><span class="line">         if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing ordered broadcast &quot; + r</span><br><span class="line">                 + &quot;: prev had &quot; + queue.mOrderedBroadcasts.size());</span><br><span class="line">         if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                 &quot;Enqueueing broadcast &quot; + r.intent.getAction());</span><br><span class="line">       </span><br><span class="line">         final BroadcastRecord oldRecord =</span><br><span class="line">                 replacePending ? queue.replaceOrderedBroadcastLocked(r) : null;</span><br><span class="line">         if (oldRecord != null) &#123;</span><br><span class="line">             // Replaced, fire the result-to receiver.</span><br><span class="line">             if (oldRecord.resultTo != null) &#123;</span><br><span class="line">                 final BroadcastQueue oldQueue = broadcastQueueForIntent(oldRecord.intent);</span><br><span class="line">                 try &#123;</span><br><span class="line">                     oldQueue.performReceiveLocked(oldRecord.callerApp, oldRecord.resultTo,</span><br><span class="line">                             oldRecord.intent,</span><br><span class="line">                             Activity.RESULT_CANCELED, null, null,</span><br><span class="line">                             false, false, oldRecord.userId);</span><br><span class="line">                 &#125; catch (RemoteException e) &#123;</span><br><span class="line">                     Slog.w(TAG, &quot;Failure [&quot;</span><br><span class="line">                             + queue.mQueueName + &quot;] sending broadcast result of &quot;</span><br><span class="line">                             + intent, e);</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             //将BroadcastRecord加入到有序广播队列</span><br><span class="line">             queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">             //处理广播，见4.1节</span><br><span class="line">             queue.scheduleBroadcastsLocked();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         // There was nobody interested in the broadcast, but we still want to record</span><br><span class="line">         // that it happened.</span><br><span class="line">         if (intent.getComponent() == null &amp;&amp; intent.getPackage() == null</span><br><span class="line">                 &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;</span><br><span class="line">             // This was an implicit broadcast... let&apos;s record it for posterity.</span><br><span class="line">             addBroadcastStatLocked(intent.getAction(), callerPackage, 0, 0, 0);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>广播队列中有一个mOrderedBroadcasts变量，类型为ArrayList，记录所有的有序广播</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//串行广播加入到mOrderedBroadcasts队列</span><br><span class="line">public void enqueueOrderedBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">        mOrderedBroadcasts.add(r);</span><br><span class="line">        enqueueBroadcastHelper(r);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4  小结"></a>3.4  小结</h3><p>发送广播的过程：</p>
<p>1.默认不发送给已停止的（FLAG_EXCLUDE_STOPPED_PACKAGES）应用和即时应用（需要添加该FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS标记才可以）</p>
<p>2.对广播进行权限验证，是否是受保护的广播，是否允许后台接收广播，是否允许后台发送广播</p>
<p>3.处理系统广播，主要是package、时间、网络相关的广播</p>
<p>4.当为粘性广播时，将sticky广播增加到list，并放入mStickyBroadcasts队列</p>
<p>5.当广播的intent没有设置FLAG_RECEIVER_REGISTERED_ONLY，则允许静态广播接收者来处理该广播；创建BroadcastRecord对象，并将该对象加入到相应的广播队列，然后调用BroadcastQueue的scheduleBroadcastsLocked方法来完成不同广播的处理。</p>
<p>不同广播的处理方式：</p>
<p>1.sticky广播：广播注册过程中处理AMS.registerReceiver，开始处理粘性广播，见2.4节</p>
<ul>
<li>创建BroadcastRecord对象</li>
<li>添加到mParallelBroadcasts队列</li>
<li>然后执行 queue.scheduleBroadcastsLocked()</li>
</ul>
<p>2.并行广播：广播发送处理过程见3.3.6节</p>
<ul>
<li>只有动态注册的registeredReceivers才会进行并行处理</li>
<li>创建BroadcastRecord对象</li>
<li>添加到mParallelBroadcasts队列</li>
<li>然后执行 queue.scheduleBroadcastsLocked()</li>
</ul>
<p>3.串行广播：广播发送处理过程见3.3.8节</p>
<ul>
<li>所有静态注册的receivers以及动态注册的registeredReceivers（发送的广播是有序广播）合并到一张表处理</li>
<li>创建BroadcastRecord对象</li>
<li>添加到mOrderedBroadcasts队列</li>
<li>然后执行 queue.scheduleBroadcastsLocked()</li>
</ul>
<p>从上面可以看出，不管哪种广播方式，都是通过broadcastQueueForIntent来根据intent的flag判段是前台队列还是后台队列广播，然后再调用对应广播队列的scheduleBroadcastsLocked方法来处理广播。</p>
<h2 id="四、接收广播"><a href="#四、接收广播" class="headerlink" title="四、接收广播"></a>四、接收广播</h2><p>在发送广播的过程会执行scheduleBroadcastsLocked方法来处理广播</p>
<h3 id="4-1-BQ-scheduleBroadcastsLocked"><a href="#4-1-BQ-scheduleBroadcastsLocked" class="headerlink" title="4.1  BQ.scheduleBroadcastsLocked"></a>4.1  BQ.scheduleBroadcastsLocked</h3><p>[-&gt;BroadcastQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">      if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</span><br><span class="line">              + mQueueName + &quot;]: current=&quot;</span><br><span class="line">              + mBroadcastsScheduled);</span><br><span class="line">      //正在处理BROADCAST_INTENT_MSG消息</span><br><span class="line">      if (mBroadcastsScheduled) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      //发送BROADCAST_INTENT_MSG消息</span><br><span class="line">      mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">      mBroadcastsScheduled = true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-1-BroadcastHandler"><a href="#4-1-1-BroadcastHandler" class="headerlink" title="4.1.1 BroadcastHandler"></a>4.1.1 BroadcastHandler</h4><p>[-&gt;BroadcastQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final class BroadcastHandler extends Handler &#123;</span><br><span class="line">       public BroadcastHandler(Looper looper) &#123;</span><br><span class="line">           super(looper, null, true);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line">           switch (msg.what) &#123;</span><br><span class="line">               case BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                   if (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                           TAG_BROADCAST, &quot;Received BROADCAST_INTENT_MSG&quot;);</span><br><span class="line">                   //见4.2节</span><br><span class="line">                   processNextBroadcast(true);</span><br><span class="line">               &#125; break;</span><br><span class="line">               case BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                   synchronized (mService) &#123;</span><br><span class="line">                       broadcastTimeoutLocked(true);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>发送BROADCAST_INTENT_MSG消息后，BroadcastHandler进行处理，其初始化在构造函数中创建，而BroadcastQueue是在AMS初始化，从源码中可以看出handler采用的是”ActivityManagerService”线程的loop。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue(ActivityManagerService service, Handler handler,</span><br><span class="line">           String name, long timeoutPeriod, boolean allowDelayBehindServices) &#123;</span><br><span class="line">       mService = service;</span><br><span class="line">       //创建BroadcastHandler</span><br><span class="line">       mHandler = new BroadcastHandler(handler.getLooper());</span><br><span class="line">       mQueueName = name;</span><br><span class="line">       mTimeoutPeriod = timeoutPeriod;</span><br><span class="line">       mDelayBehindServices = allowDelayBehindServices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">       ...</span><br><span class="line">       //名为ActivityManagerService的线程</span><br><span class="line">       mHandlerThread = new ServiceThread(TAG,</span><br><span class="line">               THREAD_PRIORITY_FOREGROUND, false /*allowIo*/);</span><br><span class="line">       mHandlerThread.start();</span><br><span class="line">       mHandler = new MainHandler(mHandlerThread.getLooper());</span><br><span class="line">       //创建BroadcastQueue对象</span><br><span class="line">       mFgBroadcastQueue = new BroadcastQueue(this, mHandler,</span><br><span class="line">               &quot;foreground&quot;, BROADCAST_FG_TIMEOUT, false);</span><br><span class="line">       mBgBroadcastQueue = new BroadcastQueue(this, mHandler,</span><br><span class="line">               &quot;background&quot;, BROADCAST_BG_TIMEOUT, true);</span><br><span class="line">       </span><br><span class="line">       //android10.0新增加的一个分流队列，目前仅处理BOOT_COMPLETED广播</span><br><span class="line">       // Convenient for easy iteration over the queues. Foreground is first</span><br><span class="line">       // so that dispatch of foreground broadcasts gets precedence.</span><br><span class="line">       final BroadcastQueue[] mBroadcastQueues = new BroadcastQueue[2];</span><br><span class="line">       ...</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//广播超时时间定义</span><br><span class="line">// How long we allow a receiver to run before giving up on it.</span><br><span class="line">static final int BROADCAST_FG_TIMEOUT = 10*1000;</span><br><span class="line">static final int BROADCAST_BG_TIMEOUT = 60*1000;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-BQ-processNextBroadcast"><a href="#4-2-BQ-processNextBroadcast" class="headerlink" title="4.2  BQ.processNextBroadcast"></a>4.2  BQ.processNextBroadcast</h3><p>[-&gt;BroadcastQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">    //同步mService</span><br><span class="line">    synchronized (mService) &#123;</span><br><span class="line">        processNextBroadcastLocked(fromMsg, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此次mService为AMS，整个流程比较长，全程持有AMS锁，所以广播效率低下的情况下，直接会严重影响手机的性能和流畅度，这里是否应考虑细化同步锁的粒度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) &#123;</span><br><span class="line">       //setp1：处理并行广播</span><br><span class="line">       //setp2：处理串行广播</span><br><span class="line">       //setp3：获取下条有序广播</span><br><span class="line">       //setp4：处理下条有序广播  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个处理的过程比较长，将分为四个部分进行分析。</p>
<h4 id="4-2-1-处理并行广播"><a href="#4-2-1-处理并行广播" class="headerlink" title="4.2.1 处理并行广播"></a>4.2.1 处理并行广播</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">BroadcastRecord r;</span><br><span class="line">if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;processNextBroadcast [&quot;</span><br><span class="line">        + mQueueName + &quot;]: &quot;</span><br><span class="line">        + mParallelBroadcasts.size() + &quot; parallel broadcasts, &quot;</span><br><span class="line">        + mOrderedBroadcasts.size() + &quot; ordered broadcasts&quot;);</span><br><span class="line">//更新cpu统计信息</span><br><span class="line">mService.updateCpuStats();</span><br><span class="line">//方法传进来的是true，将mBroadcastsScheduled重置为false</span><br><span class="line">if (fromMsg) &#123;</span><br><span class="line">    mBroadcastsScheduled = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理并行队列</span><br><span class="line">// First, deliver any non-serialized broadcasts right away.</span><br><span class="line">while (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">    r = mParallelBroadcasts.remove(0);</span><br><span class="line">    r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">    r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">        Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">            createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),</span><br><span class="line">            System.identityHashCode(r));</span><br><span class="line">        Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">            createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),</span><br><span class="line">            System.identityHashCode(r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int N = r.receivers.size();</span><br><span class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</span><br><span class="line">            + mQueueName + &quot;] &quot; + r);</span><br><span class="line">    for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">        Object target = r.receivers.get(i);</span><br><span class="line">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</span><br><span class="line">                + target + &quot;: &quot; + r);</span><br><span class="line">        //分发广播给已经注册的receiver，见4.3节</span><br><span class="line">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i);</span><br><span class="line">    &#125;</span><br><span class="line">    //将广播添加到历史记录</span><br><span class="line">    addBroadcastToHistoryLocked(r); </span><br><span class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</span><br><span class="line">            + mQueueName + &quot;] &quot; + r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过while循环，每次取出一个，一次性分发完所有的并发广播后，将分发完成的添加到历史广播队列。</p>
<h4 id="4-2-2-处理串行广播"><a href="#4-2-2-处理串行广播" class="headerlink" title="4.2.2 处理串行广播"></a>4.2.2 处理串行广播</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">// Now take care of the next serialized one...</span><br><span class="line">// If we are waiting for a process to come up to handle the next</span><br><span class="line">// broadcast, then do nothing at this point.  Just in case, we</span><br><span class="line">// check that the process we&apos;re waiting for still exists.</span><br><span class="line">if (mPendingBroadcast != null) &#123;</span><br><span class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">            &quot;processNextBroadcast [&quot; + mQueueName + &quot;]: waiting for &quot;</span><br><span class="line">            + mPendingBroadcast.curApp);</span><br><span class="line"></span><br><span class="line">    boolean isDead;</span><br><span class="line">    if (mPendingBroadcast.curApp.pid &gt; 0) &#123;</span><br><span class="line">        synchronized (mService.mPidsSelfLocked) &#123;</span><br><span class="line">            //从mPidsSelfLocked获取正在处理的广播进程，判断进程是否死亡</span><br><span class="line">            ProcessRecord proc = mService.mPidsSelfLocked.get(</span><br><span class="line">                    mPendingBroadcast.curApp.pid);</span><br><span class="line">            isDead = proc == null || proc.crashing;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //从mProcessNames获取正在处理的广播进程，判断进程是否死亡</span><br><span class="line">        final ProcessRecord proc = mService.mProcessNames.get(</span><br><span class="line">                mPendingBroadcast.curApp.processName, mPendingBroadcast.curApp.uid);</span><br><span class="line">        isDead = proc == null || !proc.pendingStart;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isDead) &#123;</span><br><span class="line">        // 如果正在处理广播的进程保持活跃状态，则继续等待其执行完成</span><br><span class="line">        // It&apos;s still alive, so keep waiting</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Slog.w(TAG, &quot;pending app  [&quot;</span><br><span class="line">                + mQueueName + &quot;]&quot; + mPendingBroadcast.curApp</span><br><span class="line">                + &quot; died before responding to broadcast&quot;);</span><br><span class="line">        mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">        mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">        mPendingBroadcast = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean looped = false;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    if (mOrderedBroadcasts.size() == 0) &#123;</span><br><span class="line">        // No more broadcasts pending, so all done!</span><br><span class="line">        //所有的串行广播处理完成，则调度执行gc</span><br><span class="line">        mService.scheduleAppGcsLocked();</span><br><span class="line">        if (looped) &#123;</span><br><span class="line">            // If we had finished the last ordered broadcast, then</span><br><span class="line">            // make sure all processes have correct oom and sched</span><br><span class="line">            // adjustments.</span><br><span class="line">            mService.updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    r = mOrderedBroadcasts.get(0);</span><br><span class="line">    boolean forceReceive = false;</span><br><span class="line"></span><br><span class="line">    // Ensure that even if something goes awry with the timeout</span><br><span class="line">    // detection, we catch &quot;hung&quot; broadcasts here, discard them,</span><br><span class="line">    // and continue to make progress.</span><br><span class="line">    //</span><br><span class="line">    // This is only done if the system is ready so that PRE_BOOT_COMPLETED</span><br><span class="line">    // receivers don&apos;t get executed with timeouts. They&apos;re intended for</span><br><span class="line">    // one time heavy lifting after system upgrades and can take</span><br><span class="line">    // significant amounts of time.</span><br><span class="line">    //所有有序广播的接收者</span><br><span class="line">    int numReceivers = (r.receivers != null) ? r.receivers.size() : 0;</span><br><span class="line">    //系统进程已经准备好</span><br><span class="line">    if (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) &#123;</span><br><span class="line">        long now = SystemClock.uptimeMillis();</span><br><span class="line">        if ((numReceivers &gt; 0) &amp;&amp;</span><br><span class="line">                (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Hung broadcast [&quot;</span><br><span class="line">                    + mQueueName + &quot;] discarded after timeout failure:&quot;</span><br><span class="line">                    + &quot; now=&quot; + now</span><br><span class="line">                    + &quot; dispatchTime=&quot; + r.dispatchTime</span><br><span class="line">                    + &quot; startTime=&quot; + r.receiverTime</span><br><span class="line">                    + &quot; intent=&quot; + r.intent</span><br><span class="line">                    + &quot; numReceivers=&quot; + numReceivers</span><br><span class="line">                    + &quot; nextReceiver=&quot; + r.nextReceiver</span><br><span class="line">                    + &quot; state=&quot; + r.state);</span><br><span class="line">            //广播超时，强制结束这条广播        </span><br><span class="line">            broadcastTimeoutLocked(false); // forcibly finish this broadcast</span><br><span class="line">            forceReceive = true;</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (r.state != BroadcastRecord.IDLE) &#123;</span><br><span class="line">        if (DEBUG_BROADCAST) Slog.d(TAG_BROADCAST,</span><br><span class="line">                &quot;processNextBroadcast(&quot;</span><br><span class="line">                + mQueueName + &quot;) called when not idle (state=&quot;</span><br><span class="line">                + r.state + &quot;)&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.receivers == null || r.nextReceiver &gt;= numReceivers</span><br><span class="line">            || r.resultAbort || forceReceive) &#123;</span><br><span class="line">        // No more receivers for this broadcast!  Send the final</span><br><span class="line">        // result if requested...</span><br><span class="line">        if (r.resultTo != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                        &quot;Finishing broadcast [&quot; + mQueueName + &quot;] &quot;</span><br><span class="line">                        + r.intent.getAction() + &quot; app=&quot; + r.callerApp);</span><br><span class="line">                //处理广播消息，调用到onReceive()        </span><br><span class="line">                performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                    new Intent(r.intent), r.resultCode,</span><br><span class="line">                    r.resultData, r.resultExtras, false, false, r.userId);</span><br><span class="line">                // Set this to null so that the reference</span><br><span class="line">                // (local and remote) isn&apos;t kept in the mBroadcastHistory.</span><br><span class="line">                r.resultTo = null;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                r.resultTo = null;</span><br><span class="line">                Slog.w(TAG, &quot;Failure [&quot;</span><br><span class="line">                        + mQueueName + &quot;] sending broadcast result of &quot;</span><br><span class="line">                        + r.intent, e);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Cancelling BROADCAST_TIMEOUT_MSG&quot;);</span><br><span class="line">        //取消BROADCAST_TIMEOUT_MSG消息</span><br><span class="line">        cancelBroadcastTimeoutLocked();</span><br><span class="line"></span><br><span class="line">        if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                &quot;Finished with ordered broadcast &quot; + r);</span><br><span class="line">        </span><br><span class="line">        // 添加到队列消息记录</span><br><span class="line">        // ... and on to the next...</span><br><span class="line">        addBroadcastToHistoryLocked(r);</span><br><span class="line">        if (r.intent.getComponent() == null &amp;&amp; r.intent.getPackage() == null</span><br><span class="line">                &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;</span><br><span class="line">            // This was an implicit broadcast... let&apos;s record it for posterity.</span><br><span class="line">            mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                    r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">        &#125;</span><br><span class="line">        mOrderedBroadcasts.remove(0);</span><br><span class="line">        r = null;</span><br><span class="line">        looped = true;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; while (r == null);</span><br></pre></td></tr></table></figure>
<p>mTimeoutPeriod，对于前台广播为10s,后台广播为60s。广播超时为2 <em> mTimeoutPeriod </em> numReceivers，接收者个数numReceivers越多，则广播超时总时间越大。</p>
<h4 id="4-2-3-获取下条有序广播"><a href="#4-2-3-获取下条有序广播" class="headerlink" title="4.2.3 获取下条有序广播"></a>4.2.3 获取下条有序广播</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line">//获取下条广播的index</span><br><span class="line">// Get the next receiver...</span><br><span class="line">int recIdx = r.nextReceiver++;</span><br><span class="line"></span><br><span class="line">// Keep track of when this receiver started, and make sure there</span><br><span class="line">// is a timeout message pending to kill it if need be.</span><br><span class="line">//记录开始时间</span><br><span class="line">r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">if (recIdx == 0) &#123;</span><br><span class="line">    r.dispatchTime = r.receiverTime;</span><br><span class="line">    r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">    if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">        Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">            createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),</span><br><span class="line">            System.identityHashCode(r));</span><br><span class="line">        Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">            createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),</span><br><span class="line">            System.identityHashCode(r));</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing ordered broadcast [&quot;</span><br><span class="line">            + mQueueName + &quot;] &quot; + r);</span><br><span class="line">&#125;</span><br><span class="line">if (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">    long timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">            &quot;Submitting BROADCAST_TIMEOUT_MSG [&quot;</span><br><span class="line">            + mQueueName + &quot;] for &quot; + r + &quot; at &quot; + timeoutTime);</span><br><span class="line">    //发送广播超时        </span><br><span class="line">    setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final BroadcastOptions brOptions = r.options;</span><br><span class="line">final Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line"></span><br><span class="line">if (nextReceiver instanceof BroadcastFilter) &#123;</span><br><span class="line">    // Simple case: this is a registered receiver who gets</span><br><span class="line">    // a direct call.</span><br><span class="line">    //对于动态注册的广播接收者</span><br><span class="line">    BroadcastFilter filter = (BroadcastFilter)nextReceiver;</span><br><span class="line">    if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">            &quot;Delivering ordered [&quot;</span><br><span class="line">            + mQueueName + &quot;] to registered &quot;</span><br><span class="line">            + filter + &quot;: &quot; + r);</span><br><span class="line">    //处理广播，见4.3节        </span><br><span class="line">    deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line">    if (r.receiver == null || !r.ordered) &#123;</span><br><span class="line">        // The receiver has already finished, so schedule to</span><br><span class="line">        // process the next one.</span><br><span class="line">        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Quick finishing [&quot;</span><br><span class="line">                + mQueueName + &quot;]: ordered=&quot;</span><br><span class="line">                + r.ordered + &quot; receiver=&quot; + r.receiver);</span><br><span class="line">        r.state = BroadcastRecord.IDLE;</span><br><span class="line">        //处理下一个广播</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123;</span><br><span class="line">            scheduleTempWhitelistLocked(filter.owningUid,</span><br><span class="line">                    brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Hard case: need to instantiate the receiver, possibly</span><br><span class="line">// starting its application process to host it.</span><br><span class="line">//对于静态注册的广播接收者</span><br><span class="line">ResolveInfo info =</span><br><span class="line">    (ResolveInfo)nextReceiver;</span><br><span class="line">ComponentName component = new ComponentName(</span><br><span class="line">        info.activityInfo.applicationInfo.packageName,</span><br><span class="line">        info.activityInfo.name);</span><br><span class="line">       </span><br><span class="line">//下面都是各种检查权限，权限不满足时则跳过</span><br><span class="line">boolean skip = false;</span><br><span class="line">if (brOptions != null &amp;&amp;</span><br><span class="line">        (info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                &lt; brOptions.getMinManifestReceiverApiLevel() ||</span><br><span class="line">        info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                &gt; brOptions.getMaxManifestReceiverApiLevel())) &#123;</span><br><span class="line">    skip = true;  //sdk版本，Androidmanifest中设置</span><br><span class="line">&#125;</span><br><span class="line">int perm = mService.checkComponentPermission(info.activityInfo.permission,</span><br><span class="line">        r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,</span><br><span class="line">        info.activityInfo.exported);</span><br><span class="line">//Component权限</span><br><span class="line">if (!skip &amp;&amp; perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    if (!info.activityInfo.exported) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Permission Denial: broadcasting &quot;</span><br><span class="line">                + r.intent.toString()</span><br><span class="line">                + &quot; from &quot; + r.callerPackage + &quot; (pid=&quot; + r.callingPid</span><br><span class="line">                + &quot;, uid=&quot; + r.callingUid + &quot;)&quot;</span><br><span class="line">                + &quot; is not exported from uid &quot; + info.activityInfo.applicationInfo.uid</span><br><span class="line">                + &quot; due to receiver &quot; + component.flattenToShortString());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Permission Denial: broadcasting &quot;</span><br><span class="line">                + r.intent.toString()</span><br><span class="line">                + &quot; from &quot; + r.callerPackage + &quot; (pid=&quot; + r.callingPid</span><br><span class="line">                + &quot;, uid=&quot; + r.callingUid + &quot;)&quot;</span><br><span class="line">                + &quot; requires &quot; + info.activityInfo.permission</span><br><span class="line">                + &quot; due to receiver &quot; + component.flattenToShortString());</span><br><span class="line">    &#125;</span><br><span class="line">    skip = true;</span><br><span class="line">&#125; else if (!skip &amp;&amp; info.activityInfo.permission != null) &#123;</span><br><span class="line">    final int opCode = AppOpsManager.permissionToOpCode(info.activityInfo.permission);</span><br><span class="line">    if (opCode != AppOpsManager.OP_NONE</span><br><span class="line">            &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                    r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Appop Denial: broadcasting &quot;</span><br><span class="line">                + r.intent.toString()</span><br><span class="line">                + &quot; from &quot; + r.callerPackage + &quot; (pid=&quot;</span><br><span class="line">                + r.callingPid + &quot;, uid=&quot; + r.callingUid + &quot;)&quot;</span><br><span class="line">                + &quot; requires appop &quot; + AppOpsManager.permissionToOp(</span><br><span class="line">                        info.activityInfo.permission)</span><br><span class="line">                + &quot; due to registered receiver &quot;</span><br><span class="line">                + component.flattenToShortString());</span><br><span class="line">        skip = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">if (!skip &amp;&amp; info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &amp;&amp;</span><br><span class="line">    r.requiredPermissions != null &amp;&amp; r.requiredPermissions.length &gt; 0) &#123;</span><br><span class="line">    for (int i = 0; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">        String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">        try &#123;</span><br><span class="line">            perm = AppGlobals.getPackageManager().</span><br><span class="line">                    checkPermission(requiredPermission,</span><br><span class="line">                            info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                            UserHandle</span><br><span class="line">                                    .getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            perm = PackageManager.PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">        if (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Permission Denial: receiving &quot;</span><br><span class="line">                    + r.intent + &quot; to &quot;</span><br><span class="line">                    + component.flattenToShortString()</span><br><span class="line">                    + &quot; requires &quot; + requiredPermission</span><br><span class="line">                    + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">                    + &quot; (uid &quot; + r.callingUid + &quot;)&quot;);</span><br><span class="line">            skip = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        int appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">        if (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Appop Denial: receiving &quot;</span><br><span class="line">                    + r.intent + &quot; to &quot;</span><br><span class="line">                    + component.flattenToShortString()</span><br><span class="line">                    + &quot; requires appop &quot; + AppOpsManager.permissionToOp(</span><br><span class="line">                    requiredPermission)</span><br><span class="line">                    + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">                    + &quot; (uid &quot; + r.callingUid + &quot;)&quot;);</span><br><span class="line">            skip = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">        &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">        info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">        != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;Appop Denial: receiving &quot;</span><br><span class="line">            + r.intent + &quot; to &quot;</span><br><span class="line">            + component.flattenToShortString()</span><br><span class="line">            + &quot; requires appop &quot; + AppOpsManager.opToName(r.appOp)</span><br><span class="line">            + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">            + &quot; (uid &quot; + r.callingUid + &quot;)&quot;);</span><br><span class="line">    skip = true;</span><br><span class="line">&#125;</span><br><span class="line">if (!skip) &#123;</span><br><span class="line">    skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">            r.callingPid, r.resolvedType, info.activityInfo.applicationInfo.uid);</span><br><span class="line">&#125;</span><br><span class="line">boolean isSingleton = false;</span><br><span class="line">try &#123;</span><br><span class="line">    isSingleton = mService.isSingleton(info.activityInfo.processName,</span><br><span class="line">            info.activityInfo.applicationInfo,</span><br><span class="line">            info.activityInfo.name, info.activityInfo.flags);</span><br><span class="line">&#125; catch (SecurityException e) &#123;</span><br><span class="line">    Slog.w(TAG, e.getMessage());</span><br><span class="line">    skip = true;</span><br><span class="line">&#125;</span><br><span class="line">if ((info.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != 0) &#123;</span><br><span class="line">    if (ActivityManager.checkUidPermission(</span><br><span class="line">            android.Manifest.permission.INTERACT_ACROSS_USERS,</span><br><span class="line">            info.activityInfo.applicationInfo.uid)</span><br><span class="line">                    != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Permission Denial: Receiver &quot; + component.flattenToShortString()</span><br><span class="line">                + &quot; requests FLAG_SINGLE_USER, but app does not hold &quot;</span><br><span class="line">                + android.Manifest.permission.INTERACT_ACROSS_USERS);</span><br><span class="line">        skip = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!skip &amp;&amp; info.activityInfo.applicationInfo.isInstantApp()</span><br><span class="line">        &amp;&amp; r.callingUid != info.activityInfo.applicationInfo.uid) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;Instant App Denial: receiving &quot;</span><br><span class="line">            + r.intent</span><br><span class="line">            + &quot; to &quot; + component.flattenToShortString()</span><br><span class="line">            + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">            + &quot; (uid &quot; + r.callingUid + &quot;)&quot;</span><br><span class="line">            + &quot; Instant Apps do not support manifest receivers&quot;);</span><br><span class="line">    skip = true;</span><br><span class="line">&#125;</span><br><span class="line">if (!skip &amp;&amp; r.callerInstantApp</span><br><span class="line">        &amp;&amp; (info.activityInfo.flags &amp; ActivityInfo.FLAG_VISIBLE_TO_INSTANT_APP) == 0</span><br><span class="line">        &amp;&amp; r.callingUid != info.activityInfo.applicationInfo.uid) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;Instant App Denial: receiving &quot;</span><br><span class="line">            + r.intent</span><br><span class="line">            + &quot; to &quot; + component.flattenToShortString()</span><br><span class="line">            + &quot; requires receiver have visibleToInstantApps set&quot;</span><br><span class="line">            + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">            + &quot; (uid &quot; + r.callingUid + &quot;)&quot;);</span><br><span class="line">    skip = true;</span><br><span class="line">&#125;</span><br><span class="line">if (r.curApp != null &amp;&amp; r.curApp.crashing) &#123;</span><br><span class="line">    // If the target process is crashing, just skip it.</span><br><span class="line">    Slog.w(TAG, &quot;Skipping deliver ordered [&quot; + mQueueName + &quot;] &quot; + r</span><br><span class="line">            + &quot; to &quot; + r.curApp + &quot;: process crashing&quot;);</span><br><span class="line">    skip = true;</span><br><span class="line">&#125;</span><br><span class="line">if (!skip) &#123;</span><br><span class="line">    boolean isAvailable = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        isAvailable = AppGlobals.getPackageManager().isPackageAvailable(</span><br><span class="line">                info.activityInfo.packageName,</span><br><span class="line">                UserHandle.getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // all such failures mean we skip this receiver</span><br><span class="line">        Slog.w(TAG, &quot;Exception getting recipient info for &quot;</span><br><span class="line">                + info.activityInfo.packageName, e);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isAvailable) &#123;</span><br><span class="line">        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                &quot;Skipping delivery to &quot; + info.activityInfo.packageName + &quot; / &quot;</span><br><span class="line">                + info.activityInfo.applicationInfo.uid</span><br><span class="line">                + &quot; : package no longer available&quot;);</span><br><span class="line">        skip = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// If permissions need a review before any of the app components can run, we drop</span><br><span class="line">// the broadcast and if the calling app is in the foreground and the broadcast is</span><br><span class="line">// explicit we launch the review UI passing it a pending intent to send the skipped</span><br><span class="line">// broadcast.</span><br><span class="line">if (mService.mPermissionReviewRequired &amp;&amp; !skip) &#123;</span><br><span class="line">    if (!requestStartTargetPermissionsReviewIfNeededLocked(r,</span><br><span class="line">            info.activityInfo.packageName, UserHandle.getUserId(</span><br><span class="line">                    info.activityInfo.applicationInfo.uid))) &#123;</span><br><span class="line">        skip = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   // This is safe to do even if we are skipping the broadcast, and we need</span><br><span class="line">// this information now to evaluate whether it is going to be allowed to run.</span><br><span class="line">final int receiverUid = info.activityInfo.applicationInfo.uid;</span><br><span class="line">// If it&apos;s a singleton, it needs to be the same app or a special app</span><br><span class="line">if (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton</span><br><span class="line">        &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;</span><br><span class="line">    info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, 0);</span><br><span class="line">&#125;</span><br><span class="line">String targetProcess = info.activityInfo.processName;</span><br><span class="line">ProcessRecord app = mService.getProcessRecordLocked(targetProcess,</span><br><span class="line">        info.activityInfo.applicationInfo.uid, false);</span><br><span class="line"></span><br><span class="line">if (!skip) &#123;</span><br><span class="line">    final int allowed = mService.getAppStartModeLocked(</span><br><span class="line">            info.activityInfo.applicationInfo.uid, info.activityInfo.packageName,</span><br><span class="line">            info.activityInfo.applicationInfo.targetSdkVersion, -1, true, false, false);</span><br><span class="line">    if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">        // We won&apos;t allow this receiver to be launched if the app has been</span><br><span class="line">        // completely disabled from launches, or it was not explicitly sent</span><br><span class="line">        // to it and the app is in a state that should not receive it</span><br><span class="line">        // (depending on how getAppStartModeLocked has determined that).</span><br><span class="line">        if (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Background execution disabled: receiving &quot;</span><br><span class="line">                    + r.intent + &quot; to &quot;</span><br><span class="line">                    + component.flattenToShortString());</span><br><span class="line">            skip = true;</span><br><span class="line">        &#125; else if (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0)</span><br><span class="line">                || (r.intent.getComponent() == null</span><br><span class="line">                    &amp;&amp; r.intent.getPackage() == null</span><br><span class="line">                    &amp;&amp; ((r.intent.getFlags()</span><br><span class="line">                            &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0)</span><br><span class="line">                    &amp;&amp; !isSignaturePerm(r.requiredPermissions))) &#123;</span><br><span class="line">            mService.addBackgroundCheckViolationLocked(r.intent.getAction(),</span><br><span class="line">                    component.getPackageName());</span><br><span class="line">            Slog.w(TAG, &quot;Background execution not allowed: receiving &quot;</span><br><span class="line">                    + r.intent + &quot; to &quot;</span><br><span class="line">                    + component.flattenToShortString());</span><br><span class="line">            skip = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!skip &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(r.intent.getAction())</span><br><span class="line">        &amp;&amp; !mService.mUserController</span><br><span class="line">        .isUserRunning(UserHandle.getUserId(info.activityInfo.applicationInfo.uid),</span><br><span class="line">                0 /* flags */)) &#123;</span><br><span class="line">    skip = true;</span><br><span class="line">    Slog.w(TAG,</span><br><span class="line">            &quot;Skipping delivery to &quot; + info.activityInfo.packageName + &quot; / &quot;</span><br><span class="line">                    + info.activityInfo.applicationInfo.uid + &quot; : user is not running&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//跳过该广播</span><br><span class="line">if (skip) &#123;</span><br><span class="line">    if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">            &quot;Skipping delivery of ordered [&quot; + mQueueName + &quot;] &quot;</span><br><span class="line">            + r + &quot; for whatever reason&quot;);</span><br><span class="line">    r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">    r.receiver = null;</span><br><span class="line">    r.curFilter = null;</span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    r.manifestSkipCount++;</span><br><span class="line">    scheduleBroadcastsLocked();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">r.manifestCount++;</span><br><span class="line"></span><br><span class="line">r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">r.state = BroadcastRecord.APP_RECEIVE;</span><br><span class="line">r.curComponent = component;</span><br><span class="line">r.curReceiver = info.activityInfo;</span><br><span class="line">if (DEBUG_MU &amp;&amp; r.callingUid &gt; UserHandle.PER_USER_RANGE) &#123;</span><br><span class="line">    Slog.v(TAG_MU, &quot;Updated broadcast record activity info for secondary user, &quot;</span><br><span class="line">            + info.activityInfo + &quot;, callingUid = &quot; + r.callingUid + &quot;, uid = &quot;</span><br><span class="line">            + receiverUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123;</span><br><span class="line">    scheduleTempWhitelistLocked(receiverUid,</span><br><span class="line">            brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">&#125;</span><br><span class="line">// Broadcast正在执行，stopped状态设置成false</span><br><span class="line">// Broadcast is being executed, its package can&apos;t be stopped.</span><br><span class="line">try &#123;</span><br><span class="line">    AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">            r.curComponent.getPackageName(), false, UserHandle.getUserId(r.callingUid));</span><br><span class="line">&#125; catch (RemoteException e) &#123;</span><br><span class="line">&#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;Failed trying to unstop package &quot;</span><br><span class="line">            + r.curComponent.getPackageName() + &quot;: &quot; + e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送广播超时，如果是动态注册的广播则执行deliverToRegisteredReceiverLocked方法，如果是静态注册的广播，则进行一系列的权限检查，不满足则跳过该广播。</p>
<h4 id="4-2-4-处理下条有序广播"><a href="#4-2-4-处理下条有序广播" class="headerlink" title="4.2.4 处理下条有序广播"></a>4.2.4 处理下条有序广播</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> // Is this receiver&apos;s application already running?</span><br><span class="line">if (app != null &amp;&amp; app.thread != null &amp;&amp; !app.killed) &#123;</span><br><span class="line">    // 接收广播的进程还在运行</span><br><span class="line">    try &#123;</span><br><span class="line">        app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">        processCurBroadcastLocked(r, app, skipOomAdj);</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Exception when sending broadcast to &quot;</span><br><span class="line">              + r.curComponent, e);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        Slog.wtf(TAG, &quot;Failed sending broadcast to &quot;</span><br><span class="line">                + r.curComponent + &quot; with &quot; + r.intent, e);</span><br><span class="line">        // If some unexpected exception happened, just skip</span><br><span class="line">        // this broadcast.  At this point we are not in the call</span><br><span class="line">        // from a client, so throwing an exception out from here</span><br><span class="line">        // will crash the entire system instead of just whoever</span><br><span class="line">        // sent the broadcast.</span><br><span class="line">        logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                r.resultExtras, r.resultAbort, false);</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line">        //如果启动receiver失败，则重置状态</span><br><span class="line">        // We need to reset the state if we failed to start the receiver.</span><br><span class="line">        r.state = BroadcastRecord.IDLE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If a dead object exception was thrown -- fall through to</span><br><span class="line">    // restart the application.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Not running -- get it started, to be executed when the app comes up.</span><br><span class="line">if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">        &quot;Need to start app [&quot;</span><br><span class="line">        + mQueueName + &quot;] &quot; + targetProcess + &quot; for broadcast &quot; + r);</span><br><span class="line">//receiver所对应的进程尚未启动，则创建该进程        </span><br><span class="line">if ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">        info.activityInfo.applicationInfo, true,</span><br><span class="line">        r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">        &quot;broadcast&quot;, r.curComponent,</span><br><span class="line">        (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))</span><br><span class="line">                == null) &#123;</span><br><span class="line">    // Ah, this recipient is unavailable.  Finish it if necessary,</span><br><span class="line">    // and mark the broadcast record as ready for the next.</span><br><span class="line">    Slog.w(TAG, &quot;Unable to launch app &quot;</span><br><span class="line">            + info.activityInfo.applicationInfo.packageName + &quot;/&quot;</span><br><span class="line">            + receiverUid + &quot; for broadcast &quot;</span><br><span class="line">            + r.intent + &quot;: process is bad&quot;);</span><br><span class="line">    //创建失败，直接结束该receiver        </span><br><span class="line">    logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">    finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">            r.resultExtras, r.resultAbort, false);</span><br><span class="line">    //开启下一个广播</span><br><span class="line">    scheduleBroadcastsLocked();</span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mPendingBroadcast = r;</span><br><span class="line">mPendingBroadcastRecvIndex = recIdx;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果是动态广播接收者，则调用deliverToRegisteredReceiverLocked处理</p>
</li>
<li><p>如果是静态广播接收者，且对应进程已经创建，则调用processCurBroadcastLocked处理</p>
</li>
<li><p>如果是静态广播接收者，且对应进程未创建，则调用startProcessLocked创建进程</p>
</li>
</ul>
<h3 id="4-3-BQ-deliverToRegisteredReceiverLocked"><a href="#4-3-BQ-deliverToRegisteredReceiverLocked" class="headerlink" title="4.3  BQ.deliverToRegisteredReceiverLocked"></a>4.3  BQ.deliverToRegisteredReceiverLocked</h3><p>[-&gt;BroadcastQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">private void deliverToRegisteredReceiverLocked(BroadcastRecord r,</span><br><span class="line">           BroadcastFilter filter, boolean ordered, int index) &#123;</span><br><span class="line">       boolean skip = false;</span><br><span class="line">       //检查发送者是否有BroadcastFilter所需要的权限</span><br><span class="line">       if (filter.requiredPermission != null) &#123;</span><br><span class="line">           int perm = mService.checkComponentPermission(filter.requiredPermission,</span><br><span class="line">                   r.callingPid, r.callingUid, -1, true);</span><br><span class="line">           if (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Permission Denial: broadcasting &quot;</span><br><span class="line">                       + r.intent.toString()</span><br><span class="line">                       + &quot; from &quot; + r.callerPackage + &quot; (pid=&quot;</span><br><span class="line">                       + r.callingPid + &quot;, uid=&quot; + r.callingUid + &quot;)&quot;</span><br><span class="line">                       + &quot; requires &quot; + filter.requiredPermission</span><br><span class="line">                       + &quot; due to registered receiver &quot; + filter);</span><br><span class="line">               skip = true;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               final int opCode = AppOpsManager.permissionToOpCode(filter.requiredPermission);</span><br><span class="line">               if (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                       &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                               r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;Appop Denial: broadcasting &quot;</span><br><span class="line">                           + r.intent.toString()</span><br><span class="line">                           + &quot; from &quot; + r.callerPackage + &quot; (pid=&quot;</span><br><span class="line">                           + r.callingPid + &quot;, uid=&quot; + r.callingUid + &quot;)&quot;</span><br><span class="line">                           + &quot; requires appop &quot; + AppOpsManager.permissionToOp(</span><br><span class="line">                                   filter.requiredPermission)</span><br><span class="line">                           + &quot; due to registered receiver &quot; + filter);</span><br><span class="line">                   skip = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!skip &amp;&amp; r.requiredPermissions != null &amp;&amp; r.requiredPermissions.length &gt; 0) &#123;</span><br><span class="line">           for (int i = 0; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">               String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">               int perm = mService.checkComponentPermission(requiredPermission,</span><br><span class="line">                       filter.receiverList.pid, filter.receiverList.uid, -1, true);</span><br><span class="line">               if (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;Permission Denial: receiving &quot;</span><br><span class="line">                           + r.intent.toString()</span><br><span class="line">                           + &quot; to &quot; + filter.receiverList.app</span><br><span class="line">                           + &quot; (pid=&quot; + filter.receiverList.pid</span><br><span class="line">                           + &quot;, uid=&quot; + filter.receiverList.uid + &quot;)&quot;</span><br><span class="line">                           + &quot; requires &quot; + requiredPermission</span><br><span class="line">                           + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">                           + &quot; (uid &quot; + r.callingUid + &quot;)&quot;);</span><br><span class="line">                   skip = true;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               int appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">               if (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                       &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                       filter.receiverList.uid, filter.packageName)</span><br><span class="line">                       != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;Appop Denial: receiving &quot;</span><br><span class="line">                           + r.intent.toString()</span><br><span class="line">                           + &quot; to &quot; + filter.receiverList.app</span><br><span class="line">                           + &quot; (pid=&quot; + filter.receiverList.pid</span><br><span class="line">                           + &quot;, uid=&quot; + filter.receiverList.uid + &quot;)&quot;</span><br><span class="line">                           + &quot; requires appop &quot; + AppOpsManager.permissionToOp(</span><br><span class="line">                           requiredPermission)</span><br><span class="line">                           + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">                           + &quot; (uid &quot; + r.callingUid + &quot;)&quot;);</span><br><span class="line">                   skip = true;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!skip &amp;&amp; (r.requiredPermissions == null || r.requiredPermissions.length == 0)) &#123;</span><br><span class="line">           int perm = mService.checkComponentPermission(null,</span><br><span class="line">                   filter.receiverList.pid, filter.receiverList.uid, -1, true);</span><br><span class="line">           if (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Permission Denial: security check failed when receiving &quot;</span><br><span class="line">                       + r.intent.toString()</span><br><span class="line">                       + &quot; to &quot; + filter.receiverList.app</span><br><span class="line">                       + &quot; (pid=&quot; + filter.receiverList.pid</span><br><span class="line">                       + &quot;, uid=&quot; + filter.receiverList.uid + &quot;)&quot;</span><br><span class="line">                       + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">                       + &quot; (uid &quot; + r.callingUid + &quot;)&quot;);</span><br><span class="line">               skip = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">               &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">               filter.receiverList.uid, filter.packageName)</span><br><span class="line">               != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Appop Denial: receiving &quot;</span><br><span class="line">                   + r.intent.toString()</span><br><span class="line">                   + &quot; to &quot; + filter.receiverList.app</span><br><span class="line">                   + &quot; (pid=&quot; + filter.receiverList.pid</span><br><span class="line">                   + &quot;, uid=&quot; + filter.receiverList.uid + &quot;)&quot;</span><br><span class="line">                   + &quot; requires appop &quot; + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                   + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">                   + &quot; (uid &quot; + r.callingUid + &quot;)&quot;);</span><br><span class="line">           skip = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (!mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">               r.callingPid, r.resolvedType, filter.receiverList.uid)) &#123;</span><br><span class="line">           skip = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (!skip &amp;&amp; (filter.receiverList.app == null || filter.receiverList.app.killed</span><br><span class="line">               || filter.receiverList.app.crashing)) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Skipping deliver [&quot; + mQueueName + &quot;] &quot; + r</span><br><span class="line">                   + &quot; to &quot; + filter.receiverList + &quot;: process gone or crashing&quot;);</span><br><span class="line">           skip = true;</span><br><span class="line">       &#125;</span><br><span class="line">       //即时应用检查</span><br><span class="line">       // Ensure that broadcasts are only sent to other Instant Apps if they are marked as</span><br><span class="line">       // visible to Instant Apps.</span><br><span class="line">       final boolean visibleToInstantApps =</span><br><span class="line">               (r.intent.getFlags() &amp; Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS) != 0;</span><br><span class="line"></span><br><span class="line">       if (!skip &amp;&amp; !visibleToInstantApps &amp;&amp; filter.instantApp</span><br><span class="line">               &amp;&amp; filter.receiverList.uid != r.callingUid) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Instant App Denial: receiving &quot;</span><br><span class="line">                   + r.intent.toString()</span><br><span class="line">                   + &quot; to &quot; + filter.receiverList.app</span><br><span class="line">                   + &quot; (pid=&quot; + filter.receiverList.pid</span><br><span class="line">                   + &quot;, uid=&quot; + filter.receiverList.uid + &quot;)&quot;</span><br><span class="line">                   + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">                   + &quot; (uid &quot; + r.callingUid + &quot;)&quot;</span><br><span class="line">                   + &quot; not specifying FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS&quot;);</span><br><span class="line">           skip = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (!skip &amp;&amp; !filter.visibleToInstantApp &amp;&amp; r.callerInstantApp</span><br><span class="line">               &amp;&amp; filter.receiverList.uid != r.callingUid) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Instant App Denial: receiving &quot;</span><br><span class="line">                   + r.intent.toString()</span><br><span class="line">                   + &quot; to &quot; + filter.receiverList.app</span><br><span class="line">                   + &quot; (pid=&quot; + filter.receiverList.pid</span><br><span class="line">                   + &quot;, uid=&quot; + filter.receiverList.uid + &quot;)&quot;</span><br><span class="line">                   + &quot; requires receiver be visible to instant apps&quot;</span><br><span class="line">                   + &quot; due to sender &quot; + r.callerPackage</span><br><span class="line">                   + &quot; (uid &quot; + r.callingUid + &quot;)&quot;);</span><br><span class="line">           skip = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (skip) &#123;</span><br><span class="line">           r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If permissions need a review before any of the app components can run, we drop</span><br><span class="line">       // the broadcast and if the calling app is in the foreground and the broadcast is</span><br><span class="line">       // explicit we launch the review UI passing it a pending intent to send the skipped</span><br><span class="line">       // broadcast.</span><br><span class="line">       if (mService.mPermissionReviewRequired) &#123;</span><br><span class="line">           if (!requestStartTargetPermissionsReviewIfNeededLocked(r, filter.packageName,</span><br><span class="line">                   filter.owningUserId)) &#123;</span><br><span class="line">               r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">       //如果是有序广播</span><br><span class="line">       // If this is not being sent as an ordered broadcast, then we</span><br><span class="line">       // don&apos;t want to touch the fields that keep track of the current</span><br><span class="line">       // state of ordered broadcasts.</span><br><span class="line">       if (ordered) &#123;</span><br><span class="line">           r.receiver = filter.receiverList.receiver.asBinder();</span><br><span class="line">           r.curFilter = filter;</span><br><span class="line">           filter.receiverList.curBroadcast = r;</span><br><span class="line">           r.state = BroadcastRecord.CALL_IN_RECEIVE;</span><br><span class="line">           if (filter.receiverList.app != null) &#123;</span><br><span class="line">               // Bump hosting application to no longer be in background</span><br><span class="line">               // scheduling class.  Note that we can&apos;t do that if there</span><br><span class="line">               // isn&apos;t an app...  but we can only be in that case for</span><br><span class="line">               // things that directly call the IActivityManager API, which</span><br><span class="line">               // are already core system stuff so don&apos;t matter for this.</span><br><span class="line">               r.curApp = filter.receiverList.app;</span><br><span class="line">               filter.receiverList.app.curReceivers.add(r);</span><br><span class="line">               mService.updateOomAdjLocked(r.curApp, true);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           if (DEBUG_BROADCAST_LIGHT) Slog.i(TAG_BROADCAST,</span><br><span class="line">                   &quot;Delivering to &quot; + filter + &quot; : &quot; + r);</span><br><span class="line">           if (filter.receiverList.app != null &amp;&amp; filter.receiverList.app.inFullBackup) &#123;</span><br><span class="line">               // Skip delivery if full backup in progress</span><br><span class="line">               // If it&apos;s an ordered broadcast, we need to continue to the next receiver.</span><br><span class="line">               if (ordered) &#123;</span><br><span class="line">                   //跳过有序广播</span><br><span class="line">                   skipReceiverLocked(r);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">              //处理广播，见4.4节</span><br><span class="line">               performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                       new Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                       r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br><span class="line">           &#125;</span><br><span class="line">           if (ordered) &#123;</span><br><span class="line">               r.state = BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Failure sending broadcast &quot; + r.intent, e);</span><br><span class="line">           if (ordered) &#123;</span><br><span class="line">               r.receiver = null;</span><br><span class="line">               r.curFilter = null;</span><br><span class="line">               filter.receiverList.curBroadcast = null;</span><br><span class="line">               if (filter.receiverList.app != null) &#123;</span><br><span class="line">                   filter.receiverList.app.curReceivers.remove(r);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里是检查动态注册的广播的相关权限，如果是有序广播则跳过。最后执行performReceiveLocked处理并行广播。</p>
<h3 id="4-4-BQ-performReceiveLocked"><a href="#4-4-BQ-performReceiveLocked" class="headerlink" title="4.4  BQ.performReceiveLocked"></a>4.4  BQ.performReceiveLocked</h3><p>[-&gt;BroadcastQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</span><br><span class="line">            Intent intent, int resultCode, String data, Bundle extras,</span><br><span class="line">            boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</span><br><span class="line">        // Send the intent to the receiver asynchronously using one-way binder calls.</span><br><span class="line">        //通过binder机制，发送到广播接收者</span><br><span class="line">        if (app != null) &#123;</span><br><span class="line">            if (app.thread != null) &#123;</span><br><span class="line">                // If we have an app thread, do the call through that so it is</span><br><span class="line">                // correctly ordered with other one-way calls.</span><br><span class="line">                try &#123;</span><br><span class="line">                    //见4.5节</span><br><span class="line">                    app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                            data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">                // TODO: Uncomment this when (b/28322359) is fixed and we aren&apos;t getting</span><br><span class="line">                // DeadObjectException when the process isn&apos;t actually dead.</span><br><span class="line">                //&#125; catch (DeadObjectException ex) &#123;</span><br><span class="line">                // Failed to call into the process.  It&apos;s dying so just let it die and move on.</span><br><span class="line">                //    throw ex;</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                    // Failed to call into the process. It&apos;s either dying or wedged. Kill it gently.</span><br><span class="line">                    synchronized (mService) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Can&apos;t deliver broadcast to &quot; + app.processName</span><br><span class="line">                                + &quot; (pid &quot; + app.pid + &quot;). Crashing it.&quot;);</span><br><span class="line">                        app.scheduleCrash(&quot;can&apos;t deliver broadcast&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    throw ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //应有进程死亡，则应有不存在</span><br><span class="line">                // Application has died. Receiver doesn&apos;t exist.</span><br><span class="line">                throw new RemoteException(&quot;app.thread must not be null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //调用者进程为空</span><br><span class="line">            receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                    sticky, sendingUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过app.thread获取到IApplicationThread代理类，通过这个代理类，访问到ApplicationThread中的方法。</p>
<h3 id="4-5-AT-scheduleRegisteredReceiver"><a href="#4-5-AT-scheduleRegisteredReceiver" class="headerlink" title="4.5  AT.scheduleRegisteredReceiver"></a>4.5  AT.scheduleRegisteredReceiver</h3><p>[-&gt;ActivityThread.java::ApplicationThread]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// This function exists to make sure all receiver dispatching is</span><br><span class="line">// correctly ordered, since these are one-way calls and the binder driver</span><br><span class="line">// applies transaction ordering per object for such calls.</span><br><span class="line">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</span><br><span class="line">        int resultCode, String dataStr, Bundle extras, boolean ordered,</span><br><span class="line">        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</span><br><span class="line">    //更新进程状态</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    //见4.6节，其中receiver为2.3.2节所创建</span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>receiver是注册广播时创建的，见2.3.3节 receiver=LoadedApk.ReceiverDispatcher.InnerReceiver</p>
<h3 id="4-6-IR-performReceive"><a href="#4-6-IR-performReceive" class="headerlink" title="4.6 IR.performReceive"></a>4.6 IR.performReceive</h3><p>[-&gt;LoadedApk.java::InnerReceiver]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">           Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">       final LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">       if (intent == null) &#123;</span><br><span class="line">           Log.wtf(TAG, &quot;Null intent received&quot;);</span><br><span class="line">           rd = null;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           rd = mDispatcher.get();</span><br><span class="line">       &#125;</span><br><span class="line">       if (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">           int seq = intent.getIntExtra(&quot;seq&quot;, -1);</span><br><span class="line">           Slog.i(ActivityThread.TAG, &quot;Receiving broadcast &quot; + intent.getAction()</span><br><span class="line">                   + &quot; seq=&quot; + seq + &quot; to &quot; + (rd != null ? rd.mReceiver : null));</span><br><span class="line">       &#125;</span><br><span class="line">       if (rd != null) &#123;</span><br><span class="line">           //见4.7节</span><br><span class="line">           rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                   ordered, sticky, sendingUser);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // The activity manager dispatched a broadcast to a registered</span><br><span class="line">           // receiver in this process, but before it could be delivered the</span><br><span class="line">           // receiver was unregistered.  Acknowledge the broadcast on its</span><br><span class="line">           // behalf so that the system&apos;s broadcast sequence can continue.</span><br><span class="line">           if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                   &quot;Finishing broadcast to unregistered receiver&quot;);</span><br><span class="line">           IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">           try &#123;</span><br><span class="line">               if (extras != null) &#123;</span><br><span class="line">                   extras.setAllowFds(false);</span><br><span class="line">               &#125;</span><br><span class="line">               mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags());</span><br><span class="line">           &#125; catch (RemoteException e) &#123;</span><br><span class="line">               throw e.rethrowFromSystemServer();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-RD-performReceive"><a href="#4-7-RD-performReceive" class="headerlink" title="4.7  RD.performReceive"></a>4.7  RD.performReceive</h3><p>[-&gt;LoadedApk.java::ReceiverDispatcher]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">              Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">          final Args args = new Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">                  sticky, sendingUser);</span><br><span class="line">          if (intent == null) &#123;</span><br><span class="line">              Log.wtf(TAG, &quot;Null intent received&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              if (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">                  int seq = intent.getIntExtra(&quot;seq&quot;, -1);</span><br><span class="line">                  Slog.i(ActivityThread.TAG, &quot;Enqueueing broadcast &quot; + intent.getAction()</span><br><span class="line">                          + &quot; seq=&quot; + seq + &quot; to &quot; + mReceiver);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          //见4.8节</span><br><span class="line">          if (intent == null || !mActivityThread.post(args.getRunnable())) &#123;</span><br><span class="line">               //消息post到主线程，则不会走这里</span><br><span class="line">              if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                  IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">                  if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                          &quot;Finishing sync broadcast to &quot; + mReceiver);</span><br><span class="line">                  args.sendFinished(mgr);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p> Args继承于BroadcastReceiver.PendingResult，实现了Runnable，其中mActivityThread是当前的主线程，在2.3.1节完成赋值，post消息机制，将消息放入MessageQueue，该消息是Runnable,而后执行该Runnable。</p>
<h3 id="4-8-ReceiverDispatcher-Args-getRunnable"><a href="#4-8-ReceiverDispatcher-Args-getRunnable" class="headerlink" title="4.8  ReceiverDispatcher.Args.getRunnable"></a>4.8  ReceiverDispatcher.Args.getRunnable</h3><p>[-&gt;LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public final Runnable getRunnable() &#123;</span><br><span class="line">          return () -&gt; &#123;</span><br><span class="line">              final BroadcastReceiver receiver = mReceiver;</span><br><span class="line">              final boolean ordered = mOrdered;</span><br><span class="line"></span><br><span class="line">              if (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">                  int seq = mCurIntent.getIntExtra(&quot;seq&quot;, -1);</span><br><span class="line">                  Slog.i(ActivityThread.TAG, &quot;Dispatching broadcast &quot; + mCurIntent.getAction()</span><br><span class="line">                          + &quot; seq=&quot; + seq + &quot; to &quot; + mReceiver);</span><br><span class="line">                  Slog.i(ActivityThread.TAG, &quot;  mRegistered=&quot; + mRegistered</span><br><span class="line">                          + &quot; mOrderedHint=&quot; + ordered);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">              final Intent intent = mCurIntent;</span><br><span class="line">              if (intent == null) &#123;</span><br><span class="line">                  Log.wtf(TAG, &quot;Null intent being dispatched, mDispatched=&quot; + mDispatched</span><br><span class="line">                          + &quot;: run() previously called at &quot;</span><br><span class="line">                          + Log.getStackTraceString(mPreviousRunStacktrace));</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              mCurIntent = null;</span><br><span class="line">              mDispatched = true;</span><br><span class="line">              mPreviousRunStacktrace = new Throwable(&quot;Previous stacktrace&quot;);</span><br><span class="line">              if (receiver == null || intent == null || mForgotten) &#123;</span><br><span class="line">                  if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                      if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                              &quot;Finishing null broadcast to &quot; + mReceiver);</span><br><span class="line">                      sendFinished(mgr);</span><br><span class="line">                  &#125;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;broadcastReceiveReg&quot;);</span><br><span class="line">              try &#123;</span><br><span class="line">                  //获取mReceiver的类加载器</span><br><span class="line">                  ClassLoader cl = mReceiver.getClass().getClassLoader();</span><br><span class="line">                  intent.setExtrasClassLoader(cl);</span><br><span class="line">                  intent.prepareToEnterProcess();</span><br><span class="line">                  setExtrasClassLoader(cl);</span><br><span class="line">                  receiver.setPendingResult(this);</span><br><span class="line">                  //调用receiver的onReceive回调</span><br><span class="line">                  receiver.onReceive(mContext, intent);</span><br><span class="line">              &#125; catch (Exception e) &#123;</span><br><span class="line">                  if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                      if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                              &quot;Finishing failed broadcast to &quot; + mReceiver);</span><br><span class="line">                      sendFinished(mgr);</span><br><span class="line">                  &#125;</span><br><span class="line">                  if (mInstrumentation == null ||</span><br><span class="line">                          !mInstrumentation.onException(mReceiver, e)) &#123;</span><br><span class="line">                      Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                      throw new RuntimeException(</span><br><span class="line">                              &quot;Error receiving broadcast &quot; + intent</span><br><span class="line">                                      + &quot; in &quot; + mReceiver, e);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            </span><br><span class="line">              if (receiver.getPendingResult() != null) &#123;</span><br><span class="line">                 //见4.9节</span><br><span class="line">                  finish();</span><br><span class="line">              &#125;</span><br><span class="line">              Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-9-PendingResult-finish"><a href="#4-9-PendingResult-finish" class="headerlink" title="4.9  PendingResult.finish"></a>4.9  PendingResult.finish</h3><p>[-&gt;BroadcastReceiver.java::PendingResult]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* Finish the broadcast.  The current result will be sent and the</span><br><span class="line"> * next broadcast will proceed.</span><br><span class="line"> */</span><br><span class="line">public final void finish() &#123;</span><br><span class="line">    if (mType == TYPE_COMPONENT) &#123;//代表静态注册的广播</span><br><span class="line">        final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        if (QueuedWork.hasPendingWork()) &#123;</span><br><span class="line">            // If this is a broadcast component, we need to make sure any</span><br><span class="line">            // queued work is complete before telling AM we are done, so</span><br><span class="line">            // we don&apos;t have our process killed before that.  We now know</span><br><span class="line">            // there is pending work; put another piece of work at the end</span><br><span class="line">            // of the list to finish the broadcast, so we don&apos;t block this</span><br><span class="line">            // thread (which may be the main thread) to have it finished.</span><br><span class="line">            //</span><br><span class="line">            // Note that we don&apos;t need to use QueuedWork.addFinisher() with the</span><br><span class="line">            // runnable, since we know the AM is waiting for us until the</span><br><span class="line">            // executor gets to it.</span><br><span class="line">            QueuedWork.queue(new Runnable() &#123;</span><br><span class="line">                @Override public void run() &#123;</span><br><span class="line">                    if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                            &quot;Finishing broadcast after work to component &quot; + mToken);</span><br><span class="line">                    sendFinished(mgr);//见4.9.1节</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    &quot;Finishing broadcast to component &quot; + mToken);</span><br><span class="line">            sendFinished(mgr);//见4.9.1节</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (mOrderedHint &amp;&amp; mType != TYPE_UNREGISTERED) &#123; //动态注册的串行广播</span><br><span class="line">        if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                &quot;Finishing broadcast to &quot; + mToken);</span><br><span class="line">        final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        sendFinished(mgr);//见4.9.1节</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要工作：</p>
<p>1.静态注册的广播接收者:</p>
<ul>
<li><p>当QueuedWork工作未完成时，则等待完成再执行sendFinished</p>
</li>
<li><p>当QueuedWork工作已经完成，直接调用sendFinished方法</p>
</li>
</ul>
<p>2.动态注册的广播接收者：当发送的是串行广播，则直接调用sendFinished</p>
<p>参数说明：</p>
<p>TYPE_COMPONENT：静态注册</p>
<p>TYPE_REGISTERED：动态注册</p>
<p>TYPE_UNREGISTERED：取消注册</p>
<h4 id="4-9-1-PendingResult-sendFinished"><a href="#4-9-1-PendingResult-sendFinished" class="headerlink" title="4.9.1  PendingResult.sendFinished"></a>4.9.1  PendingResult.sendFinished</h4><p>[-&gt;BroadcastReceiver.java::PendingResult]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/** @hide */</span><br><span class="line">public void sendFinished(IActivityManager am) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mFinished) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Broadcast already finished&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mFinished = true;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (mResultExtras != null) &#123;</span><br><span class="line">                mResultExtras.setAllowFds(false);</span><br><span class="line">            &#125;</span><br><span class="line">            //串行广播，见4.9.2</span><br><span class="line">            if (mOrderedHint) &#123;</span><br><span class="line">                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,</span><br><span class="line">                        mAbortBroadcast, mFlags);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 并行广播，当属于静态注册的广播，需要告知AMS</span><br><span class="line">                // This broadcast was sent to a component; it is not ordered,</span><br><span class="line">                // but we still need to tell the activity manager we are done.</span><br><span class="line">                am.finishReceiver(mToken, 0, null, null, false, mFlags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-9-2-AMS-finishReceiver"><a href="#4-9-2-AMS-finishReceiver" class="headerlink" title="4.9.2  AMS.finishReceiver"></a>4.9.2  AMS.finishReceiver</h4><p>[-&gt;ActivityManagerService.java]</p>
<p>通过binder机制最后调用到AMS的finishReceiver方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void finishReceiver(IBinder who, int resultCode, String resultData,</span><br><span class="line">        Bundle resultExtras, boolean resultAbort, int flags) &#123;</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Finish receiver: &quot; + who);</span><br><span class="line"></span><br><span class="line">    // Refuse possible leaked file descriptors</span><br><span class="line">    if (resultExtras != null &amp;&amp; resultExtras.hasFileDescriptors()) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;File descriptors passed in Bundle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final long origId = Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean doNext = false;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            //属于哪个队列</span><br><span class="line">            BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0</span><br><span class="line">                    ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">            r = queue.getMatchingOrderedReceiver(who);</span><br><span class="line">            if (r != null) &#123;</span><br><span class="line">                //见4.9.3节</span><br><span class="line">                doNext = r.queue.finishReceiverLocked(r, resultCode,</span><br><span class="line">                    resultData, resultExtras, resultAbort, true);</span><br><span class="line">            &#125;</span><br><span class="line">            if (doNext) &#123;</span><br><span class="line">                //处理下一条广播</span><br><span class="line">                r.queue.processNextBroadcastLocked(/*fromMsg=*/ false, /*skipOomAdj=*/ true);</span><br><span class="line">            &#125;</span><br><span class="line">            // updateOomAdjLocked() will be done here</span><br><span class="line">            trimApplicationsLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-9-3-BQ-finishReceiverLocked"><a href="#4-9-3-BQ-finishReceiverLocked" class="headerlink" title="4.9.3  BQ.finishReceiverLocked"></a>4.9.3  BQ.finishReceiverLocked</h4><p>[-&gt;BroadcastQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public boolean finishReceiverLocked(BroadcastRecord r, int resultCode,</span><br><span class="line">          String resultData, Bundle resultExtras, boolean resultAbort, boolean waitForServices) &#123;</span><br><span class="line">      final int state = r.state;</span><br><span class="line">      final ActivityInfo receiver = r.curReceiver;</span><br><span class="line">      r.state = BroadcastRecord.IDLE;</span><br><span class="line">      if (state == BroadcastRecord.IDLE) &#123;</span><br><span class="line">          Slog.w(TAG, &quot;finishReceiver [&quot; + mQueueName + &quot;] called but state is IDLE&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      r.receiver = null;</span><br><span class="line">      r.intent.setComponent(null);</span><br><span class="line">      if (r.curApp != null &amp;&amp; r.curApp.curReceivers.contains(r)) &#123;</span><br><span class="line">          r.curApp.curReceivers.remove(r);</span><br><span class="line">      &#125;</span><br><span class="line">      if (r.curFilter != null) &#123;</span><br><span class="line">          r.curFilter.receiverList.curBroadcast = null;</span><br><span class="line">      &#125;</span><br><span class="line">      r.curFilter = null;</span><br><span class="line">      r.curReceiver = null;</span><br><span class="line">      r.curApp = null;</span><br><span class="line">      mPendingBroadcast = null;</span><br><span class="line"></span><br><span class="line">      r.resultCode = resultCode;</span><br><span class="line">      r.resultData = resultData;</span><br><span class="line">      r.resultExtras = resultExtras;</span><br><span class="line">      if (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == 0) &#123;</span><br><span class="line">          r.resultAbort = resultAbort;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          r.resultAbort = false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (waitForServices &amp;&amp; r.curComponent != null &amp;&amp; r.queue.mDelayBehindServices</span><br><span class="line">              &amp;&amp; r.queue.mOrderedBroadcasts.size() &gt; 0</span><br><span class="line">              &amp;&amp; r.queue.mOrderedBroadcasts.get(0) == r) &#123;</span><br><span class="line">          ActivityInfo nextReceiver;</span><br><span class="line">          if (r.nextReceiver &lt; r.receivers.size()) &#123;</span><br><span class="line">              Object obj = r.receivers.get(r.nextReceiver);</span><br><span class="line">              nextReceiver = (obj instanceof ActivityInfo) ? (ActivityInfo)obj : null;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              nextReceiver = null;</span><br><span class="line">          &#125;</span><br><span class="line">          // Don&apos;t do this if the next receive is in the same process as the current one.</span><br><span class="line">          if (receiver == null || nextReceiver == null</span><br><span class="line">                  || receiver.applicationInfo.uid != nextReceiver.applicationInfo.uid</span><br><span class="line">                  || !receiver.processName.equals(nextReceiver.processName)) &#123;</span><br><span class="line">              // In this case, we are ready to process the next receiver for the current broadcast,</span><br><span class="line">              // but are on a queue that would like to wait for services to finish before moving</span><br><span class="line">              // on.  If there are background services currently starting, then we will go into a</span><br><span class="line">              // special state where we hold off on continuing this broadcast until they are done.</span><br><span class="line">              if (mService.mServices.hasBackgroundServicesLocked(r.userId)) &#123;</span><br><span class="line">                  Slog.i(TAG, &quot;Delay finish: &quot; + r.curComponent.flattenToShortString());</span><br><span class="line">                  r.state = BroadcastRecord.WAITING_SERVICES;</span><br><span class="line">                  return false;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      r.curComponent = null;</span><br><span class="line"></span><br><span class="line">      // We will process the next receiver right now if this is finishing</span><br><span class="line">      // an app receiver (which is always asynchronous) or after we have</span><br><span class="line">      // come back from calling a receiver.</span><br><span class="line">      return state == BroadcastRecord.APP_RECEIVE</span><br><span class="line">              || state == BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个过程主要是设置BroadcastRecord各个参数为null，并判断是否还有广播需要处理。</p>
<h3 id="4-10-小结"><a href="#4-10-小结" class="headerlink" title="4.10 小结"></a>4.10 小结</h3><p>接收广播的过程，主要是对并行广播队列和串行广播队列的处理，先处理并行广播队列后处理串行广播队列：</p>
<p>1.处理广播队列，对广播队列进行相应的权限检查处理。无论是并行还是串行，最后调用的都是performReceiveLocked方法。其中串行广播还有时间限制，会调用broadcastTimeoutLocked方法，超时会强制结束广播；</p>
<p>2.通过Binder机制，将消息传递给接收广播的进程进行处理，如果接收广播的进程没起来，还需要启动其进程；</p>
<p>3.最后回调receiver.onReceive的方法，对于串行广播还需要通知AMS已经处理完该条广播，并进行下个广播的处理。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>发送广播过程的流程如下：</p>
<p><img src="/2019/BroadcastCast广播机制原理/broadcast.jpg" alt="broadcast"></p>
<p><strong>广播机制</strong></p>
<p>1.当发送串行广播（order= true）时</p>
<ul>
<li><p>静态注册的广播接收者（receivers），采用串行处理</p>
</li>
<li><p>动态注册的广播接收者（registeredReceivers），采用串行处理</p>
</li>
</ul>
<p>2.当发送并行广播（order= false）时</p>
<ul>
<li><p>静态注册的广播接收者（receivers），采用串行处理</p>
</li>
<li><p>动态注册的广播接收者（registeredReceivers），采用并行处理</p>
</li>
</ul>
<p>静态注册的receiver都是采用串行处理；动态注册的registeredReceivers处理方式无论是串行还是并行，取决于广播的发送方式（processNextBroadcast）；静态注册的广播由于其所在的进程没有创建，而进程的创建需要耗费系统的资源比较多，所以让静态注册的广播串行化，防止瞬间启动大量的进程。</p>
<p>广播ANR只有在串行广播时才需要考虑，因为接收者是串行处理的，前一个receiver处理慢，会影响后一个receiver；并行广播通过一个循环一次性将所有的receiver分发完，不存在彼此影响的问题，没有广播超时。</p>
<p>串行超时情况：某个广播处理时间&gt;2<em>receiver总个数</em>mTimeoutPeriod，其中mTimeoutPeriod，前后队列为10s,后台队列为60s；某个receiver的执行时间超过mTimeoutPeriod。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>源码路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/am/BroadcastRecord.java</span><br><span class="line">frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line">frameworks/base/core/java/android/app/LoadedApk.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/core/java/android/content/IntentFilter.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</span><br><span class="line">frameworks/base/core/java/android/content/BroadcastReceiver.java</span><br></pre></td></tr></table></figure>
      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/BroadcastCast/" rel="tag">#BroadcastCast</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/ContentProvider原理分析/" rel="next" title="ContentProvider原理分析">
                <i class="fa fa-chevron-left"></i> ContentProvider原理分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/开机广播BOOT_COMPLETED发送流程分析/" rel="prev" title="开机广播BOOT_COMPLETED发送流程分析">
                开机广播BOOT_COMPLETED发送流程分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br> 技术领域：Android、AI <br><br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、注册广播"><span class="nav-text">二、注册广播</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-CI-registerReceiver"><span class="nav-text">2.1 CI.registerReceiver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-CI-registerReceiverInternal"><span class="nav-text">2.2 CI.registerReceiverInternal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-LA-getReceiverDispatcher"><span class="nav-text">2.3 LA.getReceiverDispatcher</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-创建ReceiverDispatcher"><span class="nav-text">2.3.1 创建ReceiverDispatcher</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-创建InnerReceiver"><span class="nav-text">2.3.2 创建InnerReceiver</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-AMS-registerReceiver"><span class="nav-text">2.4 AMS.registerReceiver</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-AMS-getRecordForAppLocked"><span class="nav-text">2.4.1 AMS.getRecordForAppLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-IntentFilter-match"><span class="nav-text">2.4.3 IntentFilter.match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-AMS-broadcastQueueForIntent"><span class="nav-text">2.4.3 AMS.broadcastQueueForIntent</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-小结"><span class="nav-text">2.5  小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、发送广播"><span class="nav-text">三、发送广播</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-CI-sendBroadcast"><span class="nav-text">3.1 CI.sendBroadcast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-AMS-broadcastIntent"><span class="nav-text">3.2  AMS.broadcastIntent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-AMS-broadcastIntentLocked"><span class="nav-text">3.3  AMS.broadcastIntentLocked</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-设置广播flags"><span class="nav-text">3.3.1 设置广播flags</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-广播权限验证"><span class="nav-text">3.3.2 广播权限验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-处理系统相关广播"><span class="nav-text">3.3.3 处理系统相关广播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-增加sticky广播"><span class="nav-text">3.3.4 增加sticky广播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-查询receivers和registeredReceivers"><span class="nav-text">3.3.5 查询receivers和registeredReceivers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-6-处理并行广播"><span class="nav-text">3.3.6 处理并行广播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-7-合并registeredReceivers到receivers"><span class="nav-text">3.3.7 合并registeredReceivers到receivers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-8-处理串行广播"><span class="nav-text">3.3.8 处理串行广播</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-小结"><span class="nav-text">3.4  小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、接收广播"><span class="nav-text">四、接收广播</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-BQ-scheduleBroadcastsLocked"><span class="nav-text">4.1  BQ.scheduleBroadcastsLocked</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-BroadcastHandler"><span class="nav-text">4.1.1 BroadcastHandler</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-BQ-processNextBroadcast"><span class="nav-text">4.2  BQ.processNextBroadcast</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-处理并行广播"><span class="nav-text">4.2.1 处理并行广播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-处理串行广播"><span class="nav-text">4.2.2 处理串行广播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-获取下条有序广播"><span class="nav-text">4.2.3 获取下条有序广播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-处理下条有序广播"><span class="nav-text">4.2.4 处理下条有序广播</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-BQ-deliverToRegisteredReceiverLocked"><span class="nav-text">4.3  BQ.deliverToRegisteredReceiverLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BQ-performReceiveLocked"><span class="nav-text">4.4  BQ.performReceiveLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-AT-scheduleRegisteredReceiver"><span class="nav-text">4.5  AT.scheduleRegisteredReceiver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-IR-performReceive"><span class="nav-text">4.6 IR.performReceive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-RD-performReceive"><span class="nav-text">4.7  RD.performReceive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-ReceiverDispatcher-Args-getRunnable"><span class="nav-text">4.8  ReceiverDispatcher.Args.getRunnable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-PendingResult-finish"><span class="nav-text">4.9  PendingResult.finish</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-1-PendingResult-sendFinished"><span class="nav-text">4.9.1  PendingResult.sendFinished</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-2-AMS-finishReceiver"><span class="nav-text">4.9.2  AMS.finishReceiver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-3-BQ-finishReceiverLocked"><span class="nav-text">4.9.3  BQ.finishReceiverLocked</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-小结"><span class="nav-text">4.10 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、总结"><span class="nav-text">五、总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2019/BroadcastCast广播机制原理/';
      var disqus_title = "BroadcastCast广播机制原理";
      var disqus_url = 'http://zproo.github.io/2019/BroadcastCast广播机制原理/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
