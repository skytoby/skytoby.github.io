<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="BOOT_COMPLETED,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="基于Android10.0，分析BOOT_COMPLETED的发送流程  一、概述开机广播在很多应用中都会用到，用来启动应用程序，下面将介绍开机广播的广播过程。这个过程比较复杂，需要和AcitvityManagerService、WindowManagerService、PackageManagerService等交互，其具体的时序图如下。  二、开机广播启动过程在AMS启动那篇文章中已经讲到桌">
<meta name="keywords" content="BOOT_COMPLETED">
<meta property="og:type" content="article">
<meta property="og:title" content="开机广播BOOT_COMPLETED发送流程分析">
<meta property="og:url" content="http://zproo.github.io/2019/开机广播BOOT_COMPLETED发送流程分析/index.html">
<meta property="og:site_name" content="Skytoby">
<meta property="og:description" content="基于Android10.0，分析BOOT_COMPLETED的发送流程  一、概述开机广播在很多应用中都会用到，用来启动应用程序，下面将介绍开机广播的广播过程。这个过程比较复杂，需要和AcitvityManagerService、WindowManagerService、PackageManagerService等交互，其具体的时序图如下。  二、开机广播启动过程在AMS启动那篇文章中已经讲到桌">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://zproo.github.io/2019/开机广播BOOT_COMPLETED发送流程分析/bootcompleted.jpg">
<meta property="og:updated_time" content="2020-05-06T07:34:06.931Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="开机广播BOOT_COMPLETED发送流程分析">
<meta name="twitter:description" content="基于Android10.0，分析BOOT_COMPLETED的发送流程  一、概述开机广播在很多应用中都会用到，用来启动应用程序，下面将介绍开机广播的广播过程。这个过程比较复杂，需要和AcitvityManagerService、WindowManagerService、PackageManagerService等交互，其具体的时序图如下。  二、开机广播启动过程在AMS启动那篇文章中已经讲到桌">
<meta name="twitter:image" content="http://zproo.github.io/2019/开机广播BOOT_COMPLETED发送流程分析/bootcompleted.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zproo.github.io/2019/开机广播BOOT_COMPLETED发送流程分析/">

  <title> 开机广播BOOT_COMPLETED发送流程分析 | Skytoby </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header_post" class="header" itemscope="" itemtype="http://schema.org/WPHeader" style="background-image: url('http://ortur5wom.bkt.clouddn.com/home_bg.jpg');">
      <div class="header-inner-post"><a class="site-home" href="/">Skytoby</a>

<div class="site-meta ">
  
  
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/logo.png" style="width: 50px" alt="Skytoby">
      </a>
    </div>
  

  
  
  
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
           <li class="menu-item menu-item-关于">
             <a href="/about" rel="section">
               
               
               关于
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-目录">
             <a href="/archives" rel="section">
               
               
               目录
             </a>
           </li>
        
      
        
        
        
           <li class="menu-item menu-item-首页">
             <a href="/" rel="section">
               
               
               首页
             </a>
           </li>
        
      

      
    </ul>
  

  
</nav> </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/BOOT-COMPLETED/" rel="tag" title="BOOT_COMPLETED">BOOT_COMPLETED</a>
      
      </div>
      <h1>开机广播BOOT_COMPLETED发送流程分析</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">Posted on </span>
        <time itemprop="dateCreated" datetime="2019-10-05T21:32:23+08:00" content="2019-10-05" title="2019-10-05 21:32:23">
          2019-10-05
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                开机广播BOOT_COMPLETED发送流程分析
              
            
          </h1>
        

        <div class="post-meta">
		  

          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-10-05T21:32:23+08:00" content="2019-10-05">
              2019-10-05
            </time>
          </span>

          

          <!-- 
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/开机广播BOOT_COMPLETED发送流程分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/开机广播BOOT_COMPLETED发送流程分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>基于Android10.0，分析BOOT_COMPLETED的发送流程</p>
</blockquote>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>开机广播在很多应用中都会用到，用来启动应用程序，下面将介绍开机广播的广播过程。这个过程比较复杂，需要和AcitvityManagerService、WindowManagerService、PackageManagerService等交互，其具体的时序图如下。</p>
<p><img src="/2019/开机广播BOOT_COMPLETED发送流程分析/bootcompleted.jpg" alt="bootcompleted"></p>
<h2 id="二、开机广播启动过程"><a href="#二、开机广播启动过程" class="headerlink" title="二、开机广播启动过程"></a>二、开机广播启动过程</h2><p>在AMS启动<a href="https://skytoby.github.io/2019/AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">那篇文章</a>中已经讲到桌面如何的启动，在桌面启动完成后即桌面Activity onResume之后，就会发送开机广播。桌面Activity onResume阶段，执行了handleResumeActivity方法，见<a href="https://skytoby.github.io/2019/startActivity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Activity启动过程</a>。handleResumeActivity中加载完window之后将自己实现的IdleHandler添加到自己的消息队列中。</p>
<h3 id="1-1-AT-handleResumeActivity"><a href="#1-1-AT-handleResumeActivity" class="headerlink" title="1.1  AT.handleResumeActivity"></a>1.1  AT.handleResumeActivity</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">           String reason) &#123;</span><br><span class="line">       ...</span><br><span class="line">       //执行onResume方法</span><br><span class="line">       final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">       ...</span><br><span class="line">       r.nextIdle = mNewActivities;</span><br><span class="line">       mNewActivities = r;</span><br><span class="line">       if (localLOGV) Slog.v(TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">       //见1.2节</span><br><span class="line">       Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-MQ-addIdleHandler"><a href="#1-2-MQ-addIdleHandler" class="headerlink" title="1.2 MQ.addIdleHandler"></a>1.2 MQ.addIdleHandler</h3><p>[-&gt;MessageQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void addIdleHandler(@NonNull IdleHandler handler) &#123;</span><br><span class="line">      if (handler == null) &#123;</span><br><span class="line">          throw new NullPointerException(&quot;Can&apos;t add a null IdleHandler&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">          //见1.3节</span><br><span class="line">          mIdleHandlers.add(handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>将IdleHandler加入到消息队列，当消息队列空闲的时候执行idler.queueIdle()的回调。</p>
<h3 id="1-3-Idler-queueIdle"><a href="#1-3-Idler-queueIdle" class="headerlink" title="1.3 Idler.queueIdle"></a>1.3 Idler.queueIdle</h3><p>[-&gt;ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private class Idler implements MessageQueue.IdleHandler &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public final boolean queueIdle() &#123;</span><br><span class="line">           ActivityClientRecord a = mNewActivities;</span><br><span class="line">           boolean stopProfiling = false;</span><br><span class="line">           if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null</span><br><span class="line">                   &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">               stopProfiling = true;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a != null) &#123;</span><br><span class="line">               mNewActivities = null;</span><br><span class="line">               //获取AMS的代理</span><br><span class="line">               IActivityManager am = ActivityManager.getService();</span><br><span class="line">               ActivityClientRecord prev;</span><br><span class="line">               do &#123;</span><br><span class="line">                   if (localLOGV) Slog.v(</span><br><span class="line">                       TAG, &quot;Reporting idle of &quot; + a +</span><br><span class="line">                       &quot; finished=&quot; +</span><br><span class="line">                       (a.activity != null &amp;&amp; a.activity.mFinished));</span><br><span class="line">                   if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                       try &#123;</span><br><span class="line">                           //见1.4节</span><br><span class="line">                           am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                           a.createdConfig = null;</span><br><span class="line">                       &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                           throw ex.rethrowFromSystemServer();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   prev = a;</span><br><span class="line">                   a = a.nextIdle;</span><br><span class="line">                   prev.nextIdle = null;</span><br><span class="line">               &#125; while (a != null);</span><br><span class="line">           &#125;</span><br><span class="line">           if (stopProfiling) &#123;</span><br><span class="line">               mProfiler.stopProfiling();</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-AMS-activityIdle"><a href="#1-4-AMS-activityIdle" class="headerlink" title="1.4 AMS.activityIdle"></a>1.4 AMS.activityIdle</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123;</span><br><span class="line">       final long origId = Binder.clearCallingIdentity();</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">           if (stack != null) &#123;</span><br><span class="line">               //见1.5节</span><br><span class="line">               ActivityRecord r =</span><br><span class="line">                       mStackSupervisor.activityIdleInternalLocked(token, false /* fromTimeout */,</span><br><span class="line">                               false /* processPausingActivities */, config);</span><br><span class="line">               if (stopProfiling) &#123;</span><br><span class="line">                   if ((mProfileProc == r.app) &amp;&amp; mProfilerInfo != null) &#123;</span><br><span class="line">                       clearProfilerLocked();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Binder.restoreCallingIdentity(origId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-ASS-activityIdleInternalLocked"><a href="#1-5-ASS-activityIdleInternalLocked" class="headerlink" title="1.5 ASS.activityIdleInternalLocked"></a>1.5 ASS.activityIdleInternalLocked</h3><p>[-&gt;ActivityStackSupervisor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">// Checked.</span><br><span class="line">   @GuardedBy(&quot;mService&quot;)</span><br><span class="line">   final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,</span><br><span class="line">           boolean processPausingActivities, Configuration config) &#123;</span><br><span class="line">       if (DEBUG_ALL) Slog.v(TAG, &quot;Activity idle: &quot; + token);</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;ActivityRecord&gt; finishes = null;</span><br><span class="line">       ArrayList&lt;UserState&gt; startingUsers = null;</span><br><span class="line">       int NS = 0;</span><br><span class="line">       int NF = 0;</span><br><span class="line">       boolean booting = false;</span><br><span class="line">       boolean activityRemoved = false;</span><br><span class="line"></span><br><span class="line">       ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">       if (r != null) &#123;</span><br><span class="line">           if (DEBUG_IDLE) Slog.d(TAG_IDLE, &quot;activityIdleInternalLocked: Callers=&quot;</span><br><span class="line">                   + Debug.getCallers(4));</span><br><span class="line">           mHandler.removeMessages(IDLE_TIMEOUT_MSG, r);</span><br><span class="line">           //启动结束</span><br><span class="line">           r.finishLaunchTickingLocked();</span><br><span class="line">           if (fromTimeout) &#123;</span><br><span class="line">               reportActivityLaunchedLocked(fromTimeout, r, INVALID_DELAY);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // This is a hack to semi-deal with a race condition</span><br><span class="line">           // in the client where it can be constructed with a</span><br><span class="line">           // newer configuration from when we asked it to launch.</span><br><span class="line">           // We&apos;ll update with whatever configuration it now says</span><br><span class="line">           // it used to launch.</span><br><span class="line">           if (config != null) &#123;</span><br><span class="line">               r.setLastReportedGlobalConfiguration(config);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // We are now idle.  If someone is waiting for a thumbnail from</span><br><span class="line">           // us, we can now deliver.</span><br><span class="line">           r.idle = true;</span><br><span class="line"></span><br><span class="line">           //Slog.i(TAG, &quot;IDLE: mBooted=&quot; + mBooted + &quot;, fromTimeout=&quot; + fromTimeout);</span><br><span class="line">           if (isFocusedStack(r.getStack()) || fromTimeout) &#123;</span><br><span class="line">               //检查系统是否开机完成，见1.5节</span><br><span class="line">               booting = checkFinishBootingLocked();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //移除超时</span><br><span class="line">       if (allResumedActivitiesIdle()) &#123;</span><br><span class="line">           if (r != null) &#123;</span><br><span class="line">               mService.scheduleAppGcsLocked();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (mLaunchingActivity.isHeld()) &#123;</span><br><span class="line">               mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);</span><br><span class="line">               if (VALIDATE_WAKE_LOCK_CALLER &amp;&amp;</span><br><span class="line">                       Binder.getCallingUid() != Process.myUid()) &#123;</span><br><span class="line">                   throw new IllegalStateException(&quot;Calling must be system uid&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               mLaunchingActivity.release();</span><br><span class="line">           &#125;</span><br><span class="line">           ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Atomically retrieve all of the other things to do.</span><br><span class="line">       final ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r,</span><br><span class="line">               true /* remove */, processPausingActivities);</span><br><span class="line">       NS = stops != null ? stops.size() : 0;</span><br><span class="line">       if ((NF = mFinishingActivities.size()) &gt; 0) &#123;</span><br><span class="line">           finishes = new ArrayList&lt;&gt;(mFinishingActivities);</span><br><span class="line">           mFinishingActivities.clear();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (mStartingUsers.size() &gt; 0) &#123;</span><br><span class="line">           startingUsers = new ArrayList&lt;&gt;(mStartingUsers);</span><br><span class="line">           mStartingUsers.clear();</span><br><span class="line">       &#125;</span><br><span class="line">       //停止其他Activity</span><br><span class="line">       // Stop any activities that are scheduled to do so but have been</span><br><span class="line">       // waiting for the next one to start.</span><br><span class="line">       for (int i = 0; i &lt; NS; i++) &#123;</span><br><span class="line">           r = stops.get(i);</span><br><span class="line">           final ActivityStack stack = r.getStack();</span><br><span class="line">           if (stack != null) &#123;</span><br><span class="line">               if (r.finishing) &#123;</span><br><span class="line">                   stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false,</span><br><span class="line">                           &quot;activityIdleInternalLocked&quot;);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   stack.stopActivityLocked(r);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Finish any activities that are scheduled to do so but have been</span><br><span class="line">       // waiting for the next one to start.</span><br><span class="line">       for (int i = 0; i &lt; NF; i++) &#123;</span><br><span class="line">           r = finishes.get(i);</span><br><span class="line">           final ActivityStack stack = r.getStack();</span><br><span class="line">           if (stack != null) &#123;</span><br><span class="line">               activityRemoved |= stack.destroyActivityLocked(r, true, &quot;finish-idle&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //没有开机完成，切换user</span><br><span class="line">       if (!booting) &#123;</span><br><span class="line">           // Complete user switch</span><br><span class="line">           if (startingUsers != null) &#123;</span><br><span class="line">               for (int i = 0; i &lt; startingUsers.size(); i++) &#123;</span><br><span class="line">                   mService.mUserController.finishUserSwitch(startingUsers.get(i));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mService.trimApplications();</span><br><span class="line">       //dump();</span><br><span class="line">       //mWindowManager.dump();</span><br><span class="line"></span><br><span class="line">       if (activityRemoved) &#123;</span><br><span class="line">           resumeFocusedStackTopActivityLocked();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个和开机广播相关的是检查是否还在开机阶段。如果桌面启动完成，开机动画就结束了。</p>
<h3 id="1-6-ASS-checkFinishBootingLocked"><a href="#1-6-ASS-checkFinishBootingLocked" class="headerlink" title="1.6 ASS.checkFinishBootingLocked"></a>1.6 ASS.checkFinishBootingLocked</h3><p>[-&gt;ActivityStackSupervisor.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Called when the frontmost task is idle.</span><br><span class="line">   * @return the state of mService.mBooting before this was called.</span><br><span class="line">   */</span><br><span class="line">  @GuardedBy(&quot;mService&quot;)</span><br><span class="line">  private boolean checkFinishBootingLocked() &#123;</span><br><span class="line">      final boolean booting = mService.mBooting;</span><br><span class="line">      boolean enableScreen = false;</span><br><span class="line">      mService.mBooting = false;</span><br><span class="line">      if (!mService.mBooted) &#123;</span><br><span class="line">          mService.mBooted = true;</span><br><span class="line">          enableScreen = true;</span><br><span class="line">      &#125;</span><br><span class="line">      if (booting || enableScreen) &#123;</span><br><span class="line">          //booting = true,enableScreen = true</span><br><span class="line">          mService.postFinishBooting(booting, enableScreen);</span><br><span class="line">      &#125;</span><br><span class="line">      return booting;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>mService.mBooting是在ASM.systemReady中设置为true的，这里会修改 mService.mBooting为false;这里由于booting为true，所以会执行postFinishBooting方法。</p>
<h3 id="1-7-AMS-postFinishBooting"><a href="#1-7-AMS-postFinishBooting" class="headerlink" title="1.7 AMS.postFinishBooting"></a>1.7 AMS.postFinishBooting</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void postFinishBooting(boolean finishBooting, boolean enableScreen) &#123;</span><br><span class="line">       //传入的是true,true</span><br><span class="line">       mHandler.sendMessage(mHandler.obtainMessage(FINISH_BOOTING_MSG,</span><br><span class="line">               finishBooting ? 1 : 0, enableScreen ? 1 : 0));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">         //msg.arg1 = 1;msg.arg2=1</span><br><span class="line">         case FINISH_BOOTING_MSG: &#123;</span><br><span class="line">          if (msg.arg1 != 0) &#123;</span><br><span class="line">              Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;FinishBooting&quot;);</span><br><span class="line">              //见1.8节</span><br><span class="line">              finishBooting();</span><br><span class="line">              Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">          &#125;</span><br><span class="line">          if (msg.arg2 != 0) &#123;</span><br><span class="line">              //见1.9节</span><br><span class="line">              enableScreenAfterBoot();</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里Message要做两件事情finishBooting和enableScreenAfterBoot</p>
<h3 id="1-8-AMS-finishBooting"><a href="#1-8-AMS-finishBooting" class="headerlink" title="1.8 AMS.finishBooting"></a>1.8 AMS.finishBooting</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final void finishBooting() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //第一次进入为false,所以这里直接返回了</span><br><span class="line">            if (!mBootAnimationComplete) &#123;</span><br><span class="line">                mCallFinishBooting = true;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mCallFinishBooting = false;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第一次进来时mBootAnimationComplete是为false的，只有动画完成了才会回调方法bootAnimationComplete设置为true，所以这里直接返回了，这里再看下第二件事情enableScreenAfterBoot。</p>
<h3 id="1-9-AMS-enableScreenAfterBoot"><a href="#1-9-AMS-enableScreenAfterBoot" class="headerlink" title="1.9 AMS.enableScreenAfterBoot"></a>1.9 AMS.enableScreenAfterBoot</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void enableScreenAfterBoot() &#123;</span><br><span class="line">     EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_ENABLE_SCREEN,</span><br><span class="line">             SystemClock.uptimeMillis());</span><br><span class="line">     mWindowManager.enableScreenAfterBoot();</span><br><span class="line"></span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         updateEventDispatchingLocked();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void enableScreenAfterBoot() &#123;</span><br><span class="line">       synchronized(mWindowMap) &#123;</span><br><span class="line">           if (DEBUG_BOOT) &#123;</span><br><span class="line">               RuntimeException here = new RuntimeException(&quot;here&quot;);</span><br><span class="line">               here.fillInStackTrace();</span><br><span class="line">               Slog.i(TAG_WM, &quot;enableScreenAfterBoot: mDisplayEnabled=&quot; + mDisplayEnabled</span><br><span class="line">                       + &quot; mForceDisplayEnabled=&quot; + mForceDisplayEnabled</span><br><span class="line">                       + &quot; mShowingBootMessages=&quot; + mShowingBootMessages</span><br><span class="line">                       + &quot; mSystemBooted=&quot; + mSystemBooted, here);</span><br><span class="line">           &#125;</span><br><span class="line">           if (mSystemBooted) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           mSystemBooted = true;</span><br><span class="line">           /见下文</span><br><span class="line">           hideBootMessagesLocked();</span><br><span class="line">           // If the screen still doesn&apos;t come up after 30 seconds, give</span><br><span class="line">           // up and turn it on.</span><br><span class="line">           mH.sendEmptyMessageDelayed(H.BOOT_TIMEOUT, 30 * 1000);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mPolicy.systemBooted();</span><br><span class="line">       //见1.10节</span><br><span class="line">       performEnableScreen();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>mSystemBooted初始值为false，这里会设置成true。mShowingBootMessages为true时改成false，然后设置一个30s的延迟消息，随后调用systemBooted方法，通知keyguard开机完成，最后执行performEnableScreen方法。</p>
<h4 id="1-9-1-WMS-hideBootMessagesLocked"><a href="#1-9-1-WMS-hideBootMessagesLocked" class="headerlink" title="1.9.1 WMS.hideBootMessagesLocked"></a>1.9.1 WMS.hideBootMessagesLocked</h4><p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void hideBootMessagesLocked() &#123;</span><br><span class="line">       if (DEBUG_BOOT) &#123;</span><br><span class="line">           RuntimeException here = new RuntimeException(&quot;here&quot;);</span><br><span class="line">           here.fillInStackTrace();</span><br><span class="line">           Slog.i(TAG_WM, &quot;hideBootMessagesLocked: mDisplayEnabled=&quot; + mDisplayEnabled</span><br><span class="line">                   + &quot; mForceDisplayEnabled=&quot; + mForceDisplayEnabled</span><br><span class="line">                   + &quot; mShowingBootMessages=&quot; + mShowingBootMessages</span><br><span class="line">                   + &quot; mSystemBooted=&quot; + mSystemBooted, here);</span><br><span class="line">       &#125;</span><br><span class="line">       if (mShowingBootMessages) &#123;</span><br><span class="line">           mShowingBootMessages = false;</span><br><span class="line">           mPolicy.hideBootMessages();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-9-2-PWM-hideBootMessages"><a href="#1-9-2-PWM-hideBootMessages" class="headerlink" title="1.9.2  PWM.hideBootMessages"></a>1.9.2  PWM.hideBootMessages</h4><p>[-&gt;PhoneWindowManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** &#123;@inheritDoc&#125; */</span><br><span class="line">   @Override</span><br><span class="line">   public void hideBootMessages() &#123;</span><br><span class="line">       mHandler.sendEmptyMessage(MSG_HIDE_BOOT_MESSAGE);</span><br><span class="line">   &#125;</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">         case MSG_HIDE_BOOT_MESSAGE:</span><br><span class="line">            handleHideBootMessage();</span><br><span class="line">           break;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>这个过程主要是隐藏开机过程中显示的Android系统正在启动或者Android系统正在升级的dialog提示。</p>
<p>该dialog的启动是在SystemServer中启动PKMS初始化开始的，可以参考文章PKMS的启动过程。</p>
<p>在启动过程中会执行mPackageManagerService.updatePackagesIfNeeded方法，其中有performDexOptUpgrade方法。</p>
<p>这个方法主要是对package进行dexoat升级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private int[] performDexOptUpgrade(List&lt;PackageParser.Package&gt; pkgs, boolean showDialog,</span><br><span class="line">           final int compilationReason, boolean bootComplete) &#123;</span><br><span class="line">           ...</span><br><span class="line">           if (showDialog) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   //启动开机过程中出现的dialog</span><br><span class="line">                   ActivityManager.getService().showBootMessage(</span><br><span class="line">                           mContext.getResources().getString(R.string.android_upgrading_apk,</span><br><span class="line">                                   numberOfPackagesVisited, numberOfPackagesToDexopt), true);</span><br><span class="line">               &#125; catch (RemoteException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">               synchronized (mPackages) &#123;</span><br><span class="line">                   mDexOptDialogShown = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">       return new int[] &#123; numberOfPackagesOptimized, numberOfPackagesSkipped,</span><br><span class="line">               numberOfPackagesFailed &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    @Override</span><br><span class="line">   public void showBootMessage(final CharSequence msg, final boolean always) &#123;</span><br><span class="line">       if (Binder.getCallingUid() != myUid()) &#123;</span><br><span class="line">           throw new SecurityException();</span><br><span class="line">       &#125;</span><br><span class="line">       mWindowManager.showBootMessage(msg, always);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>调用显示正在开机的dialog。</p>
<p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void showBootMessage(final CharSequence msg, final boolean always) &#123;</span><br><span class="line">       boolean first = false;</span><br><span class="line">       synchronized(mWindowMap) &#123;</span><br><span class="line">           if (DEBUG_BOOT) &#123;</span><br><span class="line">               RuntimeException here = new RuntimeException(&quot;here&quot;);</span><br><span class="line">               here.fillInStackTrace();</span><br><span class="line">               Slog.i(TAG_WM, &quot;showBootMessage: msg=&quot; + msg + &quot; always=&quot; + always</span><br><span class="line">                       + &quot; mAllowBootMessages=&quot; + mAllowBootMessages</span><br><span class="line">                       + &quot; mShowingBootMessages=&quot; + mShowingBootMessages</span><br><span class="line">                       + &quot; mSystemBooted=&quot; + mSystemBooted, here);</span><br><span class="line">           &#125;</span><br><span class="line">           if (!mAllowBootMessages) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           if (!mShowingBootMessages) &#123;</span><br><span class="line">               if (!always) &#123;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               first = true;</span><br><span class="line">           &#125;</span><br><span class="line">           if (mSystemBooted) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           mShowingBootMessages = true;</span><br><span class="line">           mPolicy.showBootMessage(msg, always);</span><br><span class="line">       &#125;</span><br><span class="line">       if (first) &#123;</span><br><span class="line">           performEnableScreen();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面正式显示dialog，mShowingBootMessages这里设置成true。</p>
<p>[-&gt;PhoneWindowManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/** &#123;@inheritDoc&#125; */</span><br><span class="line">   @Override</span><br><span class="line">   public void showBootMessage(final CharSequence msg, final boolean always) &#123;</span><br><span class="line">       mHandler.post(new Runnable() &#123;</span><br><span class="line">           @Override public void run() &#123;</span><br><span class="line">               if (mBootMsgDialog == null) &#123;</span><br><span class="line">                   int theme;</span><br><span class="line">                   if (mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK)) &#123;</span><br><span class="line">                       theme = com.android.internal.R.style.Theme_Leanback_Dialog_Alert;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       theme = 0;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   mBootMsgDialog = new ProgressDialog(mContext, theme) &#123;</span><br><span class="line">                       // This dialog will consume all events coming in to</span><br><span class="line">                       // it, to avoid it trying to do things too early in boot.</span><br><span class="line">                       @Override public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">                           return true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       @Override public boolean dispatchKeyShortcutEvent(KeyEvent event) &#123;</span><br><span class="line">                           return true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">                           return true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       @Override public boolean dispatchTrackballEvent(MotionEvent ev) &#123;</span><br><span class="line">                           return true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       @Override public boolean dispatchGenericMotionEvent(MotionEvent ev) &#123;</span><br><span class="line">                           return true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       @Override public boolean dispatchPopulateAccessibilityEvent(</span><br><span class="line">                               AccessibilityEvent event) &#123;</span><br><span class="line">                           return true;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;;</span><br><span class="line">                   if (mContext.getPackageManager().isUpgrade()) &#123;</span><br><span class="line">                       mBootMsgDialog.setTitle(R.string.android_upgrading_title);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       mBootMsgDialog.setTitle(R.string.android_start_title);</span><br><span class="line">                   &#125;</span><br><span class="line">                   mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);</span><br><span class="line">                   mBootMsgDialog.setIndeterminate(true);</span><br><span class="line">                   mBootMsgDialog.getWindow().setType(</span><br><span class="line">                           WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);</span><br><span class="line">                   mBootMsgDialog.getWindow().addFlags(</span><br><span class="line">                           WindowManager.LayoutParams.FLAG_DIM_BEHIND</span><br><span class="line">                           | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);</span><br><span class="line">                   mBootMsgDialog.getWindow().setDimAmount(1);</span><br><span class="line">                   WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();</span><br><span class="line">                   lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;</span><br><span class="line">                   mBootMsgDialog.getWindow().setAttributes(lp);</span><br><span class="line">                   mBootMsgDialog.setCancelable(false);</span><br><span class="line">                   mBootMsgDialog.show();</span><br><span class="line">               &#125;</span><br><span class="line">               mBootMsgDialog.setMessage(msg);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最后看下handleHideBootMessage，这里会取消dialog显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void handleHideBootMessage() &#123;</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           if (!mKeyguardDrawnOnce) &#123;</span><br><span class="line">               mBootMessageNeedsHiding = true;</span><br><span class="line">               return; // keyguard hasn&apos;t drawn the first time yet, not done booting</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (mBootMsgDialog != null) &#123;</span><br><span class="line">           if (DEBUG_WAKEUP) Slog.d(TAG, &quot;handleHideBootMessage: dismissing&quot;);</span><br><span class="line">           mBootMsgDialog.dismiss();</span><br><span class="line">           mBootMsgDialog = null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-9-3-PWM-systemBooted"><a href="#1-9-3-PWM-systemBooted" class="headerlink" title="1.9.3 PWM.systemBooted"></a>1.9.3 PWM.systemBooted</h4><p>[-&gt;PhoneWindowManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** &#123;@inheritDoc&#125; */</span><br><span class="line">@Override</span><br><span class="line">public void systemBooted() &#123;</span><br><span class="line">    bindKeyguard();</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mSystemBooted = true;</span><br><span class="line">        //在systemserver启动中，设置成了true</span><br><span class="line">        if (mSystemReady) &#123;</span><br><span class="line">            //通知keyguard，开机完成</span><br><span class="line">            mKeyguardDelegate.onBootCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    startedWakingUp();</span><br><span class="line">    screenTurningOn(null);</span><br><span class="line">    screenTurnedOn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-9-4-mH-sendEmptyMessageDelayed"><a href="#1-9-4-mH-sendEmptyMessageDelayed" class="headerlink" title="1.9.4 mH.sendEmptyMessageDelayed"></a>1.9.4 mH.sendEmptyMessageDelayed</h4><p>[-&gt;WindowManagerService.java]</p>
<p>发送消息，最后执行performBootTimeout方法，可以看到performBootTimeout最后执行的是performEnableScreen方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void handleMessage(Message msg) &#123;case BOOT_TIMEOUT: &#123;</span><br><span class="line">        performBootTimeout();</span><br><span class="line">        break;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void performBootTimeout() &#123;</span><br><span class="line">       synchronized(mWindowMap) &#123;</span><br><span class="line">           //这个参数在动画结束时才为true,见1.10节</span><br><span class="line">           if (mDisplayEnabled) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           Slog.w(TAG_WM, &quot;***** BOOT TIMEOUT: forcing display enabled&quot;);</span><br><span class="line">           mForceDisplayEnabled = true;</span><br><span class="line">       &#125;</span><br><span class="line">       //如果30s内动画还没完完成则，再执行performEnableScreen</span><br><span class="line">       performEnableScreen();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-10-WMS-performEnableScreen"><a href="#1-10-WMS-performEnableScreen" class="headerlink" title="1.10 WMS.performEnableScreen"></a>1.10 WMS.performEnableScreen</h3><p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">private void performEnableScreen() &#123;</span><br><span class="line">        synchronized(mWindowMap) &#123;</span><br><span class="line">            if (DEBUG_BOOT) Slog.i(TAG_WM, &quot;performEnableScreen: mDisplayEnabled=&quot; + mDisplayEnabled</span><br><span class="line">                    + &quot; mForceDisplayEnabled=&quot; + mForceDisplayEnabled</span><br><span class="line">                    + &quot; mShowingBootMessages=&quot; + mShowingBootMessages</span><br><span class="line">                    + &quot; mSystemBooted=&quot; + mSystemBooted</span><br><span class="line">                    + &quot; mOnlyCore=&quot; + mOnlyCore,</span><br><span class="line">                    new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">           </span><br><span class="line">            if (mDisplayEnabled) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //mSystemBooted为true,在1.9节中设置</span><br><span class="line">            if (!mSystemBooted &amp;&amp; !mShowingBootMessages) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //1.9.1节mShowingBootMessages设置成了false，关键判断canDismissBootAnimation</span><br><span class="line">            if (!mShowingBootMessages &amp;&amp; !mPolicy.canDismissBootAnimation()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Don&apos;t enable the screen until all existing windows have been drawn.</span><br><span class="line">            //等所有的窗口都绘制完成，才能使能屏幕，见1.10.2节</span><br><span class="line">            if (!mForceDisplayEnabled</span><br><span class="line">                    // TODO(multidisplay): Expand to all displays?</span><br><span class="line">                    &amp;&amp; getDefaultDisplayContentLocked().checkWaitingForWindows()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //没有停止动画</span><br><span class="line">            if (!mBootAnimationStopped) &#123;</span><br><span class="line">                Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;Stop bootanim&quot;, 0);</span><br><span class="line">                // stop boot animation</span><br><span class="line">                // formerly we would just kill the process, but we now ask it to exit so it</span><br><span class="line">                // can choose where to stop the animation.</span><br><span class="line">                SystemProperties.set(&quot;service.bootanim.exit&quot;, &quot;1&quot;);</span><br><span class="line">                mBootAnimationStopped = true;</span><br><span class="line">            &#125;</span><br><span class="line">            //检查开机动画是否完成，见1.10.3节</span><br><span class="line">            if (!mForceDisplayEnabled &amp;&amp; !checkBootAnimationCompleteLocked()) &#123;</span><br><span class="line">                if (DEBUG_BOOT) Slog.i(TAG_WM, &quot;performEnableScreen: Waiting for anim complete&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                //通知surfaceFlinger完成</span><br><span class="line">                IBinder surfaceFlinger = ServiceManager.getService(&quot;SurfaceFlinger&quot;);</span><br><span class="line">                if (surfaceFlinger != null) &#123;</span><br><span class="line">                    Slog.i(TAG_WM, &quot;******* TELLING SURFACE FLINGER WE ARE BOOTED!&quot;);</span><br><span class="line">                    Parcel data = Parcel.obtain();</span><br><span class="line">                    data.writeInterfaceToken(&quot;android.ui.ISurfaceComposer&quot;);</span><br><span class="line">                    surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED</span><br><span class="line">                            data, null, 0);</span><br><span class="line">                    data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                Slog.e(TAG_WM, &quot;Boot completed: SurfaceFlinger is dead!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());</span><br><span class="line">            Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, &quot;Stop bootanim&quot;, 0);</span><br><span class="line">            //这里开机动画已经结束</span><br><span class="line">            mDisplayEnabled = true;</span><br><span class="line">            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, &quot;******************** ENABLING SCREEN!&quot;);</span><br><span class="line"></span><br><span class="line">            // Enable input dispatch.</span><br><span class="line">            mInputMonitor.setEventDispatchingLw(mEventDispatchingEnabled);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            mActivityManager.bootAnimationComplete();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        mPolicy.enableScreenAfterBoot();</span><br><span class="line"></span><br><span class="line">        // Make sure the last requested orientation has been applied.</span><br><span class="line">        updateRotationUnchecked(false, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里主要的工作是停止开机动画，通知SurfaceFlinger开机结束等。在停止开机动画前会有很多的判断，如果现有的window（桌面，状态栏，keyguard，壁纸等）都已经绘制完成包括，才会停止动画。</p>
</li>
<li><p>停止动画是执行了SystemProperties.set(“service.bootanim.exit”, “1”)；在system/bin/bootanimation一般会在显示的时候循环查询这个prop的值，如果变成了1则退出。</p>
</li>
</ul>
<h4 id="1-10-1-PWM-canDismissBootAnimation"><a href="#1-10-1-PWM-canDismissBootAnimation" class="headerlink" title="1.10.1 PWM.canDismissBootAnimation"></a>1.10.1 PWM.canDismissBootAnimation</h4><p>[-&gt;PhoneWindowManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public boolean canDismissBootAnimation() &#123;</span><br><span class="line">      synchronized (mLock) &#123;</span><br><span class="line">          return mKeyguardDrawComplete;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>mKeyguardDrawComplete是Keyguard是否绘制完成，绘制完成才会进入下面的方法。</p>
<h4 id="1-10-2-checkWaitingForWindows"><a href="#1-10-2-checkWaitingForWindows" class="headerlink" title="1.10.2  checkWaitingForWindows"></a>1.10.2  checkWaitingForWindows</h4><p>[-&gt;DisplayContent.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">boolean checkWaitingForWindows() &#123;</span><br><span class="line"></span><br><span class="line">       mHaveBootMsg = false;</span><br><span class="line">       mHaveApp = false;</span><br><span class="line">       mHaveWallpaper = false;</span><br><span class="line">       mHaveKeyguard = true;</span><br><span class="line"></span><br><span class="line">       final WindowState visibleWindow = getWindow(w -&gt; &#123;</span><br><span class="line">           if (w.isVisibleLw() &amp;&amp; !w.mObscured &amp;&amp; !w.isDrawnLw()) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           if (w.isDrawnLw()) &#123;</span><br><span class="line">               if (w.mAttrs.type == TYPE_BOOT_PROGRESS) &#123;</span><br><span class="line">                   mHaveBootMsg = true;</span><br><span class="line">               &#125; else if (w.mAttrs.type == TYPE_APPLICATION</span><br><span class="line">                       || w.mAttrs.type == TYPE_DRAWN_APPLICATION) &#123;</span><br><span class="line">                   mHaveApp = true;</span><br><span class="line">               &#125; else if (w.mAttrs.type == TYPE_WALLPAPER) &#123;</span><br><span class="line">                   mHaveWallpaper = true;</span><br><span class="line">               &#125; else if (w.mAttrs.type == TYPE_STATUS_BAR) &#123;</span><br><span class="line">                   mHaveKeyguard = mService.mPolicy.isKeyguardDrawnLw();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       if (visibleWindow != null) &#123;</span><br><span class="line">           // We have a visible window.</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // if the wallpaper service is disabled on the device, we&apos;re never going to have</span><br><span class="line">       // wallpaper, don&apos;t bother waiting for it</span><br><span class="line">       boolean wallpaperEnabled = mService.mContext.getResources().getBoolean(</span><br><span class="line">               com.android.internal.R.bool.config_enableWallpaperService)</span><br><span class="line">               &amp;&amp; mService.mContext.getResources().getBoolean(</span><br><span class="line">                       com.android.internal.R.bool.config_checkWallpaperAtBoot)</span><br><span class="line">               &amp;&amp; !mService.mOnlyCore;</span><br><span class="line"></span><br><span class="line">       if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM,</span><br><span class="line">               &quot;******** booted=&quot; + mService.mSystemBooted</span><br><span class="line">               + &quot; msg=&quot; + mService.mShowingBootMessages</span><br><span class="line">               + &quot; haveBoot=&quot; + mHaveBootMsg + &quot; haveApp=&quot; + mHaveApp</span><br><span class="line">               + &quot; haveWall=&quot; + mHaveWallpaper + &quot; wallEnabled=&quot; + wallpaperEnabled</span><br><span class="line">               + &quot; haveKeyguard=&quot; + mHaveKeyguard);</span><br><span class="line"></span><br><span class="line">       // If we are turning on the screen to show the boot message, don&apos;t do it until the boot</span><br><span class="line">       // message is actually displayed.</span><br><span class="line">       if (!mService.mSystemBooted &amp;&amp; !mHaveBootMsg) &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If we are turning on the screen after the boot is completed normally, don&apos;t do so until</span><br><span class="line">       // we have the application and wallpaper.</span><br><span class="line">       if (mService.mSystemBooted</span><br><span class="line">               &amp;&amp; ((!mHaveApp &amp;&amp; !mHaveKeyguard) || (wallpaperEnabled &amp;&amp; !mHaveWallpaper))) &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-10-3-WMS-checkWaitingForWindows"><a href="#1-10-3-WMS-checkWaitingForWindows" class="headerlink" title="1.10.3  WMS.checkWaitingForWindows"></a>1.10.3  WMS.checkWaitingForWindows</h4><p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean checkBootAnimationCompleteLocked() &#123;</span><br><span class="line">       if (SystemService.isRunning(BOOT_ANIMATION_SERVICE)) &#123;</span><br><span class="line">           mH.removeMessages(H.CHECK_IF_BOOT_ANIMATION_FINISHED);</span><br><span class="line">           mH.sendEmptyMessageDelayed(H.CHECK_IF_BOOT_ANIMATION_FINISHED,</span><br><span class="line">                   BOOT_ANIMATION_POLL_INTERVAL);</span><br><span class="line">           if (DEBUG_BOOT) Slog.i(TAG_WM, &quot;checkBootAnimationComplete: Waiting for anim complete&quot;);</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       if (DEBUG_BOOT) Slog.i(TAG_WM, &quot;checkBootAnimationComplete: Animation complete!&quot;);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里判断开机动画是否停止通过判断BOOT_ANIMATION_SERVICE服务是否在运行。</p>
<h4 id="1-10-4-WMS-enableScreenIfNeeded"><a href="#1-10-4-WMS-enableScreenIfNeeded" class="headerlink" title="1.10.4 WMS.enableScreenIfNeeded"></a>1.10.4 WMS.enableScreenIfNeeded</h4><p>performEnableScreen里面并不能一次就能停止动画，查看日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">01-01 22:00:26.180  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:26.180  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:26.182  2496  3120 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:26.182  2496  3120 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:26.521  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:26.521  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:27.166  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:27.166  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:27.193  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:27.193  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:27.198  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:27.198  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:27.200  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:27.200  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:27.201  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:27.201  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:27.207  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:27.207  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:27.873  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:27.873  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:37.807  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:37.807  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:37.809  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:37.809  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:37.819  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:37.819  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:37.825  2496  3127 I WindowManager: performEnableScreen: Waiting for anim complete</span><br><span class="line">01-01 22:00:37.830  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:37.830  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:37.830  2496  3127 I WindowManager: performEnableScreen: Waiting for anim complete</span><br><span class="line">01-01 22:00:37.839  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">01-01 22:00:37.839  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)</span><br><span class="line">01-01 22:00:37.840  2496  3127 I WindowManager: performEnableScreen: Waiting for anim complete</span><br></pre></td></tr></table></figure>
<p>除了从Launch发起的流程调用这里之外，还有其他的调用点，在WMS里面经过enableScreenIfNeeded方法发送ENABLE_SCREEN 消息给Handler进行处理。</p>
<p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void enableScreenIfNeeded() &#123;</span><br><span class="line">       synchronized (mWindowMap) &#123;</span><br><span class="line">           enableScreenIfNeededLocked();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   void enableScreenIfNeededLocked() &#123;</span><br><span class="line">       if (DEBUG_BOOT) &#123;</span><br><span class="line">           RuntimeException here = new RuntimeException(&quot;here&quot;);</span><br><span class="line">           here.fillInStackTrace();</span><br><span class="line">           Slog.i(TAG_WM, &quot;enableScreenIfNeededLocked: mDisplayEnabled=&quot; + mDisplayEnabled</span><br><span class="line">                   + &quot; mForceDisplayEnabled=&quot; + mForceDisplayEnabled</span><br><span class="line">                   + &quot; mShowingBootMessages=&quot; + mShowingBootMessages</span><br><span class="line">                   + &quot; mSystemBooted=&quot; + mSystemBooted, here);</span><br><span class="line">       &#125;</span><br><span class="line">       if (mDisplayEnabled) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!mSystemBooted &amp;&amp; !mShowingBootMessages) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       mH.sendEmptyMessage(H.ENABLE_SCREEN);</span><br><span class="line">   &#125;</span><br><span class="line">   public void handleMessage(Message msg) &#123;</span><br><span class="line">       ...</span><br><span class="line">       case ENABLE_SCREEN: &#123;</span><br><span class="line">               performEnableScreen();</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>enableScreenIfNeededLocked这个方法也调用的十分的频繁，调用点也有多个位置，大部分的调用栈如下，在WMS每次进行performSurfacePlacement等主要是完成绘制布局之后检查调用。在发送ENABLE_SCREEN消息之前会判断mDisplayEnabled是否为true，如果通过performEnableScreen设置为true，则不再执行，避免了重复操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: enableScreenIfNeededLocked: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: java.lang.RuntimeException: here</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.WindowManagerService.enableScreenIfNeededLocked(WindowManagerService.java:3417)</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.RootWindowContainer.performSurfacePlacement(RootWindowContainer.java:818)</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.WindowSurfacePlacer.performSurfacePlacementLoop(WindowSurfacePlacer.java:207)</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.WindowSurfacePlacer.performSurfacePlacement(WindowSurfacePlacer.java:155)</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.WindowManagerService.relayoutWindow(WindowManagerService.java:2031)</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.Session.relayout(Session.java:244)</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: 	at android.view.IWindowSession$Stub.onTransact(IWindowSession.java:309)</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.Session.onTransact(Session.java:164)</span><br><span class="line">10-08 08:43:06.756  1592  2422 I WindowManager: 	at android.os.Binder.execTransact(Binder.java:731)</span><br><span class="line">10-08 08:43:06.763  1592  1811 I WindowManager: skytoby performEnableScreen: mDisplayEnabled=false mForceDisplayEnabled=false mShowingBootMessages=false mSystemBooted=true mOnlyCore=false</span><br><span class="line">10-08 08:43:06.763  1592  1811 I WindowManager: java.lang.RuntimeException: here</span><br><span class="line">10-08 08:43:06.763  1592  1811 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:3457)</span><br><span class="line">10-08 08:43:06.763  1592  1811 I WindowManager: 	at com.android.server.wm.WindowManagerService.access$1100(WindowManagerService.java:274)</span><br><span class="line">10-08 08:43:06.763  1592  1811 I WindowManager: 	at com.android.server.wm.WindowManagerService$H.handleMessage(WindowManagerService.java:4845)</span><br><span class="line">10-08 08:43:06.763  1592  1811 I WindowManager: 	at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">10-08 08:43:06.763  1592  1811 I WindowManager: 	at android.os.Looper.loop(Looper.java:193)</span><br><span class="line">10-08 08:43:06.763  1592  1811 I WindowManager: 	at android.os.HandlerThread.run(HandlerThread.java:65)</span><br><span class="line">10-08 08:43:06.763  1592  1811 I WindowManager: 	at com.android.server.ServiceThread.run(ServiceThread.java:44</span><br></pre></td></tr></table></figure>
<h3 id="1-11-AMS-bootAnimationComplete"><a href="#1-11-AMS-bootAnimationComplete" class="headerlink" title="1.11  AMS.bootAnimationComplete"></a>1.11  AMS.bootAnimationComplete</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void bootAnimationComplete() &#123;</span><br><span class="line">       final boolean callFinishBooting;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           callFinishBooting = mCallFinishBooting;</span><br><span class="line">           mBootAnimationComplete = true;</span><br><span class="line">       &#125;</span><br><span class="line">       if (callFinishBooting) &#123;</span><br><span class="line">           Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;FinishBooting&quot;);</span><br><span class="line">           finishBooting();</span><br><span class="line">           Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在1.8节中mCallFinishBooting设置成true了，所以这里会执行finishBooting方法。通过bootAnimationComplete这个回调方法，再一次进入到了finishBooting方法。</p>
<h3 id="1-12-AMS-finishBooting"><a href="#1-12-AMS-finishBooting" class="headerlink" title="1.12  AMS.finishBooting"></a>1.12  AMS.finishBooting</h3><p>[-&gt;ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">final void finishBooting() &#123;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           //在1.8节中进入到这里，这次会跳过</span><br><span class="line">           if (!mBootAnimationComplete) &#123;</span><br><span class="line">               mCallFinishBooting = true;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           mCallFinishBooting = false;</span><br><span class="line">       &#125;</span><br><span class="line">       //abi设置开机完成flag</span><br><span class="line">       ArraySet&lt;String&gt; completedIsas = new ArraySet&lt;String&gt;();</span><br><span class="line">       for (String abi : Build.SUPPORTED_ABIS) &#123;</span><br><span class="line">           ZYGOTE_PROCESS.establishZygoteConnectionForAbi(abi);</span><br><span class="line">           final String instructionSet = VMRuntime.getInstructionSet(abi);</span><br><span class="line">           if (!completedIsas.contains(instructionSet)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi));</span><br><span class="line">               &#125; catch (InstallerException e) &#123;</span><br><span class="line">                   if (!VMRuntime.didPruneDalvikCache()) &#123;</span><br><span class="line">                       // This is technically not the right filter, as different zygotes may</span><br><span class="line">                       // have made different pruning decisions. But the log is best effort,</span><br><span class="line">                       // anyways.</span><br><span class="line">                       Slog.w(TAG, &quot;Unable to mark boot complete for abi: &quot; + abi + &quot; (&quot; +</span><br><span class="line">                               e.getMessage() +&quot;)&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               completedIsas.add(instructionSet);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //注册应用重启广播</span><br><span class="line">       IntentFilter pkgFilter = new IntentFilter();</span><br><span class="line">       pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);</span><br><span class="line">       pkgFilter.addDataScheme(&quot;package&quot;);</span><br><span class="line">       mContext.registerReceiver(new BroadcastReceiver() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">               String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);</span><br><span class="line">               if (pkgs != null) &#123;</span><br><span class="line">                   for (String pkg : pkgs) &#123;</span><br><span class="line">                       synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                           if (forceStopPackageLocked(pkg, -1, false, false, false, false, false,</span><br><span class="line">                                   0, &quot;query restart&quot;)) &#123;</span><br><span class="line">                               setResultCode(Activity.RESULT_OK);</span><br><span class="line">                               return;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, pkgFilter);</span><br><span class="line">       //注册ACTION_DELETE_DUMPHEAP广播</span><br><span class="line">       IntentFilter dumpheapFilter = new IntentFilter();</span><br><span class="line">       dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);</span><br><span class="line">       mContext.registerReceiver(new BroadcastReceiver() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">               if (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, false)) &#123;</span><br><span class="line">                   mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, 5*60*1000);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, dumpheapFilter);</span><br><span class="line">       </span><br><span class="line">       //通知系统服务开机完成</span><br><span class="line">       // Let system services know.</span><br><span class="line">       mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           //之前onhold的进程，开始启动</span><br><span class="line">           // Ensure that any processes we had put on hold are now started</span><br><span class="line">           // up.</span><br><span class="line">           final int NP = mProcessesOnHold.size();</span><br><span class="line">           if (NP &gt; 0) &#123;</span><br><span class="line">               ArrayList&lt;ProcessRecord&gt; procs =</span><br><span class="line">                   new ArrayList&lt;ProcessRecord&gt;(mProcessesOnHold);</span><br><span class="line">               for (int ip=0; ip&lt;NP; ip++) &#123;</span><br><span class="line">                   if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, &quot;Starting process on hold: &quot;</span><br><span class="line">                           + procs.get(ip));</span><br><span class="line">                   startProcessLocked(procs.get(ip), &quot;on-hold&quot;, null);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           // Start looking for apps that are abusing wake locks.</span><br><span class="line">           Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);</span><br><span class="line">           mHandler.sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);</span><br><span class="line">           // Tell anyone interested that we are done booting!</span><br><span class="line">           SystemProperties.set(&quot;sys.boot_completed&quot;, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">           // And trigger dev.bootcomplete if we are not showing encryption progress</span><br><span class="line">           if (!&quot;trigger_restart_min_framework&quot;.equals(VoldProperties.decrypt().orElse(&quot;&quot;))</span><br><span class="line">                   || &quot;&quot;.equals(VoldProperties.encrypt_progress().orElse(&quot;&quot;))) &#123;</span><br><span class="line">               SystemProperties.set(&quot;dev.bootcomplete&quot;, &quot;1&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           //发送开机完成广播</span><br><span class="line">           mUserController.sendBootCompleted(</span><br><span class="line">                   new IIntentReceiver.Stub() &#123;</span><br><span class="line">                       @Override</span><br><span class="line">                       public void performReceive(Intent intent, int resultCode,</span><br><span class="line">                               String data, Bundle extras, boolean ordered,</span><br><span class="line">                               boolean sticky, int sendingUser) &#123;</span><br><span class="line">                           synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                               //搜集各个进程的信息</span><br><span class="line">                               requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">           mUserController.scheduleStartProfiles();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要的工作是设置abi开机完成的flag，注册ACTION_QUERY_PACKAGE_RESTART和ACTION_DELETE_DUMPHEAP广播，通知系统服务开机启动完成，开启onhold进程，而后发送开机广播。</p>
<h3 id="1-13-UC-sendBootCompleted"><a href="#1-13-UC-sendBootCompleted" class="headerlink" title="1.13 UC.sendBootCompleted"></a>1.13 UC.sendBootCompleted</h3><p>[-&gt;UserController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void sendBootCompleted(IIntentReceiver resultTo) &#123;</span><br><span class="line">       // Get a copy of mStartedUsers to use outside of lock</span><br><span class="line">       SparseArray&lt;UserState&gt; startedUsers;</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           startedUsers = mStartedUsers.clone();</span><br><span class="line">       &#125;</span><br><span class="line">       //通知多个用户</span><br><span class="line">       for (int i = 0; i &lt; startedUsers.size(); i++) &#123;</span><br><span class="line">           UserState uss = startedUsers.valueAt(i);</span><br><span class="line">           finishUserBoot(uss, resultTo);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-14-UC-finishUserBoot"><a href="#1-14-UC-finishUserBoot" class="headerlink" title="1.14 UC.finishUserBoot"></a>1.14 UC.finishUserBoot</h3><p>[-&gt;UserController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">private void finishUserBoot(UserState uss, IIntentReceiver resultTo) &#123;</span><br><span class="line">       final int userId = uss.mHandle.getIdentifier();</span><br><span class="line">       //用户不匹配则返回</span><br><span class="line">       Slog.d(TAG, &quot;Finishing user boot &quot; + userId);</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           // Bail if we ended up with a stale user</span><br><span class="line">           if (mStartedUsers.get(userId) != uss) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       // We always walk through all the user lifecycle states to send</span><br><span class="line">       // consistent developer events. We step into RUNNING_LOCKED here,</span><br><span class="line">       // but we might immediately step into RUNNING below if the user</span><br><span class="line">       // storage is already unlocked.</span><br><span class="line">       //如果用户在锁定状态</span><br><span class="line">       if (uss.setState(STATE_BOOTING, STATE_RUNNING_LOCKED)) &#123;</span><br><span class="line">           mInjector.getUserManagerInternal().setUserState(userId, uss.state);</span><br><span class="line">           // Do not report secondary users, runtime restarts or first boot/upgrade</span><br><span class="line">           if (userId == UserHandle.USER_SYSTEM</span><br><span class="line">                   &amp;&amp; !mInjector.isRuntimeRestarted() &amp;&amp; !mInjector.isFirstBootOrUpgrade()) &#123;</span><br><span class="line">               int uptimeSeconds = (int)(SystemClock.elapsedRealtime() / 1000);</span><br><span class="line">               MetricsLogger.histogram(mInjector.getContext(),</span><br><span class="line">                       &quot;framework_locked_boot_completed&quot;, uptimeSeconds);</span><br><span class="line">               final int MAX_UPTIME_SECONDS = 120;</span><br><span class="line">               if (uptimeSeconds &gt; MAX_UPTIME_SECONDS) &#123;</span><br><span class="line">                   Slog.wtf(&quot;SystemServerTiming&quot;,</span><br><span class="line">                           &quot;finishUserBoot took too long. uptimeSeconds=&quot; + uptimeSeconds);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">           mHandler.sendMessage(mHandler.obtainMessage(REPORT_LOCKED_BOOT_COMPLETE_MSG,</span><br><span class="line">                   userId, 0));</span><br><span class="line">           //发送锁屏开机广播 ，为串行广播       </span><br><span class="line">           Intent intent = new Intent(Intent.ACTION_LOCKED_BOOT_COMPLETED, null);</span><br><span class="line">           intent.putExtra(Intent.EXTRA_USER_HANDLE, userId);</span><br><span class="line">           intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT</span><br><span class="line">                   | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);</span><br><span class="line">           mInjector.broadcastIntent(intent, null, resultTo, 0, null, null,</span><br><span class="line">                   new String[]&#123;android.Manifest.permission.RECEIVE_BOOT_COMPLETED&#125;,</span><br><span class="line">                   AppOpsManager.OP_NONE, null, true, false, MY_PID, SYSTEM_UID, userId);</span><br><span class="line">       &#125;</span><br><span class="line">       //解锁用户的credential-encrypted storage</span><br><span class="line">       // We need to delay unlocking managed profiles until the parent user</span><br><span class="line">       // is also unlocked.</span><br><span class="line">       if (mInjector.getUserManager().isManagedProfile(userId)) &#123;</span><br><span class="line">           final UserInfo parent = mInjector.getUserManager().getProfileParent(userId);</span><br><span class="line">           if (parent != null</span><br><span class="line">                   &amp;&amp; isUserRunning(parent.id, ActivityManager.FLAG_AND_UNLOCKED)) &#123;</span><br><span class="line">               Slog.d(TAG, &quot;User &quot; + userId + &quot; (parent &quot; + parent.id</span><br><span class="line">                       + &quot;): attempting unlock because parent is unlocked&quot;);</span><br><span class="line">               maybeUnlockUser(userId);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               String parentId = (parent == null) ? &quot;&lt;null&gt;&quot; : String.valueOf(parent.id);</span><br><span class="line">               Slog.d(TAG, &quot;User &quot; + userId + &quot; (parent &quot; + parentId</span><br><span class="line">                       + &quot;): delaying unlock because parent is locked&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           maybeUnlockUser(userId);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-15-UC-maybeUnlockUser"><a href="#1-15-UC-maybeUnlockUser" class="headerlink" title="1.15 UC.maybeUnlockUser"></a>1.15 UC.maybeUnlockUser</h3><p>[-&gt;UserController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Attempt to unlock user without a credential token. This typically</span><br><span class="line">    * succeeds when the device doesn&apos;t have credential-encrypted storage, or</span><br><span class="line">    * when the the credential-encrypted storage isn&apos;t tied to a user-provided</span><br><span class="line">    * PIN or pattern.</span><br><span class="line">    */</span><br><span class="line">   private boolean maybeUnlockUser(final int userId) &#123;</span><br><span class="line">       // Try unlocking storage using empty token</span><br><span class="line">       return unlockUserCleared(userId, null, null, null);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-16-UC-maybeUnlockUser"><a href="#1-16-UC-maybeUnlockUser" class="headerlink" title="1.16 UC.maybeUnlockUser"></a>1.16 UC.maybeUnlockUser</h3><p>[-&gt;UserController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private boolean unlockUserCleared(final int userId, byte[] token, byte[] secret,</span><br><span class="line">          IProgressListener listener) &#123;</span><br><span class="line">      UserState uss;</span><br><span class="line">      //解锁user storage</span><br><span class="line">      if (!StorageManager.isUserKeyUnlocked(userId)) &#123;</span><br><span class="line">          final UserInfo userInfo = getUserInfo(userId);</span><br><span class="line">          final IStorageManager storageManager = getStorageManager();</span><br><span class="line">          try &#123;</span><br><span class="line">              // We always want to unlock user storage, even user is not started yet</span><br><span class="line">              storageManager.unlockUserKey(userId, userInfo.serialNumber, token, secret);</span><br><span class="line">          &#125; catch (RemoteException | RuntimeException e) &#123;</span><br><span class="line">              Slog.w(TAG, &quot;Failed to unlock: &quot; + e.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      synchronized (mLock) &#123;</span><br><span class="line">          // Register the given listener to watch for unlock progress</span><br><span class="line">          uss = mStartedUsers.get(userId);</span><br><span class="line">          if (uss != null) &#123;</span><br><span class="line">              uss.mUnlockProgress.addListener(listener);</span><br><span class="line">              uss.tokenProvided = (token != null);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Bail if user isn&apos;t actually running</span><br><span class="line">      if (uss == null) &#123;</span><br><span class="line">          notifyFinished(userId, listener);</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      //完成解锁</span><br><span class="line">      if (!finishUserUnlocking(uss)) &#123;</span><br><span class="line">          notifyFinished(userId, listener);</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //解锁其他的用户 </span><br><span class="line">      // We just unlocked a user, so let&apos;s now attempt to unlock any</span><br><span class="line">      // managed profiles under that user.</span><br><span class="line"></span><br><span class="line">      // First, get list of userIds. Requires mLock, so we cannot make external calls, e.g. to UMS</span><br><span class="line">      int[] userIds;</span><br><span class="line">      synchronized (mLock) &#123;</span><br><span class="line">          userIds = new int[mStartedUsers.size()];</span><br><span class="line">          for (int i = 0; i &lt; userIds.length; i++) &#123;</span><br><span class="line">              userIds[i] = mStartedUsers.keyAt(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int testUserId : userIds) &#123;</span><br><span class="line">          final UserInfo parent = mInjector.getUserManager().getProfileParent(testUserId);</span><br><span class="line">          if (parent != null &amp;&amp; parent.id == userId &amp;&amp; testUserId != userId) &#123;</span><br><span class="line">              Slog.d(TAG, &quot;User &quot; + testUserId + &quot; (parent &quot; + parent.id</span><br><span class="line">                      + &quot;): attempting unlock because parent was just unlocked&quot;);</span><br><span class="line">              maybeUnlockUser(testUserId);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-17-UC-finishUserUnlocking"><a href="#1-17-UC-finishUserUnlocking" class="headerlink" title="1.17 UC.finishUserUnlocking"></a>1.17 UC.finishUserUnlocking</h3><p>[-&gt;UserController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Step from &#123;@link UserState#STATE_RUNNING_LOCKED&#125; to</span><br><span class="line">    * &#123;@link UserState#STATE_RUNNING_UNLOCKING&#125;.</span><br><span class="line">    */</span><br><span class="line">   private boolean finishUserUnlocking(final UserState uss) &#123;</span><br><span class="line">       final int userId = uss.mHandle.getIdentifier();</span><br><span class="line">       // Only keep marching forward if user is actually unlocked</span><br><span class="line">       if (!StorageManager.isUserKeyUnlocked(userId)) return false;</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           // Do not proceed if unexpected state or a stale user</span><br><span class="line">           if (mStartedUsers.get(userId) != uss || uss.state != STATE_RUNNING_LOCKED) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       uss.mUnlockProgress.start();</span><br><span class="line">       // 设置进度</span><br><span class="line">       // Prepare app storage before we go any further</span><br><span class="line">       uss.mUnlockProgress.setProgress(5,</span><br><span class="line">                   mInjector.getContext().getString(R.string.android_start_title));</span><br><span class="line"></span><br><span class="line">       // Call onBeforeUnlockUser on a worker thread that allows disk I/O</span><br><span class="line">       FgThread.getHandler().post(() -&gt; &#123;</span><br><span class="line">           if (!StorageManager.isUserKeyUnlocked(userId)) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;User key got locked unexpectedly, leaving user locked.&quot;);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           mInjector.getUserManager().onBeforeUnlockUser(userId);</span><br><span class="line">           synchronized (mLock) &#123;</span><br><span class="line">               // Do not proceed if unexpected state</span><br><span class="line">               if (!uss.setState(STATE_RUNNING_LOCKED, STATE_RUNNING_UNLOCKING)) &#123;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mInjector.getUserManagerInternal().setUserState(userId, uss.state);</span><br><span class="line"></span><br><span class="line">           uss.mUnlockProgress.setProgress(20);</span><br><span class="line">           //通知系统服务解锁完成</span><br><span class="line">           // Dispatch unlocked to system services; when fully dispatched,</span><br><span class="line">           // that calls through to the next &quot;unlocked&quot; phase</span><br><span class="line">           mHandler.obtainMessage(SYSTEM_USER_UNLOCK_MSG, userId, 0, uss)</span><br><span class="line">                   .sendToTarget();</span><br><span class="line">       &#125;);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过mHandler发送到AMS的主Handler处理，由于UserController继承了Handler.Callback，其handleMessage就在UserController类中。</p>
<h3 id="1-18-UC-handleMessage"><a href="#1-18-UC-handleMessage" class="headerlink" title="1.18 UC.handleMessage"></a>1.18 UC.handleMessage</h3><p>[-&gt;UserController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean handleMessage(Message msg) &#123;</span><br><span class="line">      ...</span><br><span class="line">      case SYSTEM_USER_UNLOCK_MSG:</span><br><span class="line">                final int userId = msg.arg1;</span><br><span class="line">                mInjector.getSystemServiceManager().unlockUser(userId);</span><br><span class="line">                // Loads recents on a worker thread that allows disk I/O</span><br><span class="line">                FgThread.getHandler().post(() -&gt; &#123;</span><br><span class="line">                    mInjector.loadUserRecents(userId);</span><br><span class="line">                &#125;);</span><br><span class="line">                finishUserUnlocked((UserState) msg.obj);</span><br><span class="line">                break;</span><br><span class="line">        ...        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先unlockUser，加载RecentTask</p>
<h3 id="1-19-UC-finishUserUnlocked"><a href="#1-19-UC-finishUserUnlocked" class="headerlink" title="1.19 UC.finishUserUnlocked"></a>1.19 UC.finishUserUnlocked</h3><p>[-&gt;UserController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Step from &#123;@link UserState#STATE_RUNNING_UNLOCKING&#125; to</span><br><span class="line">   * &#123;@link UserState#STATE_RUNNING_UNLOCKED&#125;.</span><br><span class="line">   */</span><br><span class="line">  void finishUserUnlocked(final UserState uss) &#123;</span><br><span class="line">      final int userId = uss.mHandle.getIdentifier();</span><br><span class="line">      // Only keep marching forward if user is actually unlocked</span><br><span class="line">      //没有解锁返回</span><br><span class="line">      if (!StorageManager.isUserKeyUnlocked(userId)) return;</span><br><span class="line">      synchronized (mLock) &#123;</span><br><span class="line">          // Bail if we ended up with a stale user</span><br><span class="line">          if (mStartedUsers.get(uss.mHandle.getIdentifier()) != uss) return;</span><br><span class="line"></span><br><span class="line">          // Do not proceed if unexpected state</span><br><span class="line">          if (!uss.setState(STATE_RUNNING_UNLOCKING, STATE_RUNNING_UNLOCKED)) &#123;</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //解锁完成</span><br><span class="line">      mInjector.getUserManagerInternal().setUserState(userId, uss.state);</span><br><span class="line">      uss.mUnlockProgress.finish();</span><br><span class="line"></span><br><span class="line">      // Get unaware persistent apps running and start any unaware providers</span><br><span class="line">      // in already-running apps that are partially aware</span><br><span class="line">      if (userId == UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">          mInjector.startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_UNAWARE);</span><br><span class="line">      &#125;</span><br><span class="line">      //加载credential-encrypted Providers</span><br><span class="line">      mInjector.installEncryptionUnawareProviders(userId);</span><br><span class="line"></span><br><span class="line">      // Dispatch unlocked to external apps</span><br><span class="line">      //发送ACTION_USER_UNLOCKED广播，并行广播</span><br><span class="line">      final Intent unlockedIntent = new Intent(Intent.ACTION_USER_UNLOCKED);</span><br><span class="line">      unlockedIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);</span><br><span class="line">      unlockedIntent.addFlags(</span><br><span class="line">              Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">      mInjector.broadcastIntent(unlockedIntent, null, null, 0, null,</span><br><span class="line">              null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, SYSTEM_UID,</span><br><span class="line">              userId);</span><br><span class="line"></span><br><span class="line">      if (getUserInfo(userId).isManagedProfile()) &#123;</span><br><span class="line">          UserInfo parent = mInjector.getUserManager().getProfileParent(userId);</span><br><span class="line">          if (parent != null) &#123;</span><br><span class="line">              //发送ACTION_MANAGED_PROFILE_UNLOCKED广播，并行广播</span><br><span class="line">              final Intent profileUnlockedIntent = new Intent(</span><br><span class="line">                      Intent.ACTION_MANAGED_PROFILE_UNLOCKED);</span><br><span class="line">              profileUnlockedIntent.putExtra(Intent.EXTRA_USER, UserHandle.of(userId));</span><br><span class="line">              profileUnlockedIntent.addFlags(</span><br><span class="line">                      Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                              | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">              mInjector.broadcastIntent(profileUnlockedIntent,</span><br><span class="line">                      null, null, 0, null, null, null, AppOpsManager.OP_NONE,</span><br><span class="line">                      null, false, false, MY_PID, SYSTEM_UID,</span><br><span class="line">                      parent.id);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Send PRE_BOOT broadcasts if user fingerprint changed; we</span><br><span class="line">      // purposefully block sending BOOT_COMPLETED until after all</span><br><span class="line">      // PRE_BOOT receivers are finished to avoid ANR&apos;ing apps</span><br><span class="line">      //用户fingerprint改变，则发送广播</span><br><span class="line">      final UserInfo info = getUserInfo(userId);</span><br><span class="line">      if (!Objects.equals(info.lastLoggedInFingerprint, Build.FINGERPRINT)) &#123;</span><br><span class="line">          // Suppress double notifications for managed profiles that</span><br><span class="line">          // were unlocked automatically as part of their parent user</span><br><span class="line">          // being unlocked.</span><br><span class="line">          final boolean quiet;</span><br><span class="line">          if (info.isManagedProfile()) &#123;</span><br><span class="line">              quiet = !uss.tokenProvided</span><br><span class="line">                      || !mLockPatternUtils.isSeparateProfileChallengeEnabled(userId);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              quiet = false;</span><br><span class="line">          &#125;</span><br><span class="line">          mInjector.sendPreBootBroadcast(userId, quiet,</span><br><span class="line">                  () -&gt; finishUserUnlockedCompleted(uss));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          finishUserUnlockedCompleted(uss);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-20-UC-finishUserUnlockedCompleted"><a href="#1-20-UC-finishUserUnlockedCompleted" class="headerlink" title="1.20 UC.finishUserUnlockedCompleted"></a>1.20 UC.finishUserUnlockedCompleted</h3><p>[-&gt;UserController.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private void finishUserUnlockedCompleted(UserState uss) &#123;</span><br><span class="line">       final int userId = uss.mHandle.getIdentifier();</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           // Bail if we ended up with a stale user</span><br><span class="line">           if (mStartedUsers.get(uss.mHandle.getIdentifier()) != uss) return;</span><br><span class="line">       &#125;</span><br><span class="line">       UserInfo userInfo = getUserInfo(userId);</span><br><span class="line">       if (userInfo == null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       // Only keep marching forward if user is actually unlocked</span><br><span class="line">       if (!StorageManager.isUserKeyUnlocked(userId)) return;</span><br><span class="line"></span><br><span class="line">       // Remember that we logged in</span><br><span class="line">       mInjector.getUserManager().onUserLoggedIn(userId);</span><br><span class="line"></span><br><span class="line">       if (!userInfo.isInitialized()) &#123;</span><br><span class="line">           if (userId != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">               Slog.d(TAG, &quot;Initializing user #&quot; + userId);</span><br><span class="line">               //发送ACTION_USER_INITIALIZE广播去给user初始化，，串行广播</span><br><span class="line">               Intent intent = new Intent(Intent.ACTION_USER_INITIALIZE);</span><br><span class="line">               intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND</span><br><span class="line">                       | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);</span><br><span class="line">               mInjector.broadcastIntent(intent, null,</span><br><span class="line">                       new IIntentReceiver.Stub() &#123;</span><br><span class="line">                           @Override</span><br><span class="line">                           public void performReceive(Intent intent, int resultCode,</span><br><span class="line">                                   String data, Bundle extras, boolean ordered,</span><br><span class="line">                                   boolean sticky, int sendingUser) &#123;</span><br><span class="line">                               // Note: performReceive is called with mService lock held</span><br><span class="line">                               mInjector.getUserManager().makeInitialized(userInfo.id);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;, 0, null, null, null, AppOpsManager.OP_NONE,</span><br><span class="line">                       null, true, false, MY_PID, SYSTEM_UID, userId);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Spin up app widgets prior to boot-complete, so they can be ready promptly</span><br><span class="line">       mInjector.startUserWidgets(userId);</span><br><span class="line"></span><br><span class="line">       Slog.i(TAG, &quot;Sending BOOT_COMPLETE user #&quot; + userId);</span><br><span class="line">       // Do not report secondary users, runtime restarts or first boot/upgrade</span><br><span class="line">       if (userId == UserHandle.USER_SYSTEM</span><br><span class="line">               &amp;&amp; !mInjector.isRuntimeRestarted() &amp;&amp; !mInjector.isFirstBootOrUpgrade()) &#123;</span><br><span class="line">           int uptimeSeconds = (int) (SystemClock.elapsedRealtime() / 1000);</span><br><span class="line">           MetricsLogger.histogram(mInjector.getContext(), &quot;framework_boot_completed&quot;,</span><br><span class="line">                   uptimeSeconds);</span><br><span class="line">       &#125;</span><br><span class="line">       //发送ACTION_BOOT_COMPLETED广播，串行广播</span><br><span class="line">       final Intent bootIntent = new Intent(Intent.ACTION_BOOT_COMPLETED, null);</span><br><span class="line">       bootIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);</span><br><span class="line">       bootIntent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT</span><br><span class="line">               | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);</span><br><span class="line">       mInjector.broadcastIntent(bootIntent, null, new IIntentReceiver.Stub() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">                           Bundle extras, boolean ordered, boolean sticky, int sendingUser)</span><br><span class="line">                           throws RemoteException &#123;</span><br><span class="line">                       Slog.i(UserController.TAG, &quot;Finished processing BOOT_COMPLETED for u&quot; + userId);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;, 0, null, null,</span><br><span class="line">               new String[]&#123;android.Manifest.permission.RECEIVE_BOOT_COMPLETED&#125;,</span><br><span class="line">               AppOpsManager.OP_NONE, null, true, false, MY_PID, SYSTEM_UID, userId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>到这里已经发送了ACTION_BOOT_COMPLETED广播。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>从开机完成启动到发送开机广播，其中的流程有很多，之前的文章有讲过systemserver启动，AMS、PMS的启动，同时还有Activity和广播的启动，综合着一些再来看这个过程就相对轻松些，同时通过编译版本调试打印出日志，更加证明了分析流程的正确性。</p>
<p>1.在Launch界面resume阶段，会向主线程消息队列放入new Idler()，在消息队列空闲的时候，就会调用。</p>
<p>2.通过Binder机制执行AMS的activityIdle，这个方法里面会检查是否完成开机。</p>
<p>3.调用finishBooting方法，来完成开机。在这个过程中第一次进入由于开机动画还没有停止从而会直接返回。</p>
<p>4.调用performEnableScreen方法，确定所有的窗口都已经绘制完成，包括Launch，状态栏，壁纸，同时要求开机动画停止，在等待开机动画停止的过程中，有一个30s的超时，同时还有其他的入口来调用WMS的performEnableScreen方法，当动画包停止后通过回调再次执行finishBooting方法。</p>
<p>5.在对credential-encrypted storage解锁后就正式的发送开机广播BOOT_COMPLETED。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>源码路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span><br><span class="line">frameworks/base/core/java/android/os/MessageQueue.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/UserController.java</span><br></pre></td></tr></table></figure>
      
    </div>


    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/BOOT-COMPLETED/" rel="tag">#BOOT_COMPLETED</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/BroadcastCast广播机制原理/" rel="next" title="BroadcastCast广播机制原理">
                <i class="fa fa-chevron-left"></i> BroadcastCast广播机制原理
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/Android进程创建流程分析/" rel="prev" title="Android进程创建流程分析">
                Android进程创建流程分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Skytoby">
          <p class="site-author-name" itemprop="name">Skytoby</p>
          <p class="site-description motion-element" itemprop="description">现居深圳，毕业于电子科技大学 <br>Android、AI<br>座右铭：想法+行动+坚持</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caoxiaoliang" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/cao861544325" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、开机广播启动过程"><span class="nav-text">二、开机广播启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-AT-handleResumeActivity"><span class="nav-text">1.1  AT.handleResumeActivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-MQ-addIdleHandler"><span class="nav-text">1.2 MQ.addIdleHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Idler-queueIdle"><span class="nav-text">1.3 Idler.queueIdle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-AMS-activityIdle"><span class="nav-text">1.4 AMS.activityIdle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-ASS-activityIdleInternalLocked"><span class="nav-text">1.5 ASS.activityIdleInternalLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-ASS-checkFinishBootingLocked"><span class="nav-text">1.6 ASS.checkFinishBootingLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-AMS-postFinishBooting"><span class="nav-text">1.7 AMS.postFinishBooting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-AMS-finishBooting"><span class="nav-text">1.8 AMS.finishBooting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-AMS-enableScreenAfterBoot"><span class="nav-text">1.9 AMS.enableScreenAfterBoot</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-1-WMS-hideBootMessagesLocked"><span class="nav-text">1.9.1 WMS.hideBootMessagesLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-2-PWM-hideBootMessages"><span class="nav-text">1.9.2  PWM.hideBootMessages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-3-PWM-systemBooted"><span class="nav-text">1.9.3 PWM.systemBooted</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-4-mH-sendEmptyMessageDelayed"><span class="nav-text">1.9.4 mH.sendEmptyMessageDelayed</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-WMS-performEnableScreen"><span class="nav-text">1.10 WMS.performEnableScreen</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-1-PWM-canDismissBootAnimation"><span class="nav-text">1.10.1 PWM.canDismissBootAnimation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-2-checkWaitingForWindows"><span class="nav-text">1.10.2  checkWaitingForWindows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-3-WMS-checkWaitingForWindows"><span class="nav-text">1.10.3  WMS.checkWaitingForWindows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-4-WMS-enableScreenIfNeeded"><span class="nav-text">1.10.4 WMS.enableScreenIfNeeded</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-AMS-bootAnimationComplete"><span class="nav-text">1.11  AMS.bootAnimationComplete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-AMS-finishBooting"><span class="nav-text">1.12  AMS.finishBooting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-UC-sendBootCompleted"><span class="nav-text">1.13 UC.sendBootCompleted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-UC-finishUserBoot"><span class="nav-text">1.14 UC.finishUserBoot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-UC-maybeUnlockUser"><span class="nav-text">1.15 UC.maybeUnlockUser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-UC-maybeUnlockUser"><span class="nav-text">1.16 UC.maybeUnlockUser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-17-UC-finishUserUnlocking"><span class="nav-text">1.17 UC.finishUserUnlocking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-18-UC-handleMessage"><span class="nav-text">1.18 UC.handleMessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-19-UC-finishUserUnlocked"><span class="nav-text">1.19 UC.finishUserUnlocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-20-UC-finishUserUnlockedCompleted"><span class="nav-text">1.20 UC.finishUserUnlockedCompleted</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、总结"><span class="nav-text">三、总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2019 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skytoby</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme Next
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'https-zproo-github-io';
      var disqus_identifier = '2019/开机广播BOOT_COMPLETED发送流程分析/';
      var disqus_title = "开机广播BOOT_COMPLETED发送流程分析";
      var disqus_url = 'http://zproo.github.io/2019/开机广播BOOT_COMPLETED发送流程分析/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  









  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
